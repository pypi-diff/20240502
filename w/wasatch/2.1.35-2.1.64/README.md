# Comparing `tmp/wasatch-2.1.35.tar.gz` & `tmp/wasatch-2.1.64.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "wasatch-2.1.35.tar", last modified: Fri Jan  1 00:00:00 2016, max compression
+gzip compressed data, was "wasatch-2.1.64.tar", last modified: Fri Jan  1 00:00:00 2016, max compression
```

## Comparing `wasatch-2.1.35.tar` & `wasatch-2.1.64.tar`

### file list

```diff
@@ -1,80 +1,85 @@
--rw-r--r--   0        0        0      282 2022-04-22 11:42:26.280888 wasatch-2.1.35/.example_pypirc
--rw-r--r--   0        0        0     1368 2023-08-07 13:32:37.605465 wasatch-2.1.35/.gitignore
--rw-r--r--   0        0        0   114678 2021-08-10 23:05:24.690860 wasatch-2.1.35/Doxyfile
--rw-r--r--   0        0        0     1074 2018-01-05 13:20:02.000000 wasatch-2.1.35/LICENSE
--rw-r--r--   0        0        0       17 2022-04-22 11:42:26.283332 wasatch-2.1.35/MANIFEST.in
--rw-r--r--   0        0        0      864 2022-04-22 11:42:26.285214 wasatch-2.1.35/Makefile
--rw-r--r--   0        0        0    20629 2022-07-27 13:35:35.050889 wasatch-2.1.35/README.md
--rw-r--r--   0        0        0    22911 2023-11-01 21:08:27.876246 wasatch-2.1.35/README_CHANGELOG.md
--rw-r--r--   0        0        0     2246 2022-10-26 15:39:47.543404 wasatch-2.1.35/README_PYPI.md
--rw-r--r--   0        0        0     7106 2022-07-27 13:31:46.643915 wasatch-2.1.35/README_RPI.md
--rw-r--r--   0        0        0     5936 2021-09-01 16:55:16.091843 wasatch-2.1.35/README_SETTINGS.md
--rw-r--r--   0        0        0     1733 2022-11-29 20:47:20.253694 wasatch-2.1.35/README_VIRTUAL.md
--rw-r--r--   0        0        0     3826 2019-09-18 18:04:41.000000 wasatch-2.1.35/WasatchShell/README.md
--rwxr-xr-x   0        0        0     4621 2019-04-24 16:56:32.000000 wasatch-2.1.35/WasatchShell/laser-test.py
--rwxr-xr-x   0        0        0     9159 2019-06-20 18:48:53.000000 wasatch-2.1.35/WasatchShell/load-test.py
--rwxr-xr-x   0        0        0     2059 2019-09-18 14:02:17.000000 wasatch-2.1.35/WasatchShell/one-shot.py
--rwxr-xr-x   0        0        0    34033 2023-09-19 18:26:30.125522 wasatch-2.1.35/WasatchShell/wasatch-shell.py
--rwxr-xr-x   0        0        0     2263 2023-06-23 14:45:48.435856 wasatch-2.1.35/demo-simple.py
--rw-r--r--   0        0        0      515 2022-10-17 20:08:52.380944 wasatch-2.1.35/demo-virtual.py
--rw-r--r--   0        0        0     5620 2023-06-29 23:26:13.474772 wasatch-2.1.35/demo-workflow.py
--rwxr-xr-x   0        0        0    12932 2022-10-26 13:48:56.143983 wasatch-2.1.35/demo.py
--rw-r--r--   0        0        0      189 2022-08-11 13:43:29.091006 wasatch-2.1.35/environments/conda-linux.yml
--rw-r--r--   0        0        0      178 2022-04-22 11:42:26.401203 wasatch-2.1.35/environments/conda-macos.yml
--rw-r--r--   0        0        0      172 2022-04-22 11:42:26.402369 wasatch-2.1.35/environments/conda-rpi.yml
--rw-r--r--   0        0        0      288 2022-08-11 13:43:29.091225 wasatch-2.1.35/environments/conda-win10.yml
--rw-r--r--   0        0        0      380 2022-04-22 11:42:26.404326 wasatch-2.1.35/pyproject.toml
--rw-r--r--   0        0        0       76 2023-02-01 00:14:07.624753 wasatch-2.1.35/requirements.txt
--rw-r--r--   0        0        0   332281 2018-01-23 15:15:17.000000 wasatch-2.1.35/screenshots/multiplatform.png
--rwxr-xr-x   0        0        0     2895 2022-10-26 15:37:41.955854 wasatch-2.1.35/scripts/dark-vs-integ.py
--rwxr-xr-x   0        0        0     1522 2019-06-05 19:59:37.000000 wasatch-2.1.35/scripts/deploy
--rw-r--r--   0        0        0      621 2022-04-22 11:42:26.404978 wasatch-2.1.35/setup.cfg
--rw-r--r--   0        0        0     5085 2022-10-12 13:38:46.236134 wasatch-2.1.35/testSpectrometers/SiG_785/eeprom/EEPROM-EM-9c65d19f4c.json
--rw-r--r--   0        0        0    38895 2022-10-12 13:38:46.236603 wasatch-2.1.35/testSpectrometers/SiG_785/readings/enlighten-20210329-094722-799520-WP-00686.csv
--rw-r--r--   0        0        0    38895 2022-10-12 13:38:46.237050 wasatch-2.1.35/testSpectrometers/SiG_785/readings/enlighten-20210329-094755-288958-WP-00686.csv
--rw-r--r--   0        0        0    52730 2022-10-12 13:38:46.237580 wasatch-2.1.35/testSpectrometers/WP-00887/eeprom/WP-00887-mock.json
--rw-r--r--   0        0        0    89301 2022-10-12 13:38:46.238221 wasatch-2.1.35/testSpectrometers/WP-00904/eeprom/WP-00904-mock.json
--rw-r--r--   0        0        0    90309 2022-10-12 13:38:46.238871 wasatch-2.1.35/testSpectrometers/WP-00913/eeprom/WP-00913-mock.json
--rw-r--r--   0        0        0      659 2023-08-07 13:32:37.605683 wasatch-2.1.35/tests/existing_implementations.py
--rwxr-xr-x   0        0        0     7341 2019-04-19 15:21:50.000000 wasatch-2.1.35/tests/noise-by-setpoint.py
--rw-r--r--   0        0        0     4436 2019-04-10 16:42:40.000000 wasatch-2.1.35/tests/queues.py
--rw-r--r--   0        0        0     3178 2023-08-07 13:32:37.605880 wasatch-2.1.35/tests/unit.py
--rw-r--r--   0        0        0      638 2023-02-01 00:14:07.625135 wasatch-2.1.35/udev/10-wasatch.rules
--rw-r--r--   0        0        0      387 2022-04-22 11:42:26.405223 wasatch-2.1.35/wasatch/AbstractUSBDevice.py
--rw-r--r--   0        0        0    34925 2023-11-01 21:05:40.660968 wasatch-2.1.35/wasatch/AndorDevice.py
--rw-r--r--   0        0        0    19750 2023-10-10 21:18:46.697100 wasatch-2.1.35/wasatch/BLEDevice.py
--rw-r--r--   0        0        0     4787 2019-04-24 14:36:28.000000 wasatch-2.1.35/wasatch/BalanceAcquisition.py
--rw-r--r--   0        0        0     7127 2023-10-10 22:23:12.214339 wasatch-2.1.35/wasatch/CSVLoader.py
--rw-r--r--   0        0        0     3490 2022-07-27 13:35:35.052909 wasatch-2.1.35/wasatch/CommandSettings.py
--rw-r--r--   0        0        0      603 2019-03-19 20:52:40.000000 wasatch-2.1.35/wasatch/ControlObject.py
--rw-r--r--   0        0        0     1062 2022-07-27 13:35:35.053227 wasatch-2.1.35/wasatch/DetectorROI.py
--rw-r--r--   0        0        0     6196 2023-06-29 23:26:13.477554 wasatch-2.1.35/wasatch/DetectorRegions.py
--rw-r--r--   0        0        0    12058 2023-09-19 18:26:30.127145 wasatch-2.1.35/wasatch/DeviceFinderUSB.py
--rw-r--r--   0        0        0    11986 2023-06-29 23:26:13.479122 wasatch-2.1.35/wasatch/DeviceID.py
--rw-r--r--   0        0        0    57696 2023-10-26 18:53:57.979009 wasatch-2.1.35/wasatch/EEPROM.py
--rw-r--r--   0        0        0     1712 2021-09-20 14:45:40.416628 wasatch-2.1.35/wasatch/EEPROM_multical.sav
--rw-r--r--   0        0        0     4591 2022-06-09 20:58:02.191416 wasatch-2.1.35/wasatch/FPGAOptions.py
--rw-r--r--   0        0        0   148219 2023-10-06 13:17:40.232792 wasatch-2.1.35/wasatch/FeatureIdentificationDevice.py
--rw-r--r--   0        0        0     1103 2023-06-29 23:26:13.482659 wasatch-2.1.35/wasatch/HardwareInfo.py
--rw-r--r--   0        0        0     1380 2023-06-29 23:26:13.483042 wasatch-2.1.35/wasatch/InterfaceDevice.py
--rw-r--r--   0        0        0    13421 2023-06-29 23:26:13.483532 wasatch-2.1.35/wasatch/MockUSBDevice.py
--rw-r--r--   0        0        0     9991 2023-06-29 23:26:13.484117 wasatch-2.1.35/wasatch/OceanDevice.py
--rw-r--r--   0        0        0     8917 2023-11-01 21:05:40.662142 wasatch-2.1.35/wasatch/ProcessedReading.py
--rw-r--r--   0        0        0      557 2023-05-05 13:42:22.754238 wasatch-2.1.35/wasatch/ROI.py
--rw-r--r--   0        0        0     2913 2023-06-08 17:38:27.333518 wasatch-2.1.35/wasatch/Reading.py
--rw-r--r--   0        0        0     1675 2022-08-04 17:30:55.426169 wasatch-2.1.35/wasatch/RealUSBDevice.py
--rw-r--r--   0        0        0    29225 2023-10-06 13:17:40.233651 wasatch-2.1.35/wasatch/SPIDevice.py
--rw-r--r--   0        0        0      410 2022-04-22 11:42:26.421257 wasatch-2.1.35/wasatch/SpectrometerRequest.py
--rw-r--r--   0        0        0     1220 2023-08-11 22:38:58.682894 wasatch-2.1.35/wasatch/SpectrometerResponse.py
--rw-r--r--   0        0        0    21210 2023-10-07 13:02:14.265006 wasatch-2.1.35/wasatch/SpectrometerSettings.py
--rw-r--r--   0        0        0    10690 2023-06-07 13:32:46.850477 wasatch-2.1.35/wasatch/SpectrometerState.py
--rw-r--r--   0        0        0      460 2018-07-13 19:34:51.000000 wasatch-2.1.35/wasatch/StatusMessage.py
--rw-r--r--   0        0        0     2280 2023-08-31 02:10:38.646507 wasatch-2.1.35/wasatch/WasatchBus.py
--rw-r--r--   0        0        0    49244 2023-09-19 18:26:30.137899 wasatch-2.1.35/wasatch/WasatchDevice.py
--rw-r--r--   0        0        0    21844 2023-06-29 23:26:13.487783 wasatch-2.1.35/wasatch/WasatchDeviceWrapper.py
--rw-r--r--   0        0        0    11971 2023-06-29 23:26:13.488407 wasatch-2.1.35/wasatch/WrapperWorker.py
--rw-r--r--   0        0        0      254 2023-11-01 21:08:35.646659 wasatch-2.1.35/wasatch/__init__.py
--rw-r--r--   0        0        0     6829 2023-10-06 13:17:40.234466 wasatch-2.1.35/wasatch/applog.py
--rw-r--r--   0        0        0     8508 2019-04-15 16:11:07.000000 wasatch-2.1.35/wasatch/simulation_protocol.py
--rw-r--r--   0        0        0    23071 2023-11-01 21:05:40.663088 wasatch-2.1.35/wasatch/utils.py
--rw-r--r--   0        0        0    20971 1970-01-01 00:00:00.000000 wasatch-2.1.35/PKG-INFO
+-rw-r--r--   0        0        0      282 2022-04-22 11:42:26.280888 wasatch-2.1.64/.example_pypirc
+-rw-r--r--   0        0        0      259 2024-03-25 12:47:34.451217 wasatch-2.1.64/.flake8
+-rw-r--r--   0        0        0     1368 2023-08-07 13:32:37.605465 wasatch-2.1.64/.gitignore
+-rw-r--r--   0        0        0    17504 2024-03-25 20:39:12.998464 wasatch-2.1.64/.pylintrc
+-rw-r--r--   0        0        0    25537 2024-05-02 19:33:21.683971 wasatch-2.1.64/CHANGELOG.md
+-rw-r--r--   0        0        0   114678 2021-08-10 23:05:24.690860 wasatch-2.1.64/Doxyfile
+-rw-r--r--   0        0        0     1074 2018-01-05 13:20:02.000000 wasatch-2.1.64/LICENSE
+-rw-r--r--   0        0        0       17 2022-04-22 11:42:26.283332 wasatch-2.1.64/MANIFEST.in
+-rw-r--r--   0        0        0      864 2022-04-22 11:42:26.285214 wasatch-2.1.64/Makefile
+-rw-r--r--   0        0        0    20622 2024-01-11 21:10:09.029199 wasatch-2.1.64/README.md
+-rw-r--r--   0        0        0     2246 2024-05-02 19:35:24.629997 wasatch-2.1.64/README_PYPI.md
+-rw-r--r--   0        0        0     7106 2022-07-27 13:31:46.643915 wasatch-2.1.64/README_RPI.md
+-rw-r--r--   0        0        0     5936 2021-09-01 16:55:16.091843 wasatch-2.1.64/README_SETTINGS.md
+-rw-r--r--   0        0        0     1733 2022-11-29 20:47:20.253694 wasatch-2.1.64/README_VIRTUAL.md
+-rw-r--r--   0        0        0     3826 2019-09-18 18:04:41.000000 wasatch-2.1.64/WasatchShell/README.md
+-rwxr-xr-x   0        0        0     4582 2024-03-25 12:47:34.453201 wasatch-2.1.64/WasatchShell/laser-test.py
+-rwxr-xr-x   0        0        0     9131 2024-03-25 12:47:34.453946 wasatch-2.1.64/WasatchShell/load-test.py
+-rwxr-xr-x   0        0        0     2059 2019-09-18 14:02:17.000000 wasatch-2.1.64/WasatchShell/one-shot.py
+-rwxr-xr-x   0        0        0    32737 2024-03-25 12:47:34.454847 wasatch-2.1.64/WasatchShell/wasatch-shell.py
+-rwxr-xr-x   0        0        0     2263 2023-06-23 14:45:48.435856 wasatch-2.1.64/demo-simple.py
+-rw-r--r--   0        0        0      515 2022-10-17 20:08:52.380944 wasatch-2.1.64/demo-virtual.py
+-rw-r--r--   0        0        0     5605 2024-03-25 12:47:34.455632 wasatch-2.1.64/demo-workflow.py
+-rwxr-xr-x   0        0        0    12907 2024-03-25 12:47:34.456409 wasatch-2.1.64/demo.py
+-rw-r--r--   0        0        0      189 2022-08-11 13:43:29.091006 wasatch-2.1.64/environments/conda-linux.yml
+-rw-r--r--   0        0        0      178 2022-04-22 11:42:26.401203 wasatch-2.1.64/environments/conda-macos.yml
+-rw-r--r--   0        0        0      172 2022-04-22 11:42:26.402369 wasatch-2.1.64/environments/conda-rpi.yml
+-rw-r--r--   0        0        0      288 2022-08-11 13:43:29.091225 wasatch-2.1.64/environments/conda-win10.yml
+-rw-r--r--   0        0        0      380 2022-04-22 11:42:26.404326 wasatch-2.1.64/pyproject.toml
+-rw-r--r--   0        0        0       76 2024-03-28 15:26:27.785421 wasatch-2.1.64/requirements.txt
+-rw-r--r--   0        0        0   332281 2018-01-23 15:15:17.000000 wasatch-2.1.64/screenshots/multiplatform.png
+-rwxr-xr-x   0        0        0     2877 2024-03-25 12:47:34.457047 wasatch-2.1.64/scripts/dark-vs-integ.py
+-rwxr-xr-x   0        0        0     1522 2019-06-05 19:59:37.000000 wasatch-2.1.64/scripts/deploy
+-rw-r--r--   0        0        0      621 2022-04-22 11:42:26.404978 wasatch-2.1.64/setup.cfg
+-rw-r--r--   0        0        0     5085 2022-10-12 13:38:46.236134 wasatch-2.1.64/testSpectrometers/SiG_785/eeprom/EEPROM-EM-9c65d19f4c.json
+-rw-r--r--   0        0        0    38895 2022-10-12 13:38:46.236603 wasatch-2.1.64/testSpectrometers/SiG_785/readings/enlighten-20210329-094722-799520-WP-00686.csv
+-rw-r--r--   0        0        0    38895 2022-10-12 13:38:46.237050 wasatch-2.1.64/testSpectrometers/SiG_785/readings/enlighten-20210329-094755-288958-WP-00686.csv
+-rw-r--r--   0        0        0    52730 2022-10-12 13:38:46.237580 wasatch-2.1.64/testSpectrometers/WP-00887/eeprom/WP-00887-mock.json
+-rw-r--r--   0        0        0    89301 2022-10-12 13:38:46.238221 wasatch-2.1.64/testSpectrometers/WP-00904/eeprom/WP-00904-mock.json
+-rw-r--r--   0        0        0    90309 2022-10-12 13:38:46.238871 wasatch-2.1.64/testSpectrometers/WP-00913/eeprom/WP-00913-mock.json
+-rw-r--r--   0        0        0      659 2023-08-07 13:32:37.605683 wasatch-2.1.64/tests/existing_implementations.py
+-rwxr-xr-x   0        0        0     7192 2024-03-25 12:47:34.457830 wasatch-2.1.64/tests/noise-by-setpoint.py
+-rw-r--r--   0        0        0     4407 2024-03-25 12:47:34.458339 wasatch-2.1.64/tests/queues.py
+-rw-r--r--   0        0        0     3086 2024-03-25 12:47:34.458959 wasatch-2.1.64/tests/unit.py
+-rw-r--r--   0        0        0      638 2023-02-01 00:14:07.625135 wasatch-2.1.64/udev/10-wasatch.rules
+-rw-r--r--   0        0        0      387 2022-04-22 11:42:26.405223 wasatch-2.1.64/wasatch/AbstractUSBDevice.py
+-rw-r--r--   0        0        0    34388 2024-03-25 20:40:37.374271 wasatch-2.1.64/wasatch/AndorDevice.py
+-rw-r--r--   0        0        0    19478 2024-03-25 20:40:13.377553 wasatch-2.1.64/wasatch/BLEDevice.py
+-rw-r--r--   0        0        0     4779 2024-01-30 15:40:12.789485 wasatch-2.1.64/wasatch/BalanceAcquisition.py
+-rw-r--r--   0        0        0     8448 2024-03-25 12:47:34.461394 wasatch-2.1.64/wasatch/CSVLoader.py
+-rw-r--r--   0        0        0     3482 2024-03-25 12:47:34.462047 wasatch-2.1.64/wasatch/CommandSettings.py
+-rw-r--r--   0        0        0      620 2024-01-30 15:40:50.108169 wasatch-2.1.64/wasatch/ControlObject.py
+-rw-r--r--   0        0        0     1062 2022-07-27 13:35:35.053227 wasatch-2.1.64/wasatch/DetectorROI.py
+-rw-r--r--   0        0        0     6241 2024-03-25 12:47:34.462737 wasatch-2.1.64/wasatch/DetectorRegions.py
+-rw-r--r--   0        0        0    11795 2024-03-25 12:47:34.463778 wasatch-2.1.64/wasatch/DeviceFinderUSB.py
+-rw-r--r--   0        0        0    11978 2024-01-30 15:40:06.785465 wasatch-2.1.64/wasatch/DeviceID.py
+-rw-r--r--   0        0        0    57116 2024-05-02 19:32:54.014665 wasatch-2.1.64/wasatch/EEPROM.py
+-rw-r--r--   0        0        0     1712 2021-09-20 14:45:40.416628 wasatch-2.1.64/wasatch/EEPROM_multical.sav
+-rw-r--r--   0        0        0     4387 2024-03-14 14:25:00.202665 wasatch-2.1.64/wasatch/FPGAOptions.py
+-rw-r--r--   0        0        0   154684 2024-05-02 19:32:54.015884 wasatch-2.1.64/wasatch/FeatureIdentificationDevice.py
+-rw-r--r--   0        0        0     1863 2024-05-02 19:32:54.016728 wasatch-2.1.64/wasatch/FirmwareRequirements.py
+-rw-r--r--   0        0        0     1095 2024-03-13 15:44:24.023102 wasatch-2.1.64/wasatch/HardwareInfo.py
+-rw-r--r--   0        0        0     1418 2024-03-25 12:47:34.467673 wasatch-2.1.64/wasatch/InterfaceDevice.py
+-rw-r--r--   0        0        0    13398 2024-03-25 20:48:43.660417 wasatch-2.1.64/wasatch/MockUSBDevice.py
+-rw-r--r--   0        0        0     9734 2024-03-25 20:42:38.259782 wasatch-2.1.64/wasatch/OceanDevice.py
+-rw-r--r--   0        0        0      373 2024-05-02 19:32:54.017375 wasatch-2.1.64/wasatch/PollStatus.py
+-rw-r--r--   0        0        0    15072 2024-04-02 12:54:06.893521 wasatch-2.1.64/wasatch/ProcessedReading.py
+-rw-r--r--   0        0        0      700 2024-01-02 16:55:08.778597 wasatch-2.1.64/wasatch/ROI.py
+-rw-r--r--   0        0        0     3190 2024-03-25 15:04:18.996793 wasatch-2.1.64/wasatch/Reading.py
+-rw-r--r--   0        0        0     1679 2024-03-25 12:47:34.470664 wasatch-2.1.64/wasatch/RealUSBDevice.py
+-rw-r--r--   0        0        0    28515 2024-03-25 12:47:34.471443 wasatch-2.1.64/wasatch/SPIDevice.py
+-rw-r--r--   0        0        0      415 2024-03-25 12:47:34.472173 wasatch-2.1.64/wasatch/SpectrometerRequest.py
+-rw-r--r--   0        0        0     1220 2023-08-11 22:38:58.682894 wasatch-2.1.64/wasatch/SpectrometerResponse.py
+-rw-r--r--   0        0        0    21328 2024-05-02 19:32:54.017917 wasatch-2.1.64/wasatch/SpectrometerSettings.py
+-rw-r--r--   0        0        0    10827 2024-05-02 19:32:54.018942 wasatch-2.1.64/wasatch/SpectrometerState.py
+-rw-r--r--   0        0        0      470 2024-03-07 17:27:49.606034 wasatch-2.1.64/wasatch/StatusMessage.py
+-rw-r--r--   0        0        0      930 2024-02-05 17:11:06.781044 wasatch-2.1.64/wasatch/TakeOneRequest.py
+-rw-r--r--   0        0        0     2199 2024-03-25 12:47:34.473690 wasatch-2.1.64/wasatch/WasatchBus.py
+-rw-r--r--   0        0        0    51093 2024-05-02 19:32:54.019926 wasatch-2.1.64/wasatch/WasatchDevice.py
+-rw-r--r--   0        0        0    21175 2024-03-25 12:47:34.475857 wasatch-2.1.64/wasatch/WasatchDeviceWrapper.py
+-rw-r--r--   0        0        0    11250 2024-03-25 12:47:34.477090 wasatch-2.1.64/wasatch/WrapperWorker.py
+-rw-r--r--   0        0        0      254 2024-04-09 19:51:28.980444 wasatch-2.1.64/wasatch/__init__.py
+-rw-r--r--   0        0        0     6619 2024-03-25 20:41:28.232487 wasatch-2.1.64/wasatch/applog.py
+-rw-r--r--   0        0        0     8545 2024-03-25 20:44:41.811714 wasatch-2.1.64/wasatch/simulation_protocol.py
+-rw-r--r--   0        0        0    23047 2024-05-02 19:32:54.020518 wasatch-2.1.64/wasatch/utils.py
+-rw-r--r--   0        0        0    20964 1970-01-01 00:00:00.000000 wasatch-2.1.64/PKG-INFO
```

### Comparing `wasatch-2.1.35/.gitignore` & `wasatch-2.1.64/.gitignore`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/Doxyfile` & `wasatch-2.1.64/Doxyfile`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/LICENSE` & `wasatch-2.1.64/LICENSE`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/Makefile` & `wasatch-2.1.64/Makefile`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/README.md` & `wasatch-2.1.64/README.md`

 * *Files 0% similar despite different names*

```diff
@@ -315,8 +315,8 @@
 
 # Backlog
 
 - update .inf files to deprecate "Stroker"
 
 # Version History
 
-See [Changelog](README_CHANGELOG.md)
+See [Changelog](CHANGELOG.md)
```

### Comparing `wasatch-2.1.35/README_PYPI.md` & `wasatch-2.1.64/README_PYPI.md`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/README_RPI.md` & `wasatch-2.1.64/README_RPI.md`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/README_SETTINGS.md` & `wasatch-2.1.64/README_SETTINGS.md`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/README_VIRTUAL.md` & `wasatch-2.1.64/README_VIRTUAL.md`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/WasatchShell/README.md` & `wasatch-2.1.64/WasatchShell/README.md`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/WasatchShell/laser-test.py` & `wasatch-2.1.64/WasatchShell/laser-test.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,22 +3,19 @@
 #                               laser-test.py
 ################################################################################
 # 
 #  DESCRIPTION:  Simple hysteresis test of laser using photodiode.
 #
 ################################################################################
 
-import traceback
 import argparse
 import datetime
 import pexpect
-import time
 import sys
 import re
-import os
 
 from pexpect.popen_spawn import PopenSpawn
 
 prompt = "wp>"
 success = "1"
 
 def read_temperature(child):
```

### Comparing `wasatch-2.1.35/WasatchShell/load-test.py` & `wasatch-2.1.64/WasatchShell/load-test.py`

 * *Files 1% similar despite different names*

```diff
@@ -11,19 +11,17 @@
 #  INVOCATION:   $ ./load-test.py [outer_loop_count] [inner_loop_count]
 #                  (value <= 0 means run indefinitely)
 #
 ################################################################################
 
 import traceback
 import argparse
-import platform
 import datetime
 import pexpect
 import random
-import time
 import sys
 import re
 import os
 
 from pexpect.popen_spawn import PopenSpawn
 
 ################################################################################
```

### Comparing `wasatch-2.1.35/WasatchShell/one-shot.py` & `wasatch-2.1.64/WasatchShell/one-shot.py`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/WasatchShell/wasatch-shell.py` & `wasatch-2.1.64/WasatchShell/wasatch-shell.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,749 +1,735 @@
-#!/usr/bin/env python -u
-
-import datetime
-import platform
-import argparse
-import logging
-import time
-import sys
-import os
-import re
-
-import wasatch
-
-from wasatch import utils
-from wasatch.WasatchBus         import WasatchBus
-from wasatch.WasatchDevice      import WasatchDevice
-from wasatch.BalanceAcquisition import BalanceAcquisition
-from wasatch.RealUSBDevice      import RealUSBDevice
-from wasatch.SpectrometerResponse import SpectrometerResponse
-from wasatch.SpectrometerResponse import ErrorLevel
-
-VERSION = "2.3.0"
-
-log = logging.getLogger(__name__)
-
-## 
-# An interactive wrapper over a wasatch.WasatchDevice.
-#
-# EXAMPLE:
-# \verbatim
-#   $ ./wasatch-shell.py [--logfile path]
-#   open
-#   set_integration_time_ms
-#   100
-#   get_spectrum
-#   close
-# \endverbatim
-#
-# @todo currently there is no support for scan averaging.  That is because 
-#       scan averaging is built into WasatchDevice.acquire_data, and configured
-#       via Feature
-class WasatchShell(object):
-    
-    def __init__(self):
-        self.device = None                      # wasatch.WasatchDevice
-        self.clear()
-
-        # process command-line options
-        parser = argparse.ArgumentParser()
-        parser.add_argument("--eod", action="store_true", help="output END_OF_DATA on a line by itself following every action")
-        parser.add_argument("--logfile", help="where to write log messages")
-        parser.add_argument("--log-level", type=str, default="info", help="logging level", choices=['debug', 'info', 'warning', 'error', 'critical'])
-        parser.add_argument("--timestamp", action="store_true", help="timestamp console messages")
-        self.args = parser.parse_args()
-
-        self.configure_logging()
-        self.input_tokens = None
-        self.dark_spectra = None
-        self.srm = False
-
-        # pass-through calls to any of these gettors (note names are lowercased)
-        # SR = SpectrometerResponse
-        self.gettors = {}
-        for func_name in [ 
-            "get_actual_frames",                        # SR
-            "get_actual_integration_time_us",           # SR
-            "get_ambient_temperature_degC",             # SR
-            "get_ccd_sensing_threshold",                # SR
-            "get_ccd_threshold_sensing_mode",           # SR
-            "get_dac",                                  # SR
-            "get_detector_gain",                        # SR
-            "get_detector_gain_odd",                    # SR
-            "get_detector_offset",                      # SR
-            "get_detector_offset_odd",                  # SR
-            "get_detector_tec_setpoint_degC",           # SR
-            "get_detector_tec_setpoint_raw",            # SR
-            "get_detector_temperature_degC",            # SR
-            "get_detector_temperature_raw",             # SR
-            "get_external_trigger_output",              # SR
-            "get_fan_enabled",                          # SR
-            "get_fpga_firmware_version",                # SR
-            "get_high_gain_mode_enabled",               # SR
-            "get_integration_time_ms",                  # SR
-            "get_lamp_enabled",                         # SR
-            "get_laser_enabled",                        # SR
-            "get_laser_power_attenuator",               # SR
-            "get_laser_interlock",                      # SR
-            "get_laser_temperature_degC",               # SR
-            "get_laser_temperature_raw",                # SR
-            "get_laser_watchdog_sec",                   # SR
-            "get_microcontroller_firmware_version",     # SR
-            "get_mod_delay_us",                         # SR
-            "get_mod_duration_us",                      # SR
-            "get_mod_enabled",                          # SR
-            "get_mod_linked_to_integration",            # SR
-            "get_mod_period_us",                        # SR
-            "get_mod_width_us",                         # SR
-            "get_opt_actual_integration_time",          # SR
-            "get_opt_area_scan",                        # SR
-            "get_opt_cf_select",                        # SR
-            "get_opt_data_header_tab",                  # SR
-            "get_opt_has_laser",                        # SR
-            "get_opt_horizontal_binning",               # SR
-            "get_opt_integration_time_resolution",      # SR
-            "get_opt_laser_control",                    # SR
-            "get_raman_delay_ms",                       # SR
-            "get_secondary_adc_calibrated",             # SR
-            "get_secondary_adc_raw",                    # SR
-            "get_selected_adc",                         # SR
-            "get_selected_laser",                       # SR
-            "get_sensor_line_length",                   # SR
-            "get_shutter_enabled",                      # SR
-            "get_strobe_enabled",                       # SR
-            "get_tec_enabled",                          # SR
-            "get_trigger_delay",                        # SR
-            "get_trigger_source",                       # SR
-            "get_vr_continuous_ccd",                    # SR
-            "get_vr_num_frames",                        # SR
-            "has_linearity_coeffs" ]:                   # BOOL
-            self.gettors[func_name.lower()] = func_name
-
-    # ##############################################################################
-    # Utility Functions
-    # ##############################################################################
-
-    def usage(self):
-        print("Version: %s" % VERSION)
-        print("""The following commands are supported:
-        help                                   - this screen
-        version                                - program and library versions
-                                               
-        open                                   - initialize connected spectrometer
-        close                                  - exit program (synonyms 'exit', 'quit')
-        connection_check                       - confirm communication
-        clear                                  - reset interpolated x axes
-                                               
-        set_scans_to_average                   - takes integer argument
-        set_integration_time_ms                - takes integer argument
-        set_laser_enable                       - takes bool argument (on/off, true/false, 1/0)
-        set_laser_power_mw                     - takes float argument
-        set_laser_power_perc                   - takes int argument
-        set_laser_power_attenuator             - takes uint8 argument
-        set_laser_watchdog_sec                 - takes integer argument
-        set_acquisition_laser_trigger_enable   - takes bool argument
-        set_acquisition_laser_trigger_delay_ms - takes float argument
-        set_tec_enable                         - takes bool argument
-        set_detector_tec_setpoint_degc         - takes float argument
-        set_detector_offset                    - override the "offset" added to pixel readings
-        set_selected_laser                     - takes 0 or 1
-        set_raman_mode                         - takes 0 or 1
-        set_raman_delay_ms                     - takes integer argument
-                                               
-        set_fan_enable                         - takes bool argument
-        set_lamp_enable                        - takes bool argument
-        set_shutter_enable                     - takes bool argument
-        set_strobe_enable                      - takes bool argument
-        set_mod_enable                         - takes bool argument
-        set_mod_period_us                      - takes int argument
-        set_mod_width_us                       - takes int argument
-        set_mod_delay_us                       - takes int argument
-
-        set_interpolated_x_axis_cm             - takes start, end, incr (zero incr to disable)
-        set_interpolated_x_axis_nm             - takes start, end, incr (zero incr to disable)
-        balance_acquisition                    - takes mode [integ, laser, laser_and_integ], 
-                                                    intensity, threshold, max_integration_time_ms, 
-                                                    max_tries, x, unit [px, nm, cm]
-                                               
-        get_spectrum                           - print received spectrum
-        set_raman_intensity_correction_enable  - takes bool argument
-        get_dark                               - captures spectrum and stores as dark
-        clear_dark                             - clears a stored dark spectrum
-        get_spectrum_pretty                    - graph received spectrum
-        get_spectrum_save                      - save spectrum to filename as CSV
-        get_config_json                        - return EEPROM as JSON string
-        get_all                                - calls all gettors
-        """)
-        print("The following gettors are also available:")
-        for k in sorted(self.gettors.keys()):
-            print("        %s" % k)
-
-    def disconnected(self):
-        self.display("ERROR: no device connected")
-
-    ## encapsulating in case any platforms don't like GNU readline
-    def get_line(self, prompt="args> "):
-        return input(prompt).strip()
-
-    def has_input(self):
-        return self.input_tokens is not None and len(self.input_tokens) > 0
-
-    def get_next_token(self):
-        while not self.has_input():
-            line = self.get_line()
-            log.info("<< %s", line)
-            self.input_tokens = [s.strip() for s in line.lower().strip().split()]
-        return self.input_tokens.pop(0)
-
-    def read_bool(self):
-        s = self.get_next_token()
-        return re.match("1|true|yes|on", s.lower()) is not None
-
-    def read_int(self):
-        return int(self.get_next_token())
-
-    def read_float(self):
-        return float(self.get_next_token())
-
-    def read_str(self):
-        return self.get_next_token()
-
-    def display(self, msg):
-        log.info(">> %s", msg)
-        print(msg)
-        sys.stdout.flush()
-
-    def configure_logging(self):
-        logging.basicConfig(filename=(self.args.logfile if self.args.logfile else ("wasatch-%s.log" % utils.timestamp())),
-                            level=self.args.log_level.upper(),
-                            format='%(asctime)s.%(msecs)03d %(name)s %(levelname)-8s %(message)s', 
-                            datefmt='%m/%d/%Y %I:%M:%S')
-
-    # ##############################################################################
-    # command loop
-    # ##############################################################################
-
-    def run(self):
-        self.display("-" * 80)
-        self.display("wasatch-shell version %s invoked (Wasatch.PY %s)" % (VERSION, wasatch.version))
-
-        try:
-            while True:
-                prompt = "wp> " if not self.args.timestamp else str(datetime.datetime.now()) + " wp> "
-                line = self.get_line(prompt)
-
-                # ignore comments
-                if line.startswith('#') or len(line) == 0:
-                    continue
-
-                log.info("<< %s", line)
-
-                # tokenize
-                self.input_tokens = [s.strip() for s in line.lower().strip().split()]
-                command = self.read_str()
-
-                # these commands always work
-                if command == "help":
-                    self.usage()
-                    continue
-
-                elif command == "version":
-                    self.display("WasatchShell version: %s" % VERSION)
-                    self.display("Wasatch.PY   version: %s" % wasatch.version)
-                    continue
-
-                if re.match("close|quit|exit", command):
-                    break
-
-                # these commands work if currently closed
-                if self.device is None:
-                    if command == "open":
-                        self.display(1 if self.open() else 0)
-                    else:
-                        self.display("ERROR: must open spectrometer first")
-
-                else:
-                    try:
-                        # anything past this point assumes spectrometer already open
-
-                        # pass-through gettors
-                        if command in self.gettors:
-                            self.run_gettor(command)
-                            
-                        # special processing for these
-                        elif command == "get_spectrum":
-                            self.get_spectrum(quiet=False)
-
-                        elif command == "get_dark":
-                            self.get_dark()
-                            self.display(1)
-
-                        elif command == "clear_dark":
-                            self.clear_dark()
-                            self.display(1)
-
-                        elif command == "get_spectrum_pretty":
-                            self.get_spectrum_pretty()
-
-                        elif command == "get_spectrum_save":
-                            self.get_spectrum_save()
-
-                        elif command == "get_config_json":
-                            self.display(self.device.settings.eeprom.json(allow_nan=False))
-
-                        elif command == "get_all":
-                            self.get_all()
-
-                        elif command == "connection_check":
-                            self.run_gettor("get_integration_time_ms")
-
-                        elif command == "balance_acquisition":
-                            self.balance_acquisition()
-
-                        elif command == "set_interpolated_x_axis_cm":
-                            self.set_interpolated_x_axis_cm(start = self.read_float(),
-                                                            end   = self.read_float(),
-                                                            incr  = self.read_float())
-
-                        elif command == "set_interpolated_x_axis_nm":
-                            self.set_interpolated_x_axis_nm(start = self.read_float(),
-                                                            end   = self.read_float(),
-                                                            incr  = self.read_float())
-
-                        elif command == "set_raman_intensity_correction_enable":
-                            self.set_raman_intensity_correction_enable(self.device, self.read_bool())
-
-                        elif command == "clear":
-                            self.clear()
-
-                        # currently these are the only setters implemented
-                        #
-                        # These originally called directly into 
-                        # FeatureIdentificationDevice, which was efficient, but:
-                        #
-                        #   1. missed value-add processing in WasatchDevice.change_setting, 
-                        #   2. couldn't utilize inline (non functional) 
-                        #      implementations in FID.write_setting,
-                        #   3. provided no obvious path to achieve scan averaging 
-                        #      (issues 1 and 2)
-                        #   4. potentially differed than ENLIGHTEN processing 
-                        #      while failing to exercise ENLIGHTEN communication
-                        #      path (part of the script's purpose)
-                        #
-                        # Therefore, setters now utilize WasatchDevice.change_setting 
-                        # where possible.
-                        #
-                        # An obvious CONSEQUENCE of using change_setting() over 
-                        # direct FID function calls is that no return value is 
-                        # possible on "settor" functions :-(
-
-                        elif command == "set_integration_time_ms":
-                            self.device.change_setting("integration_time_ms", self.read_int())
-                            self.display(1)
-
-                        elif command == "set_laser_watchdog_sec":
-                            self.device.change_setting("laser_watchdog_sec", self.read_int())
-                            self.display(1)
-
-                        elif command == "set_raman_delay_ms":
-                            self.device.change_setting("raman_delay_ms", self.read_int())
-                            self.display(1)
-
-                        elif command == "set_raman_mode":
-                            self.device.change_setting("raman_mode_enable", self.read_bool())
-                            self.display(1)
-
-                        elif command == "set_laser_power_mw":
-                            self.device.change_setting("laser_power_mW", self.read_float())
-                            self.display(1)
-
-                        elif command == "set_laser_power_perc":
-                            self.device.change_setting("laser_power_perc", self.read_float())
-                            self.display(1)
-
-                        elif command == "set_laser_power_attenuator":
-                            self.device.change_setting("laser_power_attenuator", self.read_int())
-                            self.display(1)
-
-                        elif command == "set_laser_enable":
-                            self.set_laser_enable(flag = self.read_bool())
-
-                        elif command == "set_laser_power_high_resolution":
-                            self.device.change_setting("laser_power_high_resolution", self.read_bool())
-                            self.display(1)
-
-                        elif command == "set_tec_enable":
-                            self.device.change_setting("detector_tec_enable", self.read_bool())
-                            self.display(1)
-
-                        elif command == "set_detector_tec_setpoint_degc":
-                            self.device.change_setting("detector_tec_setpoint_degC", self.read_float())
-                            self.display(1)
-
-                        elif command == "set_detector_offset":
-                            self.device.change_setting("detector_offset", self.read_int())
-                            self.display(1)
-
-                        elif command == "set_scans_to_average":
-                            self.device.change_setting("scans_to_average", self.read_int())
-                            self.display(1)
-
-                        elif command == "set_acquisition_laser_trigger_enable":
-                            self.device.change_setting("acquisition_laser_trigger_enable", self.read_bool())
-                            self.display(1)
-
-                        elif command == "set_acquisition_laser_trigger_delay_ms":
-                            self.device.change_setting("acquisition_laser_trigger_delay_ms", self.read_int())
-                            self.display(1)
-
-                        elif command == "set_selected_laser":
-                            self.device.change_setting("selected_laser", self.read_int())
-                            self.display(1)
-
-                        elif command == "set_fan_enable":
-                            self.device.change_setting("fan_enable", self.read_bool())
-                            self.display(1)
-
-                        elif command == "set_lamp_enable":
-                            self.device.change_setting("lamp_enable", self.read_bool())
-                            self.display(1)
-
-                        elif command == "set_shutter_enable":
-                            self.device.change_setting("shutter_enable", self.read_bool())
-                            self.display(1)
-
-                        elif command == "set_strobe_enable":
-                            self.device.change_setting("strobe_enable", self.read_bool())
-                            self.display(1)
-
-                        elif command == "set_mod_period_us":
-                            self.device.change_setting("mod_period_us", self.read_int())
-                            self.display(1)
-
-                        elif command == "set_mod_width_us":
-                            self.device.change_setting("mod_width_us", self.read_int())
-                            self.display(1)
-
-                        elif command == "set_mod_delay_us":
-                            self.device.change_setting("mod_period_us", self.read_int())
-                            self.display(1)
-
-                        elif command == "open":
-                            # if user re-sends open command when already open, do nothing
-                            self.display(1)
-
-                        else:
-                            self.display("ERROR: unknown command: " + command)
-                    except Exception as ex:
-                        log.critical("caught exception", exc_info=1)
-                        log.info("disconnecting")
-                        self.device.disconnect()
-                        self.device = None
-
-                        log.info("sleeping 5sec")
-                        time.sleep(5.100)
-                        
-                        log.info("re-opening")
-                        if self.open():
-                            log.info("successfully re-opened")
-                        else:
-                            log.error("could not re-open...giving up")
-                            break
-
-                if self.args.eod:
-                    self.display("END_OF_DATA")
-
-                # whatever happened, flush stdout
-                try:
-                    sys.stdout.flush()
-                except:
-                    self.display("ERROR: caller has closed stdout...exiting")
-                    break
-
-        except Exception as e:
-            log.error(e, exc_info=1)
-            raise
-
-        # disable the laser if connected
-        if self.device is not None:
-            self.set_laser_enable(False, quiet=True)
-            self.device.disconnect()
-            self.device = None
-
-        log.info("wasatch-shell exiting")
-
-    ## 
-    # If the current device is disconnected, and there is a new device, 
-    # attempt to connect to it. """
-    def open(self):
-        # if we're already connected, nevermind
-        if self.device is not None:
-            return False
-
-        # lazy-load a USB bus
-        log.debug("instantiating WasatchBus")
-        bus = WasatchBus()
-        if not bus.device_ids:
-            self.display("No Wasatch USB spectrometers found.")
-            return False
-
-        device_id = bus.device_ids[0]
-        log.debug("open: trying to connect to %s", device_id)
-        device_id.device_type = RealUSBDevice(device_id)
-        device = WasatchDevice(device_id)
-
-        ok = device.connect()
-        if not ok.data: 
-            log.critical("open: can't connect to device on bus 1")
-            return
-
-        log.info("open: device connected")
-        self.device = device
-
-        # enable exceptions
-        self.device.hardware.raise_exceptions = True
-
-        # enable immediate mode (don't queue commands until acquire_data)
-        self.device.immediate_mode = True
-
-        # enable bare readings (don't query extra hardware metadata during acquisitions)
-        self.device.bare_readings = True
-
-        # disable free-running mode (interactive shell is the definition of "slaved to user commands")
-        self.device.change_setting("free_running_mode", False)
-
-        # laser should not be on, but even so
-        self.set_laser_enable(False, quiet=True)
-
-        # enable high-resolution laser power by default
-        self.device.change_setting("laser_power_high_resolution", True)
-
-        # if laser has power calibration, require it and initialize accordingly 
-        # (so if the user enables the laser, it won't fire at an out-of-bounds 
-        # 100% unmodulated)
-        if self.device.settings.eeprom.has_laser_power_calibration():
-            log.info("laser has power calibration, so requiring modulation and initializing to max-rated power in mW")
-            self.device.change_setting("laser_power_require_modulation", True)
-            self.device.change_setting("laser_power_mW", self.device.settings.eeprom.max_laser_power_mW)
-
-        # throw random errors
-        # self.device.hardware.random_errors = True
-
-        # validate gettors (in case this is used against a StrokerProtocol unit, for instance)
-        for func_name in list(self.gettors.keys()):
-            if not hasattr(device.hardware, self.gettors[func_name]):
-                self.display("WARNING: gettor %s (%s) not found in device" % (func_name, self.gettors[func_name]))
-                del self.gettors[func_name]
-
-        # default to minimum configured integration time
-        self.device.change_setting("integration_time_ms", self.device.settings.eeprom.min_integration_time_ms)
-
-        return True
-
-    def run_gettor(self, command):
-        func_name = self.gettors[command]
-        value = getattr(self.device.hardware, func_name)()
-
-        if isinstance(value, SpectrometerResponse):
-            if value.error_msg:
-                self.display(f"ERROR: {value.error_msg}")
-                return
-            value = value.data
-
-        if isinstance(value, bool):
-            self.display(1 if value else 0)
-        else:
-            self.display(value)
-
-    def get_dark(self):
-        spectrum = self.get_spectrum(quiet=True)
-        self.dark_spectra = spectrum
-
-    def clear_dark(self):
-        self.dark_spectra = None
-
-    def set_raman_intensity_correction_enable(self, device: WasatchDevice, status: bool): # -> int 
-        if not device.settings.eeprom.has_raman_intensity_calibration():
-            self.display("Device has no Raman Intensity Calibration")
-            self.srm = False
-            return
-        else:
-            self.srm = status
-            self.display(1)
-            return
-
-    def srm_process(self, spectrum: list[float], device: WasatchDevice): # -> list[float] 
-
-        factors = device.settings.raman_intensity_factors
-        if factors is None or len(factors) != len(spectrum):
-            return 
-
-        spectrum = [px*fac for px, fac in zip(spectrum,factors)]
-        return spectrum
-
-    ##
-    # This calls WasatchDevice.acquire_data, rather than FID.get_line, because 
-    # scan averaging, bad-pixel correction, acquisition laser trigger and other
-    # high-level acquisition features are implemented in WasatchDevice rather 
-    # than FID.
-    def get_spectrum(self, quiet=True):
-        # enqueue ACQUIRE command, as we're not in free-running mode
-        self.device.change_setting("acquire", True, allow_immediate=False)
-
-        # now collect the spectrum
-        reading_response = self.device.acquire_data()
-        reading = reading_response.data
-        if reading is None or isinstance(reading, bool) or reading.spectrum is None:
-            self.display("ERROR: get_spectrum failed")
-            return
-        spectrum = reading.spectrum
-        if self.dark_spectra is not None and len(self.dark_spectra) == len(spectrum):
-            spectrum = [spec-dark for spec, dark in zip(spectrum, self.dark_spectra)]
-        log.debug("received %d pixels", len(spectrum))
-
-        if self.srm:
-            spectrum = self.srm_process(spectrum, self.device)
-
-        if self.interpolated_x_axis_cm and self.device.settings.wavenumbers:
-            spectrum = utils.interpolate_array(spectrum, 
-                                               self.device.settings.wavenumbers, 
-                                               self.interpolated_x_axis_cm)
-        elif self.interpolated_x_axis_nm:
-            spectrum = utils.interpolate_array(spectrum, 
-                                               self.device.settings.wavelengths, 
-                                               self.interpolated_x_axis_nm)
-        if quiet:
-            return spectrum
-
-        for pixel in spectrum:
-            print(pixel)
-
-    def get_spectrum_save(self):
-        spectrum = self.get_spectrum()
-        if spectrum is None:
-            return 
-
-        if self.has_input():
-            filename = self.read_str()
-        else:
-            filename = datetime.datetime.now().strftime("%Y%m%d-%H%M%S.csv")
-
-        with open(filename, "w") as outfile:
-            for i in range(len(spectrum)):
-                if self.interpolated_x_axis_cm:
-                    x = self.interpolated_x_axis_cm[i]
-                elif self.interpolated_x_axis_nm:
-                    x = self.interpolated_x_axis_nm[i]
-                elif self.device.settings.wavenumbers:
-                    x = self.device.settings.wavenumbers[i]
-                else:
-                    x = self.device.settings.wavelengths[i]
-                outfile.write("%.2f,%.2f\n" % (x, spectrum[i]))
-
-    def get_spectrum_pretty(self):
-        spectrum = self.get_spectrum()
-        if spectrum is None:
-            return 
-
-        if self.interpolated_x_axis_cm:
-            x_axis = self.interpolated_x_axis_cm
-            x_unit = "cm-1"
-        elif self.interpolated_x_axis_nm:
-            x_axis = self.interpolated_x_axis_nm
-            x_unit = "nm"
-        elif self.device.settings.wavenumbers:
-            x_axis = self.device.settings.wavenumbers
-            x_unit = "cm-1"
-        else:
-            x_axis = self.device.settings.wavelengths
-            x_unit = "nm"
-
-        lines = utils.ascii_spectrum(spectrum=spectrum, rows=24, cols=80, x_axis=x_axis, x_unit=x_unit)
-        for line in lines:
-            self.display(line)
-
-    def set_laser_enable(self, flag, quiet=False):
-        self.device.change_setting("laser_enable", flag)
-        return None if quiet else self.display(1)
-
-    ## should use numpy.arange
-    def generate_interpolated_x_axis(self, start, end, incr):
-        if incr == 0 or start >= end:
-            return [ start ]
-
-        axis = []
-        x = start
-        while x <= end:
-            axis.append(x)
-            x += incr
-        return axis
-                
-    def set_interpolated_x_axis_cm(self, start, end, incr):
-        self.interpolated_x_axis_cm = self.generate_interpolated_x_axis(start, end, incr)
-        self.display(1)
-
-    def set_interpolated_x_axis_nm(self, start, end, incr):
-        self.interpolated_x_axis_nm = self.generate_interpolated_x_axis(start, end, incr)
-        self.display(1)
-
-    def clear(self):
-        self.interpolated_x_axis_nm = None
-        self.interpolated_x_axis_cm = None
-        # ...more...
-
-    ## takes mode [integ, laser, laser_and_integ], intensity, threshold, x, unit [px, nm, cm]
-    def balance_acquisition(self):
-        mode                    = "integration" if not self.has_input() else self.read_str()
-        intensity               = 45000         if not self.has_input() else self.read_float()
-        threshold               = 2500          if not self.has_input() else self.read_float()
-        max_integration_time_ms = 5000          if not self.has_input() else self.read_int()
-        max_tries               = 20            if not self.has_input() else self.read_int()
-        x_value                 = None          if not self.has_input() else self.read_float()
-        unit                    = "px"          if not self.has_input() else self.read_str()
-
-        if not re.match('(px|cm|nm)$', unit):
-            return self.display("ERROR: invalid unit " + s)
-
-        pixel = None
-        if x_value is not None:
-            if unit == "px":
-                pixel = int(x_value)
-            elif unit == "nm":
-                pixel = utils.find_nearest_index(self.device.settings.wavelengths, x_value)
-            elif unit == "cm" and self.device.settings.wavenumbers:
-                pixel = utils.find_nearest_index(self.device.settings.wavenumbers, x_value)
-            else:
-                return self.display("ERROR: can't determine pixel from %s %s" % (x_value, unit))
-
-        ok = self.device.balance_acquisition(
-                mode                    = mode, 
-                intensity               = intensity, 
-                threshold               = threshold, 
-                pixel                   = pixel, 
-                max_integration_time_ms = max_integration_time_ms, 
-                max_tries               = max_tries)
-
-        if ok:
-            self.display("Ok integration_time_ms %s laser_power %s %s" % (
-                self.device.settings.state.integration_time_ms,
-                self.device.settings.state.laser_power, 
-                "mW" if self.device.settings.state.laser_power_in_mW else "percent"))
-        else:
-            self.display(0)
-
-    def get_all(self):
-        for command in sorted(self.gettors):
-            func_name = self.gettors[command]
-            value = getattr(self.device.hardware, func_name)()
-            if isinstance(value, bool):
-                value = 1 if value else 0
-            self.display("%-40s: %s" % (command, value))
-
-# ##############################################################################
-# main()
-# ##############################################################################
-
-shell = None
-if __name__ == "__main__":
-    shell = WasatchShell()
-    shell.run()
+#!/usr/bin/env python -u
+
+import datetime
+import argparse
+import logging
+import time
+import sys
+import re
+
+import wasatch
+
+from wasatch import utils
+from wasatch.WasatchBus         import WasatchBus
+from wasatch.WasatchDevice      import WasatchDevice
+from wasatch.RealUSBDevice      import RealUSBDevice
+from wasatch.SpectrometerResponse import SpectrometerResponse
+
+VERSION = "2.3.0"
+
+log = logging.getLogger(__name__)
+
+## 
+# An interactive wrapper over a wasatch.WasatchDevice.
+#
+# EXAMPLE:
+# \verbatim
+#   $ ./wasatch-shell.py [--logfile path]
+#   open
+#   set_integration_time_ms
+#   100
+#   get_spectrum
+#   close
+# \endverbatim
+#
+# @todo currently there is no support for scan averaging.  That is because 
+#       scan averaging is built into WasatchDevice.acquire_data, and configured
+#       via Feature
+class WasatchShell:
+    
+    def __init__(self):
+        self.device = None                      # wasatch.WasatchDevice
+        self.clear()
+
+        # process command-line options
+        parser = argparse.ArgumentParser()
+        parser.add_argument("--eod", action="store_true", help="output END_OF_DATA on a line by itself following every action")
+        parser.add_argument("--logfile", help="where to write log messages")
+        parser.add_argument("--log-level", type=str, default="info", help="logging level", choices=['debug', 'info', 'warning', 'error', 'critical'])
+        parser.add_argument("--timestamp", action="store_true", help="timestamp console messages")
+        self.args = parser.parse_args()
+
+        self.configure_logging()
+        self.input_tokens = None
+        self.dark_spectra = None
+        self.srm = False
+
+        # pass-through calls to any of these gettors (note names are lowercased)
+        # SR = SpectrometerResponse
+        self.gettors = {}
+        for func_name in [ 
+                "get_actual_frames",                        # SR
+                "get_actual_integration_time_us",           # SR
+                "get_ambient_temperature_degC",             # SR
+                "get_ccd_sensing_threshold",                # SR
+                "get_ccd_threshold_sensing_mode",           # SR
+                "get_dac",                                  # SR
+                "get_detector_gain",                        # SR
+                "get_detector_gain_odd",                    # SR
+                "get_detector_offset",                      # SR
+                "get_detector_offset_odd",                  # SR
+                "get_detector_tec_setpoint_degC",           # SR
+                "get_detector_tec_setpoint_raw",            # SR
+                "get_detector_temperature_degC",            # SR
+                "get_detector_temperature_raw",             # SR
+                "get_external_trigger_output",              # SR
+                "get_fan_enabled",                          # SR
+                "get_fpga_firmware_version",                # SR
+                "get_high_gain_mode_enabled",               # SR
+                "get_integration_time_ms",                  # SR
+                "get_lamp_enabled",                         # SR
+                "get_laser_enabled",                        # SR
+                "get_laser_power_attenuator",               # SR
+                "get_laser_interlock",                      # SR
+                "get_laser_temperature_degC",               # SR
+                "get_laser_temperature_raw",                # SR
+                "get_laser_watchdog_sec",                   # SR
+                "get_microcontroller_firmware_version",     # SR
+                "get_mod_delay_us",                         # SR
+                "get_mod_duration_us",                      # SR
+                "get_mod_enabled",                          # SR
+                "get_mod_linked_to_integration",            # SR
+                "get_mod_period_us",                        # SR
+                "get_mod_width_us",                         # SR
+                "get_opt_actual_integration_time",          # SR
+                "get_opt_area_scan",                        # SR
+                "get_opt_cf_select",                        # SR
+                "get_opt_data_header_tab",                  # SR
+                "get_opt_has_laser",                        # SR
+                "get_opt_horizontal_binning",               # SR
+                "get_opt_integration_time_resolution",      # SR
+                "get_opt_laser_control",                    # SR
+                "get_raman_delay_ms",                       # SR
+                "get_secondary_adc_calibrated",             # SR
+                "get_secondary_adc_raw",                    # SR
+                "get_selected_adc",                         # SR
+                "get_selected_laser",                       # SR
+                "get_sensor_line_length",                   # SR
+                "get_shutter_enabled",                      # SR
+                "get_strobe_enabled",                       # SR
+                "get_tec_enabled",                          # SR
+                "get_trigger_delay",                        # SR
+                "get_trigger_source",                       # SR
+                "get_vr_continuous_ccd",                    # SR
+                "get_vr_num_frames",                        # SR
+                "has_linearity_coeffs" ]:                   # BOOL
+            self.gettors[func_name.lower()] = func_name
+
+    # ##############################################################################
+    # Utility Functions
+    # ##############################################################################
+
+    def usage(self):
+        print("Version: %s" % VERSION)
+        print("""The following commands are supported:
+        help                                   - this screen
+        version                                - program and library versions
+                                               
+        open                                   - initialize connected spectrometer
+        close                                  - exit program (synonyms 'exit', 'quit')
+        connection_check                       - confirm communication
+        clear                                  - reset interpolated x axes
+                                               
+        set_scans_to_average                   - takes integer argument
+        set_integration_time_ms                - takes integer argument
+        set_laser_enable                       - takes bool argument (on/off, true/false, 1/0)
+        set_laser_power_mw                     - takes float argument
+        set_laser_power_perc                   - takes int argument
+        set_laser_power_attenuator             - takes uint8 argument
+        set_laser_watchdog_sec                 - takes integer argument
+        set_tec_enable                         - takes bool argument
+        set_detector_tec_setpoint_degc         - takes float argument
+        set_detector_offset                    - override the "offset" added to pixel readings
+        set_selected_laser                     - takes 0 or 1
+        set_raman_mode                         - takes 0 or 1
+        set_raman_delay_ms                     - takes integer argument
+                                               
+        set_fan_enable                         - takes bool argument
+        set_lamp_enable                        - takes bool argument
+        set_shutter_enable                     - takes bool argument
+        set_strobe_enable                      - takes bool argument
+        set_mod_enable                         - takes bool argument
+        set_mod_period_us                      - takes int argument
+        set_mod_width_us                       - takes int argument
+        set_mod_delay_us                       - takes int argument
+
+        set_interpolated_x_axis_cm             - takes start, end, incr (zero incr to disable)
+        set_interpolated_x_axis_nm             - takes start, end, incr (zero incr to disable)
+        balance_acquisition                    - takes mode [integ, laser, laser_and_integ], 
+                                                    intensity, threshold, max_integration_time_ms, 
+                                                    max_tries, x, unit [px, nm, cm]
+                                               
+        get_spectrum                           - print received spectrum
+        set_raman_intensity_correction_enable  - takes bool argument
+        get_dark                               - captures spectrum and stores as dark
+        clear_dark                             - clears a stored dark spectrum
+        get_spectrum_pretty                    - graph received spectrum
+        get_spectrum_save                      - save spectrum to filename as CSV
+        get_config_json                        - return EEPROM as JSON string
+        get_all                                - calls all gettors
+        """)
+        print("The following gettors are also available:")
+        for k in sorted(self.gettors.keys()):
+            print("        %s" % k)
+
+    def disconnected(self):
+        self.display("ERROR: no device connected")
+
+    ## encapsulating in case any platforms don't like GNU readline
+    def get_line(self, prompt="args> "):
+        return input(prompt).strip()
+
+    def has_input(self):
+        return self.input_tokens is not None and len(self.input_tokens) > 0
+
+    def get_next_token(self):
+        while not self.has_input():
+            line = self.get_line()
+            log.info("<< %s", line)
+            self.input_tokens = [s.strip() for s in line.lower().strip().split()]
+        return self.input_tokens.pop(0)
+
+    def read_bool(self):
+        s = self.get_next_token()
+        return re.match("1|true|yes|on", s.lower()) is not None
+
+    def read_int(self):
+        return int(self.get_next_token())
+
+    def read_float(self):
+        return float(self.get_next_token())
+
+    def read_str(self):
+        return self.get_next_token()
+
+    def display(self, msg):
+        log.info(">> %s", msg)
+        print(msg)
+        sys.stdout.flush()
+
+    def configure_logging(self):
+        logging.basicConfig(filename=(self.args.logfile if self.args.logfile else ("wasatch-%s.log" % utils.timestamp())),
+                            level=self.args.log_level.upper(),
+                            format='%(asctime)s.%(msecs)03d %(name)s %(levelname)-8s %(message)s', 
+                            datefmt='%m/%d/%Y %I:%M:%S')
+
+    # ##############################################################################
+    # command loop
+    # ##############################################################################
+
+    def run(self):
+        self.display("-" * 80)
+        self.display("wasatch-shell version %s invoked (Wasatch.PY %s)" % (VERSION, wasatch.version))
+
+        try:
+            while True:
+                prompt = "wp> " if not self.args.timestamp else str(datetime.datetime.now()) + " wp> "
+                line = self.get_line(prompt)
+
+                # ignore comments
+                if line.startswith('#') or len(line) == 0:
+                    continue
+
+                log.info("<< %s", line)
+
+                # tokenize
+                self.input_tokens = [s.strip() for s in line.lower().strip().split()]
+                command = self.read_str()
+
+                # these commands always work
+                if command == "help":
+                    self.usage()
+                    continue
+
+                elif command == "version":
+                    self.display("WasatchShell version: %s" % VERSION)
+                    self.display("Wasatch.PY   version: %s" % wasatch.version)
+                    continue
+
+                if re.match("close|quit|exit", command):
+                    break
+
+                # these commands work if currently closed
+                if self.device is None:
+                    if command == "open":
+                        self.display(1 if self.open() else 0)
+                    else:
+                        self.display("ERROR: must open spectrometer first")
+
+                else:
+                    try:
+                        # anything past this point assumes spectrometer already open
+
+                        # pass-through gettors
+                        if command in self.gettors:
+                            self.run_gettor(command)
+                            
+                        # special processing for these
+                        elif command == "get_spectrum":
+                            self.get_spectrum(quiet=False)
+
+                        elif command == "get_dark":
+                            self.get_dark()
+                            self.display(1)
+
+                        elif command == "clear_dark":
+                            self.clear_dark()
+                            self.display(1)
+
+                        elif command == "get_spectrum_pretty":
+                            self.get_spectrum_pretty()
+
+                        elif command == "get_spectrum_save":
+                            self.get_spectrum_save()
+
+                        elif command == "get_config_json":
+                            self.display(self.device.settings.eeprom.json(allow_nan=False))
+
+                        elif command == "get_all":
+                            self.get_all()
+
+                        elif command == "connection_check":
+                            self.run_gettor("get_integration_time_ms")
+
+                        elif command == "balance_acquisition":
+                            self.balance_acquisition()
+
+                        elif command == "set_interpolated_x_axis_cm":
+                            self.set_interpolated_x_axis_cm(start = self.read_float(),
+                                                            end   = self.read_float(),
+                                                            incr  = self.read_float())
+
+                        elif command == "set_interpolated_x_axis_nm":
+                            self.set_interpolated_x_axis_nm(start = self.read_float(),
+                                                            end   = self.read_float(),
+                                                            incr  = self.read_float())
+
+                        elif command == "set_raman_intensity_correction_enable":
+                            self.set_raman_intensity_correction_enable(self.device, self.read_bool())
+
+                        elif command == "clear":
+                            self.clear()
+
+                        # currently these are the only setters implemented
+                        #
+                        # These originally called directly into 
+                        # FeatureIdentificationDevice, which was efficient, but:
+                        #
+                        #   1. missed value-add processing in WasatchDevice.change_setting, 
+                        #   2. couldn't utilize inline (non functional) 
+                        #      implementations in FID.write_setting,
+                        #   3. provided no obvious path to achieve scan averaging 
+                        #      (issues 1 and 2)
+                        #   4. potentially differed than ENLIGHTEN processing 
+                        #      while failing to exercise ENLIGHTEN communication
+                        #      path (part of the script's purpose)
+                        #
+                        # Therefore, setters now utilize WasatchDevice.change_setting 
+                        # where possible.
+                        #
+                        # An obvious CONSEQUENCE of using change_setting() over 
+                        # direct FID function calls is that no return value is 
+                        # possible on "settor" functions :-(
+
+                        elif command == "set_integration_time_ms":
+                            self.device.change_setting("integration_time_ms", self.read_int())
+                            self.display(1)
+
+                        elif command == "set_laser_watchdog_sec":
+                            self.device.change_setting("laser_watchdog_sec", self.read_int())
+                            self.display(1)
+
+                        elif command == "set_raman_delay_ms":
+                            self.device.change_setting("raman_delay_ms", self.read_int())
+                            self.display(1)
+
+                        elif command == "set_raman_mode":
+                            self.device.change_setting("raman_mode_enable", self.read_bool())
+                            self.display(1)
+
+                        elif command == "set_laser_power_mw":
+                            self.device.change_setting("laser_power_mW", self.read_float())
+                            self.display(1)
+
+                        elif command == "set_laser_power_perc":
+                            self.device.change_setting("laser_power_perc", self.read_float())
+                            self.display(1)
+
+                        elif command == "set_laser_power_attenuator":
+                            self.device.change_setting("laser_power_attenuator", self.read_int())
+                            self.display(1)
+
+                        elif command == "set_laser_enable":
+                            self.set_laser_enable(flag = self.read_bool())
+
+                        elif command == "set_laser_power_high_resolution":
+                            self.device.change_setting("laser_power_high_resolution", self.read_bool())
+                            self.display(1)
+
+                        elif command == "set_tec_enable":
+                            self.device.change_setting("detector_tec_enable", self.read_bool())
+                            self.display(1)
+
+                        elif command == "set_detector_tec_setpoint_degc":
+                            self.device.change_setting("detector_tec_setpoint_degC", self.read_float())
+                            self.display(1)
+
+                        elif command == "set_detector_offset":
+                            self.device.change_setting("detector_offset", self.read_int())
+                            self.display(1)
+
+                        elif command == "set_scans_to_average":
+                            self.device.change_setting("scans_to_average", self.read_int())
+                            self.display(1)
+
+                        elif command == "set_selected_laser":
+                            self.device.change_setting("selected_laser", self.read_int())
+                            self.display(1)
+
+                        elif command == "set_fan_enable":
+                            self.device.change_setting("fan_enable", self.read_bool())
+                            self.display(1)
+
+                        elif command == "set_lamp_enable":
+                            self.device.change_setting("lamp_enable", self.read_bool())
+                            self.display(1)
+
+                        elif command == "set_shutter_enable":
+                            self.device.change_setting("shutter_enable", self.read_bool())
+                            self.display(1)
+
+                        elif command == "set_strobe_enable":
+                            self.device.change_setting("strobe_enable", self.read_bool())
+                            self.display(1)
+
+                        elif command == "set_mod_period_us":
+                            self.device.change_setting("mod_period_us", self.read_int())
+                            self.display(1)
+
+                        elif command == "set_mod_width_us":
+                            self.device.change_setting("mod_width_us", self.read_int())
+                            self.display(1)
+
+                        elif command == "set_mod_delay_us":
+                            self.device.change_setting("mod_period_us", self.read_int())
+                            self.display(1)
+
+                        elif command == "open":
+                            # if user re-sends open command when already open, do nothing
+                            self.display(1)
+
+                        else:
+                            self.display("ERROR: unknown command: " + command)
+                    except:
+                        log.critical("caught exception", exc_info=1)
+                        log.info("disconnecting")
+                        self.device.disconnect()
+                        self.device = None
+
+                        log.info("sleeping 5sec")
+                        time.sleep(5.100)
+                        
+                        log.info("re-opening")
+                        if self.open():
+                            log.info("successfully re-opened")
+                        else:
+                            log.error("could not re-open...giving up")
+                            break
+
+                if self.args.eod:
+                    self.display("END_OF_DATA")
+
+                # whatever happened, flush stdout
+                try:
+                    sys.stdout.flush()
+                except:
+                    self.display("ERROR: caller has closed stdout...exiting")
+                    break
+
+        except Exception as e:
+            log.error(e, exc_info=1)
+            raise
+
+        # disable the laser if connected
+        if self.device is not None:
+            self.set_laser_enable(False, quiet=True)
+            self.device.disconnect()
+            self.device = None
+
+        log.info("wasatch-shell exiting")
+
+    ## 
+    # If the current device is disconnected, and there is a new device, 
+    # attempt to connect to it. """
+    def open(self):
+        # if we're already connected, nevermind
+        if self.device is not None:
+            return False
+
+        # lazy-load a USB bus
+        log.debug("instantiating WasatchBus")
+        bus = WasatchBus()
+        if not bus.device_ids:
+            self.display("No Wasatch USB spectrometers found.")
+            return False
+
+        device_id = bus.device_ids[0]
+        log.debug("open: trying to connect to %s", device_id)
+        device_id.device_type = RealUSBDevice(device_id)
+        device = WasatchDevice(device_id)
+
+        ok = device.connect()
+        if not ok.data: 
+            log.critical("open: can't connect to device on bus 1")
+            return
+
+        log.info("open: device connected")
+        self.device = device
+
+        # enable exceptions
+        self.device.hardware.raise_exceptions = True
+
+        # enable immediate mode (don't queue commands until acquire_data)
+        self.device.immediate_mode = True
+
+        # enable bare readings (don't query extra hardware metadata during acquisitions)
+        self.device.bare_readings = True
+
+        # disable free-running mode (interactive shell is the definition of "slaved to user commands")
+        self.device.change_setting("free_running_mode", False)
+
+        # laser should not be on, but even so
+        self.set_laser_enable(False, quiet=True)
+
+        # enable high-resolution laser power by default
+        self.device.change_setting("laser_power_high_resolution", True)
+
+        # if laser has power calibration, require it and initialize accordingly 
+        # (so if the user enables the laser, it won't fire at an out-of-bounds 
+        # 100% unmodulated)
+        if self.device.settings.eeprom.has_laser_power_calibration():
+            log.info("laser has power calibration, so requiring modulation and initializing to max-rated power in mW")
+            self.device.change_setting("laser_power_require_modulation", True)
+            self.device.change_setting("laser_power_mW", self.device.settings.eeprom.max_laser_power_mW)
+
+        # throw random errors
+        # self.device.hardware.random_errors = True
+
+        # validate gettors (in case this is used against a StrokerProtocol unit, for instance)
+        for func_name in list(self.gettors.keys()):
+            if not hasattr(device.hardware, self.gettors[func_name]):
+                self.display("WARNING: gettor %s (%s) not found in device" % (func_name, self.gettors[func_name]))
+                del self.gettors[func_name]
+
+        # default to minimum configured integration time
+        self.device.change_setting("integration_time_ms", self.device.settings.eeprom.min_integration_time_ms)
+
+        return True
+
+    def run_gettor(self, command):
+        func_name = self.gettors[command]
+        value = getattr(self.device.hardware, func_name)()
+
+        if isinstance(value, SpectrometerResponse):
+            if value.error_msg:
+                self.display(f"ERROR: {value.error_msg}")
+                return
+            value = value.data
+
+        if isinstance(value, bool):
+            self.display(1 if value else 0)
+        else:
+            self.display(value)
+
+    def get_dark(self):
+        spectrum = self.get_spectrum(quiet=True)
+        self.dark_spectra = spectrum
+
+    def clear_dark(self):
+        self.dark_spectra = None
+
+    def set_raman_intensity_correction_enable(self, device: WasatchDevice, status: bool): # -> int 
+        if not device.settings.eeprom.has_raman_intensity_calibration():
+            self.display("Device has no Raman Intensity Calibration")
+            self.srm = False
+            return
+        else:
+            self.srm = status
+            self.display(1)
+            return
+
+    def srm_process(self, spectrum: list[float], device: WasatchDevice): # -> list[float] 
+
+        factors = device.settings.raman_intensity_factors
+        if factors is None or len(factors) != len(spectrum):
+            return 
+
+        spectrum = [px*fac for px, fac in zip(spectrum,factors)]
+        return spectrum
+
+    ##
+    # This calls WasatchDevice.acquire_data, rather than FID.get_line, because 
+    # scan averaging, bad-pixel correction, acquisition laser trigger and other
+    # high-level acquisition features are implemented in WasatchDevice rather 
+    # than FID.
+    def get_spectrum(self, quiet=True):
+        # enqueue ACQUIRE command, as we're not in free-running mode
+        self.device.change_setting("acquire", True, allow_immediate=False)
+
+        # now collect the spectrum
+        reading_response = self.device.acquire_data()
+        reading = reading_response.data
+        if reading is None or isinstance(reading, bool) or reading.spectrum is None:
+            self.display("ERROR: get_spectrum failed")
+            return
+        spectrum = reading.spectrum
+        if self.dark_spectra is not None and len(self.dark_spectra) == len(spectrum):
+            spectrum = [spec-dark for spec, dark in zip(spectrum, self.dark_spectra)]
+        log.debug("received %d pixels", len(spectrum))
+
+        if self.srm:
+            spectrum = self.srm_process(spectrum, self.device)
+
+        if self.interpolated_x_axis_cm and self.device.settings.wavenumbers:
+            spectrum = utils.interpolate_array(spectrum, 
+                                               self.device.settings.wavenumbers, 
+                                               self.interpolated_x_axis_cm)
+        elif self.interpolated_x_axis_nm:
+            spectrum = utils.interpolate_array(spectrum, 
+                                               self.device.settings.wavelengths, 
+                                               self.interpolated_x_axis_nm)
+        if quiet:
+            return spectrum
+
+        for pixel in spectrum:
+            print(pixel)
+
+    def get_spectrum_save(self):
+        spectrum = self.get_spectrum()
+        if spectrum is None:
+            return 
+
+        if self.has_input():
+            filename = self.read_str()
+        else:
+            filename = datetime.datetime.now().strftime("%Y%m%d-%H%M%S.csv")
+
+        with open(filename, "w") as outfile:
+            for i in range(len(spectrum)):
+                if self.interpolated_x_axis_cm:
+                    x = self.interpolated_x_axis_cm[i]
+                elif self.interpolated_x_axis_nm:
+                    x = self.interpolated_x_axis_nm[i]
+                elif self.device.settings.wavenumbers:
+                    x = self.device.settings.wavenumbers[i]
+                else:
+                    x = self.device.settings.wavelengths[i]
+                outfile.write("%.2f,%.2f\n" % (x, spectrum[i]))
+
+    def get_spectrum_pretty(self):
+        spectrum = self.get_spectrum()
+        if spectrum is None:
+            return 
+
+        if self.interpolated_x_axis_cm:
+            x_axis = self.interpolated_x_axis_cm
+            x_unit = "cm-1"
+        elif self.interpolated_x_axis_nm:
+            x_axis = self.interpolated_x_axis_nm
+            x_unit = "nm"
+        elif self.device.settings.wavenumbers:
+            x_axis = self.device.settings.wavenumbers
+            x_unit = "cm-1"
+        else:
+            x_axis = self.device.settings.wavelengths
+            x_unit = "nm"
+
+        lines = utils.ascii_spectrum(spectrum=spectrum, rows=24, cols=80, x_axis=x_axis, x_unit=x_unit)
+        for line in lines:
+            self.display(line)
+
+    def set_laser_enable(self, flag, quiet=False):
+        self.device.change_setting("laser_enable", flag)
+        return None if quiet else self.display(1)
+
+    ## should use numpy.arange
+    def generate_interpolated_x_axis(self, start, end, incr):
+        if incr == 0 or start >= end:
+            return [ start ]
+
+        axis = []
+        x = start
+        while x <= end:
+            axis.append(x)
+            x += incr
+        return axis
+                
+    def set_interpolated_x_axis_cm(self, start, end, incr):
+        self.interpolated_x_axis_cm = self.generate_interpolated_x_axis(start, end, incr)
+        self.display(1)
+
+    def set_interpolated_x_axis_nm(self, start, end, incr):
+        self.interpolated_x_axis_nm = self.generate_interpolated_x_axis(start, end, incr)
+        self.display(1)
+
+    def clear(self):
+        self.interpolated_x_axis_nm = None
+        self.interpolated_x_axis_cm = None
+        # ...more...
+
+    ## takes mode [integ, laser, laser_and_integ], intensity, threshold, x, unit [px, nm, cm]
+    def balance_acquisition(self):
+        mode                    = "integration" if not self.has_input() else self.read_str()
+        intensity               = 45000         if not self.has_input() else self.read_float()
+        threshold               = 2500          if not self.has_input() else self.read_float()
+        max_integration_time_ms = 5000          if not self.has_input() else self.read_int()
+        max_tries               = 20            if not self.has_input() else self.read_int()
+        x_value                 = None          if not self.has_input() else self.read_float()
+        unit                    = "px"          if not self.has_input() else self.read_str()
+
+        if not re.match('(px|cm|nm)$', unit):
+            return self.display(f"ERROR: invalid unit {unit}")
+
+        pixel = None
+        if x_value is not None:
+            if unit == "px":
+                pixel = int(x_value)
+            elif unit == "nm":
+                pixel = utils.find_nearest_index(self.device.settings.wavelengths, x_value)
+            elif unit == "cm" and self.device.settings.wavenumbers:
+                pixel = utils.find_nearest_index(self.device.settings.wavenumbers, x_value)
+            else:
+                return self.display("ERROR: can't determine pixel from %s %s" % (x_value, unit))
+
+        ok = self.device.balance_acquisition(
+                mode                    = mode, 
+                intensity               = intensity, 
+                threshold               = threshold, 
+                pixel                   = pixel, 
+                max_integration_time_ms = max_integration_time_ms, 
+                max_tries               = max_tries)
+
+        if ok:
+            self.display("Ok integration_time_ms %s laser_power %s %s" % (
+                self.device.settings.state.integration_time_ms,
+                self.device.settings.state.laser_power, 
+                "mW" if self.device.settings.state.laser_power_in_mW else "percent"))
+        else:
+            self.display(0)
+
+    def get_all(self):
+        for command in sorted(self.gettors):
+            func_name = self.gettors[command]
+            value = getattr(self.device.hardware, func_name)()
+            if isinstance(value, bool):
+                value = 1 if value else 0
+            self.display("%-40s: %s" % (command, value))
+
+# ##############################################################################
+# main()
+# ##############################################################################
+
+shell = None
+if __name__ == "__main__":
+    shell = WasatchShell()
+    shell.run()
```

### Comparing `wasatch-2.1.35/demo-simple.py` & `wasatch-2.1.64/demo-simple.py`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/demo-virtual.py` & `wasatch-2.1.64/demo-virtual.py`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/demo-workflow.py` & `wasatch-2.1.64/demo-workflow.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,15 +5,14 @@
 In particular, it walks the user through a short process to optimize the working
 distance by checking the height of a specific expected Raman peak (the 801.3cm⁻¹
 peak of cyclohexane, in this case) matches a prescribed threshold.
 """
 
 import sys
 import time
-import wasatch
 import numpy as np
 import scipy.signal
 
 from wasatch.WasatchBus    import WasatchBus
 from wasatch.WasatchDevice import WasatchDevice
 from wasatch.RealUSBDevice import RealUSBDevice
```

### Comparing `wasatch-2.1.35/demo.py` & `wasatch-2.1.64/demo.py`

 * *Files 2% similar despite different names*

```diff
@@ -34,15 +34,15 @@
 from wasatch.OceanDevice          import OceanDevice
 from wasatch.WasatchDevice        import WasatchDevice
 from wasatch.WasatchDeviceWrapper import WasatchDeviceWrapper
 from wasatch.RealUSBDevice        import RealUSBDevice
 
 log = logging.getLogger(__name__)
 
-class WasatchDemo(object):
+class WasatchDemo:
 
     ############################################################################
     #                                                                          #
     #                               Lifecycle                                  #
     #                                                                          #
     ############################################################################
 
@@ -189,15 +189,15 @@
                         self.exiting = True
 
         log.debug("WasatchDemo.run exiting")
 
     def attempt_reading(self):
         try:
             reading_response = self.acquire_reading()
-        except Exception as exc:
+        except:
             log.critical("attempt_reading caught exception", exc_info=1)
             self.exiting = True
             return
 
         if isinstance(reading_response.data, bool):
             if reading_response.data:
                 log.debug("received poison-pill, exiting")
```

### Comparing `wasatch-2.1.35/screenshots/multiplatform.png` & `wasatch-2.1.64/screenshots/multiplatform.png`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/scripts/dark-vs-integ.py` & `wasatch-2.1.64/scripts/dark-vs-integ.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,13 @@
 #!/usr/bin/env python
 
 import sys
 import logging
 import argparse
 import datetime
-import statistics
 
 import numpy as np
 
 from wasatch.WasatchBus    import WasatchBus
 from wasatch.WasatchDevice import WasatchDevice
 
 log = logging.getLogger(__name__)
```

### Comparing `wasatch-2.1.35/scripts/deploy` & `wasatch-2.1.64/scripts/deploy`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/setup.cfg` & `wasatch-2.1.64/setup.cfg`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/testSpectrometers/SiG_785/eeprom/EEPROM-EM-9c65d19f4c.json` & `wasatch-2.1.64/testSpectrometers/SiG_785/eeprom/EEPROM-EM-9c65d19f4c.json`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/testSpectrometers/SiG_785/readings/enlighten-20210329-094722-799520-WP-00686.csv` & `wasatch-2.1.64/testSpectrometers/SiG_785/readings/enlighten-20210329-094722-799520-WP-00686.csv`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/testSpectrometers/SiG_785/readings/enlighten-20210329-094755-288958-WP-00686.csv` & `wasatch-2.1.64/testSpectrometers/SiG_785/readings/enlighten-20210329-094755-288958-WP-00686.csv`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/testSpectrometers/WP-00887/eeprom/WP-00887-mock.json` & `wasatch-2.1.64/testSpectrometers/WP-00887/eeprom/WP-00887-mock.json`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/testSpectrometers/WP-00904/eeprom/WP-00904-mock.json` & `wasatch-2.1.64/testSpectrometers/WP-00904/eeprom/WP-00904-mock.json`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/testSpectrometers/WP-00913/eeprom/WP-00913-mock.json` & `wasatch-2.1.64/testSpectrometers/WP-00913/eeprom/WP-00913-mock.json`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/tests/existing_implementations.py` & `wasatch-2.1.64/tests/existing_implementations.py`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/tests/noise-by-setpoint.py` & `wasatch-2.1.64/tests/noise-by-setpoint.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,29 +1,25 @@
 #!/usr/bin/env python
 
 import re
-import os
 import sys
 import time
 import numpy
-import signal
 import logging
 import datetime
 import argparse
 
 import wasatch
-from wasatch import utils
 from wasatch import applog
 from wasatch.WasatchBus           import WasatchBus
 from wasatch.WasatchDevice        import WasatchDevice
-from wasatch.WasatchDeviceWrapper import WasatchDeviceWrapper
 
 log = logging.getLogger(__name__)
 
-class Test(object):
+class Test:
 
     def __init__(self, argv=None):
         self.bus     = None
         self.device  = None
         self.logger  = None
         self.outfile = None
         self.exiting = False
@@ -117,15 +113,14 @@
                 
             if self.exiting:
                 break
 
     # probably a numpy one-liner for this...
     def process(self, spectra):
         # compute the stdev for each pixel over time, placing in new array
-        count = len(spectra)
         pixels = len(spectra[0])
         stdevs = []
         for pix in range(pixels):
             col = []
             for spectrum in spectra:
                 col.append(spectrum[pix])
             stdevs.append(numpy.std(col))
```

### Comparing `wasatch-2.1.35/tests/queues.py` & `wasatch-2.1.64/tests/queues.py`

 * *Files 26% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 import psutil
 import random
 import datetime
 import multiprocessing
 
 max_readings = 10000
 
-class Reading(object):
+class Reading:
     count = 0
 
     def __init__(self):
         Reading.count += 1
 
         self.id = Reading.count
         self.timestamp = datetime.datetime.now()
@@ -38,19 +38,19 @@
         self.battery_raw               = int(self.rand(0, 4096))
         self.battery_percentage        = int(self.rand(0, 100))
         self.battery_charging          = None
 
     def rand(self, lo, hi):
         return lo + (hi - lo) * random.random()
 
-class SubprocessArgs(object):
+class SubprocessArgs:
     def __init__(self, response_queue):
         self.response_queue = response_queue
 
-class Wrapper(object):
+class Wrapper:
     def __init__(self):
         self.manager = multiprocessing.Manager()
         self.response_queue = self.manager.Queue(100) 
         self.poller = None 
 
     def connect(self):
         subprocessArgs = SubprocessArgs(response_queue = self.response_queue)
@@ -66,69 +66,69 @@
                 reading = self.response_queue.get_nowait()
                 if reading is None:
                     # nothing in the queue
                     return None
                 elif isinstance(reading, bool):
                     return reading
                 else:
-                    print "acquire_data: read Reading %d" % reading.id
+                    print(f"acquire_data: read Reading {reading.id}")
                     dequeue_count += 1
                     last_reading = reading
             except Queue.Empty:
                 break
 
         if dequeue_count > 1:
-            print "acquire_data: discarded %d readings" % (dequeue_count - 1)
+            print(f"acquire_data: discarded {dequeue_count - 1} readings")
 
         return last_reading
 
     def continuous_poll(self, args):
         pid = os.getpid()
-        print "worker: entering loop in process %d" % pid
+        print(f"worker: entering loop in process {pid}")
         count = 0
         while True:
             # sleep_sec = 0.01 + (.01 * random.random())
             # print "worker: sleeping %.2f sec" % sleep_sec
             # time.sleep(sleep_sec)
 
             reading = Reading()
-            print "worker: enqueuing reading %d" % reading.id
+            print(f"worker: enqueuing reading {reading.id}")
             args.response_queue.put(reading, timeout=1)
             count += 1
 
             if count >= max_readings:
-                print "worker: enqueued %d readings, quitting" % count
+                print(f"worker: enqueued {count}, readings, quitting")
                 break
                 
-        print "worker: sending poison-pill"
+        print("worker: sending poison-pill")
         args.response_queue.put(True, timeout=1)
 
-        print "worker: exiting"
+        print("worker: exiting")
         sys.exit()
 
 parent_pid = os.getpid()
-print "Main: Running from pid %d" % parent_pid
+print(f"Main: Running from pid {parent_pid}")
 
-print "Main: instantiating Wrapper"
+print("Main: instantiating Wrapper")
 wrapper = Wrapper()
 
-print "Main: connecting to background process"
+print("Main: connecting to background process")
 wrapper.connect()
 
-print "Main: reading spectra"
+print("Main: reading spectra")
 while True:
     reading = wrapper.acquire_data()
     if reading is None:
-        print "Main: no reading available"
-    elif isinstance(reading, bool) and reading == True:
+        print("Main: no reading available")
+    elif isinstance(reading, bool) and reading:
         print("Main: received poison-pill, exiting")
         break
     else:
-        print "Main: received reading %d (%s)" % (reading.id, reading.spectrum[:10])
+        print("Main: received reading %d (%s)" % (reading.id, reading.spectrum[:10]))
 
     size_in_bytes = psutil.Process(parent_pid).memory_info().rss
-    print "Main: memory = %d bytes" % size_in_bytes
+    print("Main: memory = %d bytes" % size_in_bytes)
 
-    print "Main: sleeping 1 sec"
+    print("Main: sleeping 1 sec")
     time.sleep(1)
 
-print "Main: exiting"
+print("Main: exiting")
```

### Comparing `wasatch-2.1.35/tests/unit.py` & `wasatch-2.1.64/tests/unit.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,199 +1,193 @@
-00000000: 0d0a 2320 5761 7361 7463 682e 5059 2075  ..# Wasatch.PY u
-00000010: 6e69 7420 7465 7374 730d 0a23 2052 756e  nit tests..# Run
-00000020: 2074 6869 7320 7072 6f67 7261 6d20 7769   this program wi
-00000030: 7468 6f75 7420 6172 6775 6d65 6e74 7320  thout arguments 
-00000040: 696e 2079 6f75 7220 6465 7665 6c6f 706d  in your developm
-00000050: 656e 7420 656e 7620 746f 2067 656e 6572  ent env to gener
-00000060: 6174 6520 6120 7465 7374 2072 6570 6f72  ate a test repor
-00000070: 742e 0d0a 0d0a 2320 6164 6420 7761 7361  t.....# add wasa
-00000080: 7463 6820 666f 6c64 6572 2074 6f20 696d  tch folder to im
-00000090: 706f 7274 2070 6174 6820 696e 6465 7065  port path indepe
-000000a0: 6e64 656e 7420 6f66 2063 7764 0d0a 696d  ndent of cwd..im
-000000b0: 706f 7274 2073 7973 2c20 6f73 0d0a 6669  port sys, os..fi
+00000000: 0a23 2057 6173 6174 6368 2e50 5920 756e  .# Wasatch.PY un
+00000010: 6974 2074 6573 7473 0a23 2052 756e 2074  it tests.# Run t
+00000020: 6869 7320 7072 6f67 7261 6d20 7769 7468  his program with
+00000030: 6f75 7420 6172 6775 6d65 6e74 7320 696e  out arguments in
+00000040: 2079 6f75 7220 6465 7665 6c6f 706d 656e   your developmen
+00000050: 7420 656e 7620 746f 2067 656e 6572 6174  t env to generat
+00000060: 6520 6120 7465 7374 2072 6570 6f72 742e  e a test report.
+00000070: 0a0a 2320 6164 6420 7761 7361 7463 6820  ..# add wasatch 
+00000080: 666f 6c64 6572 2074 6f20 696d 706f 7274  folder to import
+00000090: 2070 6174 6820 696e 6465 7065 6e64 656e   path independen
+000000a0: 7420 6f66 2063 7764 0a69 6d70 6f72 7420  t of cwd.import 
+000000b0: 7379 730a 696d 706f 7274 206f 730a 6669  sys.import os.fi
 000000c0: 6c65 666f 6c64 6572 203d 206f 732e 7061  lefolder = os.pa
 000000d0: 7468 2e64 6972 6e61 6d65 285f 5f66 696c  th.dirname(__fil
-000000e0: 655f 5f29 0d0a 7379 732e 7061 7468 2e61  e__)..sys.path.a
-000000f0: 7070 656e 6428 6669 6c65 666f 6c64 6572  ppend(filefolder
-00000100: 202b 206f 732e 7365 7020 2b20 222e 2e22   + os.sep + ".."
-00000110: 202b 206f 732e 7365 7020 2b20 2277 6173   + os.sep + "was
-00000120: 6174 6368 2229 0d0a 0d0a 2320 756e 6e65  atch")....# unne
-00000130: 6365 7373 6172 7920 6275 7420 6675 6e0d  cessary but fun.
-00000140: 0a66 726f 6d20 7368 7574 696c 2069 6d70  .from shutil imp
-00000150: 6f72 7420 6765 745f 7465 726d 696e 616c  ort get_terminal
-00000160: 5f73 697a 650d 0a45 5155 414c 4252 4541  _size..EQUALBREA
-00000170: 4b20 3d20 273d 272a 6765 745f 7465 726d  K = '='*get_term
-00000180: 696e 616c 5f73 697a 6528 2837 322c 3029  inal_size((72,0)
-00000190: 295b 305d 0d0a 4c49 4e45 4252 4541 4b20  )[0]..LINEBREAK 
-000001a0: 3d20 272d 272a 6765 745f 7465 726d 696e  = '-'*get_termin
-000001b0: 616c 5f73 697a 6528 2837 322c 3029 295b  al_size((72,0))[
-000001c0: 305d 0d0a 0d0a 6672 6f6d 2072 616e 646f  0]....from rando
-000001d0: 6d20 696d 706f 7274 2072 616e 646f 6d2c  m import random,
-000001e0: 2073 6565 640d 0a23 2062 6520 6465 7465   seed..# be dete
-000001f0: 726d 696e 6973 7469 630d 0a73 6565 6428  rministic..seed(
-00000200: 3029 0d0a 696d 706f 7274 206e 756d 7079  0)..import numpy
-00000210: 0d0a 696d 706f 7274 2065 7869 7374 696e  ..import existin
-00000220: 675f 696d 706c 656d 656e 7461 7469 6f6e  g_implementation
-00000230: 730d 0a0d 0a23 206d 6f64 756c 6573 2074  s....# modules t
-00000240: 6f20 7465 7374 0d0a 696d 706f 7274 2075  o test..import u
-00000250: 7469 6c73 0d0a 0d0a 6465 6620 6765 6e5f  tils....def gen_
-00000260: 7370 6563 7472 6128 293a 0d0a 2020 2020  spectra():..    
-00000270: 2222 220d 0a20 2020 2043 6f70 6965 6420  """..    Copied 
-00000280: 6672 6f6d 2070 7975 7362 2d76 6972 7453  from pyusb-virtS
-00000290: 7065 632f 7573 622f 7761 7361 7463 6843  pec/usb/wasatchC
-000002a0: 6f6e 6669 672e 7079 200d 0a20 2020 2022  onfig.py ..    "
-000002b0: 2222 0d0a 2020 2020 7065 616b 7320 3d20  ""..    peaks = 
-000002c0: 5b28 3832 332e 3136 332c 2032 2e36 6532  [(823.163, 2.6e2
-000002d0: 292c 2028 3832 382e 3031 322c 2031 2e32  ), (828.012, 1.2
-000002e0: 6532 292c 2028 3834 302e 3931 392c 202e  e2), (840.919, .
-000002f0: 3035 6532 292c 2028 3838 312e 3934 312c  05e2), (881.941,
-00000300: 2035 2e38 6532 292c 2028 3839 352e 3232   5.8e2), (895.22
-00000310: 352c 202e 3865 3229 2c20 2839 3034 2e35  5, .8e2), (904.5
-00000320: 3435 2c20 2e37 3865 3229 2c20 2839 3136  45, .78e2), (916
-00000330: 2e32 3635 2c20 2e35 3365 3229 5d0d 0a20  .265, .53e2)].. 
-00000340: 2020 2070 6561 6b73 203d 205b 2828 782d     peaks = [((x-
-00000350: 3830 3029 202a 2028 3130 3234 2f32 3030  800) * (1024/200
-00000360: 292c 2079 2920 666f 7220 2878 2c79 2920  ), y) for (x,y) 
-00000370: 696e 2070 6561 6b73 5d0d 0a20 2020 206e  in peaks]..    n
-00000380: 6f69 7365 203d 2031 300d 0a20 2020 2072  oise = 10..    r
-00000390: 6574 7572 6e20 5b69 6e74 2873 756d 285b  eturn [int(sum([
-000003a0: 705b 315d 2f28 312b 2878 2d70 5b30 5d29  p[1]/(1+(x-p[0])
-000003b0: 2a2a 3429 2066 6f72 2070 2069 6e20 7065  **4) for p in pe
-000003c0: 616b 735d 292b 6e6f 6973 652a 7261 6e64  aks])+noise*rand
-000003d0: 6f6d 2829 2920 666f 7220 7820 696e 2072  om()) for x in r
-000003e0: 616e 6765 2831 3032 3429 5d0d 0a0d 0a64  ange(1024)]....d
-000003f0: 6566 2063 6f6d 7061 7265 5f6e 756d 6572  ef compare_numer
-00000400: 6963 5f61 7272 6179 7328 6163 7475 616c  ic_arrays(actual
-00000410: 2c20 6b6e 6f77 6e29 3a0d 0a0d 0a20 2020  , known):....   
-00000420: 2069 6620 6c65 6e28 6b6e 6f77 6e29 203c   if len(known) <
-00000430: 206c 656e 2861 6374 7561 6c29 3a0d 0a20   len(actual):.. 
-00000440: 2020 2020 2020 2070 7269 6e74 2822 4172         print("Ar
-00000450: 7261 7973 2064 6f20 6e6f 7420 6d61 7463  rays do not matc
-00000460: 6820 6c65 6e67 7468 2e22 290d 0a20 2020  h length.")..   
-00000470: 2020 2020 2070 7269 6e74 2822 5468 6572       print("Ther
-00000480: 6520 6172 6520 2573 2d25 733d 2573 2065  e are %s-%s=%s e
-00000490: 7874 7261 2065 6e74 7269 6573 2220 2520  xtra entries" % 
-000004a0: 286c 656e 2861 6374 7561 6c29 2c20 6c65  (len(actual), le
-000004b0: 6e28 6b6e 6f77 6e29 2c20 6c65 6e28 6163  n(known), len(ac
-000004c0: 7475 616c 292d 6c65 6e28 6b6e 6f77 6e29  tual)-len(known)
-000004d0: 2929 0d0a 2020 2020 6966 206c 656e 286b  ))..    if len(k
-000004e0: 6e6f 776e 2920 3e20 6c65 6e28 6163 7475  nown) > len(actu
-000004f0: 616c 293a 0d0a 2020 2020 2020 2020 7072  al):..        pr
-00000500: 696e 7428 2241 7272 6179 7320 646f 206e  int("Arrays do n
-00000510: 6f74 206d 6174 6368 206c 656e 6774 682e  ot match length.
-00000520: 2229 0d0a 2020 2020 2020 2020 7072 696e  ")..        prin
-00000530: 7428 2254 6865 7265 2061 7265 206d 6973  t("There are mis
-00000540: 7369 6e67 2025 732d 2573 3d25 7320 6578  sing %s-%s=%s ex
-00000550: 7472 6120 656e 7472 6965 7322 2025 2028  tra entries" % (
-00000560: 6c65 6e28 6b6e 6f77 6e29 2c20 6c65 6e28  len(known), len(
-00000570: 6163 7475 616c 292c 206c 656e 286b 6e6f  actual), len(kno
-00000580: 776e 292d 6c65 6e28 6163 7475 616c 2929  wn)-len(actual))
-00000590: 290d 0a0d 0a20 2020 2074 6c65 6e20 3d20  )....    tlen = 
-000005a0: 6d69 6e28 6c65 6e28 6b6e 6f77 6e29 2c20  min(len(known), 
-000005b0: 6c65 6e28 6163 7475 616c 2929 0d0a 0d0a  len(actual))....
-000005c0: 2020 2020 6578 6163 7420 3d20 300d 0a20      exact = 0.. 
-000005d0: 2020 2077 6974 6869 6e35 7065 7263 656e     within5percen
-000005e0: 7420 3d20 300d 0a20 2020 2065 7272 6f72  t = 0..    error
-000005f0: 203d 2030 0d0a 0d0a 2020 2020 666f 7220   = 0....    for 
-00000600: 6920 696e 2072 616e 6765 2874 6c65 6e29  i in range(tlen)
-00000610: 3a0d 0a20 2020 2020 2020 2065 7272 6f72  :..        error
-00000620: 202b 3d20 286b 6e6f 776e 5b69 5d2d 6163   += (known[i]-ac
-00000630: 7475 616c 5b69 5d29 2a2a 320d 0a0d 0a20  tual[i])**2.... 
-00000640: 2020 2020 2020 2069 6620 6b6e 6f77 6e5b         if known[
-00000650: 695d 203d 3d20 6163 7475 616c 5b69 5d3a  i] == actual[i]:
-00000660: 0d0a 2020 2020 2020 2020 2020 2020 6578  ..            ex
-00000670: 6163 7420 2b3d 2031 0d0a 2020 2020 2020  act += 1..      
-00000680: 2020 656c 6966 2061 6374 7561 6c5b 695d    elif actual[i]
-00000690: 2061 6e64 2061 6273 286b 6e6f 776e 5b69   and abs(known[i
-000006a0: 5d2d 6163 7475 616c 5b69 5d29 2f61 6374  ]-actual[i])/act
-000006b0: 7561 6c5b 695d 203c 202e 3035 3a0d 0a20  ual[i] < .05:.. 
-000006c0: 2020 2020 2020 2020 2020 2077 6974 6869             withi
-000006d0: 6e35 7065 7263 656e 7420 2b3d 2031 0d0a  n5percent += 1..
-000006e0: 0d0a 2020 2020 7072 696e 7428 2225 2e32  ..    print("%.2
-000006f0: 6625 2520 2825 6420 656e 7472 6965 7329  f%% (%d entries)
-00000700: 2069 7320 616e 2065 7861 6374 206d 6174   is an exact mat
-00000710: 6368 2e22 2025 2028 3130 302a 6578 6163  ch." % (100*exac
-00000720: 742f 746c 656e 2c20 6578 6163 7429 290d  t/tlen, exact)).
-00000730: 0a20 2020 2070 7269 6e74 2822 252e 3266  .    print("%.2f
-00000740: 2525 2028 2564 2065 6e74 7269 6573 2920  %% (%d entries) 
-00000750: 646f 6573 206e 6f74 206d 6174 6368 2062  does not match b
-00000760: 7574 2069 7320 7769 7468 696e 2035 2525  ut is within 5%%
-00000770: 2e22 2025 2028 3130 302a 7769 7468 696e  ." % (100*within
-00000780: 3570 6572 6365 6e74 2f74 6c65 6e2c 2077  5percent/tlen, w
-00000790: 6974 6869 6e35 7065 7263 656e 7429 290d  ithin5percent)).
-000007a0: 0a20 2020 2070 7269 6e74 2822 252e 3266  .    print("%.2f
-000007b0: 2525 2028 2564 2065 6e74 7269 6573 2920  %% (%d entries) 
-000007c0: 6973 206d 6f72 6520 7468 616e 2035 2525  is more than 5%%
-000007d0: 2064 6966 6665 7265 6e74 2e22 2025 2028   different." % (
-000007e0: 3130 302a 2874 6c65 6e2d 7769 7468 696e  100*(tlen-within
-000007f0: 3570 6572 6365 6e74 2d65 7861 6374 292f  5percent-exact)/
-00000800: 746c 656e 2c20 746c 656e 2d77 6974 6869  tlen, tlen-withi
-00000810: 6e35 7065 7263 656e 742d 6578 6163 7429  n5percent-exact)
-00000820: 290d 0a20 2020 2070 7269 6e74 2822 4572  )..    print("Er
-00000830: 726f 7220 6661 6374 6f72 3a20 252e 3266  ror factor: %.2f
-00000840: 2220 2520 6572 726f 722a 2a2e 3529 0d0a  " % error**.5)..
-00000850: 0d0a 6966 205f 5f6e 616d 655f 5f20 3d3d  ..if __name__ ==
-00000860: 2022 5f5f 6d61 696e 5f5f 223a 0d0a 2020   "__main__":..  
-00000870: 2020 7072 696e 7428 4551 5541 4c42 5245    print(EQUALBRE
-00000880: 414b 290d 0a20 2020 2070 7269 6e74 2822  AK)..    print("
-00000890: 436f 6d70 6172 696e 6720 7574 696c 732e  Comparing utils.
-000008a0: 6170 706c 795f 626f 7863 6172 2077 6974  apply_boxcar wit
-000008b0: 6820 6b6e 6f77 6e20 696d 706c 656d 656e  h known implemen
-000008c0: 7461 7469 6f6e 2e22 290d 0a20 2020 2073  tation.")..    s
-000008d0: 7065 6374 7275 6d20 3d20 6765 6e5f 7370  pectrum = gen_sp
-000008e0: 6563 7472 6128 290d 0a20 2020 2070 7269  ectra()..    pri
-000008f0: 6e74 284c 494e 4542 5245 414b 290d 0a20  nt(LINEBREAK).. 
-00000900: 2020 2070 7269 6e74 2827 5369 6d20 7370     print('Sim sp
-00000910: 6563 7472 6120 7769 7468 2068 616c 665f  ectra with half_
-00000920: 7769 6474 683d 3527 290d 0a20 2020 206b  width=5')..    k
-00000930: 6e6f 776e 5f6f 7574 203d 2065 7869 7374  nown_out = exist
-00000940: 696e 675f 696d 706c 656d 656e 7461 7469  ing_implementati
-00000950: 6f6e 732e 7574 696c 732e 6170 706c 795f  ons.utils.apply_
-00000960: 626f 7863 6172 2873 7065 6374 7275 6d2c  boxcar(spectrum,
-00000970: 2035 290d 0a20 2020 2061 6374 7561 6c5f   5)..    actual_
-00000980: 6f75 7420 3d20 7574 696c 732e 6170 706c  out = utils.appl
-00000990: 795f 626f 7863 6172 2873 7065 6374 7275  y_boxcar(spectru
-000009a0: 6d2c 2035 290d 0a20 2020 2063 6f6d 7061  m, 5)..    compa
-000009b0: 7265 5f6e 756d 6572 6963 5f61 7272 6179  re_numeric_array
-000009c0: 7328 6163 7475 616c 5f6f 7574 2c20 6b6e  s(actual_out, kn
-000009d0: 6f77 6e5f 6f75 7429 0d0a 2020 2020 7072  own_out)..    pr
-000009e0: 696e 7428 4c49 4e45 4252 4541 4b29 0d0a  int(LINEBREAK)..
-000009f0: 2020 2020 7072 696e 7428 2753 696d 2073      print('Sim s
-00000a00: 7065 6374 7261 2077 6974 6820 6861 6c66  pectra with half
-00000a10: 5f77 6964 7468 3d32 3027 290d 0a20 2020  _width=20')..   
-00000a20: 206b 6e6f 776e 5f6f 7574 203d 2065 7869   known_out = exi
-00000a30: 7374 696e 675f 696d 706c 656d 656e 7461  sting_implementa
-00000a40: 7469 6f6e 732e 7574 696c 732e 6170 706c  tions.utils.appl
-00000a50: 795f 626f 7863 6172 2873 7065 6374 7275  y_boxcar(spectru
-00000a60: 6d2c 2032 3029 0d0a 2020 2020 6163 7475  m, 20)..    actu
-00000a70: 616c 5f6f 7574 203d 2075 7469 6c73 2e61  al_out = utils.a
-00000a80: 7070 6c79 5f62 6f78 6361 7228 7370 6563  pply_boxcar(spec
-00000a90: 7472 756d 2c20 3230 290d 0a20 2020 2023  trum, 20)..    #
-00000aa0: 2063 6f6d 7061 7265 5f61 7272 6179 7320   compare_arrays 
-00000ab0: 7072 696e 7473 2061 2073 7562 2d72 6570  prints a sub-rep
-00000ac0: 6f72 7420 6261 7365 6420 6f6e 206b 6e6f  ort based on kno
-00000ad0: 776e 2076 7320 6163 7475 616c 2e0d 0a20  wn vs actual... 
-00000ae0: 2020 2063 6f6d 7061 7265 5f6e 756d 6572     compare_numer
-00000af0: 6963 5f61 7272 6179 7328 6163 7475 616c  ic_arrays(actual
-00000b00: 5f6f 7574 2c20 6b6e 6f77 6e5f 6f75 7429  _out, known_out)
-00000b10: 0d0a 2020 2020 7072 696e 7428 4c49 4e45  ..    print(LINE
-00000b20: 4252 4541 4b29 0d0a 2020 2020 7072 696e  BREAK)..    prin
-00000b30: 7428 2753 696d 2073 7065 6374 7261 2077  t('Sim spectra w
-00000b40: 6974 6820 6861 6c66 5f77 6964 7468 3d31  ith half_width=1
-00000b50: 3030 2729 0d0a 2020 2020 6b6e 6f77 6e5f  00')..    known_
-00000b60: 6f75 7420 3d20 6578 6973 7469 6e67 5f69  out = existing_i
-00000b70: 6d70 6c65 6d65 6e74 6174 696f 6e73 2e75  mplementations.u
-00000b80: 7469 6c73 2e61 7070 6c79 5f62 6f78 6361  tils.apply_boxca
-00000b90: 7228 7370 6563 7472 756d 2c20 3130 3029  r(spectrum, 100)
-00000ba0: 0d0a 2020 2020 6163 7475 616c 5f6f 7574  ..    actual_out
-00000bb0: 203d 2075 7469 6c73 2e61 7070 6c79 5f62   = utils.apply_b
-00000bc0: 6f78 6361 7228 7370 6563 7472 756d 2c20  oxcar(spectrum, 
-00000bd0: 3130 3029 0d0a 2020 2020 2320 636f 6d70  100)..    # comp
-00000be0: 6172 655f 6172 7261 7973 2070 7269 6e74  are_arrays print
-00000bf0: 7320 6120 7375 622d 7265 706f 7274 2062  s a sub-report b
-00000c00: 6173 6564 206f 6e20 6b6e 6f77 6e20 7673  ased on known vs
-00000c10: 2061 6374 7561 6c2e 0d0a 2020 2020 636f   actual...    co
-00000c20: 6d70 6172 655f 6e75 6d65 7269 635f 6172  mpare_numeric_ar
-00000c30: 7261 7973 2861 6374 7561 6c5f 6f75 742c  rays(actual_out,
-00000c40: 206b 6e6f 776e 5f6f 7574 290d 0a20 2020   known_out)..   
-00000c50: 2070 7269 6e74 2845 5155 414c 4252 4541   print(EQUALBREA
-00000c60: 4b29 0d0a 0d0a 0d0a 0d0a                 K)........
+000000e0: 655f 5f29 0a73 7973 2e70 6174 682e 6170  e__).sys.path.ap
+000000f0: 7065 6e64 2866 696c 6566 6f6c 6465 7220  pend(filefolder 
+00000100: 2b20 6f73 2e73 6570 202b 2022 2e2e 2220  + os.sep + ".." 
+00000110: 2b20 6f73 2e73 6570 202b 2022 7761 7361  + os.sep + "wasa
+00000120: 7463 6822 290a 0a23 2075 6e6e 6563 6573  tch")..# unneces
+00000130: 7361 7279 2062 7574 2066 756e 0a66 726f  sary but fun.fro
+00000140: 6d20 7368 7574 696c 2069 6d70 6f72 7420  m shutil import 
+00000150: 6765 745f 7465 726d 696e 616c 5f73 697a  get_terminal_siz
+00000160: 650a 4551 5541 4c42 5245 414b 203d 2027  e.EQUALBREAK = '
+00000170: 3d27 2a67 6574 5f74 6572 6d69 6e61 6c5f  ='*get_terminal_
+00000180: 7369 7a65 2828 3732 2c30 2929 5b30 5d0a  size((72,0))[0].
+00000190: 4c49 4e45 4252 4541 4b20 3d20 272d 272a  LINEBREAK = '-'*
+000001a0: 6765 745f 7465 726d 696e 616c 5f73 697a  get_terminal_siz
+000001b0: 6528 2837 322c 3029 295b 305d 0a0a 6672  e((72,0))[0]..fr
+000001c0: 6f6d 2072 616e 646f 6d20 696d 706f 7274  om random import
+000001d0: 2072 616e 646f 6d2c 2073 6565 640a 2320   random, seed.# 
+000001e0: 6265 2064 6574 6572 6d69 6e69 7374 6963  be deterministic
+000001f0: 0a73 6565 6428 3029 0a69 6d70 6f72 7420  .seed(0).import 
+00000200: 6578 6973 7469 6e67 5f69 6d70 6c65 6d65  existing_impleme
+00000210: 6e74 6174 696f 6e73 0a0a 2320 6d6f 6475  ntations..# modu
+00000220: 6c65 7320 746f 2074 6573 740a 696d 706f  les to test.impo
+00000230: 7274 2075 7469 6c73 0a0a 6465 6620 6765  rt utils..def ge
+00000240: 6e5f 7370 6563 7472 6128 293a 0a20 2020  n_spectra():.   
+00000250: 2022 2222 0a20 2020 2043 6f70 6965 6420   """.    Copied 
+00000260: 6672 6f6d 2070 7975 7362 2d76 6972 7453  from pyusb-virtS
+00000270: 7065 632f 7573 622f 7761 7361 7463 6843  pec/usb/wasatchC
+00000280: 6f6e 6669 672e 7079 200a 2020 2020 2222  onfig.py .    ""
+00000290: 220a 2020 2020 7065 616b 7320 3d20 5b28  ".    peaks = [(
+000002a0: 3832 332e 3136 332c 2032 2e36 6532 292c  823.163, 2.6e2),
+000002b0: 2028 3832 382e 3031 322c 2031 2e32 6532   (828.012, 1.2e2
+000002c0: 292c 2028 3834 302e 3931 392c 202e 3035  ), (840.919, .05
+000002d0: 6532 292c 2028 3838 312e 3934 312c 2035  e2), (881.941, 5
+000002e0: 2e38 6532 292c 2028 3839 352e 3232 352c  .8e2), (895.225,
+000002f0: 202e 3865 3229 2c20 2839 3034 2e35 3435   .8e2), (904.545
+00000300: 2c20 2e37 3865 3229 2c20 2839 3136 2e32  , .78e2), (916.2
+00000310: 3635 2c20 2e35 3365 3229 5d0a 2020 2020  65, .53e2)].    
+00000320: 7065 616b 7320 3d20 5b28 2878 2d38 3030  peaks = [((x-800
+00000330: 2920 2a20 2831 3032 342f 3230 3029 2c20  ) * (1024/200), 
+00000340: 7929 2066 6f72 2028 782c 7929 2069 6e20  y) for (x,y) in 
+00000350: 7065 616b 735d 0a20 2020 206e 6f69 7365  peaks].    noise
+00000360: 203d 2031 300a 2020 2020 7265 7475 726e   = 10.    return
+00000370: 205b 696e 7428 7375 6d28 5b70 5b31 5d2f   [int(sum([p[1]/
+00000380: 2831 2b28 782d 705b 305d 292a 2a34 2920  (1+(x-p[0])**4) 
+00000390: 666f 7220 7020 696e 2070 6561 6b73 5d29  for p in peaks])
+000003a0: 2b6e 6f69 7365 2a72 616e 646f 6d28 2929  +noise*random())
+000003b0: 2066 6f72 2078 2069 6e20 7261 6e67 6528   for x in range(
+000003c0: 3130 3234 295d 0a0a 6465 6620 636f 6d70  1024)]..def comp
+000003d0: 6172 655f 6e75 6d65 7269 635f 6172 7261  are_numeric_arra
+000003e0: 7973 2861 6374 7561 6c2c 206b 6e6f 776e  ys(actual, known
+000003f0: 293a 0a0a 2020 2020 6966 206c 656e 286b  ):..    if len(k
+00000400: 6e6f 776e 2920 3c20 6c65 6e28 6163 7475  nown) < len(actu
+00000410: 616c 293a 0a20 2020 2020 2020 2070 7269  al):.        pri
+00000420: 6e74 2822 4172 7261 7973 2064 6f20 6e6f  nt("Arrays do no
+00000430: 7420 6d61 7463 6820 6c65 6e67 7468 2e22  t match length."
+00000440: 290a 2020 2020 2020 2020 7072 696e 7428  ).        print(
+00000450: 2254 6865 7265 2061 7265 2025 732d 2573  "There are %s-%s
+00000460: 3d25 7320 6578 7472 6120 656e 7472 6965  =%s extra entrie
+00000470: 7322 2025 2028 6c65 6e28 6163 7475 616c  s" % (len(actual
+00000480: 292c 206c 656e 286b 6e6f 776e 292c 206c  ), len(known), l
+00000490: 656e 2861 6374 7561 6c29 2d6c 656e 286b  en(actual)-len(k
+000004a0: 6e6f 776e 2929 290a 2020 2020 6966 206c  nown))).    if l
+000004b0: 656e 286b 6e6f 776e 2920 3e20 6c65 6e28  en(known) > len(
+000004c0: 6163 7475 616c 293a 0a20 2020 2020 2020  actual):.       
+000004d0: 2070 7269 6e74 2822 4172 7261 7973 2064   print("Arrays d
+000004e0: 6f20 6e6f 7420 6d61 7463 6820 6c65 6e67  o not match leng
+000004f0: 7468 2e22 290a 2020 2020 2020 2020 7072  th.").        pr
+00000500: 696e 7428 2254 6865 7265 2061 7265 206d  int("There are m
+00000510: 6973 7369 6e67 2025 732d 2573 3d25 7320  issing %s-%s=%s 
+00000520: 6578 7472 6120 656e 7472 6965 7322 2025  extra entries" %
+00000530: 2028 6c65 6e28 6b6e 6f77 6e29 2c20 6c65   (len(known), le
+00000540: 6e28 6163 7475 616c 292c 206c 656e 286b  n(actual), len(k
+00000550: 6e6f 776e 292d 6c65 6e28 6163 7475 616c  nown)-len(actual
+00000560: 2929 290a 0a20 2020 2074 6c65 6e20 3d20  )))..    tlen = 
+00000570: 6d69 6e28 6c65 6e28 6b6e 6f77 6e29 2c20  min(len(known), 
+00000580: 6c65 6e28 6163 7475 616c 2929 0a0a 2020  len(actual))..  
+00000590: 2020 6578 6163 7420 3d20 300a 2020 2020    exact = 0.    
+000005a0: 7769 7468 696e 3570 6572 6365 6e74 203d  within5percent =
+000005b0: 2030 0a20 2020 2065 7272 6f72 203d 2030   0.    error = 0
+000005c0: 0a0a 2020 2020 666f 7220 6920 696e 2072  ..    for i in r
+000005d0: 616e 6765 2874 6c65 6e29 3a0a 2020 2020  ange(tlen):.    
+000005e0: 2020 2020 6572 726f 7220 2b3d 2028 6b6e      error += (kn
+000005f0: 6f77 6e5b 695d 2d61 6374 7561 6c5b 695d  own[i]-actual[i]
+00000600: 292a 2a32 0a0a 2020 2020 2020 2020 6966  )**2..        if
+00000610: 206b 6e6f 776e 5b69 5d20 3d3d 2061 6374   known[i] == act
+00000620: 7561 6c5b 695d 3a0a 2020 2020 2020 2020  ual[i]:.        
+00000630: 2020 2020 6578 6163 7420 2b3d 2031 0a20      exact += 1. 
+00000640: 2020 2020 2020 2065 6c69 6620 6163 7475         elif actu
+00000650: 616c 5b69 5d20 616e 6420 6162 7328 6b6e  al[i] and abs(kn
+00000660: 6f77 6e5b 695d 2d61 6374 7561 6c5b 695d  own[i]-actual[i]
+00000670: 292f 6163 7475 616c 5b69 5d20 3c20 2e30  )/actual[i] < .0
+00000680: 353a 0a20 2020 2020 2020 2020 2020 2077  5:.            w
+00000690: 6974 6869 6e35 7065 7263 656e 7420 2b3d  ithin5percent +=
+000006a0: 2031 0a0a 2020 2020 7072 696e 7428 2225   1..    print("%
+000006b0: 2e32 6625 2520 2825 6420 656e 7472 6965  .2f%% (%d entrie
+000006c0: 7329 2069 7320 616e 2065 7861 6374 206d  s) is an exact m
+000006d0: 6174 6368 2e22 2025 2028 3130 302a 6578  atch." % (100*ex
+000006e0: 6163 742f 746c 656e 2c20 6578 6163 7429  act/tlen, exact)
+000006f0: 290a 2020 2020 7072 696e 7428 2225 2e32  ).    print("%.2
+00000700: 6625 2520 2825 6420 656e 7472 6965 7329  f%% (%d entries)
+00000710: 2064 6f65 7320 6e6f 7420 6d61 7463 6820   does not match 
+00000720: 6275 7420 6973 2077 6974 6869 6e20 3525  but is within 5%
+00000730: 252e 2220 2520 2831 3030 2a77 6974 6869  %." % (100*withi
+00000740: 6e35 7065 7263 656e 742f 746c 656e 2c20  n5percent/tlen, 
+00000750: 7769 7468 696e 3570 6572 6365 6e74 2929  within5percent))
+00000760: 0a20 2020 2070 7269 6e74 2822 252e 3266  .    print("%.2f
+00000770: 2525 2028 2564 2065 6e74 7269 6573 2920  %% (%d entries) 
+00000780: 6973 206d 6f72 6520 7468 616e 2035 2525  is more than 5%%
+00000790: 2064 6966 6665 7265 6e74 2e22 2025 2028   different." % (
+000007a0: 3130 302a 2874 6c65 6e2d 7769 7468 696e  100*(tlen-within
+000007b0: 3570 6572 6365 6e74 2d65 7861 6374 292f  5percent-exact)/
+000007c0: 746c 656e 2c20 746c 656e 2d77 6974 6869  tlen, tlen-withi
+000007d0: 6e35 7065 7263 656e 742d 6578 6163 7429  n5percent-exact)
+000007e0: 290a 2020 2020 7072 696e 7428 2245 7272  ).    print("Err
+000007f0: 6f72 2066 6163 746f 723a 2025 2e32 6622  or factor: %.2f"
+00000800: 2025 2065 7272 6f72 2a2a 2e35 290a 0a69   % error**.5)..i
+00000810: 6620 5f5f 6e61 6d65 5f5f 203d 3d20 225f  f __name__ == "_
+00000820: 5f6d 6169 6e5f 5f22 3a0a 2020 2020 7072  _main__":.    pr
+00000830: 696e 7428 4551 5541 4c42 5245 414b 290a  int(EQUALBREAK).
+00000840: 2020 2020 7072 696e 7428 2243 6f6d 7061      print("Compa
+00000850: 7269 6e67 2075 7469 6c73 2e61 7070 6c79  ring utils.apply
+00000860: 5f62 6f78 6361 7220 7769 7468 206b 6e6f  _boxcar with kno
+00000870: 776e 2069 6d70 6c65 6d65 6e74 6174 696f  wn implementatio
+00000880: 6e2e 2229 0a20 2020 2073 7065 6374 7275  n.").    spectru
+00000890: 6d20 3d20 6765 6e5f 7370 6563 7472 6128  m = gen_spectra(
+000008a0: 290a 2020 2020 7072 696e 7428 4c49 4e45  ).    print(LINE
+000008b0: 4252 4541 4b29 0a20 2020 2070 7269 6e74  BREAK).    print
+000008c0: 2827 5369 6d20 7370 6563 7472 6120 7769  ('Sim spectra wi
+000008d0: 7468 2068 616c 665f 7769 6474 683d 3527  th half_width=5'
+000008e0: 290a 2020 2020 6b6e 6f77 6e5f 6f75 7420  ).    known_out 
+000008f0: 3d20 6578 6973 7469 6e67 5f69 6d70 6c65  = existing_imple
+00000900: 6d65 6e74 6174 696f 6e73 2e75 7469 6c73  mentations.utils
+00000910: 2e61 7070 6c79 5f62 6f78 6361 7228 7370  .apply_boxcar(sp
+00000920: 6563 7472 756d 2c20 3529 0a20 2020 2061  ectrum, 5).    a
+00000930: 6374 7561 6c5f 6f75 7420 3d20 7574 696c  ctual_out = util
+00000940: 732e 6170 706c 795f 626f 7863 6172 2873  s.apply_boxcar(s
+00000950: 7065 6374 7275 6d2c 2035 290a 2020 2020  pectrum, 5).    
+00000960: 636f 6d70 6172 655f 6e75 6d65 7269 635f  compare_numeric_
+00000970: 6172 7261 7973 2861 6374 7561 6c5f 6f75  arrays(actual_ou
+00000980: 742c 206b 6e6f 776e 5f6f 7574 290a 2020  t, known_out).  
+00000990: 2020 7072 696e 7428 4c49 4e45 4252 4541    print(LINEBREA
+000009a0: 4b29 0a20 2020 2070 7269 6e74 2827 5369  K).    print('Si
+000009b0: 6d20 7370 6563 7472 6120 7769 7468 2068  m spectra with h
+000009c0: 616c 665f 7769 6474 683d 3230 2729 0a20  alf_width=20'). 
+000009d0: 2020 206b 6e6f 776e 5f6f 7574 203d 2065     known_out = e
+000009e0: 7869 7374 696e 675f 696d 706c 656d 656e  xisting_implemen
+000009f0: 7461 7469 6f6e 732e 7574 696c 732e 6170  tations.utils.ap
+00000a00: 706c 795f 626f 7863 6172 2873 7065 6374  ply_boxcar(spect
+00000a10: 7275 6d2c 2032 3029 0a20 2020 2061 6374  rum, 20).    act
+00000a20: 7561 6c5f 6f75 7420 3d20 7574 696c 732e  ual_out = utils.
+00000a30: 6170 706c 795f 626f 7863 6172 2873 7065  apply_boxcar(spe
+00000a40: 6374 7275 6d2c 2032 3029 0a20 2020 2023  ctrum, 20).    #
+00000a50: 2063 6f6d 7061 7265 5f61 7272 6179 7320   compare_arrays 
+00000a60: 7072 696e 7473 2061 2073 7562 2d72 6570  prints a sub-rep
+00000a70: 6f72 7420 6261 7365 6420 6f6e 206b 6e6f  ort based on kno
+00000a80: 776e 2076 7320 6163 7475 616c 2e0a 2020  wn vs actual..  
+00000a90: 2020 636f 6d70 6172 655f 6e75 6d65 7269    compare_numeri
+00000aa0: 635f 6172 7261 7973 2861 6374 7561 6c5f  c_arrays(actual_
+00000ab0: 6f75 742c 206b 6e6f 776e 5f6f 7574 290a  out, known_out).
+00000ac0: 2020 2020 7072 696e 7428 4c49 4e45 4252      print(LINEBR
+00000ad0: 4541 4b29 0a20 2020 2070 7269 6e74 2827  EAK).    print('
+00000ae0: 5369 6d20 7370 6563 7472 6120 7769 7468  Sim spectra with
+00000af0: 2068 616c 665f 7769 6474 683d 3130 3027   half_width=100'
+00000b00: 290a 2020 2020 6b6e 6f77 6e5f 6f75 7420  ).    known_out 
+00000b10: 3d20 6578 6973 7469 6e67 5f69 6d70 6c65  = existing_imple
+00000b20: 6d65 6e74 6174 696f 6e73 2e75 7469 6c73  mentations.utils
+00000b30: 2e61 7070 6c79 5f62 6f78 6361 7228 7370  .apply_boxcar(sp
+00000b40: 6563 7472 756d 2c20 3130 3029 0a20 2020  ectrum, 100).   
+00000b50: 2061 6374 7561 6c5f 6f75 7420 3d20 7574   actual_out = ut
+00000b60: 696c 732e 6170 706c 795f 626f 7863 6172  ils.apply_boxcar
+00000b70: 2873 7065 6374 7275 6d2c 2031 3030 290a  (spectrum, 100).
+00000b80: 2020 2020 2320 636f 6d70 6172 655f 6172      # compare_ar
+00000b90: 7261 7973 2070 7269 6e74 7320 6120 7375  rays prints a su
+00000ba0: 622d 7265 706f 7274 2062 6173 6564 206f  b-report based o
+00000bb0: 6e20 6b6e 6f77 6e20 7673 2061 6374 7561  n known vs actua
+00000bc0: 6c2e 0a20 2020 2063 6f6d 7061 7265 5f6e  l..    compare_n
+00000bd0: 756d 6572 6963 5f61 7272 6179 7328 6163  umeric_arrays(ac
+00000be0: 7475 616c 5f6f 7574 2c20 6b6e 6f77 6e5f  tual_out, known_
+00000bf0: 6f75 7429 0a20 2020 2070 7269 6e74 2845  out).    print(E
+00000c00: 5155 414c 4252 4541 4b29 0a0a 0a0a       QUALBREAK)....
```

### Comparing `wasatch-2.1.35/udev/10-wasatch.rules` & `wasatch-2.1.64/udev/10-wasatch.rules`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/wasatch/AndorDevice.py` & `wasatch-2.1.64/wasatch/AndorDevice.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,764 +1,766 @@
-import re
-import os
-import usb
-import time
-import json
-import queue
-import struct
-import logging
-import datetime
-from ctypes import *
-from typing import TypeVar, Any, Callable
-
-from .SpectrometerSettings        import SpectrometerSettings
-from .SpectrometerState           import SpectrometerState
-from .SpectrometerResponse        import SpectrometerResponse
-from .SpectrometerRequest         import SpectrometerRequest
-from .SpectrometerResponse        import ErrorLevel
-from .InterfaceDevice             import InterfaceDevice
-from .DeviceID                    import DeviceID
-from .Reading                     import Reading
-
-log = logging.getLogger(__name__)
-
-class AndorDevice(InterfaceDevice):
-    """
-    This is the basic implementation of our interface with Andor cameras     
-
-    @todo have check_result return a SpectrometerResponse 
-    @todo try to auto-detect whether x-axis needs inverted via DLL.GetImageFlip()
-
-    ##########################################################################
-    This class adopts the external device interface structure.
-    This involves receiving a request through the handle_request function.
-    A request is processed based on the key in the request.
-    The processing function passes the commands to the requested device.
-    Once it receives a response from the connected device it then passes that
-    back up the chain.
-    @verbatim
-                               Enlighten Request
-                                       |
-                                handle_requests
-                                       |
-                                 ------------
-                                /   /  |  \  \  
-             { get_laser status, acquire, set_laser_watchdog, etc....}
-                                \   \  |  /  /
-                                 ------------
-                                       |
-                         {self.driver.some_andor_sdk_call}
-    @endverbatim
-    ############################################################################
-    """
-
-    SUCCESS = 20002             #!< see load_error_codes()
-    SHUTTER_SPEED_MS = 50       #!< allow time for mechanical shutter to stabilize
-
-    def __init__(self, device_id, message_queue=None): # -> None 
-        # if passed a string representation of a DeviceID, deserialize it
-        super().__init__()
-        if type(device_id) is str:
-            device_id = DeviceID(label=device_id)
-
-        self.device_id      = device_id
-        self.message_queue  = message_queue
-
-        self.load_error_codes()
-
-        self.connected = False
-
-        # Receives ENLIGHTEN's 'change settings' commands in the spectrometer
-        # process. 
-        self.command_queue = []
-
-        self.immediate_mode = False
-
-        self.settings = SpectrometerSettings(self.device_id)
-        self.summed_spectra         = None
-        self.sum_count              = 0
-        self.session_reading_count  = 0
-        self.take_one               = False
-        self.failure_count          = 0
-        self.dll_fail               = True
-        self.toggle_state           = True
-        self.driver                 = None
-
-        self.process_id = os.getpid()
-        self.last_memory_check = datetime.datetime.now()
-        self.last_battery_percentage = 0
-        self.spec_index = 0 
-        self._scan_averaging = 1
-        self.dark = None
-        self.boxcar_half_width = 0
-
-        # decide appropriate DLL filename for architecture
-        arch = 64 if 64 == struct.calcsize("P") * 8 else 32
-        filename = f"atmcd{arch}d.dll"
-
-        # Andor libraries may be found in various locations
-        dll_paths = [ r"C:\Program Files\Andor Driver Pack 2",
-                      r"C:\Program Files\Andor SDK",
-                      r"dist\Andor",
-                      r"dist" ]
-
-        # try to find correct DLL in any known location
-        for path in dll_paths:
-            pathname = os.path.join(path, filename)
-            if os.path.exists(pathname):
-                try:
-                    log.debug(f"attempting to load {pathname}")
-                    self.driver = cdll.LoadLibrary(pathname)
-                    self.dll_fail = False
-                except Exception as e:
-                    log.error(f"Error loading {pathname}: {e}")
-
-                if self.driver is not None:
-                    break
-
-        if self.driver is None:
-            log.error(f"could not find {filename} in search path: {dll_paths}")
-            # MZ: interesting that we don't return here
-
-        # "serial_number", "model" etc are ambiguous in an Andor configuration 
-        # file -- do they refer to the camera (Andor), or the spectrometer 
-        # (Wasatch)?  Therefore, some Wasatch EEPROM fields get extra "wp_" 
-        # prefixes in Andor configuration files to be clear.
-        self.config_names_to_eeprom = {
-            'wp_serial_number': 'serial_number',
-            'wp_model': 'model' 
-        }
-
-        # set Andor defaults for important "EEPROM" settings
-        # (all but has_cooling can be overridden via config file)
-
-        # Andor API doesn't have access to detector info
-        # Note that we use non-iDus cameras, including the Newton
-        self.settings.eeprom.detector = "iDus" 
-        self.settings.eeprom.wavelength_coeffs = [0,1,0,0]
-        self.settings.eeprom.has_cooling = True
-        self.settings.eeprom.startup_integration_time_ms = 10
-        self.settings.eeprom.startup_temp_degC = -60
-        self.settings.eeprom.detector_gain = 1
-        self.settings.eeprom.detector_gain_odd = 1
-
-        self.process_f = self._init_process_funcs()
-
-    ###############################################################
-    # Private Methods
-    ###############################################################
-
-    def _init_process_funcs(self): # -> dict[str, Callable[..., Any]] 
-        process_f = {}
-
-        process_f["connect"] = self.connect
-        process_f["acquire_data"] = self.acquire_data
-        process_f["set_shutter_enable"] = self.set_shutter_enable
-        process_f["set_integration_time_ms"] = self.set_integration_time_ms
-        process_f["get_serial_number"] = self.get_serial_number
-        process_f["init_tec_setpoint"] = self.init_tec_setpoint
-        process_f["set_tec_setpoint"] = self.set_tec_setpoint
-        process_f["init_detector_area"] = self.init_detector_area
-        process_f["scans_to_average"] = self.scans_to_average
-        process_f["high_gain_mode_enable"] = self.high_gain_mode_enable
-        process_f["save_config"] = self.save_config
-
-        ##################################################################
-        # What follows is the old init-lambdas that are squashed into process_f
-        # Long term, the upstream requests should be changed to match the new format
-        # This is an easy fix for the time being to make things behave
-        ##################################################################
-        process_f["integration_time_ms"] = lambda x: self.set_integration_time_ms(x) # conversion from millisec to microsec
-        process_f["fan_enable"] = lambda x: self.set_fan_enable(bool(x))
-        process_f["shutter_enable"] = lambda x: self.set_shutter_enable(bool(x))
-        process_f["detector_tec_enable"]                = lambda x: self.toggle_tec(bool(x))
-        process_f["detector_tec_setpoint_degC"]         = lambda x: self.set_tec_setpoint(int(round(x)))
-
-        return process_f
-
-    def high_gain_mode_enable(self, enabled: bool): # -> SpectrometerResponse 
-        if enabled:
-            result = self.driver.SetPreAmpGain(self.gain_idx[-1])
-            assert(self.SUCCESS == result), f"unable to set detector gain, got value of {result}"
-            log.debug(f"for {enabled} setting gain to {self.gain_options[-1]}")
-            return
-        else:
-            result = self.driver.SetPreAmpGain(self.gain_idx[0])
-            assert(self.SUCCESS == result), f"unable to set detector gain, got value of {result}"
-            log.debug(f"for {enabled} setting gain to {self.gain_options[0]}")
-            return
-
-    # MZ: nothing seems to call this?
-    def _update_wavelength_coeffs(self, coeffs: list[float]): # -> None 
-        self.settings.eeprom.wavelength_coeffs = coeffs
-        self.config_values['wavelength_coeffs'] = coeffs
-        self.save_config()
-
-    def set_fan_enable(self, x: bool): # -> SpectrometerResponse 
-        self.check_result(self.driver.SetFanMode(int(x)), f"Andor Fan On {x}")
-        return SpectrometerResponse()
-
-    def _get_default_data_dir(self): # -> str 
-        if os.name == "nt":
-            return os.path.join(os.path.expanduser("~"), "Documents", "EnlightenSpectra")
-        return os.path.join(os.environ["HOME"], "EnlightenSpectra")
-
-    def _check_config_file(self): # -> bool 
-        self.config_dir = os.path.join(self._get_default_data_dir(), 'config')
-        self.config_file = os.path.join(self.config_dir, self.serial + '.json')
-        if not os.path.exists(self.config_dir):
-            os.makedirs(self.config_dir)
-        return os.path.isfile(self.config_file)
-
-    def _get_spectrum_raw(self): # -> list[float] 
-        """
-        @todo missing bad-pixel correction
-        """
-        spec_arr = c_long * self.pixels
-        spec_init_vals = [0] * self.pixels
-        spec = spec_arr(*spec_init_vals)
-
-        # ask for spectrum then collect, NOT multithreaded (though we should look into that!), blocks
-        self.driver.StartAcquisition();
-        self.driver.WaitForAcquisition();
-        success = self.driver.GetAcquiredData(spec, c_ulong(self.pixels));
-
-        if (success != self.SUCCESS):
-            log.debug(f"getting spectra did not succeed. Received code of {success}. Returning")
-            return
-
-        # convert from wasatch.AndorDevice.c_long_Array_512
-        convertedSpec = [x for x in spec]
-
-        if (self.settings.eeprom.invert_x_axis):
-            convertedSpec.reverse()
-
-        return convertedSpec;
-
-    def _take_one_averaged_reading(self): # -> SpectrometerResponse 
-        averaging_enabled = (self.settings.state.scans_to_average > 1)
-
-        if averaging_enabled and not self.settings.state.free_running_mode:
-            # collect the entire averaged spectrum at once (added for
-            # BatchCollection with laser delay)
-            #
-            # So: we're NOT in "free-running" mode, so we're basically being
-            # slaved to parent process and doing exactly what is requested
-            # "on command."  That means we can perform a big, heavy blocking
-            # scan average all at once, because they requested it.
-            self.sum_count = 0
-            loop_count = self.settings.state.scans_to_average
-        else:
-            # we're in free-running mode
-            loop_count = 1
-
-        log.debug("take_one_averaged_reading: loop_count = %d", loop_count)
-
-        # either take one measurement (normal), or a bunch (blocking averaging)
-        reading = None
-        for loop_index in range(0, loop_count):
-
-            # start a new reading
-            # NOTE: reading.timestamp is when reading STARTED, not FINISHED!
-            reading = Reading(self.device_id)
-
-            if self.settings.eeprom.has_cooling and self.toggle_state:
-                c_temp = c_int()
-                result = self.driver.GetTemperature(0,c_temp)
-                if (self.SUCCESS != result):
-                    log.error(f"unable to read tec temp, result was {result}")
-                else:
-                    log.debug(f"andor read temperature, value of {c_temp.value}")
-                    reading.detector_temperature_degC = c_temp.value
-            try:
-                reading.integration_time_ms = self.settings.state.integration_time_ms
-                reading.laser_power_perc    = self.settings.state.laser_power_perc
-                reading.laser_power_mW      = self.settings.state.laser_power_mW
-                reading.laser_enabled       = self.settings.state.laser_enabled
-                reading.spectrum            = self._get_spectrum_raw()
-
-                temperature = c_float()
-                temp_success = self.driver.GetTemperatureF(byref(temperature))
-
-                reading.detector_temperature_degC = temperature.value
-            except usb.USBError:
-                self.failure_count += 1
-                log.error(f"Andor Device: encountered USB error in reading for device {self.device}")
-
-            if reading.spectrum is None or reading.spectrum == []:
-                if self.failure_count > 3:
-                    return SpectrometerResponse(data=False,error_msg="exceeded failure for readings")
-
-            if not reading.failure:
-                if averaging_enabled:
-                    if self.sum_count == 0:
-                        self.summed_spectra = [float(i) for i in reading.spectrum]
-                    else:
-                        log.debug("device.take_one_averaged_reading: summing spectra")
-                        for i in range(len(self.summed_spectra)):
-                            self.summed_spectra[i] += reading.spectrum[i]
-                    self.sum_count += 1
-                    log.debug("device.take_one_averaged_reading: summed_spectra : %s ...", self.summed_spectra[0:9])
-
-            # count spectra
-            self.session_reading_count += 1
-            reading.session_count = self.session_reading_count
-            reading.sum_count = self.sum_count
-
-            # have we completed the averaged reading?
-            if averaging_enabled:
-                if self.sum_count >= self.settings.state.scans_to_average:
-                    reading.spectrum = [ x / self.sum_count for x in self.summed_spectra ]
-                    log.debug("device.take_one_averaged_reading: averaged_spectrum : %s ...", reading.spectrum[0:9])
-                    reading.averaged = True
-
-                    # reset for next average
-                    self.summed_spectra = None
-                    self.sum_count = 0
-            else:
-                # if averaging isn't enabled...then a single reading is the
-                # "averaged" final measurement (check reading.sum_count to confirm)
-                reading.averaged = True
-
-            # were we told to only take one (potentially averaged) measurement?
-            if self.take_one and reading.averaged:
-                log.debug("completed take_one")
-                self.change_setting("cancel_take_one", True)
-
-
-        log.debug("device.take_one_averaged_reading: returning %s", reading)
-        if reading.spectrum is not None and reading.spectrum != []:
-            self.failure_count = 0
-        # reading.dump_area_scan()
-        return SpectrometerResponse(data=reading)
-
-    def _close_ex_shutter(self): # -> SpectrometerResponse 
-        self.check_result(self.driver.SetShutterEx(1, 1, self.SHUTTER_SPEED_MS, self.SHUTTER_SPEED_MS, 2), "SetShutterEx(2)")
-        self.settings.state.shutter_enabled = False
-        return SpectrometerResponse(True)
-
-    def _open_ex_shutter(self): # -> SpectrometerResponse 
-        self.check_result(self.driver.SetShutterEx(1, 1, self.SHUTTER_SPEED_MS, self.SHUTTER_SPEED_MS, 1), "SetShutterEx(1)")
-        self.settings.state.shutter_enabled = True
-        return SpectrometerResponse(True)
-
-    ###############################################################
-    # Public Methods
-    ###############################################################
-
-    def check_result(self, result, func):
-        if result != self.SUCCESS:
-            name = self.get_error_code(result)
-            msg = f"error calling {func}: {result} ({name})"
-            log.error(msg)
-            raise RuntimeError(msg)
-        log.debug(f"successfully called {func}")
-
-    def connect(self): # -> SpectrometerResponse 
-        if self.dll_fail:
-            return SpectrometerResponse(False, error_msg="can't find Andor DLL; please confirm Andor Driver Pack 2 installed")
-
-        cameraHandle = c_int()
-        self.check_result(self.driver.GetCameraHandle(self.spec_index, byref(cameraHandle)), "GetCameraHandle") # step 1
-        self.check_result(self.driver.SetCurrentCamera(cameraHandle.value), "SetCurrentCamera") # step 2
-
-        try:
-            path_to_ini = create_string_buffer(b'\000' * 256) 
-            self.check_result(self.driver.Initialize(path_to_ini), "Initialize") # step 3
-        except:
-            log.error("Andor.Initialize failed", exc_info=1)
-            return SpectrometerResponse(False, error_msg="Andor initialization failed")
-
-        # @todo missing: step 4 capabilities
-
-        self.get_serial_number() # step 16
-        self.init_tec_setpoint() # step 5+6
-        self.init_detector_area() # step 7
-
-        if not self._check_config_file():
-            self.config_values = {
-                'detector_serial_number': self.serial,
-                'wavelength_coeffs': [0,1,0,0],
-                'excitation_nm_float': 0,
-                'raman_intensity_coeffs': [],
-                'raman_intensity_calibration_order': 0,
-                'invert_x_axis': False 
-            }
-            log.debug(f"connect: config file not found, so defaulting to these: {self.config_values}")
-            self.save_config()
-        else:
-            self._load_config_values()
-            log.debug(f"connect: loaded config file: {self.config_values}")
-
-        self.check_result(self.driver.CoolerON(), "CoolerON") # step 8
-        self.check_result(self.driver.SetAcquisitionMode(1), "SetAcquisitionMode(single_scan)") # step 9
-        self.check_result(self.driver.SetTriggerMode(0), "SetTriggerMode") # step 10
-        self.check_result(self.driver.SetReadMode(0), "SetReadMode(full_vertical_binning)") # step 11
-
-        self.init_detector_speed() # step 12+13
-
-        # step 14
-        self.check_result(self.driver.SetShutterEx(1, 1, self.SHUTTER_SPEED_MS, self.SHUTTER_SPEED_MS, 0), "SetShutterEx(fully automatic external with internal always open)")
-        self.settings.state.shutter_enabled = True
-
-        # step 15
-        self.set_integration_time_ms(self.settings.eeprom.startup_integration_time_ms)
-
-        # step 17 (WasatchNET doesn't do this)
-        self._obtain_gain_info()
-
-        # success!
-        log.info("AndorDevice successfully connected")
-
-        self.connected = True
-        self.settings.eeprom.active_pixels_horizontal = self.pixels 
-        self.settings.eeprom.has_cooling = True
-        return SpectrometerResponse(data=True)
-
-    def save_config(self, eeprom=None):
-        """
-        The user has edited the "virtual EEPROM", for instance using ENLIGHTEN's 
-        EEPROM Editor, and wants to save the new EEPROM.  Therefore we need to
-        generate a fresh JSON equivalent and write it to disk.
-
-        @param eeprom: if provided, overwrite current settings with those in the 
-               passed dict before writing to disk
-        """
-        log.debug("save_config: here")
-        if eeprom is not None:
-            self.update_config_from_eeprom(eeprom)
-
-        f = open(self.config_file, 'w')
-        json.dump(self.config_values, f, indent=2, sort_keys=True)
-        log.debug(f"saved {self.config_file}: {self.config_values}")
-
-    def update_config_from_eeprom(self, eeprom):
-        """ 
-        Populates a dict used to update the configuration file `self.config_file`
-        from `self.settings.eeprom` members.
-        """
-        # first, copy over any EEPROM fields which have a different name in 
-        # wasatch.EEPROM vs the external JSON file 
-        for json_name, python_name in self.config_names_to_eeprom.items():
-            self.config_values[json_name] = getattr(eeprom, python_name)
-
-        # now do all the standard attributes of the wasatch.EEPROM, adding 
-        # their values into the same dict
-        for python_name, python_value in eeprom.__dict__.items():
-            if python_name in self.config_values:
-                self.config_values[python_name] = python_value
-
-    def _load_config_values(self):
-        """
-        Loads configuration from file `self.config_file` and populates `self.settings.eeprom` with members.
-        """
-        f = open(self.config_file,)
-        self.config_values = dict(json.load(f))
-        log.debug(f"loaded {self.config_file}: {self.config_values}")
-
-        # handle wp_ prefixes
-        for k, v in self.config_names_to_eeprom.items():
-            if k in self.config_values:
-                setattr(self.settings.eeprom, v, self.config_values[k])
-
-        # same spelling
-        for k in [ 'model', 
-                   'detector', 
-                   'serial_number', 
-                   'invert_x_axis',
-                   'wavelength_coeffs', 
-                   'excitation_nm_float',
-                   'raman_intensity_coeffs',
-                   'raman_intensity_calibration_order',
-                   'startup_temp_degC', 
-                   'startup_integration_time_ms' ]:
-            if k in self.config_values:
-                setattr(self.settings.eeprom, k, self.config_values[k])
-
-        # default missing-but-obvious fields
-        if "raman_intensity_coeffs" in self.config_values:
-            if "raman_intensity_calibration_order" not in self.config_values:
-                self.settings.eeprom.raman_intensity_calibration_order = len(self.settings.eeprom.raman_intensity_coeffs) - 1
-
-        # post-load initialization
-        if 'startup_temp_degC' in self.config_values:
-            self.set_tec_setpoint(self.settings.eeprom.startup_temp_degC)
-
-    def acquire_data(self): # -> SpectrometerResponse 
-        reading = self._take_one_averaged_reading()
-        return reading
-
-    def set_shutter_enable(self, enable: bool): # -> SpectrometerResponse 
-        if enable:
-            return self._open_ex_shutter()
-        else:
-            return self._close_ex_shutter()
-
-    def set_integration_time_ms(self, ms: float): # -> SpectrometerResponse 
-        self.integration_time_ms = ms
-        log.debug(f"setting integration time to {self.integration_time_ms}ms")
-
-        exposure = c_float()
-        accumulate = c_float()
-        kinetic = c_float()
-
-        sec = ms / 1000.0
-        self.check_result(self.driver.SetExposureTime(c_float(sec)), f"SetExposureTime({sec})")
-        self.check_result(self.driver.GetAcquisitionTimings(byref(exposure), byref(accumulate), byref(kinetic)), "GetAcquisitionTimings")
-        log.debug(f"read integration time of {exposure.value:.3f}sec (expected {ms}ms)")
-        return SpectrometerResponse(data=True)
-
-    def get_serial_number(self): # -> SpectrometerResponse 
-        sn = c_int()
-        self.check_result(self.driver.GetCameraSerialNumber(byref(sn)), "GetCameraSerialNumber")
-        self.serial = f"CCD-{sn.value}"
-        self.settings.eeprom.serial_number = self.serial # temporary
-        self.settings.eeprom.detector_serial_number = self.serial
-        log.debug(f"get_serial_number: connected to {self.serial}")
-        return SpectrometerResponse(True)
-
-    def init_tec_setpoint(self): # -> SpectrometerResponse 
-        minTemp = c_int()
-        maxTemp = c_int()
-        self.check_result(self.driver.GetTemperatureRange(byref(minTemp), byref(maxTemp)), "GetTemperatureRange") # step 5
-
-        self.settings.eeprom.max_temp_degC = maxTemp.value
-        self.settings.eeprom.min_temp_degC = minTemp.value
-
-        # commenting-out because Andor camera is reporting -120C for a device 
-        # only rated at -60C...leaving hardcoded default for now
-        #
-        # self.settings.eeprom.startup_temp_degC = minTemp.value 
-
-        # however the startup temperature was set (hardcode, JSON, clamped to min)...apply it
-        self.setpoint_deg_c = self.settings.eeprom.startup_temp_degC 
-        self.check_result(self.driver.SetTemperature(self.setpoint_deg_c), f"SetTemperature({self.setpoint_deg_c})") # step 6
-        log.debug(f"set TEC to {self.setpoint_deg_c}°C (range {self.settings.eeprom.min_temp_degC}, {self.settings.eeprom.max_temp_degC})")
-
-        return SpectrometerResponse(True)
-
-    def toggle_tec(self, toggle_state):
-        c_toggle = c_int(toggle_state)
-        self.toggle_state = c_toggle.value
-        if toggle_state:
-            self.check_result(self.driver.CoolerON(), "CoolerON")
-        else:
-            self.check_result(self.driver.CoolerOFF(), "CoolerOFF")
-        return SpectrometerResponse(True)
-
-    def set_tec_setpoint(self, set_temp):
-        if set_temp < self.settings.eeprom.min_temp_degC or set_temp > self.settings.eeprom.max_temp_degC:
-            log.error(f"requested temp of {set_temp}, but it is outside range ({self.settings.eeprom.min_temp_degC}C, {self.settings.eeprom.max_temp_degC}C)")
-            return
-        if not self.toggle_state:
-            log.error(f"returning because toggle state is {self.toggle_state}")
-            return
-        self.setpoint_deg_c = set_temp
-        # I don't think CoolerON should need to be called, but I'm not seeing temperature changes
-        # when it is not present here.
-        self.check_result(self.driver.CoolerON(), "CoolerON")
-        self.check_result(self.driver.SetTemperature(self.setpoint_deg_c), f"SetTemperature({self.setpoint_deg_c})")
-        return SpectrometerResponse(True)
-
-    def init_detector_area(self): # -> SpectrometerResponse 
-        xPixels = c_int()
-        yPixels = c_int()
-        self.check_result(self.driver.GetDetector(byref(xPixels), byref(yPixels)), "GetDetector(x, y)")
-        log.debug(f"detector {xPixels.value} width x {yPixels.value} height")
-        self.pixels = xPixels.value
-        self.height = yPixels.value
-        return SpectrometerResponse(True)
-
-    def _obtain_gain_info(self):
-        num_gains = c_int()
-        result = self.driver.GetNumberPreAmpGains(byref(num_gains))
-        assert(self.SUCCESS == result), f"unable to get number of gains. Got result {result}"
-        log.debug(f"got number of gains is {num_gains.value}")
-        self.gain_options = []
-        self.gain_idx = []
-        spec_gain_opt = c_float()
-        for i in range(num_gains.value):
-            result = self.driver.GetPreAmpGain(i, byref(spec_gain_opt))
-            assert(self.SUCCESS == result), f"unable to get gains index {i}. Got result {result}"
-            self.gain_options.append(spec_gain_opt.value)
-            self.gain_idx.append(i)
-        self.gain_idx = self.gain_idx[::-1]
-        self.gain_options = self.gain_options[::-1]
-        log.debug(f"obtained gain options for spec, values were {self.gain_options}")
-
-    def init_detector_speed(self): # -> SpectrometerResponse 
-        speed = c_float()
-
-        # for CCDs, set vertical to recommended
-        if self.height > 1:
-            VSnumber = c_int()
-            self.check_result(self.driver.GetFastestRecommendedVSSpeed(byref(VSnumber), byref(speed)), "GetFastestRecommendedVSSpeed") # step 12
-            self.check_result(self.driver.SetVSSpeed(VSnumber.value), f"SetVSSpeed({VSnumber.value})")
-        else:
-            log.debug("vertical speed does not apply to linear array detectors")
-
-        # set horizontal to max
-        nAD = c_int()
-        sIndex = c_int()
-        STemp = 0.0
-        HSnumber = 0
-        ADnumber = 0
-        self.check_result(self.driver.GetNumberADChannels(byref(nAD)), "GetNumberADChannels") # step 13.1
-        for iAD in range(nAD.value):
-            self.check_result(self.driver.GetNumberHSSpeeds(iAD, 0, byref(sIndex)), f"GetNumberHSSpeeds({iAD})") # step 13.2
-            for iSpeed in range(sIndex.value):
-                self.check_result(self.driver.GetHSSpeed(iAD, 0, iSpeed, byref(speed)), f"GetHSSpeed(iAD {iAD}, iSpeed {iSpeed})") # step 13.3
-                if speed.value > STemp:
-                    STemp = speed.value
-                    HSnumber = iSpeed
-                    ADnumber = iAD
-        self.check_result(self.driver.SetADChannel(ADnumber), f"SetADChannel({ADnumber})") # 13.4
-        self.check_result(self.driver.SetHSSpeed(0, HSnumber), f"SetHSSpeed({HSnumber})") # 13.5
-        log.debug(f"set AD channel {ADnumber} with horizontal speed {HSnumber} ({STemp})")
-        return SpectrometerResponse(True)
-
-    def scans_to_average(self, value: int): # -> SpectrometerResponse 
-        self.sum_count = 0
-        self.settings.state.scans_to_average = int(value)
-        return SpectrometerResponse(True)
-
-    def get_error_code(self, code):
-        if code in self.error_codes:
-            return self.error_codes[code]
-        return "UNKNOWN_ANDOR_ERROR"
-
-    ## @see ATMCD32D.H
-    def load_error_codes(self):
-        self.error_codes = {
-            20001: "DRV_ERROR_CODES",
-            20002: "DRV_SUCCESS",
-            20003: "DRV_VXDNOTINSTALLED",
-            20004: "DRV_ERROR_SCAN",
-            20005: "DRV_ERROR_CHECK_SUM",
-            20006: "DRV_ERROR_FILELOAD",
-            20007: "DRV_UNKNOWN_FUNCTION",
-            20008: "DRV_ERROR_VXD_INIT",
-            20009: "DRV_ERROR_ADDRESS",
-            20010: "DRV_ERROR_PAGELOCK",
-            20011: "DRV_ERROR_PAGEUNLOCK",
-            20012: "DRV_ERROR_BOARDTEST",
-            20013: "DRV_ERROR_ACK",
-            20014: "DRV_ERROR_UP_FIFO",
-            20015: "DRV_ERROR_PATTERN",
-            20017: "DRV_ACQUISITION_ERRORS",
-            20018: "DRV_ACQ_BUFFER",
-            20019: "DRV_ACQ_DOWNFIFO_FULL",
-            20020: "DRV_PROC_UNKONWN_INSTRUCTION",
-            20021: "DRV_ILLEGAL_OP_CODE",
-            20022: "DRV_KINETIC_TIME_NOT_MET",
-            20023: "DRV_ACCUM_TIME_NOT_MET",
-            20024: "DRV_NO_NEW_DATA",
-            20025: "DRV_PCI_DMA_FAIL",
-            20026: "DRV_SPOOLERROR",
-            20027: "DRV_SPOOLSETUPERROR",
-            20028: "DRV_FILESIZELIMITERROR",
-            20029: "DRV_ERROR_FILESAVE",
-            20033: "DRV_TEMPERATURE_CODES",
-            20034: "DRV_TEMPERATURE_OFF",
-            20035: "DRV_TEMPERATURE_NOT_STABILIZED",
-            20036: "DRV_TEMPERATURE_STABILIZED",
-            20037: "DRV_TEMPERATURE_NOT_REACHED",
-            20038: "DRV_TEMPERATURE_OUT_RANGE",
-            20039: "DRV_TEMPERATURE_NOT_SUPPORTED",
-            20040: "DRV_TEMPERATURE_DRIFT",
-            20033: "DRV_TEMP_CODES",
-            20034: "DRV_TEMP_OFF",
-            20035: "DRV_TEMP_NOT_STABILIZED",
-            20036: "DRV_TEMP_STABILIZED",
-            20037: "DRV_TEMP_NOT_REACHED",
-            20038: "DRV_TEMP_OUT_RANGE",
-            20039: "DRV_TEMP_NOT_SUPPORTED",
-            20040: "DRV_TEMP_DRIFT",
-            20049: "DRV_GENERAL_ERRORS",
-            20050: "DRV_INVALID_AUX",
-            20051: "DRV_COF_NOTLOADED",
-            20052: "DRV_FPGAPROG",
-            20053: "DRV_FLEXERROR",
-            20054: "DRV_GPIBERROR",
-            20055: "DRV_EEPROMVERSIONERROR",
-            20064: "DRV_DATATYPE",
-            20065: "DRV_DRIVER_ERRORS",
-            20066: "DRV_P1INVALID",
-            20067: "DRV_P2INVALID",
-            20068: "DRV_P3INVALID",
-            20069: "DRV_P4INVALID",
-            20070: "DRV_INIERROR",
-            20071: "DRV_COFERROR",
-            20072: "DRV_ACQUIRING",
-            20073: "DRV_IDLE",
-            20074: "DRV_TEMPCYCLE",
-            20075: "DRV_NOT_INITIALIZED",
-            20076: "DRV_P5INVALID",
-            20077: "DRV_P6INVALID",
-            20078: "DRV_INVALID_MODE",
-            20079: "DRV_INVALID_FILTER",
-            20080: "DRV_I2CERRORS",
-            20081: "DRV_I2CDEVNOTFOUND",
-            20082: "DRV_I2CTIMEOUT",
-            20083: "DRV_P7INVALID",
-            20084: "DRV_P8INVALID",
-            20085: "DRV_P9INVALID",
-            20086: "DRV_P10INVALID",
-            20087: "DRV_P11INVALID",
-            20089: "DRV_USBERROR",
-            20090: "DRV_IOCERROR",
-            20091: "DRV_VRMVERSIONERROR",
-            20092: "DRV_GATESTEPERROR",
-            20093: "DRV_USB_INTERRUPT_ENDPOINT_ERROR",
-            20094: "DRV_RANDOM_TRACK_ERROR",
-            20095: "DRV_INVALID_TRIGGER_MODE",
-            20096: "DRV_LOAD_FIRMWARE_ERROR",
-            20097: "DRV_DIVIDE_BY_ZERO_ERROR",
-            20098: "DRV_INVALID_RINGEXPOSURES",
-            20099: "DRV_BINNING_ERROR",
-            20100: "DRV_INVALID_AMPLIFIER",
-            20101: "DRV_INVALID_COUNTCONVERT_MODE",
-            20102: "DRV_USB_INTERRUPT_ENDPOINT_TIMEOUT",
-            20990: "DRV_ERROR_NOCAMERA",
-            20991: "DRV_NOT_SUPPORTED",
-            20992: "DRV_NOT_AVAILABLE",
-            20115: "DRV_ERROR_MAP",
-            20116: "DRV_ERROR_UNMAP",
-            20117: "DRV_ERROR_MDL",
-            20118: "DRV_ERROR_UNMDL",
-            20119: "DRV_ERROR_BUFFSIZE",
-            20121: "DRV_ERROR_NOHANDLE",
-            20130: "DRV_GATING_NOT_AVAILABLE",
-            20131: "DRV_FPGA_VOLTAGE_ERROR",
-            20150: "DRV_OW_CMD_FAIL",
-            20151: "DRV_OWMEMORY_BAD_ADDR",
-            20152: "DRV_OWCMD_NOT_AVAILABLE",
-            20153: "DRV_OW_NO_SLAVES",
-            20154: "DRV_OW_NOT_INITIALIZED",
-            20155: "DRV_OW_ERROR_SLAVE_NUM",
-            20156: "DRV_MSTIMINGS_ERROR",
-            20173: "DRV_OA_NULL_ERROR",
-            20174: "DRV_OA_PARSE_DTD_ERROR",
-            20175: "DRV_OA_DTD_VALIDATE_ERROR",
-            20176: "DRV_OA_FILE_ACCESS_ERROR",
-            20177: "DRV_OA_FILE_DOES_NOT_EXIST",
-            20178: "DRV_OA_XML_INVALID_OR_NOT_FOUND_ERROR",
-            20179: "DRV_OA_PRESET_FILE_NOT_LOADED",
-            20180: "DRV_OA_USER_FILE_NOT_LOADED",
-            20181: "DRV_OA_PRESET_AND_USER_FILE_NOT_LOADED",
-            20182: "DRV_OA_INVALID_FILE",
-            20183: "DRV_OA_FILE_HAS_BEEN_MODIFIED",
-            20184: "DRV_OA_BUFFER_FULL",
-            20185: "DRV_OA_INVALID_STRING_LENGTH",
-            20186: "DRV_OA_INVALID_CHARS_IN_NAME",
-            20187: "DRV_OA_INVALID_NAMING",
-            20188: "DRV_OA_GET_CAMERA_ERROR",
-            20189: "DRV_OA_MODE_ALREADY_EXISTS",
-            20190: "DRV_OA_STRINGS_NOT_EQUAL",
-            20191: "DRV_OA_NO_USER_DATA",
-            20192: "DRV_OA_VALUE_NOT_SUPPORTED",
-            20193: "DRV_OA_MODE_DOES_NOT_EXIST",
-            20194: "DRV_OA_CAMERA_NOT_SUPPORTED",
-            20195: "DRV_OA_FAILED_TO_GET_MODE",
-            20196: "DRV_OA_CAMERA_NOT_AVAILABLE",
-            20211: "DRV_PROCESSING_FAILED"
-        }
+import os
+import usb
+import json
+import struct
+import logging
+import datetime
+from ctypes import *
+
+from .SpectrometerSettings        import SpectrometerSettings
+from .SpectrometerResponse        import SpectrometerResponse
+from .InterfaceDevice             import InterfaceDevice
+from .DeviceID                    import DeviceID
+from .Reading                     import Reading
+
+log = logging.getLogger(__name__)
+
+class AndorDevice(InterfaceDevice):
+    """
+    This is the basic implementation of our interface with Andor cameras     
+
+    @todo have check_result return a SpectrometerResponse 
+    @todo try to auto-detect whether x-axis needs inverted via DLL.GetImageFlip()
+
+    ##########################################################################
+    This class adopts the external device interface structure.
+    This involves receiving a request through the handle_request function.
+    A request is processed based on the key in the request.
+    The processing function passes the commands to the requested device.
+    Once it receives a response from the connected device it then passes that
+    back up the chain.
+    @verbatim
+                               Enlighten Request
+                                       |
+                                handle_requests
+                                       |
+                                 ------------
+                                /   /  |  \  \  
+             { get_laser status, acquire, set_laser_watchdog, etc....}
+                                \   \  |  /  /
+                                 ------------
+                                       |
+                         {self.driver.some_andor_sdk_call}
+    @endverbatim
+    ############################################################################
+    """
+
+    SUCCESS = 20002             #!< see load_error_codes()
+    SHUTTER_SPEED_MS = 50       #!< allow time for mechanical shutter to stabilize
+
+    def __init__(self, device_id, message_queue=None): # -> None 
+        # if passed a string representation of a DeviceID, deserialize it
+        super().__init__()
+        if type(device_id) is str:
+            device_id = DeviceID(label=device_id)
+
+        self.device_id      = device_id
+        self.message_queue  = message_queue
+
+        self.load_error_codes()
+
+        self.connected = False
+
+        # Receives ENLIGHTEN's 'change settings' commands in the spectrometer
+        # process. 
+        self.command_queue = []
+
+        self.immediate_mode = False
+
+        self.settings = SpectrometerSettings(self.device_id)
+        self.summed_spectra         = None
+        self.sum_count              = 0
+        self.session_reading_count  = 0
+        self.take_one               = False
+        self.failure_count          = 0
+        self.dll_fail               = True
+        self.tec_enabled            = True
+        self.driver                 = None
+
+        self.process_id = os.getpid()
+        self.last_memory_check = datetime.datetime.now()
+        self.last_battery_percentage = 0
+        self.spec_index = 0 
+        self._scan_averaging = 1
+        self.dark = None
+        self.boxcar_half_width = 0
+
+        # decide appropriate DLL filename for architecture
+        arch = 64 if 64 == struct.calcsize("P") * 8 else 32
+        filename = f"atmcd{arch}d.dll"
+
+        # Andor libraries may be found in various locations
+        dll_paths = [ r"C:\Program Files\Andor Driver Pack 2",
+                      r"C:\Program Files\Andor SDK",
+                      r"dist\Andor",
+                      r"dist" ]
+
+        # try to find correct DLL in any known location
+        for path in dll_paths:
+            pathname = os.path.join(path, filename)
+            if os.path.exists(pathname):
+                try:
+                    log.debug(f"attempting to load {pathname}")
+                    self.driver = cdll.LoadLibrary(pathname)
+                    self.dll_fail = False
+                except Exception as e:
+                    log.error(f"Error loading {pathname}: {e}")
+
+                if self.driver is not None:
+                    break
+
+        if self.driver is None:
+            log.error(f"could not find {filename} in search path: {dll_paths}")
+            # MZ: interesting that we don't return here
+
+        # "serial_number", "model" etc are ambiguous in an Andor configuration 
+        # file -- do they refer to the camera (Andor), or the spectrometer 
+        # (Wasatch)?  Therefore, some Wasatch EEPROM fields get extra "wp_" 
+        # prefixes in Andor configuration files to be clear.
+        self.config_names_to_eeprom = {
+            'wp_serial_number': 'serial_number',
+            'wp_model': 'model' 
+        }
+
+        # set Andor defaults for important "EEPROM" settings
+        # (all but has_cooling can be overridden via config file)
+
+        # Andor API doesn't have access to detector info
+        # Note that we use non-iDus cameras, including the Newton
+        self.settings.eeprom.detector = "iDus" 
+        self.settings.eeprom.wavelength_coeffs = [0,1,0,0]
+        self.settings.eeprom.has_cooling = True
+        self.settings.eeprom.startup_integration_time_ms = 10
+        self.settings.eeprom.startup_temp_degC = -60
+        self.settings.eeprom.detector_gain = 1
+        self.settings.eeprom.detector_gain_odd = 1
+
+        self.process_f = self._init_process_funcs()
+
+    ###############################################################
+    # Private Methods
+    ###############################################################
+
+    def _init_process_funcs(self): # -> dict[str, Callable[..., Any]] 
+        process_f = {}
+
+        process_f["connect"] = self.connect
+        process_f["acquire_data"] = self.acquire_data
+        process_f["set_shutter_enable"] = self.set_shutter_enable
+        process_f["set_integration_time_ms"] = self.set_integration_time_ms
+        process_f["get_serial_number"] = self.get_serial_number
+        process_f["init_tec_setpoint"] = self.init_tec_setpoint
+        process_f["set_tec_setpoint"] = self.set_tec_setpoint
+        process_f["init_detector_area"] = self.init_detector_area
+        process_f["scans_to_average"] = self.scans_to_average
+        process_f["high_gain_mode_enable"] = self.high_gain_mode_enable
+        process_f["save_config"] = self.save_config
+
+        ##################################################################
+        # What follows is the old init-lambdas that are squashed into process_f
+        # Long term, the upstream requests should be changed to match the new format
+        # This is an easy fix for the time being to make things behave
+        ##################################################################
+        process_f["integration_time_ms"] = lambda x: self.set_integration_time_ms(x) # conversion from millisec to microsec
+        process_f["fan_enable"] = lambda x: self.set_fan_enable(bool(x))
+        process_f["shutter_enable"] = lambda x: self.set_shutter_enable(bool(x))
+        process_f["detector_tec_enable"]                = lambda x: self.toggle_tec(bool(x))
+        process_f["detector_tec_setpoint_degC"]         = lambda x: self.set_tec_setpoint(int(round(x)))
+
+        return process_f
+
+    def high_gain_mode_enable(self, enabled: bool): # -> SpectrometerResponse 
+        if enabled:
+            result = self.driver.SetPreAmpGain(self.gain_idx[-1])
+            assert(self.SUCCESS == result), f"unable to set detector gain, got value of {result}"
+            log.debug(f"for {enabled} setting gain to {self.gain_options[-1]}")
+            return
+        else:
+            result = self.driver.SetPreAmpGain(self.gain_idx[0])
+            assert(self.SUCCESS == result), f"unable to set detector gain, got value of {result}"
+            log.debug(f"for {enabled} setting gain to {self.gain_options[0]}")
+            return
+
+    # MZ: nothing seems to call this?
+    def _update_wavelength_coeffs(self, coeffs: list[float]): # -> None 
+        self.settings.eeprom.wavelength_coeffs = coeffs
+        self.config_values['wavelength_coeffs'] = coeffs
+        self.save_config()
+
+    def set_fan_enable(self, x: bool): # -> SpectrometerResponse 
+        self.check_result(self.driver.SetFanMode(int(x)), f"Andor Fan On {x}")
+        return SpectrometerResponse()
+
+    def _get_default_data_dir(self): # -> str 
+        if os.name == "nt":
+            return os.path.join(os.path.expanduser("~"), "Documents", "EnlightenSpectra")
+        return os.path.join(os.environ["HOME"], "EnlightenSpectra")
+
+    def _check_config_file(self): # -> bool 
+        self.config_dir = os.path.join(self._get_default_data_dir(), 'config')
+        self.config_file = os.path.join(self.config_dir, self.serial + '.json')
+        if not os.path.exists(self.config_dir):
+            os.makedirs(self.config_dir)
+        return os.path.isfile(self.config_file)
+
+    def _get_spectrum_raw(self): # -> list[float] 
+        """
+        @todo missing bad-pixel correction
+        """
+        spec_arr = c_long * self.pixels
+        spec_init_vals = [0] * self.pixels
+        spec = spec_arr(*spec_init_vals)
+
+        # ask for spectrum then collect, NOT multithreaded (though we should look into that!), blocks
+        self.driver.StartAcquisition()
+        self.driver.WaitForAcquisition()
+        success = self.driver.GetAcquiredData(spec, c_ulong(self.pixels))
+
+        if (success != self.SUCCESS):
+            log.debug(f"getting spectra did not succeed. Received code of {success}. Returning")
+            return
+
+        # convert from wasatch.AndorDevice.c_long_Array_512
+        convertedSpec = [x for x in spec]
+
+        if (self.settings.eeprom.invert_x_axis):
+            convertedSpec.reverse()
+
+        return convertedSpec
+
+    def _take_one_averaged_reading(self): # -> SpectrometerResponse 
+        averaging_enabled = (self.settings.state.scans_to_average > 1)
+
+        if averaging_enabled and not self.settings.state.free_running_mode:
+            # collect the entire averaged spectrum at once (added for
+            # BatchCollection with laser delay)
+            #
+            # So: we're NOT in "free-running" mode, so we're basically being
+            # slaved to parent process and doing exactly what is requested
+            # "on command."  That means we can perform a big, heavy blocking
+            # scan average all at once, because they requested it.
+            self.sum_count = 0
+            loop_count = self.settings.state.scans_to_average
+        else:
+            # we're in free-running mode
+            loop_count = 1
+
+        log.debug("take_one_averaged_reading: loop_count = %d", loop_count)
+
+        # either take one measurement (normal), or a bunch (blocking averaging)
+        reading = None
+        for _ in range(0, loop_count):
+
+            # start a new reading
+            # NOTE: reading.timestamp is when reading STARTED, not FINISHED!
+            reading = Reading(self.device_id)
+
+            if self.tec_enabled:
+                log.debug("TEC enabled, so reading temperature")
+
+                use_float = True    # seems to work on 785XL (WP-01635)
+
+                if use_float:
+                    c_temp = c_float()
+                    result = self.driver.GetTemperatureF(byref(c_temp))
+                else:
+                    c_temp = c_int()
+                    result = self.driver.GetTemperature(byref(c_temp))
+
+                label = self.get_error_code(result)
+                
+                if label in ["DRV_SUCCESS", "DRV_TEMP_STABILIZED", "DRV_TEMP_NOT_REACHED", "DRV_TEMP_DRIFT", "DRV_TEMP_NOT_STABILIZED"]:
+                    reading.detector_temperature_degC = c_temp.value
+                    log.debug(f"Andor temperature {reading.detector_temperature_degC:.2f} ({label})")
+                else:
+                    log.error(f"unable to read detector temperature, result was {label}")
+
+            try:
+                reading.integration_time_ms = self.settings.state.integration_time_ms
+                reading.laser_power_perc    = self.settings.state.laser_power_perc
+                reading.laser_power_mW      = self.settings.state.laser_power_mW
+                reading.laser_enabled       = self.settings.state.laser_enabled
+                reading.spectrum            = self._get_spectrum_raw()
+
+                # MZ: why were we trying to use GetTemperatureF(float) here, when above it was GetTemperature(int)?
+                # temperature = c_float()
+                # temp_success = self.driver.GetTemperatureF(byref(temperature))
+                # reading.detector_temperature_degC = temperature.value
+            except usb.USBError:
+                self.failure_count += 1
+                log.error(f"Andor Device: encountered USB error in reading for device {self.device}")
+
+            if reading.spectrum is None or reading.spectrum == []:
+                if self.failure_count > 3:
+                    return SpectrometerResponse(data=False,error_msg="exceeded failure for readings")
+
+            if not reading.failure:
+                if averaging_enabled:
+                    if self.sum_count == 0:
+                        self.summed_spectra = [float(i) for i in reading.spectrum]
+                    else:
+                        log.debug("device.take_one_averaged_reading: summing spectra")
+                        for i in range(len(self.summed_spectra)):
+                            self.summed_spectra[i] += reading.spectrum[i]
+                    self.sum_count += 1
+                    log.debug("device.take_one_averaged_reading: summed_spectra : %s ...", self.summed_spectra[0:9])
+
+            # count spectra
+            self.session_reading_count += 1
+            reading.session_count = self.session_reading_count
+            reading.sum_count = self.sum_count
+
+            # have we completed the averaged reading?
+            if averaging_enabled:
+                if self.sum_count >= self.settings.state.scans_to_average:
+                    reading.spectrum = [ x / self.sum_count for x in self.summed_spectra ]
+                    log.debug("device.take_one_averaged_reading: averaged_spectrum : %s ...", reading.spectrum[0:9])
+                    reading.averaged = True
+
+                    # reset for next average
+                    self.summed_spectra = None
+                    self.sum_count = 0
+            else:
+                # if averaging isn't enabled...then a single reading is the
+                # "averaged" final measurement (check reading.sum_count to confirm)
+                reading.averaged = True
+
+            # were we told to only take one (potentially averaged) measurement?
+            if self.take_one and reading.averaged:
+                log.debug("completed take_one")
+                self.change_setting("cancel_take_one", True)
+
+
+        log.debug("device.take_one_averaged_reading: returning %s", reading)
+        if reading.spectrum is not None and reading.spectrum != []:
+            self.failure_count = 0
+        # reading.dump_area_scan()
+        return SpectrometerResponse(data=reading)
+
+    def _close_ex_shutter(self): # -> SpectrometerResponse 
+        self.check_result(self.driver.SetShutterEx(1, 1, self.SHUTTER_SPEED_MS, self.SHUTTER_SPEED_MS, 2), "SetShutterEx(2)")
+        self.settings.state.shutter_enabled = False
+        return SpectrometerResponse(True)
+
+    def _open_ex_shutter(self): # -> SpectrometerResponse 
+        self.check_result(self.driver.SetShutterEx(1, 1, self.SHUTTER_SPEED_MS, self.SHUTTER_SPEED_MS, 1), "SetShutterEx(1)")
+        self.settings.state.shutter_enabled = True
+        return SpectrometerResponse(True)
+
+    ###############################################################
+    # Public Methods
+    ###############################################################
+
+    def check_result(self, result, func):
+        if result != self.SUCCESS:
+            name = self.get_error_code(result)
+            msg = f"error calling {func}: {result} ({name})"
+            log.error(msg)
+            raise RuntimeError(msg)
+        log.debug(f"successfully called {func}")
+
+    def connect(self): # -> SpectrometerResponse 
+        if self.dll_fail:
+            return SpectrometerResponse(False, error_msg="can't find Andor DLL; please confirm Andor Driver Pack 2 installed")
+
+        cameraHandle = c_int()
+        self.check_result(self.driver.GetCameraHandle(self.spec_index, byref(cameraHandle)), "GetCameraHandle") # step 1
+        self.check_result(self.driver.SetCurrentCamera(cameraHandle.value), "SetCurrentCamera") # step 2
+
+        try:
+            path_to_ini = create_string_buffer(b'\000' * 256) 
+            self.check_result(self.driver.Initialize(path_to_ini), "Initialize") # step 3
+        except:
+            log.error("Andor.Initialize failed", exc_info=1)
+            return SpectrometerResponse(False, error_msg="Andor initialization failed")
+
+        # @todo missing: step 4 capabilities
+
+        self.get_serial_number() # step 16
+        self.init_tec_setpoint() # step 5+6
+        self.init_detector_area() # step 7
+
+        if not self._check_config_file():
+            self.config_values = {
+                'detector_serial_number': self.serial,
+                'wavelength_coeffs': [0,1,0,0],
+                'excitation_nm_float': 0,
+                'raman_intensity_coeffs': [],
+                'raman_intensity_calibration_order': 0,
+                'invert_x_axis': False 
+            }
+            log.debug(f"connect: config file not found, so defaulting to these: {self.config_values}")
+            self.save_config()
+        else:
+            self._load_config_values()
+            log.debug(f"connect: loaded config file: {self.config_values}")
+
+        self.check_result(self.driver.CoolerON(), "CoolerON") # step 8
+        self.check_result(self.driver.SetAcquisitionMode(1), "SetAcquisitionMode(single_scan)") # step 9
+        self.check_result(self.driver.SetTriggerMode(0), "SetTriggerMode") # step 10
+        self.check_result(self.driver.SetReadMode(0), "SetReadMode(full_vertical_binning)") # step 11
+
+        self.init_detector_speed() # step 12+13
+
+        # step 14
+        self.check_result(self.driver.SetShutterEx(1, 1, self.SHUTTER_SPEED_MS, self.SHUTTER_SPEED_MS, 0), "SetShutterEx(fully automatic external with internal always open)")
+        self.settings.state.shutter_enabled = True
+
+        # step 15
+        self.set_integration_time_ms(self.settings.eeprom.startup_integration_time_ms)
+
+        # step 17 (WasatchNET doesn't do this)
+        self._obtain_gain_info()
+
+        # success!
+        log.info("AndorDevice successfully connected")
+
+        self.connected = True
+        self.settings.eeprom.active_pixels_horizontal = self.pixels 
+        self.settings.eeprom.has_cooling = True
+        return SpectrometerResponse(data=True)
+
+    def save_config(self, eeprom=None):
+        """
+        The user has edited the "virtual EEPROM", for instance using ENLIGHTEN's 
+        EEPROM Editor, and wants to save the new EEPROM.  Therefore we need to
+        generate a fresh JSON equivalent and write it to disk.
+
+        @param eeprom: if provided, overwrite current settings with those in the 
+               passed dict before writing to disk
+        """
+        log.debug("save_config: here")
+        if eeprom is not None:
+            self.update_config_from_eeprom(eeprom)
+
+        f = open(self.config_file, 'w')
+        json.dump(self.config_values, f, indent=2, sort_keys=True)
+        log.debug(f"saved {self.config_file}: {self.config_values}")
+
+    def update_config_from_eeprom(self, eeprom):
+        """ 
+        Populates a dict used to update the configuration file `self.config_file`
+        from `self.settings.eeprom` members.
+        """
+        # first, copy over any EEPROM fields which have a different name in 
+        # wasatch.EEPROM vs the external JSON file 
+        for json_name, python_name in self.config_names_to_eeprom.items():
+            self.config_values[json_name] = getattr(eeprom, python_name)
+
+        # now do all the standard attributes of the wasatch.EEPROM, adding 
+        # their values into the same dict
+        for python_name, python_value in eeprom.__dict__.items():
+            if python_name in self.config_values:
+                self.config_values[python_name] = python_value
+
+    def _load_config_values(self):
+        """
+        Loads configuration from file `self.config_file` and populates `self.settings.eeprom` with members.
+        """
+        f = open(self.config_file,)
+        self.config_values = dict(json.load(f))
+        log.debug(f"loaded {self.config_file}: {self.config_values}")
+
+        # handle wp_ prefixes
+        for k, v in self.config_names_to_eeprom.items():
+            if k in self.config_values:
+                setattr(self.settings.eeprom, v, self.config_values[k])
+
+        # same spelling
+        for k in [ 'model', 
+                   'detector', 
+                   'serial_number', 
+                   'invert_x_axis',
+                   'wavelength_coeffs', 
+                   'excitation_nm_float',
+                   'raman_intensity_coeffs',
+                   'raman_intensity_calibration_order',
+                   'startup_temp_degC', 
+                   'startup_integration_time_ms' ]:
+            if k in self.config_values:
+                setattr(self.settings.eeprom, k, self.config_values[k])
+
+        # default missing-but-obvious fields
+        if "raman_intensity_coeffs" in self.config_values:
+            if "raman_intensity_calibration_order" not in self.config_values:
+                self.settings.eeprom.raman_intensity_calibration_order = len(self.settings.eeprom.raman_intensity_coeffs) - 1
+
+        # post-load initialization
+        if 'startup_temp_degC' in self.config_values:
+            self.set_tec_setpoint(self.settings.eeprom.startup_temp_degC)
+
+    def acquire_data(self): # -> SpectrometerResponse 
+        reading = self._take_one_averaged_reading()
+        return reading
+
+    def set_shutter_enable(self, enable: bool): # -> SpectrometerResponse 
+        if enable:
+            return self._open_ex_shutter()
+        else:
+            return self._close_ex_shutter()
+
+    def set_integration_time_ms(self, ms: float): # -> SpectrometerResponse 
+        self.integration_time_ms = ms
+        log.debug(f"setting integration time to {self.integration_time_ms}ms")
+
+        exposure = c_float()
+        accumulate = c_float()
+        kinetic = c_float()
+
+        sec = ms / 1000.0
+        self.check_result(self.driver.SetExposureTime(c_float(sec)), f"SetExposureTime({sec})")
+        self.check_result(self.driver.GetAcquisitionTimings(byref(exposure), byref(accumulate), byref(kinetic)), "GetAcquisitionTimings")
+        log.debug(f"read integration time of {exposure.value:.3f}sec (expected {ms}ms)")
+        return SpectrometerResponse(data=True)
+
+    def get_serial_number(self): # -> SpectrometerResponse 
+        sn = c_int()
+        self.check_result(self.driver.GetCameraSerialNumber(byref(sn)), "GetCameraSerialNumber")
+        self.serial = f"CCD-{sn.value}"
+        self.settings.eeprom.serial_number = self.serial # temporary
+        self.settings.eeprom.detector_serial_number = self.serial
+        log.debug(f"get_serial_number: connected to {self.serial}")
+        return SpectrometerResponse(True)
+
+    def init_tec_setpoint(self): # -> SpectrometerResponse 
+        minTemp = c_int()
+        maxTemp = c_int()
+        self.check_result(self.driver.GetTemperatureRange(byref(minTemp), byref(maxTemp)), "GetTemperatureRange") # step 5
+
+        self.settings.eeprom.max_temp_degC = maxTemp.value
+        self.settings.eeprom.min_temp_degC = minTemp.value
+
+        # commenting-out because Andor camera is reporting -120C for a device 
+        # only rated at -60C...leaving hardcoded default for now
+        #
+        # self.settings.eeprom.startup_temp_degC = minTemp.value 
+
+        # however the startup temperature was set (hardcode, JSON, clamped to min)...apply it
+        self.setpoint_deg_c = self.settings.eeprom.startup_temp_degC 
+        self.check_result(self.driver.SetTemperature(self.setpoint_deg_c), f"SetTemperature({self.setpoint_deg_c})") # step 6
+        log.debug(f"set TEC to {self.setpoint_deg_c}°C (range {self.settings.eeprom.min_temp_degC}, {self.settings.eeprom.max_temp_degC})")
+
+        return SpectrometerResponse(True)
+
+    def toggle_tec(self, toggle_state):
+        c_toggle = c_int(toggle_state)
+        self.tec_enabled = c_toggle.value
+        if self.tec_enabled:
+            self.check_result(self.driver.CoolerON(), "CoolerON")
+        else:
+            self.check_result(self.driver.CoolerOFF(), "CoolerOFF")
+        return SpectrometerResponse(True)
+
+    def set_tec_setpoint(self, set_temp):
+        if set_temp < self.settings.eeprom.min_temp_degC or set_temp > self.settings.eeprom.max_temp_degC:
+            log.error(f"requested temp of {set_temp}, but it is outside range ({self.settings.eeprom.min_temp_degC}C, {self.settings.eeprom.max_temp_degC}C)")
+            return
+        if not self.tec_enabled:
+            log.error(f"returning because tec_enabled {self.tec_enabled}")
+            return
+        self.setpoint_deg_c = set_temp
+        # I don't think CoolerON should need to be called, but I'm not seeing temperature changes
+        # when it is not present here.
+        self.check_result(self.driver.CoolerON(), "CoolerON")
+        self.check_result(self.driver.SetTemperature(self.setpoint_deg_c), f"SetTemperature({self.setpoint_deg_c})")
+        return SpectrometerResponse(True)
+
+    def init_detector_area(self): # -> SpectrometerResponse 
+        xPixels = c_int()
+        yPixels = c_int()
+        self.check_result(self.driver.GetDetector(byref(xPixels), byref(yPixels)), "GetDetector(x, y)")
+        log.debug(f"detector {xPixels.value} width x {yPixels.value} height")
+        self.pixels = xPixels.value
+        self.height = yPixels.value
+        return SpectrometerResponse(True)
+
+    def _obtain_gain_info(self):
+        num_gains = c_int()
+        result = self.driver.GetNumberPreAmpGains(byref(num_gains))
+        assert(self.SUCCESS == result), f"unable to get number of gains. Got result {result}"
+        log.debug(f"got number of gains is {num_gains.value}")
+        self.gain_options = []
+        self.gain_idx = []
+        spec_gain_opt = c_float()
+        for i in range(num_gains.value):
+            result = self.driver.GetPreAmpGain(i, byref(spec_gain_opt))
+            assert(self.SUCCESS == result), f"unable to get gains index {i}. Got result {result}"
+            self.gain_options.append(spec_gain_opt.value)
+            self.gain_idx.append(i)
+        self.gain_idx = self.gain_idx[::-1]
+        self.gain_options = self.gain_options[::-1]
+        log.debug(f"obtained gain options for spec, values were {self.gain_options}")
+
+    def init_detector_speed(self): # -> SpectrometerResponse 
+        speed = c_float()
+
+        # for CCDs, set vertical to recommended
+        if self.height > 1:
+            VSnumber = c_int()
+            self.check_result(self.driver.GetFastestRecommendedVSSpeed(byref(VSnumber), byref(speed)), "GetFastestRecommendedVSSpeed") # step 12
+            self.check_result(self.driver.SetVSSpeed(VSnumber.value), f"SetVSSpeed({VSnumber.value})")
+        else:
+            log.debug("vertical speed does not apply to linear array detectors")
+
+        # set horizontal to max
+        nAD = c_int()
+        sIndex = c_int()
+        STemp = 0.0
+        HSnumber = 0
+        ADnumber = 0
+        self.check_result(self.driver.GetNumberADChannels(byref(nAD)), "GetNumberADChannels") # step 13.1
+        for iAD in range(nAD.value):
+            self.check_result(self.driver.GetNumberHSSpeeds(iAD, 0, byref(sIndex)), f"GetNumberHSSpeeds({iAD})") # step 13.2
+            for iSpeed in range(sIndex.value):
+                self.check_result(self.driver.GetHSSpeed(iAD, 0, iSpeed, byref(speed)), f"GetHSSpeed(iAD {iAD}, iSpeed {iSpeed})") # step 13.3
+                if speed.value > STemp:
+                    STemp = speed.value
+                    HSnumber = iSpeed
+                    ADnumber = iAD
+        self.check_result(self.driver.SetADChannel(ADnumber), f"SetADChannel({ADnumber})") # 13.4
+        self.check_result(self.driver.SetHSSpeed(0, HSnumber), f"SetHSSpeed({HSnumber})") # 13.5
+        log.debug(f"set AD channel {ADnumber} with horizontal speed {HSnumber} ({STemp})")
+        return SpectrometerResponse(True)
+
+    def scans_to_average(self, value: int): # -> SpectrometerResponse 
+        self.sum_count = 0
+        self.settings.state.scans_to_average = int(value)
+        return SpectrometerResponse(True)
+
+    def get_error_code_long(self, code):
+        if code in self.error_codes:
+            return f"{code} ({self.error_codes[code]})"
+        return f"{code} (UNKNOWN_ANDOR_ERROR)"
+
+    def get_error_code(self, code):
+        if code in self.error_codes:
+            return self.error_codes[code]
+        return "UNKNOWN_ANDOR_ERROR"
+
+    ## @see ATMCD32D.H
+    def load_error_codes(self):
+        self.error_codes = {
+            20001: "DRV_ERROR_CODES",
+            20002: "DRV_SUCCESS",
+            20003: "DRV_VXDNOTINSTALLED",
+            20004: "DRV_ERROR_SCAN",
+            20005: "DRV_ERROR_CHECK_SUM",
+            20006: "DRV_ERROR_FILELOAD",
+            20007: "DRV_UNKNOWN_FUNCTION",
+            20008: "DRV_ERROR_VXD_INIT",
+            20009: "DRV_ERROR_ADDRESS",
+            20010: "DRV_ERROR_PAGELOCK",
+            20011: "DRV_ERROR_PAGEUNLOCK",
+            20012: "DRV_ERROR_BOARDTEST",
+            20013: "DRV_ERROR_ACK",
+            20014: "DRV_ERROR_UP_FIFO",
+            20015: "DRV_ERROR_PATTERN",
+            20017: "DRV_ACQUISITION_ERRORS",
+            20018: "DRV_ACQ_BUFFER",
+            20019: "DRV_ACQ_DOWNFIFO_FULL",
+            20020: "DRV_PROC_UNKONWN_INSTRUCTION",
+            20021: "DRV_ILLEGAL_OP_CODE",
+            20022: "DRV_KINETIC_TIME_NOT_MET",
+            20023: "DRV_ACCUM_TIME_NOT_MET",
+            20024: "DRV_NO_NEW_DATA",
+            20025: "DRV_PCI_DMA_FAIL",
+            20026: "DRV_SPOOLERROR",
+            20027: "DRV_SPOOLSETUPERROR",
+            20028: "DRV_FILESIZELIMITERROR",
+            20029: "DRV_ERROR_FILESAVE",
+            20033: "DRV_TEMPERATURE_CODES",
+            20034: "DRV_TEMPERATURE_OFF",
+            20035: "DRV_TEMPERATURE_NOT_STABILIZED",
+            20036: "DRV_TEMPERATURE_STABILIZED",
+            20037: "DRV_TEMPERATURE_NOT_REACHED",
+            20038: "DRV_TEMPERATURE_OUT_RANGE",
+            20039: "DRV_TEMPERATURE_NOT_SUPPORTED",
+            20040: "DRV_TEMPERATURE_DRIFT",
+            20049: "DRV_GENERAL_ERRORS",
+            20050: "DRV_INVALID_AUX",
+            20051: "DRV_COF_NOTLOADED",
+            20052: "DRV_FPGAPROG",
+            20053: "DRV_FLEXERROR",
+            20054: "DRV_GPIBERROR",
+            20055: "DRV_EEPROMVERSIONERROR",
+            20064: "DRV_DATATYPE",
+            20065: "DRV_DRIVER_ERRORS",
+            20066: "DRV_P1INVALID", # param #1
+            20067: "DRV_P2INVALID", # param #2
+            20068: "DRV_P3INVALID", # param #3
+            20069: "DRV_P4INVALID", # param #4
+            20070: "DRV_INIERROR",
+            20071: "DRV_COFERROR",
+            20072: "DRV_ACQUIRING",
+            20073: "DRV_IDLE",
+            20074: "DRV_TEMPCYCLE",
+            20075: "DRV_NOT_INITIALIZED",
+            20076: "DRV_P5INVALID",
+            20077: "DRV_P6INVALID",
+            20078: "DRV_INVALID_MODE",
+            20079: "DRV_INVALID_FILTER",
+            20080: "DRV_I2CERRORS",
+            20081: "DRV_I2CDEVNOTFOUND",
+            20082: "DRV_I2CTIMEOUT",
+            20083: "DRV_P7INVALID",
+            20084: "DRV_P8INVALID",
+            20085: "DRV_P9INVALID",
+            20086: "DRV_P10INVALID",
+            20087: "DRV_P11INVALID",
+            20089: "DRV_USBERROR",
+            20090: "DRV_IOCERROR",
+            20091: "DRV_VRMVERSIONERROR",
+            20092: "DRV_GATESTEPERROR",
+            20093: "DRV_USB_INTERRUPT_ENDPOINT_ERROR",
+            20094: "DRV_RANDOM_TRACK_ERROR",
+            20095: "DRV_INVALID_TRIGGER_MODE",
+            20096: "DRV_LOAD_FIRMWARE_ERROR",
+            20097: "DRV_DIVIDE_BY_ZERO_ERROR",
+            20098: "DRV_INVALID_RINGEXPOSURES",
+            20099: "DRV_BINNING_ERROR",
+            20100: "DRV_INVALID_AMPLIFIER",
+            20101: "DRV_INVALID_COUNTCONVERT_MODE",
+            20102: "DRV_USB_INTERRUPT_ENDPOINT_TIMEOUT",
+            20115: "DRV_ERROR_MAP",
+            20116: "DRV_ERROR_UNMAP",
+            20117: "DRV_ERROR_MDL",
+            20118: "DRV_ERROR_UNMDL",
+            20119: "DRV_ERROR_BUFFSIZE",
+            20121: "DRV_ERROR_NOHANDLE",
+            20130: "DRV_GATING_NOT_AVAILABLE",
+            20131: "DRV_FPGA_VOLTAGE_ERROR",
+            20150: "DRV_OW_CMD_FAIL",
+            20151: "DRV_OWMEMORY_BAD_ADDR",
+            20152: "DRV_OWCMD_NOT_AVAILABLE",
+            20153: "DRV_OW_NO_SLAVES",
+            20154: "DRV_OW_NOT_INITIALIZED",
+            20155: "DRV_OW_ERROR_SLAVE_NUM",
+            20156: "DRV_MSTIMINGS_ERROR",
+            20173: "DRV_OA_NULL_ERROR",
+            20174: "DRV_OA_PARSE_DTD_ERROR",
+            20175: "DRV_OA_DTD_VALIDATE_ERROR",
+            20176: "DRV_OA_FILE_ACCESS_ERROR",
+            20177: "DRV_OA_FILE_DOES_NOT_EXIST",
+            20178: "DRV_OA_XML_INVALID_OR_NOT_FOUND_ERROR",
+            20179: "DRV_OA_PRESET_FILE_NOT_LOADED",
+            20180: "DRV_OA_USER_FILE_NOT_LOADED",
+            20181: "DRV_OA_PRESET_AND_USER_FILE_NOT_LOADED",
+            20182: "DRV_OA_INVALID_FILE",
+            20183: "DRV_OA_FILE_HAS_BEEN_MODIFIED",
+            20184: "DRV_OA_BUFFER_FULL",
+            20185: "DRV_OA_INVALID_STRING_LENGTH",
+            20186: "DRV_OA_INVALID_CHARS_IN_NAME",
+            20187: "DRV_OA_INVALID_NAMING",
+            20188: "DRV_OA_GET_CAMERA_ERROR",
+            20189: "DRV_OA_MODE_ALREADY_EXISTS",
+            20190: "DRV_OA_STRINGS_NOT_EQUAL",
+            20191: "DRV_OA_NO_USER_DATA",
+            20192: "DRV_OA_VALUE_NOT_SUPPORTED",
+            20193: "DRV_OA_MODE_DOES_NOT_EXIST",
+            20194: "DRV_OA_CAMERA_NOT_SUPPORTED",
+            20195: "DRV_OA_FAILED_TO_GET_MODE",
+            20196: "DRV_OA_CAMERA_NOT_AVAILABLE",
+            20211: "DRV_PROCESSING_FAILED",
+            20990: "DRV_ERROR_NOCAMERA",
+            20991: "DRV_NOT_SUPPORTED",
+            20992: "DRV_NOT_AVAILABLE"
+        }
```

### Comparing `wasatch-2.1.35/wasatch/BLEDevice.py` & `wasatch-2.1.64/wasatch/BLEDevice.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,25 +1,16 @@
 import os
-import re
-import json
-import time
-import random
-import struct
 import logging
 import asyncio
 import threading
 
-from typing import TypeVar, Any, Callable
-from bleak import discover, BleakClient, BleakScanner
-from bleak.exc import BleakError
+from bleak import BleakClient
 
-from . import utils
 from .Reading import Reading
 from wasatch.EEPROM import EEPROM
-from wasatch.DeviceID import DeviceID
 from .ControlObject import ControlObject
 from .InterfaceDevice import InterfaceDevice
 from .SpectrometerResponse import ErrorLevel
 from .SpectrometerSettings import SpectrometerSettings
 from .SpectrometerResponse import SpectrometerResponse
 from .SpectrometerRequest  import SpectrometerRequest
 
@@ -215,15 +206,15 @@
             return SpectrometerResponse(False, error_msg="error trying to write gain", error_lvl=ErrorLevel.medium)
         return SpectrometerResponse(True)
 
     async def _ble_acquire(self) -> SpectrometerResponse:
         if self.disconnect:
             log.debug("ble spec is set to disconnect, returning False")
             return SpectrometerResponse(False)
-        request = await self.client.write_gatt_char(DEVICE_ACQUIRE_UUID, bytes(0), response = True)
+        _ = await self.client.write_gatt_char(DEVICE_ACQUIRE_UUID, bytes(0), response = True)
         pixels = self.settings.eeprom.active_pixels_horizontal
         request_retry = False
         averaging_enabled = (self.settings.state.scans_to_average > 1)
         if self.pixels_read == 0:
             self.spectrum = [0 for pix in range(pixels)]
 
         if averaging_enabled and not self.settings.state.free_running_mode:
@@ -231,15 +222,15 @@
             self.sum_count = 0
             loop_count = self.settings.state.scans_to_average
 
         else:
             # we're in free-running mode
             loop_count = 1
         reading = None
-        for loop_index in range(0, loop_count):
+        for _ in range(0, loop_count):
             reading = Reading(self.device_id)
             reading.integration_time_ms = self.settings.state.integration_time_ms
             reading.laser_power_perc    = self.settings.state.laser_power_perc
             reading.laser_power_mW      = self.settings.state.laser_power_mW
             reading.laser_enabled       = self.settings.state.laser_enabled
             header_len = 2
             if self.disconnect:
@@ -268,19 +259,19 @@
 
             request_retry = False
 
             log.debug(f"requesting spectrum packet starting at pixel {self.pixels_read}")
             request = self.pixels_read.to_bytes(2, byteorder="big")
             await self.client.write_gatt_char(SPECTRUM_PIXELS_UUID, request, response = True)
 
-            log.debug(f"reading spectrumChar (pixelsRead {self.pixels_read})");
+            log.debug(f"reading spectrumChar (pixelsRead {self.pixels_read})")
             response = await self.client.read_gatt_char(READ_SPECTRUM_UUID)
 
             # make sure response length is even, and has both header and at least one pixel of data
-            response_len = len(response);
+            response_len = len(response)
             if (response_len < header_len or response_len % 2 != 0):
                 log.error(f"received invalid response of {response_len} bytes")
                 request_retry = True
                 continue
             if self.disconnect:
                 log.debug("ble spec is set to disconnect, returning False")
                 return SpectrometerResponse(False)
@@ -288,17 +279,17 @@
             # firstPixel is a big-endian UInt16
             first_pixel = int((response[0] << 8) | response[1])
             if (first_pixel > 2048 or first_pixel < 0):
                 log.error(f"received NACK (first_pixel {first_pixel}, retrying")
                 request_retry = True
                 continue
 
-            pixels_in_packet = int((response_len - header_len) / 2);
+            pixels_in_packet = int((response_len - header_len) / 2)
 
-            log.debug(f"received spectrum packet starting at pixel {first_pixel} with {pixels_in_packet} pixels");
+            log.debug(f"received spectrum packet starting at pixel {first_pixel} with {pixels_in_packet} pixels")
 
             for i in range(pixels_in_packet):
                 # pixel intensities are little-endian UInt16
                 offset = header_len + i * 2
                 intensity = int((response[offset+1] << 8) | response[offset])
                 self.spectrum[self.pixels_read] = intensity
                 if self.disconnect:
@@ -307,26 +298,26 @@
 
                 self.pixels_read += 1
 
                 if self.pixels_read == pixels:
                     log.debug("read complete spectrum")
                     self.session_reading_count += 1
                     if (i + 1 != pixels_in_packet):
-                        log.error(f"ignoring {pixels_in_packet - (i + 1)} trailing pixels");
+                        log.error(f"ignoring {pixels_in_packet - (i + 1)} trailing pixels")
                     break
-            response = None;
+            response = None
             #### WHILE LOOP ENDS HERE ####
             for i in range(4):
                 self.spectrum[i] = self.spectrum[4]
 
             self.spectrum[pixels-1] = self.spectrum[pixels-2]
 
             reading.session_count = self.session_reading_count
             reading.sum_count = self.sum_count
-            log.debug("Spectrometer.takeOneAsync: returning completed spectrum");
+            log.debug("Spectrometer.takeOneAsync: returning completed spectrum")
             reading.spectrum = self.spectrum
 
             if not reading.failure:
                 if averaging_enabled:
                     if self.sum_count == 0:
                         self.summed_spectra = [float(i) for i in reading.spectrum]
                     else:
@@ -361,19 +352,18 @@
         return response
 
     async def _get_eeprom(self) -> list[list[int]]:
         log.debug("Trying BLE eeprom read")
         pages = []
         for i in range(EEPROM.MAX_PAGES):
             buf = bytearray()
-            pos = 0
             for j in range(EEPROM.SUBPAGE_COUNT):
                 page_ids = bytearray([i, j])
                 log.debug(f"Writing to tell gateway to get page {i} ands subpage {j}")
-                request = await self.client.write_gatt_char(SELECT_EEPROM_PAGE_UUID, page_ids, response = True)
+                _ = await self.client.write_gatt_char(SELECT_EEPROM_PAGE_UUID, page_ids, response = True)
                 log.debug("Attempting to read page data")
                 response = await self.client.read_gatt_char(READ_EEPROM_UUID)
                 for byte in response:
                     buf.append(byte)
             pages.append(buf)
         return pages
 
@@ -441,9 +431,9 @@
         self.sum_count = 0
         self.settings.state.scans_to_average = int(value)
 
     def close(self): # -> None 
         log.info("BLE close called, trying to disconnect spec")
         self.disconnect = True
         fut = asyncio.run_coroutine_threadsafe(self._disconnect_spec(), self.loop)
-        result = fut.result()
+        _ = fut.result()
         self.loop.stop()
```

### Comparing `wasatch-2.1.35/wasatch/BalanceAcquisition.py` & `wasatch-2.1.64/wasatch/BalanceAcquisition.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 import logging
 import re
 
 log = logging.getLogger(__name__)
 
-class BalanceAcquisition(object):
+class BalanceAcquisition:
 
     INTEGRATION            = 0
     LASER                  = 1
     LASER_THEN_INTEGRATION = 2
 
     def __init__(self, mode=INTEGRATION, intensity=45000, threshold=2500, pixel=None, device=None, max_integration_time_ms=5000, max_tries=20):
         self.mode      = mode
```

### Comparing `wasatch-2.1.35/wasatch/CSVLoader.py` & `wasatch-2.1.64/wasatch/CSVLoader.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,157 +1,184 @@
 import datetime
 import logging
-import copy
 import csv
 import re
 
 from .Reading              import Reading
 from .ProcessedReading     import ProcessedReading
 
 log = logging.getLogger(__name__)
 
 ##
 # A file parser to deserialize one Measurement from a column-ordered CSV file.
 #
+# It looks like the basic usage is to instantiate it with a CSV pathname, call
+# load_data() with or without scalar_metadata, then access the .processed_reading
+# and .metadata elements. So, arguably this could have been a separate 
+# constructor for ProcessedReading?
+#
 # Given the similarity between the columnar CSV and "export" file formats, it 
 # would be SO TEMPTING to imagine you could easily generalize them.  I thought
 # they're just different enough that it would be a nightmare, so here we are.
 #
 # It is expected that this will be able to handle "raw" columnar CSV formats as
 # well, which contain no metadata, but instead begin directly with the header
 # row.  In that case, wavelength and wavenumber are used directly from the input
 # data, as no wavecal coefficients or excitation are available.
 #
-# Currently this class is used by two callers:
+# Currently this class is used by at least three callers:
 #
-# - enlighten.parser.ColumFileParser
+# - enlighten.parser.ColumnFileParser
 # - wasatch.MockUSBDevice
+# - an OEM plugin
+# - maybe a shell script or two? (check enlighten/scripts)
 #
-class CSVLoader(object):
+class CSVLoader:
 
-    def __init__(self, pathname, save_options=None, encoding="utf-8"):
+    def __init__(self, pathname, encoding="utf-8"):
         self.pathname = pathname
-        self.save_options = save_options
         self.encoding = encoding
 
         # default
         self.timestamp = datetime.datetime.now()
 
         # temporarily store these if no wavecal is provided
         self.metadata = {
-            "pixel": [],
-            "wavelength": [],
-            "wavenumber": []
+            "pixel": []
         }
 
         self.headers = []
         self.processed_reading = ProcessedReading()
         self.processed_reading.reading = Reading(device_id = "LOAD:" + pathname)
 
-    def parse_metadata(self, line, scalar_metadata=False):
+    def __repr__(self):
+        return f"CSVLoader<{self.pathname}> with ProcessedReading {self.processed_reading} and metadata {self.metadata.keys()}"
+
+    def _parse_metadata(self, line, scalar_metadata=False):
         """
         MZ: I'm not sure who is using this method and wants the metadata 
         values to be returned as lists, but it unnecessarily complicates 
         ColumnFileParser, so adding the scalar option.
         """
         line = list(line)
-        key   = line[0]
+        key = line[0]
         if scalar_metadata:
             value = line[1]
         else:
             value = line[1:] # for lists with only one element this will give []
                              # Useful for cases like Declared Match,,,,,,,,
         self.metadata[key] = value
 
-    def parse_header(self, line):
+    def _parse_header(self, line):
         self.headers = [ x.lower().strip() for x in line ] # force lowercase
         if "processed" in self.headers: self.processed_reading.processed = []
         if "raw"       in self.headers: self.processed_reading.raw       = []
         if "dark"      in self.headers: self.processed_reading.dark      = []
         if "reference" in self.headers: self.processed_reading.reference = []
         if "corrected" in self.headers: self.processed_reading.processed = []
-        log.debug("parse_header: headers = %s", self.headers)
+        # log.debug("_parse_header: headers = %s", self.headers)
 
     def load_data(self, scalar_metadata=False):
+
+        # create empty arrays for all of these so we have someplace to put data as we load lines
+        self.processed_reading.processed = []
+        self.processed_reading.raw = []
+        self.processed_reading.dark = []
+        self.processed_reading.reference = []
+        self.processed_reading.wavelengths = []
+        self.processed_reading.wavenumbers = []
+
         state = "reading_metadata"
         data_rows_read = 0
         with open(self.pathname, "r", encoding=self.encoding) as infile:
             csv_lines = csv.reader(infile)
             for line in csv_lines:
                 # skip comments and blanks
                 if len(line) == 0 or line[0].startswith('#'):
                     continue
 
                 line[-1] = line[-1].strip() # remove the \n
-                log.debug("load_data[%s]: %s", state, line)
+                # log.debug("load_data[%s]: %s", state, line)
 
                 if state == "reading_metadata":
                     
-                    # check for end of metadata (note trailing comma!)
-                    cleanup_line = lambda x: x.strip().lower()
-                    clean_line = [cleanup_line(part) for part in line]
-                    check_present = lambda x: x in clean_line
-                    contains_header = [check_present(header) 
-                                       for header in ["pixel", "wavelength", "wavenumber", "processed"]]
-                    if any(contains_header):
-                        self.parse_header(line)
+                    # check for end of metadata
+                    looks_like_header = False
+                    for tok in [ part.strip().lower() for part in line ]:
+                        if tok in ["pixel", "wavelength", "wavenumber", "processed", "intensity"]:
+                            looks_like_header = True
+                            break
+
+                    if looks_like_header:
+                        self._parse_header(line)
                         state = "reading_data"
                     else:
                         # still in metadata
-                        self.parse_metadata(line, scalar_metadata)
+                        self._parse_metadata(line, scalar_metadata)
 
                 elif state == "reading_metadata_final":
-                    self.parse_metadata(line, scalar_metadata)
+                    self._parse_metadata(line, scalar_metadata)
                 
                 elif state == "reading_data":
                     values = [x.strip() for x in line]
 
                     # if we find more metadata after data ended, store it but 
                     # do not transition back
                     if not re.match(r'^[-+]?\d', values[0]):
                         state = "reading_metadata_final"
-                        self.parse_metadata(line, scalar_metadata)
+                        self._parse_metadata(line, scalar_metadata)
                         continue
 
                     # Assume each value read aligns with a known headers, but recognize that there
                     # could be more headers than there are values (some columns with headers may
                     # not actually have populated data, blank or otherwise).  This is the number of
                     # comma-delimited fields actually read (or the number of headers, if more values
                     # were read than had headers).
                     count = min(len(self.headers), len(values))
+                    # log.debug(f"parsing {count} fields")
 
                     for i in range(count):
                         header = self.headers[i]
+                        # log.debug(f"parsing header {i} ({header})")
 
                         # SKIP nulls.  Note we're APPENDING data to each list, so this means that 
                         # if there are blanks (rather than '0' zeros) in the MIDDLE of a column, 
                         # the resulting spectral matrix will have different-length columns and
                         # improperly-associated "rows".
                         value = values[i]
                         if len(value) == 0:
+                            # log.debug(f"skipping value {i} ({value})")
                             continue
 
                         # MZ: honestly not sure if we should skip these or treat as zero
                         if value == "NA":
+                            # log.debug(f"treating value {i} ({value}) as zero")
                             value = 0
 
                         # add to array
                         array = None
-                        if   header == "processed":  array = self.processed_reading.processed
+                        if   header in ["processed", "intensity"]:  array = self.processed_reading.processed
                         elif header == "corrected":  array = self.processed_reading.processed 
                         elif header == "raw":        array = self.processed_reading.raw
                         elif header == "dark":       array = self.processed_reading.dark
                         elif header == "reference":  array = self.processed_reading.reference
-                        elif header == "pixel":      array = self.metadata['pixel']      
-                        elif header == "wavelength": array = self.metadata['wavelength'] 
-                        elif header == "wavenumber": array = self.metadata['wavenumber'] 
+                        elif header == "wavelength": array = self.processed_reading.wavelengths
+                        elif header == "wavenumber": array = self.processed_reading.wavenumbers
+                        elif header == "pixel":      array = self.metadata["pixel"]
 
                         if array is not None:
-                            # log.debug("appending to %s: %s", header, value)
+                            # log.debug(f"appending to {header}: {value}")
                             array.append(float(value))
                         else:
-                            log.error("load_data: null array?")
+                            log.error(f"load_data: null array? headers {self.headers}, header {header}, value {value}, line {line} ({self.pathname})")
 
                         if data_rows_read == 0 and header == "pixel" and int(value) != 0:
-                            self.processed_reading.first_pixel = int(value)
+                            value = int(value)
+                            # log.debug(f"first pixel = {value}")
+                            self.processed_reading.first_pixel = value
 
                     data_rows_read += 1
+
+        # clear any arrays we ended up not filling
+        self.processed_reading.post_load_cleanup()
+
+        return self.processed_reading, self.metadata
```

### Comparing `wasatch-2.1.35/wasatch/CommandSettings.py` & `wasatch-2.1.64/wasatch/CommandSettings.py`

 * *Files 2% similar despite different names*

```diff
@@ -53,30 +53,30 @@
 # traditionally called "settings" when passing ControlObjects from ENLIGHTEN
 # down into Wasatch.PY via "settings queues", but are very different from
 # SpectrometerSettings (actual settings of the spectrometer, vs commands
 # being passed between processes). 
 #
 # We're not actually using this at the moment, but it would be a way to provide 
 # some automated data validation and type-checking on callers like wasatch-shell.py
-class CommandSettings(object):
+class CommandSettings:
 
     def get_settings(self):
         return sorted(SETTINGS.keys())
 
     def get_datatype(self, setting):
-        if not setting in SETTINGS:
+        if setting not in SETTINGS:
             return None
 
         return SETTINGS[setting]["datatype"]
 
     def valid(self, setting):
         return setting in SETTINGS
 
     def convert_type(self, setting, value):
-        if not setting in SETTINGS:
+        if setting not in SETTINGS:
             log.error("invalid setting: %s", setting)
             return None
 
         dt = SETTINGS[setting]["datatype"]
         if dt == "bool":
             return "true" in value.lower()
         elif dt == "int":
```

### Comparing `wasatch-2.1.35/wasatch/ControlObject.py` & `wasatch-2.1.64/wasatch/ControlObject.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,14 +1,15 @@
-##
-# A class holding setting-value pairs sent from ENLIGHTEN to the spectrometer.
-# Compare to StatusMessage as an outbound (spectrometer subprocess -> ENLIGHTEN) counterpart.
-# 
-# There is no enumeration of supported settings, but CommandSettings
-# is an (unused) step in that direction.  For now, the true master list
-# would be the set implemented by FeatureIdentificationDevice.write_setting.
-class ControlObject(object):
+class ControlObject:
+    """
+    A class holding setting-value pairs sent from ENLIGHTEN to the spectrometer.
+    Compare to StatusMessage as an outbound (spectrometer subprocess -> ENLIGHTEN) counterpart.
+    
+    There is no enumeration of supported settings, but CommandSettings
+    is an (unused) step in that direction.  For now, the true master list
+    would be the set implemented by FeatureIdentificationDevice.write_setting.
+    """
     def __init__(self, setting, value):
         self.setting = setting
         self.value = value
 
     def __str__(self):
         return "%s -> %s" % (self.setting, self.value)
```

### Comparing `wasatch-2.1.35/wasatch/DetectorROI.py` & `wasatch-2.1.64/wasatch/DetectorROI.py`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/wasatch/DetectorRegions.py` & `wasatch-2.1.64/wasatch/DetectorRegions.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,11 @@
 import logging
 
+from wasatch.DetectorROI import DetectorROI
+
 log = logging.getLogger(__name__)
 
 ##
 # This class encapsulates all of the DetectorROI regions that have been 
 # configured for the current detetor. If no DetectorROI regions have been
 # configured for a detector, SpectrometerState.detector_regions may be None
 # (indicating the full detector is being vertically binned and read-out).
```

### Comparing `wasatch-2.1.35/wasatch/DeviceFinderUSB.py` & `wasatch-2.1.64/wasatch/DeviceFinderUSB.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,232 +1,232 @@
-import re
-import usb
-import logging
-import platform
-from functools import partial
-
-if platform.system() == "Darwin":
-    # would like to include in Mac stub
-    # * imports must be at the module level though
-    from ctypes import *
-    from CoreFoundation import *
-    import usb.backend.libusb1 as backend
-else:
-    import usb.backend.libusb0 as backend
-
-log = logging.getLogger(__name__)
-
-from .DeviceID import DeviceID
-
-##
-# Generates a list of DeviceID objects for all connected USB Wasatch Photonics 
-# spectrometers.
-class DeviceFinderUSB(object):
-
-    WASATCH_VID = 0x24aa
-    OCEAN_VID = 0x2457
-    ANDOR_VID = 0x136e
-    FT232_SPI_VID = 0x0403
-    WP_HAMA_SILICON_PID = 0x1000
-    WP_HAMA_INGAAS_PID = 0x2000
-    WP_ARM_PID = 0x4000
-    VALID_ID_LIST = [WASATCH_VID, OCEAN_VID, ANDOR_VID, FT232_SPI_VID]
-    STR_VALID_IDS = [hex(id)[2:] for id in VALID_ID_LIST]
-    USE_MONITORING = True
-
-    MIN_POLLING_SCANS = 10
-
-    def __init__(self):
-        self.startup_scan = 0
-        if platform.system() == "Windows":
-            log.debug("configuring for Windows")
-            import win32com.client
-            # see https://docs.microsoft.com/en-us/windows/win32/wmisdk/creating-a-wmi-script
-            obj_WMI_service = win32com.client.GetObject("winmgmts:")
-            # see https://docs.microsoft.com/en-us/windows/win32/wmisdk/querying-with-wql
-            raw_wql = "SELECT * FROM __InstanceCreationEvent WITHIN 1 WHERE TargetInstance ISA \'Win32_PnPEntity\'"
-            # see https://docs.microsoft.com/en-us/windows/win32/wmisdk/monitoring-events
-            # while it removes polling the usb bus
-            # the polling now shifts to WMI events as the query is a polling operation
-            self.obj_events = obj_WMI_service.ExecNotificationQuery(raw_wql)
-        elif platform.system() == "Linux":
-            log.debug("configuring for Linux")
-            import pyudev
-            self.context = pyudev.Context()
-            self.monitor = pyudev.Monitor.from_netlink(self.context)
-        elif platform.system() == "Darwin":
-            log.debug("configuring for MacOS")
-        else:
-            pass
-
-    ##
-    # Iterates over each supported PID, searching for any Wasatch devices
-    # with a known VID/PID and generating a list of DeviceIDs.
-    #
-    # Note that DeviceID internally pulls more attributes from the Device object.
-    # def find_usb_devices_alternate_unused(self):
-    #     vid = 0x24aa
-    #     device_ids = []
-    #     count = 0
-    #     for pid in [0x1000, 0x2000, 0x4000]:
-    #         # we could also remove iProduct and do one find on vid
-    #         devices = usb.core.find(find_all=True, idVendor=vid, idProduct=pid)
-    #         for device in devices:
-    #             count += 1
-    #             log.debug("DeviceListFID: discovered vid 0x%04x, pid 0x%04x (count %d)", vid, pid, count)
-    #
-    #             device_id = DeviceID(device=device)
-    #             device_ids.append(device_id)
-    #     return device_ids
-    
-    ##
-    # Iterates over each USB bus, and each device on the bus, retaining any
-    # with a Wasatch Photonics VID and supported PID and instantiating a
-    # DeviceID for each.  
-    #
-    # Note that DeviceID internally pulls more attributes from the Device object.
-    def bus_polling(self): # -> list[DeviceID] 
-        device_ids = []
-        count = 0
-        devices = usb.core.find(find_all=True, backend=backend.get_backend())
-        for device in devices:
-            count += 1
-            vid = int(device.idVendor)
-            pid = int(device.idProduct)
-            log.debug("DeviceListFID: discovered vid 0x%04x, pid 0x%04x (count %d), address %s", vid, pid, count, device.address)
-
-            if vid not in [self.WASATCH_VID, self.OCEAN_VID, self.ANDOR_VID, self.FT232_SPI_VID]:
-                continue
-
-            if vid == self.WASATCH_VID and pid not in [ self.WP_HAMA_SILICON_PID, self.WP_HAMA_INGAAS_PID, self.WP_ARM_PID ]:
-                continue
-
-            device_id = DeviceID(device=device)
-            device_ids.append(device_id)
-        return device_ids
-
-    def linux_monitoring(self): # -> list[DeviceID] 
-        device_ids = []
-        for device in iter(partial(self.monitor.poll, 0.001), None):
-            # sometimes I see events with None for the vendor id, those should be skipped
-            if device is not None and device.action == "add" and device.get('ID_VENDOR_ID') is not None:
-                device_ids.append(device)
-                log.debug(f"got a udev device add event")
-        valid_devices = [dev for dev in device_ids if dev.get('ID_VENDOR_ID').lower() in self.STR_VALID_IDS]
-        pyusb_devices = [usb.core.find(idVendor=int(dev.get('ID_VENDOR_ID'), 16), idProduct=int(dev.get('ID_MODEL_ID'), 16)) for dev in valid_devices]
-        # if there is an error/can't find pyusb returns none
-        # filter those out
-        if None in pyusb_devices:
-            log.error(f"pyudev notified of a matching device, but error when doing pyusb query")
-            pyusb_devices = [dev for dev in pyusb_devices if dev is not None] 
-        if pyusb_devices != []:
-            log.debug(f"pyudev returned devices of {pyusb_devices}")
-        return [DeviceID(device) for device in pyusb_devices]
-
-    # I like this line but think it deserves a comment
-    # map across the STR_VALID_IDS checking if it is in current id string, resulting in a bool array
-    # if any true in that bool array then any() is true and thus it will be in the list
-    def id_in_valid_ids(self, dev_id):
-        valid_id_present = map(lambda valid: valid in dev_id, self.STR_VALID_IDS)
-        return any(valid_id_present)
-
-    def windows_monitoring(self): # -> list[DeviceID] 
-        device_ids = []
-        try:
-            # the next event raises an error on timeout
-            # so if a connection has occured then add it to device ids
-            # when we stop seeing devices then pass on to the processing
-            while True:
-                obj_received = self.obj_events.NextEvent(0.001)
-                device_id = obj_received.Properties_("TargetInstance").Value.DeviceID
-                device_ids.append(device_id.lower())
-        except:
-            pass
-        if device_ids != []:
-            log.debug(f"found a WMI event of {device_ids}")
-        valid_ids = [dev_id for dev_id in device_ids if self.id_in_valid_ids(dev_id)] 
-        pids = [re.findall(r'pid_(....)', dev) for dev in valid_ids]
-        pids = [id_num[0] for id_num in pids if id_num is not []]
-        vids = [re.findall(r'vid_(....)', dev) for dev in valid_ids]
-        vids = [id_num[0] for id_num in vids if id_num is not []]
-        # end by querying just the desired Wasatch Devices via pyusb
-        # this provides an easy meshing with our current setup using pyusb devices
-        pyusb_devices = [usb.core.find(idVendor=int(vid, 16), idProduct=int(pid, 16), backend=backend.get_backend()) for vid, pid in zip(vids, pids)]
-        # if there is an error/can't find pyusb returns none
-        # filter those out
-        if None in pyusb_devices:
-            log.error(f"WMI notified of a matching device, but error when doing pyusb query")
-            pyusb_devices = [dev for dev in pyusb_devices if dev is not None] 
-        if pyusb_devices != []:
-            log.debug(f"WMI returned devices of {pyusb_devices}")
-        return [DeviceID(device) for device in pyusb_devices]
-
-    def find_usb_devices(self, poll = False):
-        log.debug("DeviceFinderUSB.find_usb_devices: starting")
-        device_ids = []
-
-        # MZ/ED: If USE_MONITORING is True, I had to disable the call to remove_all in enlighten.Controller
-        if self.startup_scan < self.MIN_POLLING_SCANS or not self.USE_MONITORING or poll:
-            # our first few scans should always be a bus poll
-            # this is because no events will be registered
-            log.debug(f"DeviceFinderUSB.find_usb_devices: just doing a bus poll for startup_scan {self.startup_scan}")
-            device_ids = self.bus_polling()
-            self.startup_scan += 1
-        elif platform.system() == "Windows":
-            device_ids = self.windows_monitoring()
-        elif platform.system() == "Linux":
-            device_ids = self.linux_monitoring()
-        else:
-            device_ids = self.bus_polling()
-        log.debug(f"DeviceFinderUSB.find_usb_devices: returning {len(device_ids)} devices")
-        return device_ids
-
-    def mac_monitoring(self):
-        """
-        The challenge of implementing Mac usb events was decided not to be worth it
-        since it is such a small porition of users. I've included my code below the not implemented error
-        for reference in case we decide to implement later. This is incomplete and shouldn't be called.
-        """
-        raise NotImplementedError
-
-        from ctypes import cdll, util
-
-        #iokit = cdll.LoadLibrary(util.find_library('IOKit'))
-
-        # See ctypes for what these calls are doing
-        # For where iokit info is coming from
-        # Apple docs, which imo are bad with clear examples, if any, 
-        # so I'm structuring this 
-        # in a how to actually create and do way
-        # IO notifications in python using ctypes
-        # https://developer.apple.com/library/archive/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/Introduction/Introduction.html
-        # AddMatchingNotification is our goal since that provides the iterator of devices
-        # https://developer.apple.com/documentation/iokit/1514362-ioserviceaddmatchingnotification?language=objc
-        # So our requirements are to create the following args
-        # IONotificationPortRef, io_name_t, CFDictionaryRef, IOServiceMatchingCallback, io_iterator_t
-
-        # For the IONotificationPortRef we call IONotificationPortCreate, which requires a mach_port_t
-        # the primary port comes from a constant used in the dylib
-        # https://developer.apple.com/documentation/iokit/1514480-ionotificationportcreate?language=objc
-        kIOMasterPortDefault = c_void_p.in_dll(iokit, 'kIOMasterPortDefault')
-        res = iokit.IONotificationPortCreate(kIOMasterPortDefault)
-
-        # For the io_name_t that comes from a constant in the dll
-        # See the parameter description in the AddMatchinServiceNotification link at the top
-        # We want publish because it means whenever a connection occurs
-        kIOPublishNotification = c_int.in_dll(iokit, 'kIOPublishNotification') # this throws an error that it doesn't have this symbol, idk why. It should export that
-
-        # CFDictionary creation call info, along with args to pass, can be found here
-        # https://developer.apple.com/documentation/corefoundation/1516791-cfdictionarycreatemutable?language=objc
-        # the pyobjc docs weren't helpful and just say this call exists but not how to call it
-        # we choose mutable when it could just be CFDictionaryCreate because it's easier to work with
-        # after creation this can be interacted with like a python dict
-        # the nonmutable requires passing c arrays for keys, values, which why bother when we can use python syntax
-        # expected keys example can be seen in xml doc in 
-        # Figure 4-2 I found more helpful since it is for USB
-        # https://developer.apple.com/library/archive/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/Matching/Matching.html
-        # XML docs say every dict requires IOProviderClass
-        # The value for the key can be found in the appendix of the driver docs
-        matching_dict = CFDictionaryCreateMutable(None, 0,  kCFTypeDictionaryKeyCallBacks, kCFTypeDictionaryValueCallBacks)
-        matching_dict["IOProviderClass"] = "IOUSBDevice"
-        matching_dict["idVendor"] = 0x24aa # we can have the driver pre filter for wasatch, so I'm utilizing that
-
+import re
+import usb
+import logging
+import platform
+from functools import partial
+
+if platform.system() == "Darwin":
+    # would like to include in Mac stub
+    # * imports must be at the module level though
+    from ctypes import *
+    from CoreFoundation import *
+    import usb.backend.libusb1 as backend
+else:
+    import usb.backend.libusb0 as backend
+
+log = logging.getLogger(__name__)
+
+from .DeviceID import DeviceID
+
+##
+# Generates a list of DeviceID objects for all connected USB Wasatch Photonics 
+# spectrometers.
+class DeviceFinderUSB:
+
+    WASATCH_VID = 0x24aa
+    OCEAN_VID = 0x2457
+    ANDOR_VID = 0x136e
+    FT232_SPI_VID = 0x0403
+    WP_HAMA_SILICON_PID = 0x1000
+    WP_HAMA_INGAAS_PID = 0x2000
+    WP_ARM_PID = 0x4000
+    VALID_ID_LIST = [WASATCH_VID, OCEAN_VID, ANDOR_VID, FT232_SPI_VID]
+    STR_VALID_IDS = [hex(id)[2:] for id in VALID_ID_LIST]
+    USE_MONITORING = True
+
+    MIN_POLLING_SCANS = 10
+
+    def __init__(self):
+        self.startup_scan = 0
+        if platform.system() == "Windows":
+            log.debug("configuring for Windows")
+            import win32com.client
+            # see https://docs.microsoft.com/en-us/windows/win32/wmisdk/creating-a-wmi-script
+            obj_WMI_service = win32com.client.GetObject("winmgmts:")
+            # see https://docs.microsoft.com/en-us/windows/win32/wmisdk/querying-with-wql
+            raw_wql = "SELECT * FROM __InstanceCreationEvent WITHIN 1 WHERE TargetInstance ISA \'Win32_PnPEntity\'"
+            # see https://docs.microsoft.com/en-us/windows/win32/wmisdk/monitoring-events
+            # while it removes polling the usb bus
+            # the polling now shifts to WMI events as the query is a polling operation
+            self.obj_events = obj_WMI_service.ExecNotificationQuery(raw_wql)
+        elif platform.system() == "Linux":
+            log.debug("configuring for Linux")
+            import pyudev
+            self.context = pyudev.Context()
+            self.monitor = pyudev.Monitor.from_netlink(self.context)
+        elif platform.system() == "Darwin":
+            log.debug("configuring for MacOS")
+        else:
+            pass
+
+    ##
+    # Iterates over each supported PID, searching for any Wasatch devices
+    # with a known VID/PID and generating a list of DeviceIDs.
+    #
+    # Note that DeviceID internally pulls more attributes from the Device object.
+    # def find_usb_devices_alternate_unused(self):
+    #     vid = 0x24aa
+    #     device_ids = []
+    #     count = 0
+    #     for pid in [0x1000, 0x2000, 0x4000]:
+    #         # we could also remove iProduct and do one find on vid
+    #         devices = usb.core.find(find_all=True, idVendor=vid, idProduct=pid)
+    #         for device in devices:
+    #             count += 1
+    #             log.debug("DeviceListFID: discovered vid 0x%04x, pid 0x%04x (count %d)", vid, pid, count)
+    #
+    #             device_id = DeviceID(device=device)
+    #             device_ids.append(device_id)
+    #     return device_ids
+    
+    ##
+    # Iterates over each USB bus, and each device on the bus, retaining any
+    # with a Wasatch Photonics VID and supported PID and instantiating a
+    # DeviceID for each.  
+    #
+    # Note that DeviceID internally pulls more attributes from the Device object.
+    def bus_polling(self): # -> list[DeviceID] 
+        device_ids = []
+        count = 0
+        devices = usb.core.find(find_all=True, backend=backend.get_backend())
+        for device in devices:
+            count += 1
+            vid = int(device.idVendor)
+            pid = int(device.idProduct)
+            log.debug("DeviceListFID: discovered vid 0x%04x, pid 0x%04x (count %d), address %s", vid, pid, count, device.address)
+
+            if vid not in [self.WASATCH_VID, self.OCEAN_VID, self.ANDOR_VID, self.FT232_SPI_VID]:
+                continue
+
+            if vid == self.WASATCH_VID and pid not in [ self.WP_HAMA_SILICON_PID, self.WP_HAMA_INGAAS_PID, self.WP_ARM_PID ]:
+                continue
+
+            device_id = DeviceID(device=device)
+            device_ids.append(device_id)
+        return device_ids
+
+    def linux_monitoring(self): # -> list[DeviceID] 
+        device_ids = []
+        for device in iter(partial(self.monitor.poll, 0.001), None):
+            # sometimes I see events with None for the vendor id, those should be skipped
+            if device is not None and device.action == "add" and device.get('ID_VENDOR_ID') is not None:
+                device_ids.append(device)
+                log.debug(f"got a udev device add event")
+        valid_devices = [dev for dev in device_ids if dev.get('ID_VENDOR_ID').lower() in self.STR_VALID_IDS]
+        pyusb_devices = [usb.core.find(idVendor=int(dev.get('ID_VENDOR_ID'), 16), idProduct=int(dev.get('ID_MODEL_ID'), 16)) for dev in valid_devices]
+        # if there is an error/can't find pyusb returns none
+        # filter those out
+        if None in pyusb_devices:
+            log.error(f"pyudev notified of a matching device, but error when doing pyusb query")
+            pyusb_devices = [dev for dev in pyusb_devices if dev is not None] 
+        if pyusb_devices != []:
+            log.debug(f"pyudev returned devices of {pyusb_devices}")
+        return [DeviceID(device) for device in pyusb_devices]
+
+    # I like this line but think it deserves a comment
+    # map across the STR_VALID_IDS checking if it is in current id string, resulting in a bool array
+    # if any true in that bool array then any() is true and thus it will be in the list
+    def id_in_valid_ids(self, dev_id):
+        valid_id_present = map(lambda valid: valid in dev_id, self.STR_VALID_IDS)
+        return any(valid_id_present)
+
+    def windows_monitoring(self): # -> list[DeviceID] 
+        device_ids = []
+        try:
+            # the next event raises an error on timeout
+            # so if a connection has occured then add it to device ids
+            # when we stop seeing devices then pass on to the processing
+            while True:
+                obj_received = self.obj_events.NextEvent(0.001)
+                device_id = obj_received.Properties_("TargetInstance").Value.DeviceID
+                device_ids.append(device_id.lower())
+        except:
+            pass
+        if device_ids != []:
+            log.debug(f"found a WMI event of {device_ids}")
+        valid_ids = [dev_id for dev_id in device_ids if self.id_in_valid_ids(dev_id)] 
+        pids = [re.findall(r'pid_(....)', dev) for dev in valid_ids]
+        pids = [id_num[0] for id_num in pids if id_num is not []]
+        vids = [re.findall(r'vid_(....)', dev) for dev in valid_ids]
+        vids = [id_num[0] for id_num in vids if id_num is not []]
+        # end by querying just the desired Wasatch Devices via pyusb
+        # this provides an easy meshing with our current setup using pyusb devices
+        pyusb_devices = [usb.core.find(idVendor=int(vid, 16), idProduct=int(pid, 16), backend=backend.get_backend()) for vid, pid in zip(vids, pids)]
+        # if there is an error/can't find pyusb returns none
+        # filter those out
+        if None in pyusb_devices:
+            log.error(f"WMI notified of a matching device, but error when doing pyusb query")
+            pyusb_devices = [dev for dev in pyusb_devices if dev is not None] 
+        if pyusb_devices != []:
+            log.debug(f"WMI returned devices of {pyusb_devices}")
+        return [DeviceID(device) for device in pyusb_devices]
+
+    def find_usb_devices(self, poll = False):
+        log.debug("DeviceFinderUSB.find_usb_devices: starting")
+        device_ids = []
+
+        # MZ/ED: If USE_MONITORING is True, I had to disable the call to remove_all in enlighten.Controller
+        if self.startup_scan < self.MIN_POLLING_SCANS or not self.USE_MONITORING or poll:
+            # our first few scans should always be a bus poll
+            # this is because no events will be registered
+            log.debug(f"DeviceFinderUSB.find_usb_devices: just doing a bus poll for startup_scan {self.startup_scan}")
+            device_ids = self.bus_polling()
+            self.startup_scan += 1
+        elif platform.system() == "Windows":
+            device_ids = self.windows_monitoring()
+        elif platform.system() == "Linux":
+            device_ids = self.linux_monitoring()
+        else:
+            device_ids = self.bus_polling()
+        log.debug(f"DeviceFinderUSB.find_usb_devices: returning {len(device_ids)} devices")
+        return device_ids
+
+    def mac_monitoring(self):
+        """
+        The challenge of implementing Mac usb events was decided not to be worth it
+        since it is such a small porition of users. I've included my code below the not implemented error
+        for reference in case we decide to implement later. This is incomplete and shouldn't be called.
+        """
+        raise NotImplementedError
+
+        from ctypes import cdll, util
+
+        #iokit = cdll.LoadLibrary(util.find_library('IOKit'))
+
+        # See ctypes for what these calls are doing
+        # For where iokit info is coming from
+        # Apple docs, which imo are bad with clear examples, if any, 
+        # so I'm structuring this 
+        # in a how to actually create and do way
+        # IO notifications in python using ctypes
+        # https://developer.apple.com/library/archive/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/Introduction/Introduction.html
+        # AddMatchingNotification is our goal since that provides the iterator of devices
+        # https://developer.apple.com/documentation/iokit/1514362-ioserviceaddmatchingnotification?language=objc
+        # So our requirements are to create the following args
+        # IONotificationPortRef, io_name_t, CFDictionaryRef, IOServiceMatchingCallback, io_iterator_t
+
+        # For the IONotificationPortRef we call IONotificationPortCreate, which requires a mach_port_t
+        # the primary port comes from a constant used in the dylib
+        # https://developer.apple.com/documentation/iokit/1514480-ionotificationportcreate?language=objc
+        kIOMasterPortDefault = c_void_p.in_dll(iokit, 'kIOMasterPortDefault')
+        _ = iokit.IONotificationPortCreate(kIOMasterPortDefault)
+
+        # For the io_name_t that comes from a constant in the dll
+        # See the parameter description in the AddMatchinServiceNotification link at the top
+        # We want publish because it means whenever a connection occurs
+        _ = c_int.in_dll(iokit, 'kIOPublishNotification') # this throws an error that it doesn't have this symbol, idk why. It should export that
+
+        # CFDictionary creation call info, along with args to pass, can be found here
+        # https://developer.apple.com/documentation/corefoundation/1516791-cfdictionarycreatemutable?language=objc
+        # the pyobjc docs weren't helpful and just say this call exists but not how to call it
+        # we choose mutable when it could just be CFDictionaryCreate because it's easier to work with
+        # after creation this can be interacted with like a python dict
+        # the nonmutable requires passing c arrays for keys, values, which why bother when we can use python syntax
+        # expected keys example can be seen in xml doc in 
+        # Figure 4-2 I found more helpful since it is for USB
+        # https://developer.apple.com/library/archive/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/Matching/Matching.html
+        # XML docs say every dict requires IOProviderClass
+        # The value for the key can be found in the appendix of the driver docs
+        matching_dict = CFDictionaryCreateMutable(None, 0,  kCFTypeDictionaryKeyCallBacks, kCFTypeDictionaryValueCallBacks)
+        matching_dict["IOProviderClass"] = "IOUSBDevice"
+        matching_dict["idVendor"] = 0x24aa # we can have the driver pre filter for wasatch, so I'm utilizing that
+
```

### Comparing `wasatch-2.1.35/wasatch/DeviceID.py` & `wasatch-2.1.64/wasatch/DeviceID.py`

 * *Files 0% similar despite different names*

```diff
@@ -63,15 +63,15 @@
 # TCP/IP (which has IP addresses)...basically I think objects on a "bus" should 
 # be uniquely identifiable and addressable from their bus address, WITHOUT making
 # guesses based on position or ordering or claim-state or anything like that.
 #
 # So yeah, I think this is useful and a good design.
 #
 # @note USB VID and PID are stored as ints
-class DeviceID(object):
+class DeviceID:
 
     ##
     # Instantiates a DeviceID object from either a usb.device or an
     # existing device_id string representation.
     def __init__(self, device=None, label=None, directory=None, device_type=None, overrides = None, spectra_options = None):
 
         self.type      = None
```

### Comparing `wasatch-2.1.35/wasatch/EEPROM.py` & `wasatch-2.1.64/wasatch/EEPROM.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,1183 +1,1198 @@
-import hashlib
-import logging
-import struct
-import array
-import math
-import copy
-import json
-import re
-
-from . import utils
-
-from .ROI import ROI
-
-log = logging.getLogger(__name__)
-
-##
-# This class encapsulates the post-read parsing, pre-write marshalling, and current
-# state of the 8-page EEPROM used to store non-volatile configuration data in Wasatch
-# Photonics spectrometers.  It is essential to keep this class synchronized (in naming,
-# datatype / datasize and sequence) with the ENG-0034 customer-facing documentation.
-#
-# This class is normally accessed as an attribute of SpectrometerSettings.
-#
-# @see ENG-0034
-# @see AT24C256C for ARM (32KB, http://ww1.microchip.com/downloads/en/DeviceDoc/20006270A.pdf)
-# @see 24LC128 for FX2 (16KB, https://www.microchip.com/en-us/product/24LC128)
-class EEPROM(object):
-
-    # This was mistakenly set to 15 earlier, probably out of confusion between 
-    # ENG-0001 vs ENG-0034 release level (the former WAS at 15, the latter is
-    # only now advancing to 15).  Leaving it alone for now.
-    LATEST_REV = 15 
-
-    MAX_PAGES = 8
-    PAGE_LENGTH = 64
-    SUBPAGE_COUNT = 4  # is this used for BLE?
-    MAX_RAMAN_INTENSITY_CALIBRATION_ORDER = 7
-
-    DEFAULT_LASER_WATCHDOG_SEC = 10
-
-    def __init__(self):
-        self.model                       = None
-        self.serial_number               = None
-        self.baud_rate                   = 0
-        self.has_cooling                 = False    # explicitly means detector TEC, not laser
-        self.has_battery                 = False
-        self.has_laser                   = False
-        self.feature_mask                = 0
-        self.invert_x_axis               = False
-        self.bin_2x2                     = False
-        self.gen15                       = False
-        self.cutoff_filter_installed     = False
-        self.hardware_even_odd           = False
-        self.sig_laser_tec               = False
-        self.has_interlock_feedback      = False
-        self.has_shutter                 = False
-        self.excitation_nm               = 0.0
-        self.excitation_nm_float         = 0.0
-        self.slit_size_um                = 0
-        self.startup_integration_time_ms = 10
-        self.startup_temp_degC           = 15       # normally used for detector TEC; now also used for raw laser TEC on SiG (needs updated in ENG-0034)
-        self.startup_triggering_scheme   = 0
-        self.detector_gain               = 1.9
-        self.detector_offset             = 0
-        self.detector_gain_odd           = 1.9
-        self.detector_offset_odd         = 0
-        self.laser_warmup_sec            = 0
-        self.laser_watchdog_sec          = 0
-        self.light_source_type           = 0
-                                         
-        self.wavelength_coeffs           = []
-        self.degC_to_dac_coeffs          = []
-        self.adc_to_degC_coeffs          = []
-        self.max_temp_degC               = 20 
-        self.min_temp_degC               = 10
-        self.tec_r298                    = 0
-        self.tec_beta                    = 0
-        self.calibration_date            = None
-        self.calibrated_by               = None
-                                         
-        self.detector                    = None
-        self.detector_serial_number      = None
-        self.active_pixels_horizontal    = 1024
-        self.active_pixels_vertical      = 0
-        self.min_integration_time_ms     = 10
-        self.max_integration_time_ms     = 60000
-        self.actual_horizontal           = 0
-        self.actual_vertical             = 0     # not a real EEPROM field, though it should be
-        self.roi_horizontal_start        = 0
-        self.roi_horizontal_end          = 0
-        self.roi_vertical_region_1_start = 0
-        self.roi_vertical_region_1_end   = 0
-        self.roi_vertical_region_2_start = 0
-        self.roi_vertical_region_2_end   = 0
-        self.roi_vertical_region_3_start = 0
-        self.roi_vertical_region_3_end   = 0
-        self.linearity_coeffs            = []
-
-        self.max_laser_power_mW          = 0.0
-        self.min_laser_power_mW          = 0.0
-        self.laser_power_coeffs          = []
-        self.avg_resolution              = 0.0
-
-        self.user_data                   = None
-        self.user_text                   = None
-
-        self.bad_pixels                  = [] # should be set, not list (but this works with EEPROMEditor)
-        self.product_configuration       = None
-
-        self.format                      = EEPROM.LATEST_REV
-        self.subformat                   = 0 # pages 6-7
-
-        self.buffers = []
-        self.write_buffers = []
-        self.digest = None
-
-        self.editable = [ "excitation_nm",
-                          "excitation_nm_float",
-                          "detector_gain",
-                          "detector_offset",
-                          "detector_gain_odd",
-                          "detector_offset_odd",
-                          "calibrated_by",
-                          "calibration_date", 
-                          "user_text",
-                          "wavelength_coeffs",
-                          "linearity_coeffs",
-                          "max_laser_power_mW",
-                          "min_laser_power_mW",
-                          "laser_power_coeffs",
-                          "bad_pixels",
-                          "bin_2x2",
-                          "gen15",
-                          "cutoff_filter_installed",
-                          "has_shutter",
-                          "laser_warmup_sec",
-                          "laser_watchdog_sec",
-                          "roi_horizontal_end",             
-                          "roi_horizontal_start",           
-                          "roi_vertical_region_1_end",      
-                          "roi_vertical_region_1_start",    
-                          "roi_vertical_region_2_end",      
-                          "roi_vertical_region_2_start",    
-                          "roi_vertical_region_3_end",      
-                          "roi_vertical_region_3_start",
-                          "raman_intensity_calibration_order",
-                          "raman_intensity_coeffs" ]
-
-        self.init_raman_intensity_calibration()
-        self.init_spline()
-        self.init_untethered()
-        self.init_regions()
-
-    ## whether the given field is normally editable by users via ENLIGHTEN
-    #
-    # @return False otherwise (don't trust in None's truthiness, as you can't 
-    #         pass None to Qt's setEnabled)
-    def is_editable(self, name): # -> bool 
-        s = name.lower()
-        for field in self.editable:
-            if s == field.lower():
-                return True
-        return False
-
-    ## 
-    # passed a temporary copy of another EEPROM object, copy-over any
-    # "editable" fields to this one
-    def update_editable(self, new_eeprom):
-        for field in self.editable:
-            old = getattr(self, field)
-            new = copy.deepcopy(getattr(new_eeprom, field))
-            if old == new:
-                log.debug("  %s: no change (%s == %s)", field, old, new)
-            else:
-                setattr(self, field, new)
-                log.debug("  %s: changed %s --> %s", field, old, new)
-
-    # ##########################################################################
-    #                                                                          #
-    #                               Read EEPROM                                #
-    #                                                                          #
-    # ##########################################################################
-
-    ## 
-    # given a set of the 8 buffers read from a spectrometer via USB,
-    # parse those into the approrpriate fields and datatypes
-    def parse(self, buffers): # -> bool 
-        if len(buffers) < EEPROM.MAX_PAGES:
-            log.error("EEPROM.parse expects at least %d buffers", EEPROM.MAX_PAGES)
-            return False
-
-        # store these locally so self.unpack() can access them
-        self.buffers = buffers
-        self.digest = self.generate_digest()
-
-        # handy for debugs
-        self.hexbuf = [" ".join([f"{v:02x}" for v in buf]) for buf in buffers]
-
-        # check for known ne'er-do-well
-        bad = r"c2 47 05 31 21 00 00 04 00 03 00 00 02 31 a5 00 03 00 33 02 39 0f 00 03 00 43 02 2f 00 00 03 00 " \
-            + r"4b 02 2b 23 00 03 00 53 02 2f 00 03 ff 01 00 90 e6 78 e0 54 10 ff c4 54 0f 44 50 f5 09 13 e4"
-        for i, s in enumerate(self.hexbuf):
-            if bad in s:
-                log.error(f"bad string found in EEPROM page {i}")
-
-        # unpack all the fields we know about
-        try:
-            self.read_eeprom()
-            return True
-        except:
-            log.error("failed to parse EEPROM", exc_info=1)
-            return False
-
-    ## 
-    # Assuming a set of 8 buffers have been passed in via parse(), actually
-    # unpack (deserialize / unmarshall) the binary data into the appropriate
-    # fields and datatypes.
-    # 
-    # @see https://docs.python.org/2/library/struct.html#format-characters
-    # (capitals are unsigned)
-    def read_eeprom(self):
-        self.format = self.unpack((0, 63,  1), "B", "format")
-        log.debug("parsing EEPROM format %d", self.format)
-
-        # ######################################################################
-        # Page 0
-        # ######################################################################
-
-        self.model                           = self.unpack((0,  0, 16), "s", "model")
-        self.serial_number                   = self.unpack((0, 16, 16), "s", "serial")
-        self.baud_rate                       = self.unpack((0, 32,  4), "I", "baud")
-        self.has_cooling                     = self.unpack((0, 36,  1), "?", "cooling")
-        self.has_battery                     = self.unpack((0, 37,  1), "?", "battery")
-        self.has_laser                       = self.unpack((0, 38,  1), "?", "laser")
-        if self.format > 9:
-            self.feature_mask                = self.unpack((0, 39,  2), "H", "feature_mask")
-        elif self.format >= 3:
-            self.excitation_nm               = self.unpack((0, 39,  2), "H", "excitation_nm (unsigned)")
-        else:
-            self.excitation_nm               = self.unpack((0, 39,  2), "h", "excitation_nm (signed)")
-
-        if self.format >= 4:
-            self.slit_size_um                = self.unpack((0, 41,  2), "H", "slit (unsigned)")
-        else:
-            self.slit_size_um                = self.unpack((0, 41,  2), "h", "slit (signed)")
-
-        # NOTE: the new InGaAs detector gain/offset won't be usable from 
-        #       EEPROM until we start bumping production spectrometers to
-        #       EEPROM Page 0 Revision 3!
-        if self.format >= 3:
-            self.startup_integration_time_ms = self.unpack((0, 43,  2), "H", "start_integ")
-            self.startup_temp_degC           = self.unpack((0, 45,  2), "h", "start_temp")
-            self.startup_triggering_scheme   = self.unpack((0, 47,  1), "B", "start_trigger")
-            self.detector_gain               = self.unpack((0, 48,  4), "f", "gain") # "even pixels" for InGaAs
-            self.detector_offset             = self.unpack((0, 52,  2), "h", "offset") # "even pixels" for InGaAs
-            self.detector_gain_odd           = self.unpack((0, 54,  4), "f", "gain_odd") # InGaAs-only
-            self.detector_offset_odd         = self.unpack((0, 58,  2), "h", "offset_odd") # InGaAs-only
-
-        # ######################################################################
-        # Page 1
-        # ######################################################################
-
-        self.wavelength_coeffs = []
-        self.wavelength_coeffs         .append(self.unpack((1,  0,  4), "f", "wavecal_coeff_0"))
-        self.wavelength_coeffs         .append(self.unpack((1,  4,  4), "f"))
-        self.wavelength_coeffs         .append(self.unpack((1,  8,  4), "f"))
-        self.wavelength_coeffs         .append(self.unpack((1, 12,  4), "f"))
-        self.degC_to_dac_coeffs = []
-        self.degC_to_dac_coeffs        .append(self.unpack((1, 16,  4), "f", "degCtoDAC_coeff_0"))
-        self.degC_to_dac_coeffs        .append(self.unpack((1, 20,  4), "f"))
-        self.degC_to_dac_coeffs        .append(self.unpack((1, 24,  4), "f"))
-        self.max_temp_degC                   = self.unpack((1, 28,  2), "h", "max_temp")
-        self.min_temp_degC                   = self.unpack((1, 30,  2), "h", "min_temp")
-        self.adc_to_degC_coeffs = []
-        self.adc_to_degC_coeffs        .append(self.unpack((1, 32,  4), "f", "adcToDegC_coeff_0"))
-        self.adc_to_degC_coeffs        .append(self.unpack((1, 36,  4), "f"))
-        self.adc_to_degC_coeffs        .append(self.unpack((1, 40,  4), "f"))
-        self.tec_r298                        = self.unpack((1, 44,  2), "h", "r298")
-        self.tec_beta                        = self.unpack((1, 46,  2), "h", "beta")
-        self.calibration_date                = self.unpack((1, 48, 12), "s", "date")
-        self.calibrated_by                   = self.unpack((1, 60,  3), "s", "tech")
-                                    
-        # ######################################################################
-        # Page 2                    
-        # ######################################################################
-
-        self.detector                        = self.unpack((2,  0, 16), "s", "detector")
-        self.active_pixels_horizontal        = self.unpack((2, 16,  2), "H", "pixels")
-        if self.format >= 10:
-            self.laser_warmup_sec            = self.unpack((2, 18,  1), "B", "laser_warmup_sec")
-        self.active_pixels_vertical          = self.unpack((2, 19,  2), "H" if self.format >= 4 else "h")
-
-        if self.format >= 8:
-            self.wavelength_coeffs     .append(self.unpack((2, 21,  4), "f", "wavecal_coeff_4"))
-        else:
-            # just go ahead and initialize the 5th coeff to zero
-            self.wavelength_coeffs.append(0)
-            if self.format < 5:
-                self.min_integration_time_ms     = self.unpack((2, 21,  2), "H", "min_integ(ushort)")
-                self.max_integration_time_ms     = self.unpack((2, 23,  2), "H", "max_integ(ushort)") 
-
-        self.actual_horizontal               = self.unpack((2, 25,  2), "H" if self.format >= 4 else "h", "actual_horiz")
-        self.actual_vertical                 = self.active_pixels_vertical  # approximate for now
-        self.roi_horizontal_start            = self.unpack((2, 27,  2), "H" if self.format >= 4 else "h")
-        self.roi_horizontal_end              = self.unpack((2, 29,  2), "H" if self.format >= 4 else "h")
-        self.roi_vertical_region_1_start     = self.unpack((2, 31,  2), "H" if self.format >= 4 else "h")
-        self.roi_vertical_region_1_end       = self.unpack((2, 33,  2), "H" if self.format >= 4 else "h")
-        self.roi_vertical_region_2_start     = self.unpack((2, 35,  2), "H" if self.format >= 4 else "h")
-        self.roi_vertical_region_2_end       = self.unpack((2, 37,  2), "H" if self.format >= 4 else "h")
-        self.roi_vertical_region_3_start     = self.unpack((2, 39,  2), "H" if self.format >= 4 else "h")
-        self.roi_vertical_region_3_end       = self.unpack((2, 41,  2), "H" if self.format >= 4 else "h")
-        self.linearity_coeffs = []
-        self.linearity_coeffs          .append(self.unpack((2, 43,  4), "f", "linearity_coeff_0")) # overloading for secondary ADC
-        self.linearity_coeffs          .append(self.unpack((2, 47,  4), "f"))
-        self.linearity_coeffs          .append(self.unpack((2, 51,  4), "f"))
-        self.linearity_coeffs          .append(self.unpack((2, 55,  4), "f"))
-        self.linearity_coeffs          .append(self.unpack((2, 59,  4), "f"))
-
-        # ######################################################################
-        # Page 3
-        # ######################################################################
-        
-        self.laser_power_coeffs = []
-        self.laser_power_coeffs        .append(self.unpack((3, 12,  4), "f", "laser_power_coeff_0"))
-        self.laser_power_coeffs        .append(self.unpack((3, 16,  4), "f"))
-        self.laser_power_coeffs        .append(self.unpack((3, 20,  4), "f"))
-        self.laser_power_coeffs        .append(self.unpack((3, 24,  4), "f"))
-        self.max_laser_power_mW              = self.unpack((3, 28,  4), "f", "max_laser_mW")
-        self.min_laser_power_mW              = self.unpack((3, 32,  4), "f", "min_laser_mW")
-
-        if self.format >= 4:
-            self.excitation_nm_float         = self.unpack((3, 36,  4), "f", "excitation(float)")
-        else:
-            self.excitation_nm_float = self.excitation_nm
-
-        if self.format >= 5:
-            self.min_integration_time_ms     = self.unpack((3, 40,  4), "I", "min_integ(uint)")
-            self.max_integration_time_ms     = self.unpack((3, 44,  4), "I", "max_integ(uint)") 
-
-        if self.format >= 7:
-            self.avg_resolution              = self.unpack((3, 48,  4), "f", "avg_resolution")
-
-        if self.format >= 15:
-            self.laser_watchdog_sec          = self.unpack((3, 52,  2), "H", "laser_watchdog_sec")
-            self.light_source_type           = self.unpack((3, 54,  1), "B", "light_source_type")
-
-        # ######################################################################
-        # Page 4
-        # ######################################################################
-
-        self.user_data = self.buffers[4][:63]
-        self.user_text = self.printable(self.user_data)
-
-        # ######################################################################
-        # Page 5
-        # ######################################################################
-
-        bad = set()
-        for count in range(15):
-            pixel = self.unpack((5, count * 2, 2), "h")
-            if pixel != -1:
-                bad.add(pixel)
-        self.bad_pixels = list(bad)
-        self.bad_pixels.sort()
-
-        if self.format >= 5:
-            self.product_configuration       = self.unpack((5,  30, 16), "s", "product_config")
-        if self.format >= 7:
-            self.subformat                   = self.unpack((5,  63,  1), "B", "subformat")
-
-        # ######################################################################
-        # Page 6-7
-        # ######################################################################
-
-        if self.subformat == 0:
-            pass
-        elif self.subformat == 1:
-            self.read_raman_intensity_calibration()
-        elif self.subformat == 2:
-            self.read_spline()
-        elif self.subformat == 3:
-            self.read_untethered()
-        elif self.subformat == 4:
-            self.read_regions()
-        else:
-            log.debug(f"Unreadable EEPROM subformat {self.subformat}")
-        
-        # ######################################################################
-        # feature mask
-        # ######################################################################
-
-        if self.format >= 9:
-            self.invert_x_axis           = 0 != self.feature_mask & 0x0001
-            self.bin_2x2                 = 0 != self.feature_mask & 0x0002
-            self.gen15                   = 0 != self.feature_mask & 0x0004
-            self.cutoff_filter_installed = 0 != self.feature_mask & 0x0008
-            self.hardware_even_odd       = 0 != self.feature_mask & 0x0010
-            self.sig_laser_tec           = 0 != self.feature_mask & 0x0020
-            self.has_interlock_feedback  = 0 != self.feature_mask & 0x0040
-            self.has_shutter             = 0 != self.feature_mask & 0x0080
-        else:
-            self.invert_x_axis           = 0 
-            self.bin_2x2                 = 0
-            self.gen15                   = 0
-            self.cutoff_filter_installed = 0
-            self.hardware_even_odd       = 0
-            self.sig_laser_tec           = 0
-            self.has_interlock_feedback  = 0
-            self.has_shutter             = 0
-
-        # ######################################################################
-        # sanity checks
-        # ######################################################################
-
-        utils.clean_nan(self.wavelength_coeffs)
-
-        if self.min_integration_time_ms == 0xffff:
-            self.min_integration_time_ms = 1 
-            self.max_integration_time_ms = 60000
-
-        if self.min_integration_time_ms > self.max_integration_time_ms:
-            (self.min_integration_time_ms, self.max_integration_time_ms) = \
-            (self.max_integration_time_ms, self.min_integration_time_ms)
-
-        if self.startup_integration_time_ms < self.min_integration_time_ms:
-            self.startup_integration_time_ms = self.min_integration_time_ms
-
-        if self.min_temp_degC > self.max_temp_degC:
-            (self.min_temp_degC, self.max_temp_degC) = \
-            (self.max_temp_degC, self.min_temp_degC) 
-
-        if self.min_laser_power_mW > self.max_laser_power_mW:
-            (self.min_laser_power_mW, self.max_laser_power_mW) = \
-            (self.max_laser_power_mW, self.min_laser_power_mW)
-
-    ############################################################################
-    #                                                                          #
-    #                               Write EEPROM                               #
-    #                                                                          #
-    ############################################################################
-
-    def generate_feature_mask(self):
-        mask = 0
-        mask |= 0x0001 if self.invert_x_axis           else 0
-        mask |= 0x0002 if self.bin_2x2                 else 0
-        mask |= 0x0004 if self.gen15                   else 0
-        mask |= 0x0008 if self.cutoff_filter_installed else 0
-        mask |= 0x0010 if self.hardware_even_odd       else 0
-        mask |= 0x0020 if self.sig_laser_tec           else 0
-        mask |= 0x0040 if self.has_interlock_feedback  else 0
-        mask |= 0x0080 if self.has_shutter             else 0
-        return mask
-
-    ##
-    # Call this to populate an internal array of "write buffers" which may be written back
-    # to spectrometers (or used to generate the digest of what WOULD be written).
-    def generate_write_buffers(self):
-        # stub-out 8 blank buffers
-        self.write_buffers = []
-        for page in range(EEPROM.MAX_PAGES):
-            self.write_buffers.append(array.array('B', [0] * 64))
-
-        # Eventually we'll stop worrying about the legacy per-page format versions, but
-        # for now maximize compatibility with StrokerConsole/ModelConfigurationFormat.cs
-        # by making its expected format values the default for each page:
-        revs = { 0: 1,
-                 1: 1,
-                 2: 2, 
-                 3: 255,
-                 4: 1, 
-                 5: 1,
-                 6: 0 }
-        for page in list(revs.keys()):
-            self.write_buffers[page][63] = revs[page]
-
-        # ...but the truth is that we don't really care about the old per-page formats,
-        # and all modern code should just be looking at this one byte:
-        self.write_buffers[0][63] = EEPROM.LATEST_REV
-
-        # ######################################################################
-        # Page 0
-        # ######################################################################
-
-        self.pack((0,  0, 16), "s", self.model)
-        self.pack((0, 16, 16), "s", self.serial_number)
-        self.pack((0, 32,  4), "I", self.baud_rate)
-        self.pack((0, 36,  1), "?", self.has_cooling)
-        self.pack((0, 37,  1), "?", self.has_battery)
-        self.pack((0, 38,  1), "?", self.has_laser)
-        self.pack((0, 39,  2), "H", self.generate_feature_mask(), "FeatureMask")
-        self.pack((0, 41,  2), "H", self.slit_size_um)
-        self.pack((0, 43,  2), "H", self.startup_integration_time_ms)
-        self.pack((0, 45,  2), "h", self.startup_temp_degC)
-        self.pack((0, 47,  1), "B", self.startup_triggering_scheme)
-        self.pack((0, 48,  4), "f", self.detector_gain)
-        self.pack((0, 52,  2), "h", self.detector_offset)
-        self.pack((0, 54,  4), "f", self.detector_gain_odd)
-        self.pack((0, 58,  2), "h", self.detector_offset_odd)
-
-        # ######################################################################
-        # Page 1
-        # ######################################################################
-
-        if self.wavelength_coeffs is not None:
-            for i in range(min(4, len(self.wavelength_coeffs))):
-                self.pack((1,  0 + i * 4,  4), "f", self.wavelength_coeffs[i])
-                
-        if self.degC_to_dac_coeffs is not None:
-            for i in range(min(3, len(self.degC_to_dac_coeffs))):
-                self.pack((1, 16 + i * 4,  4), "f", self.degC_to_dac_coeffs[i])
-
-        if self.adc_to_degC_coeffs is not None:
-            for i in range(min(3, len(self.adc_to_degC_coeffs))):
-                self.pack((1, 32 + i * 4,  4), "f", self.adc_to_degC_coeffs[i])
-
-        self.pack((1, 28,  2), "h", self.max_temp_degC)
-        self.pack((1, 30,  2), "h", self.min_temp_degC)
-        self.pack((1, 44,  2), "h", self.tec_r298)
-        self.pack((1, 46,  2), "h", self.tec_beta)
-        self.pack((1, 48, 12), "s", self.calibration_date)
-        self.pack((1, 60,  3), "s", self.calibrated_by)
-                                    
-        # ######################################################################
-        # Page 2                    
-        # ######################################################################
-
-        self.pack((2,  0, 16), "s", self.detector)
-        self.pack((2, 16,  2), "H", self.active_pixels_horizontal)
-        self.pack((2, 18,  1), "B", self.laser_warmup_sec)
-        self.pack((2, 19,  2), "H", self.active_pixels_vertical)
-        if self.format < 7:
-            self.pack((2, 21,  2), "H", max(0xffff, self.min_integration_time_ms))
-            self.pack((2, 23,  2), "H", max(0xffff, self.max_integration_time_ms))
-        else:
-            coeff = 0.0
-            if len(self.wavelength_coeffs) > 4:
-                coeff = self.wavelength_coeffs[4]
-            self.pack((2, 21,  4), "f", coeff)
-        self.pack((2, 25,  2), "H", self.actual_horizontal)
-        self.pack((2, 27,  2), "H", self.roi_horizontal_start)
-        self.pack((2, 29,  2), "H", self.roi_horizontal_end)
-        self.pack((2, 31,  2), "H", self.roi_vertical_region_1_start)
-        self.pack((2, 33,  2), "H", self.roi_vertical_region_1_end)
-        self.pack((2, 35,  2), "H", self.roi_vertical_region_2_start)
-        self.pack((2, 37,  2), "H", self.roi_vertical_region_2_end)
-        self.pack((2, 39,  2), "H", self.roi_vertical_region_3_start)
-        self.pack((2, 41,  2), "H", self.roi_vertical_region_3_end)
-
-        if self.linearity_coeffs is not None:
-            for i in range(min(5, len(self.linearity_coeffs))):
-                self.pack((2, 43 + i * 4,  4), "f", self.linearity_coeffs[i])
-
-        # ######################################################################
-        # Page 3
-        # ######################################################################
-
-        if self.laser_power_coeffs is not None:
-            for i in range(min(4, len(self.laser_power_coeffs))):
-                self.pack((3, 12 + i * 4,  4), "f", self.laser_power_coeffs[i])
-
-        self.pack((3, 28,  4), "f", self.max_laser_power_mW)
-        self.pack((3, 32,  4), "f", self.min_laser_power_mW)
-        self.pack((3, 36,  4), "f", self.excitation_nm_float)
-        self.pack((3, 40,  4), "I", self.min_integration_time_ms)
-        self.pack((3, 44,  4), "I", self.max_integration_time_ms)
-        self.pack((3, 48,  4), "f", self.avg_resolution)
-        self.pack((3, 52,  2), "H", self.laser_watchdog_sec)
-        self.pack((3, 54,  1), "B", self.light_source_type)
-
-        # ######################################################################
-        # Page 4
-        # ######################################################################
-
-        self.pack((4,  0, 63), "s", self.user_text)
-
-        # ######################################################################
-        # Page 5
-        # ######################################################################
-
-        bad_pixel_set = set()
-        for i in self.bad_pixels:
-            if i >= 0:
-                bad_pixel_set.add(i)
-        bad_pixels = list(bad_pixel_set)
-        bad_pixels.sort()
-        for i in range(15):
-            if i < len(bad_pixels):
-                value = bad_pixels[i]
-            else:
-                value = -1
-            self.pack((5, i * 2, 2), "h", value)
-
-        self.pack((5, 30, 16), "s", self.product_configuration)
-        self.pack((5, 63,  1), "B", self.subformat)
-
-        # ######################################################################
-        # Page 6-7
-        # ######################################################################
-
-        if self.subformat == 0:
-            pass
-        elif self.subformat == 1:
-            self.write_raman_intensity_calibration()
-        elif self.subformat == 2:
-            self.write_spline()
-        elif self.subformat == 3:
-            self.write_untethered()
-        elif self.subformat == 4:
-            self.write_regions()
-        else:
-            log.error(f"Unwriteable EEPROM subformat {self.subformat}")
-
-    # ##########################################################################
-    #                                                                          #
-    #                             Utility methods                              #
-    #                                                                          #
-    # ##########################################################################
-
-    ## make a printable ASCII string out of possibly-binary data
-    def printable(self, buf):
-        s = ""
-        for c in buf:
-            if 31 < c < 127:
-                s += chr(c)
-            elif c == 0:
-                break
-            else:
-                s += '.'
-        return s
-
-    def set(self, name, value):
-        setattr(self, name, value)
-
-    ##
-    # Convert a floating-point value into the big-endian 16-bit "funky float" 
-    # used for detector gain in the FPGA on both Hamamatsu and IMX sensors.
-    #
-    # Note that this TRUNCATES (takes the floor) the fractional portion rather 
-    # than rounding, which I believe matches WasatchNET.FunkyFloat.fromFloat().
-    #
-    # Conversely, it DOES provide minor rounding on the INTEGRAL portion, to 
-    # avoid this problem:
-    #
-    # \verbatim
-    # dB = 0
-    # while dB < 2.1:
-    #     self.set_detector_gain(dB) # old code treats 1.0 as 0.0 because actually sends 0.99999999
-    #     dB += 0.1
-    # \endverbatim
-    #
-    # @see https://wasatchphotonics.com/api/Wasatch.NET/class_wasatch_n_e_t_1_1_funky_float.html
-    def float_to_uint16(self, gain):
-        msb = int(round(gain, 5)) & 0xff
-        # if self.format >= 13: lsb = round((gain - msb) * 256) & 0xff
-        lsb = int((gain - msb) * 256) & 0xff
-        raw = (msb << 8) | lsb
-        log.debug("float_to_uint16: %f -> 0x%04x", gain, raw)
-        return raw
-
-    ## 
-    # Unpack a single field at a given buffer offset of the given datatype.
-    #
-    # @param address    a tuple of the form (buf, offset, len)
-    # @param data_type  see https://docs.python.org/2/library/struct.html#format-characters
-    # @param label      if provided, is included in debug log output
-    def unpack(self, address, data_type, label=None):
-        page       = address[0]
-        start_byte = address[1]
-        length     = address[2]
-        end_byte   = start_byte + length
-
-        if page > len(self.buffers):
-            log.error("error unpacking EEPROM page %d, offset %d, len %d as %s: invalid page (label %s)", 
-                page, start_byte, length, data_type, label, exc_info=1)
-            return
-
-        buf = self.buffers[page]
-        if buf is None or end_byte > len(buf):
-            log.error("error unpacking EEPROM page %d, offset %d, len %d as %s: buf is %s (label %s)", 
-                page, start_byte, length, data_type, buf, label, exc_info=1)
-            return
-
-        if data_type == "s":
-            # This stops at the first NULL, so is not appropriate for binary data (user_data).
-            # OTOH, it doesn't currently enforce "printable" characters either (nor support Unicode).
-            unpack_result = ""
-            for c in buf[start_byte:end_byte]:
-                if c == 0:
-                    break
-                unpack_result += chr(c)
-        else:
-            unpack_result = 0
-            try:
-                unpack_result = struct.unpack(data_type, buf[start_byte:end_byte])[0]
-            except:
-                log.error("error unpacking EEPROM page %d, offset %d, len %d as %s", page, start_byte, length, data_type, exc_info=1)
-
-        if label is None:
-            log.debug("Unpacked [%s]: %s", data_type, unpack_result)
-        else:
-            log.debug("Unpacked [%s]: %s (%s)", data_type, unpack_result, label)
-        return unpack_result
-
-    ## 
-    # Marshall or serialize a single field at a given buffer offset of the given datatype.
-    #
-    # @param address    a tuple of the form (buf, offset, len)
-    # @param data_type  see https://docs.python.org/2/library/struct.html#format-characters
-    # @param value      value to serialize
-    def pack(self, address, data_type, value, label=None):
-        page       = address[0]
-        start_byte = address[1]
-        length     = address[2]
-        end_byte   = start_byte + length
-
-        if page > len(self.write_buffers):
-            log.error("error unpacking EEPROM page %d, offset %d, len %d as %s: invalid page (label %s)", 
-                page, start_byte, length, data_type, label, exc_info=1)
-            return
-
-        # don't try to write negatives to unsigned types
-        if data_type in ["H", "I"] and value < 0:
-            log.error("rounding negative to zero when writing to unsigned field (address %s, data_type %s, value %s)", address, data_type, value)
-            value = 0
-
-        buf = self.write_buffers[page]
-        if buf is None or end_byte > 64:
-            raise Exception("error packing EEPROM page %d, offset %2d, len %2d as %s: buf is %s" % (
-                page, start_byte, length, data_type, buf))
-
-        if data_type == "s":
-            if value is None:
-                value = ""
-            for i in range(min(length, len(value))):
-                if i < len(value):
-                    buf[start_byte + i] = ord(value[i])
-                else:
-                    buf[start_byte + i] = 0
-        else:
-            struct.pack_into(data_type, buf, start_byte, value)
-
-        extra = "" if label is None else (" (%s)" % label)
-        # log.debug("Packed (%d, %2d, %2d) '%s' value %s -> %s%s", 
-        #     page, start_byte, length, data_type, value, buf[start_byte:end_byte], extra)
-
-    ##
-    # If asked to regenerate, return a digest of the contents that WOULD BE 
-    # WRITTEN from current settings in memory.
-    def generate_digest(self, regenerate=False):
-        buffers = self.buffers
-        if regenerate:
-            self.generate_write_buffers()
-            buffers = self.write_buffers
-
-        h = hashlib.new("md5")
-        for buf in buffers:
-            h.update(bytes(buf))
-        digest = h.hexdigest()
-
-        log.debug("EEPROM MD5 digest = %s (regenerate = %s)", digest, regenerate)
-        return digest
-
-    def to_dict(self):
-        d = {}
-        for k, v in self.__dict__.items():
-            if k not in ["user_data", "buffers", "write_buffers", "editable"]:
-                d[k] = v
-        return d
-
-    ## render the attributes of this object as a JSON string
-    #
-    # @note some callers may prefer SpectrometerSettings.to_dict() or to_json()
-    def json(self, allow_nan=True):
-        tmp_buf  = self.buffers
-        tmp_data = self.user_data
-
-        self.buffers   = str(self.buffers)
-        self.user_data = str(self.user_data)
-
-        # this does take an allow_nan argument, but it throws an exception on NaN, 
-        # rather than replacing with null :-(
-        # https://stackoverflow.com/questions/6601812/sending-nan-in-json
-        s = json.dumps(self.__dict__, indent=2, sort_keys=True)
-        if not allow_nan:
-            s = re.sub(r"\bNaN\b", "null", s)
-
-        self.buffers   = tmp_buf
-        self.user_data = tmp_data
-
-        return s
-
-    ## log this object
-    def dump(self):
-        log.debug("EEPROM settings:")
-        log.debug("  Model:            %s", self.model)
-        log.debug("  Serial Number:    %s", self.serial_number)
-        log.debug("  Baud Rate:        %d", self.baud_rate)
-        log.debug("  Has Cooling:      %s", self.has_cooling)
-        log.debug("  Has Battery:      %s", self.has_battery)
-        log.debug("  Has Laser:        %s", self.has_laser)
-        log.debug("  Invert X-Axis:    %s", self.invert_x_axis)
-        log.debug("  Bin 2x2:          %s", self.bin_2x2)
-        log.debug("  Gen 1.5:          %s", self.gen15)
-        log.debug("  Cutoff Filter:    %s", self.cutoff_filter_installed)
-        log.debug("  HW Even/Odd:      %s", self.hardware_even_odd)
-        log.debug("  SiG Laser TEC:    %s", self.sig_laser_tec)
-        log.debug("  Int'Lck Feedback: %s", self.has_interlock_feedback)
-        log.debug("  Shutter:          %s", self.has_shutter)
-        log.debug("  Excitation:       %s nm", self.excitation_nm)
-        log.debug("  Excitation (f):   %.2f nm", self.excitation_nm_float)
-        log.debug("  Laser Warmup Sec: %d", self.laser_warmup_sec)
-        log.debug("  Laser Watchdog:   %d", self.laser_watchdog_sec)
-        log.debug("  Light Source:     %d", self.light_source_type)
-        log.debug("  Slit size:        %s um", self.slit_size_um)
-        log.debug("  Start Integ Time: %d ms", self.startup_integration_time_ms)
-        log.debug("  Start Temp:       %.2f degC", self.startup_temp_degC)
-        log.debug("  Start Triggering: 0x%04x", self.startup_triggering_scheme)
-        log.debug("  Det Gain:         %f", self.detector_gain)
-        log.debug("  Det Offset:       %d", self.detector_offset)
-        log.debug("  Det Gain Odd:     %f", self.detector_gain_odd)
-        log.debug("  Det Offset Odd:   %d", self.detector_offset_odd)
-        log.debug("")
-        log.debug("  Wavecal coeffs:   %s", self.wavelength_coeffs)
-        log.debug("  degCToDAC coeffs: %s", self.degC_to_dac_coeffs)
-        log.debug("  adcToDegC coeffs: %s", self.adc_to_degC_coeffs)
-        log.debug("  Det temp max:     %s degC", self.max_temp_degC)
-        log.debug("  Det temp min:     %s degC", self.min_temp_degC)
-        log.debug("  TEC R298:         %s", self.tec_r298)
-        log.debug("  TEC beta:         %s", self.tec_beta)
-        log.debug("  Calibration Date: %s", self.calibration_date)
-        log.debug("  Calibration By:   %s", self.calibrated_by)
-        log.debug("")
-        log.debug("  Detector name:    %s", self.detector)
-        log.debug("  Active horiz:     %d", self.active_pixels_horizontal)
-        log.debug("  Active vertical:  %d", self.active_pixels_vertical)
-        log.debug("  Min integration:  %d ms", self.min_integration_time_ms)
-        log.debug("  Max integration:  %d ms", self.max_integration_time_ms)
-        log.debug("  Actual Horiz:     %d", self.actual_horizontal)
-        log.debug("  ROI Horiz Start:  %d", self.roi_horizontal_start)
-        log.debug("  ROI Horiz End:    %d", self.roi_horizontal_end)
-        log.debug("  ROI Vert Reg 1:   (%d, %d)", self.roi_vertical_region_1_start, self.roi_vertical_region_1_end)
-        log.debug("  ROI Vert Reg 2:   (%d, %d)", self.roi_vertical_region_2_start, self.roi_vertical_region_2_end)
-        log.debug("  ROI Vert Reg 3:   (%d, %d)", self.roi_vertical_region_3_start, self.roi_vertical_region_3_end)
-        log.debug("  Linearity Coeffs: %s", self.linearity_coeffs)
-        log.debug("")
-        log.debug("  Laser coeffs:     %s", self.laser_power_coeffs)
-        log.debug("  Max Laser Power:  %s mW", self.max_laser_power_mW)
-        log.debug("  Min Laser Power:  %s mW", self.min_laser_power_mW)
-        log.debug("  Avg Resolution:   %.2f", self.avg_resolution)
-        log.debug("")
-        log.debug("  User Text:        %s", self.user_text)
-        log.debug("")
-        log.debug("  Bad Pixels:       %s", self.bad_pixels)
-        log.debug("  Product Config:   %s", self.product_configuration)
-
-        if self.subformat == 1:
-            self.dump_raman_intensity_calibration()
-        elif self.subformat == 2:
-            self.dump_spline()
-        elif self.subformat == 3:
-            self.dump_raman_intensity_calibration()
-            self.dump_untethered()
-        elif self.subformat == 4:
-            self.dump_regions()
-
-    # ##########################################################################
-    #                                                                          #
-    #                              Convenience accessors                       #
-    #                                                                          #
-    # ##########################################################################
-
-    def latest_rev(self):
-        return EEPROM.LATEST_REV
-
-    ## pixel frame (end is last index, not last+1),
-    def get_horizontal_roi(self):
-        start  = self.roi_horizontal_start
-        end    = self.roi_horizontal_end
-        pixels = self.active_pixels_horizontal
-
-        if 0 <= start and start < end and end < pixels:
-            return ROI(start, end)
-
-    ## 
-    # On a 1024-pixel detector, note the expected / correct result based on the 
-    # roi_horizontal_start/stop fields:
-    #
-    # - (0, 1024) FALSE (last pixel invalid)
-    # - (0, 1023) TRUE  (even though no vignetting is occuring)
-    # - (0, 1022) TRUE  (crops last pixel)
-    # - (1, 1023) TRUE  (crops first pixel)
-    # - (1, 1024) FALSE (last pixel invalid)
-    # - (1,    1) FALSE (start must < end)
-    # - (1,    2) TRUE  (valid 2-pixel spectrum)
-    # - (2,    1) FALSE (start must < end)
-    #   
-    # @return whether a valid horizontal ROI is configured
-    def has_horizontal_roi(self): # -> bool 
-        return self.get_horizontal_roi() is not None
-
-    def has_laser_power_calibration(self): # -> bool 
-        if self.max_laser_power_mW <= 0:
-            return False
-        return utils.coeffs_look_valid(self.laser_power_coeffs, count=4)
-
-    def has_detector_tec_calibration(self): # -> bool 
-        """ simplified version of WasatchNET.Util.validTECCal """
-
-        if not utils.coeffs_look_valid(self.degC_to_dac_coeffs, count=3):
-            return False
-
-        # check it's not the "default"
-        if self.degC_to_dac_coeffs[0] == 2700 and \
-           self.degC_to_dac_coeffs[1] == 0 and \
-           self.degC_to_dac_coeffs[2] == 0:
-            return False
-
-        return True
-
-    def has_raman_intensity_calibration(self): # -> bool 
-        if self.format < 6:
-            log.debug(f"has_raman_intensity_calibration: false because format {self.format}")
-            return False
-
-        if not (0 < self.raman_intensity_calibration_order <= EEPROM.MAX_RAMAN_INTENSITY_CALIBRATION_ORDER):
-            log.debug(f"has_raman_intensity_calibration: false because invalid order {self.raman_intensity_calibration_order}")
-            return False
-            
-        if not utils.coeffs_look_valid(self.raman_intensity_coeffs, count = self.raman_intensity_calibration_order + 1):
-            log.debug(f"has_raman_intensity_calibration: false because coeffs look weird")
-            return False
-
-        return True
-
-    ## convert the given laser output power from milliwatts to percentage
-    #  using the configured calibration
-    def laser_power_mW_to_percent(self, mW):
-        if not self.has_laser_power_calibration():
-            return 0
-
-        perc = self.laser_power_coeffs[0] \
-             + self.laser_power_coeffs[1] * mW \
-             + self.laser_power_coeffs[2] * mW * mW \
-             + self.laser_power_coeffs[3] * mW * mW * mW
-
-        return perc
-
-    # ##########################################################################
-    #                                                                          #
-    #                                 Subformats                               #
-    #                                                                          #
-    # ##########################################################################
-
-    # ##########################################################################
-    # Subformat: Raman Intensity Calibration
-    # ##########################################################################
-
-    def init_raman_intensity_calibration(self):
-        self.raman_intensity_calibration_order = 0
-        self.raman_intensity_coeffs      = []
-
-    def read_raman_intensity_calibration(self):
-        self.raman_intensity_coeffs = []
-        self.raman_intensity_calibration_order = self.unpack((6, 0, 1), "B", "raman_intensity_calibration_order")
-        if 0 == self.raman_intensity_calibration_order:
-            pass
-        elif self.raman_intensity_calibration_order <= EEPROM.MAX_RAMAN_INTENSITY_CALIBRATION_ORDER:
-            order = self.raman_intensity_calibration_order
-            terms = order + 1
-            for i in range(terms):
-                offset = i * 4 + 1
-                self.raman_intensity_coeffs.append(self.unpack((6, offset, 4), "f", "raman_intensity_coeff_%d" % i))
-        else:
-            log.error("Unsupported Raman Intensity Calibration order: %d", self.raman_intensity_calibration_order)
-
-    def write_raman_intensity_calibration(self):
-        self.pack((6, 0,  1), "B", self.raman_intensity_calibration_order)
-        if 0 <= self.raman_intensity_calibration_order <= EEPROM.MAX_RAMAN_INTENSITY_CALIBRATION_ORDER:
-            order = self.raman_intensity_calibration_order
-            terms = order + 1
-            for i in range(EEPROM.MAX_RAMAN_INTENSITY_CALIBRATION_ORDER + 1):
-                offset = i * 4 + 1
-                if i < terms and self.raman_intensity_coeffs is not None and i < len(self.raman_intensity_coeffs):
-                    coeff = self.raman_intensity_coeffs[i]
-                else:
-                    coeff = 0.0
-                # log.debug("packing raman_intensity_coeffs[%d] (offset %d, order %d, terms %d) => %e", i, offset, order, terms, coeff)
-                self.pack((6, offset, 4), "f", coeff)
-        else:
-            log.error("Unsupported Raman Intensity Calibration order: %d", self.raman_intensity_calibration_order)
-            for i in range(EEPROM.MAX_RAMAN_INTENSITY_CALIBRATION_ORDER + 1):
-                offset = i * 4 + 1
-                self.pack((6, offset, 4), "f", 0.0)
-
-    def dump_raman_intensity_calibration(self):
-        log.debug("Raman Intensity Calibration:")
-        log.debug("  Raman Int Order:  %d", self.raman_intensity_calibration_order)
-        log.debug("  Raman Int Coeffs: %s", self.raman_intensity_coeffs)
-
-    # ##########################################################################
-    # Subformat: Spline
-    # ##########################################################################
-
-    def init_spline(self):
-        self.spline_points               = 0
-        self.spline_min                  = 0
-        self.spline_max                  = 0
-        self.spline_wavelengths          = []
-        self.spline_y                    = []
-        self.spline_y2                   = []
-
-    ##
-    # @todo turn into EEPROMSpline
-    def read_spline(self):
-        self.spline_wavelengths = []
-        self.spline_y = []
-        self.splint_y2 = []
-
-        self.spline_points = self.unpack((6, 0, 1), "B", "spline.points")
-        if self.spline_points <= 0:
-            log.debug("empty spline")
-            return
-
-        if self.spline_points > 14:
-            log.error("invalid spline (%d points)", self.spline_points)
-            return
-
-        for i in len(range(self.spline_points)):
-            if i < 5:
-                page = 6
-                base = 4
-                first = 0
-            elif i < 10:
-                page = 7
-                base = 0
-                first = 5
-            else:
-                page = 4
-                base = 0
-                first = 10
-
-            offset = base + (i - first) * 12
-            wavelength = self.unpack((page, offset, 4), "f", "spline.wavelength[%d]" % i)
-            y  = self.unpack((page, offset + 4, 4), "f", "spline.y[%d]" % i)
-            y2 = self.unpack((page, offset + 8, 4), "f", "spline.y2[%d]" % i)
-
-            self.spline_wavelengths.append(wavelength)
-            self.spline_y.append(y)
-            self.spline_y2.append(y2)
-        
-        self.spline_min = self.unpack((4, 56, 4), "f", "spline_wavelength_min")
-        self.spline_max = self.unpack((4, 60, 4), "f", "spline_wavelength_max")
-        if lo >= hi:
-            log.error("invalid spline (min %f, max %f)", self.spline_min, self.spline_max)
-            return
-
-    def write_spline(self):
-        log.error("EEPROM.write_spline not implemented")
-
-    def dump_spline(self):
-        return # not implemented
-
-    # ##########################################################################
-    # Subformat: Untethered
-    # ##########################################################################
-
-    def init_untethered(self):
-        self.untethered_library_type     = 0
-        self.untethered_library_id       = 0
-        self.untethered_scans_to_average = 0
-        self.untethered_min_ramp_pixels  = 0
-        self.untethered_min_peak_height  = 0
-        self.untethered_match_threshold  = 0
-        self.untethered_library_count    = 0
-                                         
-    def read_untethered(self):
-        self.untethered_library_type     = self.unpack((7,  0,  1), "B", "library_type")
-        self.untethered_library_id       = self.unpack((7,  1,  2), "H", "library_id")
-        self.untethered_scans_to_average = self.unpack((7,  3,  1), "B", "scans_to_average")
-        self.untethered_min_ramp_pixels  = self.unpack((7,  4,  1), "B", "min_ramp_pixels")
-        self.untethered_min_peak_height  = self.unpack((7,  5,  2), "H", "min_peak_height")
-        self.untethered_match_threshold  = self.unpack((7,  7,  1), "B", "match_threshold")
-        self.untethered_library_count    = self.unpack((7,  8,  1), "B", "library_count")
-
-    def write_untethered(self):
-        self.pack((7, 0, 1), "B", self.untethered_library_type)
-        self.pack((7, 1, 2), "H", self.untethered_library_id)
-        self.pack((7, 3, 1), "B", self.untethered_scans_to_average)
-        self.pack((7, 4, 1), "B", self.untethered_min_ramp_pixels)
-        self.pack((7, 5, 2), "H", self.untethered_min_peak_height)
-        self.pack((7, 7, 1), "B", self.untethered_match_threshold)
-        self.pack((7, 8, 1), "B", self.untethered_library_count)
-
-    def dump_untethered(self):
-        log.debug("Untethered:")
-        log.debug("  Library Type:     %d", self.untethered_library_type)
-        log.debug("  Library ID:       %d", self.untethered_library_id)
-        log.debug("  Scans to Average: %d", self.untethered_scans_to_average)
-        log.debug("  Min Ramp Pixels:  %d", self.untethered_min_ramp_pixels)
-        log.debug("  Min Peak Height:  %d", self.untethered_min_peak_height)
-        log.debug("  Match Threshold:  %d", self.untethered_match_threshold)
-        log.debug("  Library Count:    %d", self.untethered_library_count)
-
-    # ##########################################################################
-    # Subformat: Regions
-    # ##########################################################################
-
-    # Already have names in standard format:
-    #
-    # -	R1C0-3: Wavecal Coeff 0-3       (Region 1)
-    # -	R1X0: ROI Horizontal Start      (Region 1)
-    # -	R1X1: ROI Horizontal End        (Region 1)
-    # -	R1Y0: ROI Vertical Region 1 Start
-    # -	R1Y1: ROI Vertical Region 1 End
-    # -	R2Y0: ROI Vertical Region 2 Start
-    # -	R2Y1: ROI Vertical Region 2 End
-    # -	R3Y0: ROI Vertical Region 3 Start
-    # -	R3Y1: ROI Vertical Region 3 End
-
-    def init_regions(self):
-        self.region_count                   = 0
-        self.roi_horiz_region_2_start       = 0
-        self.roi_horiz_region_2_end         = 0
-        self.roi_horiz_region_3_start       = 0
-        self.roi_horiz_region_3_end         = 0
-        self.roi_horiz_region_4_start       = 0
-        self.roi_horiz_region_4_end         = 0
-        self.roi_vertical_region_4_start    = 0
-        self.roi_vertical_region_4_end      = 0
-        self.roi_wavecal_region_2_coeffs    = [ 0, 1, 0, 0 ]
-        self.roi_wavecal_region_3_coeffs    = [ 0, 1, 0, 0 ]
-        self.roi_wavecal_region_4_coeffs    = [ 0, 1, 0, 0 ]
-
-    def read_regions(self):
-        log.debug("read_regions")
-        self.region_count = self.unpack((7, 0, 1), "B", "region_count")
-
-        self.roi_horiz_region_2_start       = self.unpack((6,  0, 2), "H", "roi_horiz_region_2_start")
-        self.roi_horiz_region_2_end         = self.unpack((6,  2, 2), "H", "roi_horiz_region_2_end")
-        self.roi_horiz_region_3_start       = self.unpack((6, 20, 2), "H", "roi_horiz_region_3_start")
-        self.roi_horiz_region_3_end         = self.unpack((6, 22, 2), "H", "roi_horiz_region_3_end")
-        self.roi_horiz_region_4_start       = self.unpack((6, 44, 2), "H", "roi_horiz_region_4_start")
-        self.roi_horiz_region_4_end         = self.unpack((6, 46, 2), "H", "roi_horiz_region_4_end")
-        self.roi_vertical_region_4_start    = self.unpack((6, 40, 2), "H", "roi_vertical_region_4_start")
-        self.roi_vertical_region_4_end      = self.unpack((6, 42, 2), "H", "roi_vertical_region_4_end")
-
-        for i in range(4):
-            self.roi_wavecal_region_2_coeffs[i] = self.unpack((6,  4 + i * 4, 4), "f", f"roi_wavecal_region_2_coeffs[{i}]")
-            self.roi_wavecal_region_3_coeffs[i] = self.unpack((6, 24 + i * 4, 4), "f", f"roi_wavecal_region_3_coeffs[{i}]")
-            self.roi_wavecal_region_4_coeffs[i] = self.unpack((6, 48 + i * 4, 4), "f", f"roi_wavecal_region_4_coeffs[{i}]")
-
-    def write_regions(self):
-        log.debug("write_regions")
-
-        self.pack((7,  0, 1), "B", self.region_count)
-        self.pack((6,  0, 2), "H", self.roi_horiz_region_2_start)
-        self.pack((6,  2, 2), "H", self.roi_horiz_region_2_end)
-        self.pack((6, 20, 2), "H", self.roi_horiz_region_3_start)
-        self.pack((6, 22, 2), "H", self.roi_horiz_region_3_end)
-        self.pack((6, 44, 2), "H", self.roi_horiz_region_4_start)
-        self.pack((6, 46, 2), "H", self.roi_horiz_region_4_end)
-        self.pack((6, 40, 2), "H", self.roi_vertical_region_4_start)
-        self.pack((6, 42, 2), "H", self.roi_vertical_region_4_end)
-                                    
-        for i in range(4):
-            self.pack((6,  4 + i * 4, 4), "f", self.roi_wavecal_region_2_coeffs[i])
-            self.pack((6, 24 + i * 4, 4), "f", self.roi_wavecal_region_3_coeffs[i])
-            self.pack((6, 48 + i * 4, 4), "f", self.roi_wavecal_region_4_coeffs[i])
-
-    def dump_regions(self):
-        log.debug("Regions:")
-        log.debug("  Region Count:             %d", self.region_count)
-        log.debug("  ROI Horiz Region 2 Start: %d", self.roi_horiz_region_2_start)
-        log.debug("  ROI Horiz Region 2 End:   %d", self.roi_horiz_region_2_end)
-        log.debug("  ROI Horiz Region 3 Start: %d", self.roi_horiz_region_3_start)
-        log.debug("  ROI Horiz Region 3 End:   %d", self.roi_horiz_region_3_end)
-        log.debug("  ROI Horiz Region 4 Start: %d", self.roi_horiz_region_4_start)
-        log.debug("  ROI Horiz Region 4 End:   %d", self.roi_horiz_region_4_end)
-        log.debug("  ROI Vert Region 4 Start:  %d", self.roi_vertical_region_4_start)
-        log.debug("  ROI Vert Region 4 End:    %d", self.roi_vertical_region_4_end)
-        log.debug("  Region 2 Wavecal:         %s", self.roi_wavecal_region_2_coeffs)
-        log.debug("  Region 3 Wavecal:         %s", self.roi_wavecal_region_3_coeffs)
-        log.debug("  Region 4 Wavecal:         %s", self.roi_wavecal_region_4_coeffs)
+import hashlib
+import logging
+import struct
+import array
+import copy
+import json
+import re
+
+from . import utils
+
+from .ROI import ROI
+
+log = logging.getLogger(__name__)
+
+##
+# This class encapsulates the post-read parsing, pre-write marshalling, and current
+# state of the 8-page EEPROM used to store non-volatile configuration data in Wasatch
+# Photonics spectrometers.  It is essential to keep this class synchronized (in naming,
+# datatype / datasize and sequence) with the ENG-0034 customer-facing documentation.
+#
+# This class is normally accessed as an attribute of SpectrometerSettings.
+#
+# @see ENG-0034
+# @see AT24C256C for ARM (32KB, http://ww1.microchip.com/downloads/en/DeviceDoc/20006270A.pdf)
+# @see 24LC128 for FX2 (16KB, https://www.microchip.com/en-us/product/24LC128)
+class EEPROM:
+
+    # This was mistakenly set to 15 earlier, probably out of confusion between 
+    # ENG-0001 vs ENG-0034 release level (the former WAS at 15, the latter is
+    # only now advancing to 15).  Leaving it alone for now.
+    LATEST_REV = 15
+
+    MAX_PAGES = 8
+    PAGE_LENGTH = 64
+    SUBPAGE_COUNT = 4  # is this used for BLE?
+    MAX_RAMAN_INTENSITY_CALIBRATION_ORDER = 7
+
+    DEFAULT_LASER_WATCHDOG_SEC = 10
+
+    def __init__(self):
+        self.model                       = None
+        self.serial_number               = None
+        self.baud_rate                   = 0
+        self.has_cooling                 = False    # explicitly means detector TEC, not laser
+        self.has_battery                 = False
+        self.has_laser                   = False
+        self.feature_mask                = 0
+        self.invert_x_axis               = False
+        self.bin_2x2                     = False
+        self.gen15                       = False
+        self.cutoff_filter_installed     = False
+        self.hardware_even_odd           = False
+        self.sig_laser_tec               = False
+        self.has_interlock_feedback      = False
+        self.has_shutter                 = False
+        self.excitation_nm               = 0.0
+        self.excitation_nm_float         = 0.0
+        self.slit_size_um                = 0
+        self.startup_integration_time_ms = 10
+        self.startup_temp_degC           = 15       # normally used for detector TEC; now also used for raw laser TEC on SiG (needs updated in ENG-0034)
+        self.startup_triggering_scheme   = 0
+        self.detector_gain               = 1.9
+        self.detector_offset             = 0
+        self.detector_gain_odd           = 1.9
+        self.detector_offset_odd         = 0
+        self.laser_warmup_sec            = 0
+        self.laser_watchdog_sec          = 0
+        self.light_source_type           = 0
+                                         
+        self.wavelength_coeffs           = []
+        self.degC_to_dac_coeffs          = []
+        self.adc_to_degC_coeffs          = []
+        self.max_temp_degC               = 20 
+        self.min_temp_degC               = 10
+        self.tec_r298                    = 0
+        self.tec_beta                    = 0
+        self.calibration_date            = None
+        self.calibrated_by               = None
+                                         
+        self.detector                    = None
+        self.detector_serial_number      = None
+        self.active_pixels_horizontal    = 1024
+        self.active_pixels_vertical      = 0
+        self.min_integration_time_ms     = 10
+        self.max_integration_time_ms     = 60000
+        self.actual_horizontal           = 0
+        self.actual_vertical             = 0     # not a real EEPROM field, though it should be
+        self.roi_horizontal_start        = 0
+        self.roi_horizontal_end          = 0
+        self.roi_vertical_region_1_start = 0
+        self.roi_vertical_region_1_end   = 0
+        self.roi_vertical_region_2_start = 0
+        self.roi_vertical_region_2_end   = 0
+        self.roi_vertical_region_3_start = 0
+        self.roi_vertical_region_3_end   = 0
+        self.linearity_coeffs            = []
+
+        self.max_laser_power_mW          = 0.0
+        self.min_laser_power_mW          = 0.0
+        self.laser_power_coeffs          = []
+        self.avg_resolution              = 0.0
+
+        self.user_data                   = None
+        self.user_text                   = None
+
+        self.bad_pixels                  = [] # should be set, not list (but this works with EEPROMEditor)
+        self.product_configuration       = None
+
+        self.format                      = EEPROM.LATEST_REV
+        self.subformat                   = 0 # pages 6-7
+
+        self.buffers = []
+        self.write_buffers = []
+        self.digest = None
+
+        self.editable = [ "excitation_nm",
+                          "excitation_nm_float",
+                          "detector_gain",
+                          "detector_offset",
+                          "detector_gain_odd",
+                          "detector_offset_odd",
+                          "calibrated_by",
+                          "calibration_date", 
+                          "user_text",
+                          "wavelength_coeffs",
+                          "linearity_coeffs",
+                          "max_laser_power_mW",
+                          "min_laser_power_mW",
+                          "laser_power_coeffs",
+                          "bad_pixels",
+                          "bin_2x2",
+                          "gen15",
+                          "cutoff_filter_installed",
+                          "has_shutter",
+                          "laser_warmup_sec",
+                          "laser_watchdog_sec",
+                          "roi_horizontal_end",             
+                          "roi_horizontal_start",           
+                          "roi_vertical_region_1_end",      
+                          "roi_vertical_region_1_start",    
+                          "roi_vertical_region_2_end",      
+                          "roi_vertical_region_2_start",    
+                          "roi_vertical_region_3_end",      
+                          "roi_vertical_region_3_start",
+                          "raman_intensity_calibration_order",
+                          "raman_intensity_coeffs" ]
+
+        self.init_raman_intensity_calibration()
+        self.init_spline()
+        self.init_untethered()
+        self.init_regions()
+
+    ## whether the given field is normally editable by users via ENLIGHTEN
+    #
+    # @return False otherwise (don't trust in None's truthiness, as you can't 
+    #         pass None to Qt's setEnabled)
+    def is_editable(self, name): # -> bool 
+        s = name.lower()
+        for field in self.editable:
+            if s == field.lower():
+                return True
+        return False
+
+    ## 
+    # passed a temporary copy of another EEPROM object, copy-over any
+    # "editable" fields to this one
+    def update_editable(self, new_eeprom):
+        for field in self.editable:
+            old = getattr(self, field)
+            new = copy.deepcopy(getattr(new_eeprom, field))
+            if old == new:
+                log.debug("  %s: no change (%s == %s)", field, old, new)
+            else:
+                setattr(self, field, new)
+                log.debug("  %s: changed %s --> %s", field, old, new)
+
+    # ##########################################################################
+    #                                                                          #
+    #                               Read EEPROM                                #
+    #                                                                          #
+    # ##########################################################################
+
+    ## 
+    # given a set of the 8 buffers read from a spectrometer via USB,
+    # parse those into the approrpriate fields and datatypes
+    def parse(self, buffers): # -> bool 
+        if len(buffers) < EEPROM.MAX_PAGES:
+            log.error("EEPROM.parse expects at least %d buffers", EEPROM.MAX_PAGES)
+            return False
+
+        # store these locally so self.unpack() can access them
+        self.buffers = buffers
+        self.digest = self.generate_digest()
+
+        # handy for debugs
+        self.hexbuf = [" ".join([f"{v:02x}" for v in buf]) for buf in buffers]
+
+        # check for known ne'er-do-well
+        bad = r"c2 47 05 31 21 00 00 04 00 03 00 00 02 31 a5 00 03 00 33 02 39 0f 00 03 00 43 02 2f 00 00 03 00 " \
+            + r"4b 02 2b 23 00 03 00 53 02 2f 00 03 ff 01 00 90 e6 78 e0 54 10 ff c4 54 0f 44 50 f5 09 13 e4"
+        for i, s in enumerate(self.hexbuf):
+            if bad in s:
+                log.error(f"bad string found in EEPROM page {i}")
+
+        # unpack all the fields we know about
+        try:
+            self.read_eeprom()
+            return True
+        except:
+            log.error("failed to parse EEPROM", exc_info=1)
+            return False
+
+    ## 
+    # Assuming a set of 8 buffers have been passed in via parse(), actually
+    # unpack (deserialize / unmarshall) the binary data into the appropriate
+    # fields and datatypes.
+    # 
+    # @see https://docs.python.org/2/library/struct.html#format-characters
+    # (capitals are unsigned)
+    def read_eeprom(self):
+        self.format = self.unpack((0, 63,  1), "B", "format")
+        log.debug("parsing EEPROM format %d", self.format)
+
+        # ######################################################################
+        # Page 0
+        # ######################################################################
+
+        self.model                           = self.unpack((0,  0, 16), "s", "model")
+        self.serial_number                   = self.unpack((0, 16, 16), "s", "serial")
+        self.baud_rate                       = self.unpack((0, 32,  4), "I", "baud")
+        self.has_cooling                     = self.unpack((0, 36,  1), "?", "cooling")
+        self.has_battery                     = self.unpack((0, 37,  1), "?", "battery")
+        self.has_laser                       = self.unpack((0, 38,  1), "?", "laser")
+        if self.format > 9:
+            self.feature_mask                = self.unpack((0, 39,  2), "H", "feature_mask")
+        elif self.format >= 3:
+            self.excitation_nm               = self.unpack((0, 39,  2), "H", "excitation_nm (unsigned)")
+        else:
+            self.excitation_nm               = self.unpack((0, 39,  2), "h", "excitation_nm (signed)")
+
+        if self.format >= 4:
+            self.slit_size_um                = self.unpack((0, 41,  2), "H", "slit (unsigned)")
+        else:
+            self.slit_size_um                = self.unpack((0, 41,  2), "h", "slit (signed)")
+
+        # NOTE: the new InGaAs detector gain/offset won't be usable from 
+        #       EEPROM until we start bumping production spectrometers to
+        #       EEPROM Page 0 Revision 3!
+        if self.format >= 3:
+            self.startup_integration_time_ms = self.unpack((0, 43,  2), "H", "start_integ")
+            self.startup_temp_degC           = self.unpack((0, 45,  2), "h", "start_temp")
+            self.startup_triggering_scheme   = self.unpack((0, 47,  1), "B", "start_trigger")
+            self.detector_gain               = self.unpack((0, 48,  4), "f", "gain") # "even pixels" for InGaAs
+            self.detector_offset             = self.unpack((0, 52,  2), "h", "offset") # "even pixels" for InGaAs
+            self.detector_gain_odd           = self.unpack((0, 54,  4), "f", "gain_odd") # InGaAs-only
+            self.detector_offset_odd         = self.unpack((0, 58,  2), "h", "offset_odd") # InGaAs-only
+
+        # ######################################################################
+        # Page 1
+        # ######################################################################
+
+        self.wavelength_coeffs = []
+        self.wavelength_coeffs         .append(self.unpack((1,  0,  4), "f", "wavecal_coeff_0"))
+        self.wavelength_coeffs         .append(self.unpack((1,  4,  4), "f"))
+        self.wavelength_coeffs         .append(self.unpack((1,  8,  4), "f"))
+        self.wavelength_coeffs         .append(self.unpack((1, 12,  4), "f"))
+        self.degC_to_dac_coeffs = []
+        self.degC_to_dac_coeffs        .append(self.unpack((1, 16,  4), "f", "degCtoDAC_coeff_0"))
+        self.degC_to_dac_coeffs        .append(self.unpack((1, 20,  4), "f"))
+        self.degC_to_dac_coeffs        .append(self.unpack((1, 24,  4), "f"))
+        self.max_temp_degC                   = self.unpack((1, 28,  2), "h", "max_temp")
+        self.min_temp_degC                   = self.unpack((1, 30,  2), "h", "min_temp")
+        self.adc_to_degC_coeffs = []
+        self.adc_to_degC_coeffs        .append(self.unpack((1, 32,  4), "f", "adcToDegC_coeff_0"))
+        self.adc_to_degC_coeffs        .append(self.unpack((1, 36,  4), "f"))
+        self.adc_to_degC_coeffs        .append(self.unpack((1, 40,  4), "f"))
+        self.tec_r298                        = self.unpack((1, 44,  2), "h", "r298")
+        self.tec_beta                        = self.unpack((1, 46,  2), "h", "beta")
+        self.calibration_date                = self.unpack((1, 48, 12), "s", "date")
+        self.calibrated_by                   = self.unpack((1, 60,  3), "s", "tech")
+                                    
+        # ######################################################################
+        # Page 2                    
+        # ######################################################################
+
+        self.detector                        = self.unpack((2,  0, 16), "s", "detector")
+        self.active_pixels_horizontal        = self.unpack((2, 16,  2), "H", "pixels")
+        if self.format >= 10:
+            self.laser_warmup_sec            = self.unpack((2, 18,  1), "B", "laser_warmup_sec")
+        self.active_pixels_vertical          = self.unpack((2, 19,  2), "H" if self.format >= 4 else "h")
+
+        if self.format >= 8:
+            self.wavelength_coeffs     .append(self.unpack((2, 21,  4), "f", "wavecal_coeff_4"))
+        else:
+            # just go ahead and initialize the 5th coeff to zero
+            self.wavelength_coeffs.append(0)
+            if self.format < 5:
+                self.min_integration_time_ms     = self.unpack((2, 21,  2), "H", "min_integ(ushort)")
+                self.max_integration_time_ms     = self.unpack((2, 23,  2), "H", "max_integ(ushort)") 
+
+        self.actual_horizontal               = self.unpack((2, 25,  2), "H" if self.format >= 4 else "h", "actual_horiz")
+        self.actual_vertical                 = self.active_pixels_vertical  # approximate for now
+        self.roi_horizontal_start            = self.unpack((2, 27,  2), "H" if self.format >= 4 else "h")
+        self.roi_horizontal_end              = self.unpack((2, 29,  2), "H" if self.format >= 4 else "h")
+        self.roi_vertical_region_1_start     = self.unpack((2, 31,  2), "H" if self.format >= 4 else "h")
+        self.roi_vertical_region_1_end       = self.unpack((2, 33,  2), "H" if self.format >= 4 else "h")
+        self.roi_vertical_region_2_start     = self.unpack((2, 35,  2), "H" if self.format >= 4 else "h")
+        self.roi_vertical_region_2_end       = self.unpack((2, 37,  2), "H" if self.format >= 4 else "h")
+        self.roi_vertical_region_3_start     = self.unpack((2, 39,  2), "H" if self.format >= 4 else "h")
+        self.roi_vertical_region_3_end       = self.unpack((2, 41,  2), "H" if self.format >= 4 else "h")
+        self.linearity_coeffs = []
+        self.linearity_coeffs          .append(self.unpack((2, 43,  4), "f", "linearity_coeff_0")) # overloading for secondary ADC
+        self.linearity_coeffs          .append(self.unpack((2, 47,  4), "f"))
+        self.linearity_coeffs          .append(self.unpack((2, 51,  4), "f"))
+        self.linearity_coeffs          .append(self.unpack((2, 55,  4), "f"))
+        self.linearity_coeffs          .append(self.unpack((2, 59,  4), "f"))
+
+        # ######################################################################
+        # Page 3
+        # ######################################################################
+        
+        self.laser_power_coeffs = []
+        self.laser_power_coeffs        .append(self.unpack((3, 12,  4), "f", "laser_power_coeff_0"))
+        self.laser_power_coeffs        .append(self.unpack((3, 16,  4), "f"))
+        self.laser_power_coeffs        .append(self.unpack((3, 20,  4), "f"))
+        self.laser_power_coeffs        .append(self.unpack((3, 24,  4), "f"))
+        self.max_laser_power_mW              = self.unpack((3, 28,  4), "f", "max_laser_mW")
+        self.min_laser_power_mW              = self.unpack((3, 32,  4), "f", "min_laser_mW")
+
+        if self.format >= 4:
+            self.excitation_nm_float         = self.unpack((3, 36,  4), "f", "excitation(float)")
+        else:
+            self.excitation_nm_float = self.excitation_nm
+
+        if self.format >= 5:
+            self.min_integration_time_ms     = self.unpack((3, 40,  4), "I", "min_integ(uint)")
+            self.max_integration_time_ms     = self.unpack((3, 44,  4), "I", "max_integ(uint)") 
+
+        if self.format >= 7:
+            self.avg_resolution              = self.unpack((3, 48,  4), "f", "avg_resolution")
+
+        if self.format >= 15:
+            self.laser_watchdog_sec          = self.unpack((3, 52,  2), "H", "laser_watchdog_sec")
+            self.light_source_type           = self.unpack((3, 54,  1), "B", "light_source_type")
+
+        # ######################################################################
+        # Page 4
+        # ######################################################################
+
+        self.user_data = self.buffers[4][:63]
+        self.user_text = self.printable(self.user_data)
+
+        # ######################################################################
+        # Page 5
+        # ######################################################################
+
+        bad = set()
+        for count in range(15):
+            pixel = self.unpack((5, count * 2, 2), "h")
+            if pixel != -1:
+                bad.add(pixel)
+        self.bad_pixels = list(bad)
+        self.bad_pixels.sort()
+
+        if self.format >= 5:
+            self.product_configuration       = self.unpack((5,  30, 16), "s", "product_configuration")
+        if self.format >= 7:
+            self.subformat                   = self.unpack((5,  63,  1), "B", "subformat")
+
+        # ######################################################################
+        # Page 6-7
+        # ######################################################################
+
+        if self.subformat == 0:
+            pass
+        elif self.subformat == 1:
+            self.read_raman_intensity_calibration()
+        elif self.subformat == 2:
+            self.read_spline()
+        elif self.subformat == 3:
+            self.read_untethered()
+        elif self.subformat == 4:
+            self.read_regions()
+        else:
+            log.debug(f"Unreadable EEPROM subformat {self.subformat}")
+        
+        # ######################################################################
+        # feature mask
+        # ######################################################################
+
+        if self.format >= 9:
+            self.invert_x_axis           = 0 != self.feature_mask & 0x0001
+            self.bin_2x2                 = 0 != self.feature_mask & 0x0002
+            self.gen15                   = 0 != self.feature_mask & 0x0004
+            self.cutoff_filter_installed = 0 != self.feature_mask & 0x0008
+            self.hardware_even_odd       = 0 != self.feature_mask & 0x0010
+            self.sig_laser_tec           = 0 != self.feature_mask & 0x0020
+            self.has_interlock_feedback  = 0 != self.feature_mask & 0x0040
+            self.has_shutter             = 0 != self.feature_mask & 0x0080
+        else:
+            self.invert_x_axis           = 0 
+            self.bin_2x2                 = 0
+            self.gen15                   = 0
+            self.cutoff_filter_installed = 0
+            self.hardware_even_odd       = 0
+            self.sig_laser_tec           = 0
+            self.has_interlock_feedback  = 0
+            self.has_shutter             = 0
+
+        # ######################################################################
+        # sanity checks
+        # ######################################################################
+
+        utils.clean_nan(self.wavelength_coeffs)
+
+        if self.min_integration_time_ms == 0xffff:
+            self.min_integration_time_ms = 1 
+            self.max_integration_time_ms = 60000
+
+        if self.min_integration_time_ms > self.max_integration_time_ms:
+            (self.min_integration_time_ms, self.max_integration_time_ms) = \
+            (self.max_integration_time_ms, self.min_integration_time_ms)
+
+        if self.startup_integration_time_ms < self.min_integration_time_ms:
+            self.startup_integration_time_ms = self.min_integration_time_ms
+
+        if self.min_temp_degC > self.max_temp_degC:
+            (self.min_temp_degC, self.max_temp_degC) = \
+            (self.max_temp_degC, self.min_temp_degC) 
+
+        if self.min_laser_power_mW > self.max_laser_power_mW:
+            (self.min_laser_power_mW, self.max_laser_power_mW) = \
+            (self.max_laser_power_mW, self.min_laser_power_mW)
+
+    ############################################################################
+    #                                                                          #
+    #                               Write EEPROM                               #
+    #                                                                          #
+    ############################################################################
+
+    def generate_feature_mask(self):
+        mask = 0
+        mask |= 0x0001 if self.invert_x_axis           else 0
+        mask |= 0x0002 if self.bin_2x2                 else 0
+        mask |= 0x0004 if self.gen15                   else 0
+        mask |= 0x0008 if self.cutoff_filter_installed else 0
+        mask |= 0x0010 if self.hardware_even_odd       else 0
+        mask |= 0x0020 if self.sig_laser_tec           else 0
+        mask |= 0x0040 if self.has_interlock_feedback  else 0
+        mask |= 0x0080 if self.has_shutter             else 0
+        return mask
+
+    ##
+    # Call this to populate an internal array of "write buffers" which may be written back
+    # to spectrometers (or used to generate the digest of what WOULD be written).
+    def generate_write_buffers(self):
+        # stub-out 8 blank buffers
+        self.write_buffers = []
+        for page in range(EEPROM.MAX_PAGES):
+            self.write_buffers.append(array.array('B', [0] * 64))
+
+        # Eventually we'll stop worrying about the legacy per-page format versions, but
+        # for now maximize compatibility with StrokerConsole/ModelConfigurationFormat.cs
+        # by making its expected format values the default for each page:
+        revs = { 0: 1,
+                 1: 1,
+                 2: 2, 
+                 3: 255,
+                 4: 1, 
+                 5: 1,
+                 6: 0 }
+        for page in list(revs.keys()):
+            self.write_buffers[page][63] = revs[page]
+
+        # ...but the truth is that we don't really care about the old per-page formats,
+        # and all modern code should just be looking at this one byte:
+        self.write_buffers[0][63] = EEPROM.LATEST_REV
+
+        # ######################################################################
+        # Page 0
+        # ######################################################################
+
+        self.pack((0,  0, 16), "s", self.model)
+        self.pack((0, 16, 16), "s", self.serial_number)
+        self.pack((0, 32,  4), "I", self.baud_rate)
+        self.pack((0, 36,  1), "?", self.has_cooling)
+        self.pack((0, 37,  1), "?", self.has_battery)
+        self.pack((0, 38,  1), "?", self.has_laser)
+        self.pack((0, 39,  2), "H", self.generate_feature_mask(), "FeatureMask")
+        self.pack((0, 41,  2), "H", self.slit_size_um)
+        self.pack((0, 43,  2), "H", self.startup_integration_time_ms)
+        self.pack((0, 45,  2), "h", self.startup_temp_degC)
+        self.pack((0, 47,  1), "B", self.startup_triggering_scheme)
+        self.pack((0, 48,  4), "f", self.detector_gain)
+        self.pack((0, 52,  2), "h", self.detector_offset)
+        self.pack((0, 54,  4), "f", self.detector_gain_odd)
+        self.pack((0, 58,  2), "h", self.detector_offset_odd)
+
+        # ######################################################################
+        # Page 1
+        # ######################################################################
+
+        if self.wavelength_coeffs is not None:
+            for i in range(min(4, len(self.wavelength_coeffs))):
+                self.pack((1,  0 + i * 4,  4), "f", self.wavelength_coeffs[i])
+                
+        if self.degC_to_dac_coeffs is not None:
+            for i in range(min(3, len(self.degC_to_dac_coeffs))):
+                self.pack((1, 16 + i * 4,  4), "f", self.degC_to_dac_coeffs[i])
+
+        if self.adc_to_degC_coeffs is not None:
+            for i in range(min(3, len(self.adc_to_degC_coeffs))):
+                self.pack((1, 32 + i * 4,  4), "f", self.adc_to_degC_coeffs[i])
+
+        self.pack((1, 28,  2), "h", self.max_temp_degC)
+        self.pack((1, 30,  2), "h", self.min_temp_degC)
+        self.pack((1, 44,  2), "h", self.tec_r298)
+        self.pack((1, 46,  2), "h", self.tec_beta)
+        self.pack((1, 48, 12), "s", self.calibration_date)
+        self.pack((1, 60,  3), "s", self.calibrated_by)
+                                    
+        # ######################################################################
+        # Page 2                    
+        # ######################################################################
+
+        self.pack((2,  0, 16), "s", self.detector)
+        self.pack((2, 16,  2), "H", self.active_pixels_horizontal)
+        self.pack((2, 18,  1), "B", self.laser_warmup_sec)
+        self.pack((2, 19,  2), "H", self.active_pixels_vertical)
+        if self.format < 7:
+            self.pack((2, 21,  2), "H", max(0xffff, self.min_integration_time_ms))
+            self.pack((2, 23,  2), "H", max(0xffff, self.max_integration_time_ms))
+        else:
+            coeff = 0.0
+            if len(self.wavelength_coeffs) > 4:
+                coeff = self.wavelength_coeffs[4]
+            self.pack((2, 21,  4), "f", coeff)
+        self.pack((2, 25,  2), "H", self.actual_horizontal)
+        self.pack((2, 27,  2), "H", self.roi_horizontal_start)
+        self.pack((2, 29,  2), "H", self.roi_horizontal_end)
+        self.pack((2, 31,  2), "H", self.roi_vertical_region_1_start)
+        self.pack((2, 33,  2), "H", self.roi_vertical_region_1_end)
+        self.pack((2, 35,  2), "H", self.roi_vertical_region_2_start)
+        self.pack((2, 37,  2), "H", self.roi_vertical_region_2_end)
+        self.pack((2, 39,  2), "H", self.roi_vertical_region_3_start)
+        self.pack((2, 41,  2), "H", self.roi_vertical_region_3_end)
+
+        if self.linearity_coeffs is not None:
+            for i in range(min(5, len(self.linearity_coeffs))):
+                self.pack((2, 43 + i * 4,  4), "f", self.linearity_coeffs[i])
+
+        # ######################################################################
+        # Page 3
+        # ######################################################################
+
+        if self.laser_power_coeffs is not None:
+            for i in range(min(4, len(self.laser_power_coeffs))):
+                self.pack((3, 12 + i * 4,  4), "f", self.laser_power_coeffs[i])
+
+        self.pack((3, 28,  4), "f", self.max_laser_power_mW)
+        self.pack((3, 32,  4), "f", self.min_laser_power_mW)
+        self.pack((3, 36,  4), "f", self.excitation_nm_float)
+        self.pack((3, 40,  4), "I", self.min_integration_time_ms)
+        self.pack((3, 44,  4), "I", self.max_integration_time_ms)
+        self.pack((3, 48,  4), "f", self.avg_resolution)
+        self.pack((3, 52,  2), "H", self.laser_watchdog_sec)
+        self.pack((3, 54,  1), "B", self.light_source_type)
+
+        # ######################################################################
+        # Page 4
+        # ######################################################################
+
+        self.pack((4,  0, 63), "s", self.user_text)
+
+        # ######################################################################
+        # Page 5
+        # ######################################################################
+
+        bad_pixel_set = set()
+        for i in self.bad_pixels:
+            if i >= 0:
+                bad_pixel_set.add(i)
+        bad_pixels = list(bad_pixel_set)
+        bad_pixels.sort()
+        for i in range(15):
+            if i < len(bad_pixels):
+                value = bad_pixels[i]
+            else:
+                value = -1
+            self.pack((5, i * 2, 2), "h", value)
+
+        self.pack((5, 30, 16), "s", self.product_configuration)
+        self.pack((5, 63,  1), "B", self.subformat)
+
+        # ######################################################################
+        # Page 6-7
+        # ######################################################################
+
+        if self.subformat == 0:
+            pass
+        elif self.subformat == 1:
+            self.write_raman_intensity_calibration()
+        elif self.subformat == 2:
+            self.write_spline()
+        elif self.subformat == 3:
+            self.write_untethered()
+        elif self.subformat == 4:
+            self.write_regions()
+        else:
+            log.error(f"Unwriteable EEPROM subformat {self.subformat}")
+
+    # ##########################################################################
+    #                                                                          #
+    #                             Utility methods                              #
+    #                                                                          #
+    # ##########################################################################
+
+    ## make a printable ASCII string out of possibly-binary data
+    def printable(self, buf):
+        s = ""
+        for c in buf:
+            if 31 < c < 127:
+                s += chr(c)
+            elif c == 0:
+                break
+            else:
+                s += '.'
+        return s
+
+    def set(self, name, value):
+        setattr(self, name, value)
+
+    ##
+    # Convert a floating-point value into the big-endian 16-bit "funky float" 
+    # used for detector gain in the FPGA on both Hamamatsu and IMX sensors.
+    #
+    # Note that this TRUNCATES (takes the floor) the fractional portion rather 
+    # than rounding, which I believe matches WasatchNET.FunkyFloat.fromFloat().
+    #
+    # Conversely, it DOES provide minor rounding on the INTEGRAL portion, to 
+    # avoid this problem:
+    #
+    # \verbatim
+    # dB = 0
+    # while dB < 2.1:
+    #     self.set_detector_gain(dB) # old code treats 1.0 as 0.0 because actually sends 0.99999999
+    #     dB += 0.1
+    # \endverbatim
+    #
+    # @see https://wasatchphotonics.com/api/Wasatch.NET/class_wasatch_n_e_t_1_1_funky_float.html
+    def float_to_uint16(self, gain):
+        msb = int(round(gain, 5)) & 0xff
+        # if self.format >= 13: lsb = round((gain - msb) * 256) & 0xff
+        lsb = int((gain - msb) * 256) & 0xff
+        raw = (msb << 8) | lsb
+        log.debug("float_to_uint16: %f -> 0x%04x", gain, raw)
+        return raw
+
+    ## 
+    # Unpack a single field at a given buffer offset of the given datatype.
+    #
+    # @param address    a tuple of the form (buf, offset, len)
+    # @param data_type  see https://docs.python.org/2/library/struct.html#format-characters
+    # @param label      if provided, is included in debug log output
+    def unpack(self, address, data_type, label=None):
+        page       = address[0]
+        start_byte = address[1]
+        length     = address[2]
+        end_byte   = start_byte + length
+
+        if page > len(self.buffers):
+            log.error("error unpacking EEPROM page %d, offset %d, len %d as %s: invalid page (label %s)", 
+                page, start_byte, length, data_type, label, exc_info=1)
+            return
+
+        buf = self.buffers[page]
+        if buf is None or end_byte > len(buf):
+            log.error("error unpacking EEPROM page %d, offset %d, len %d as %s: buf is %s (label %s)", 
+                page, start_byte, length, data_type, buf, label, exc_info=1)
+            return
+
+        if data_type == "s":
+            # This stops at the first NULL, so is not appropriate for binary data (user_data).
+            # OTOH, it doesn't currently enforce "printable" characters either (nor support Unicode).
+            unpack_result = ""
+            for c in buf[start_byte:end_byte]:
+                if c == 0:
+                    break
+                unpack_result += chr(c)
+        else:
+            unpack_result = 0
+            try:
+                unpack_result = struct.unpack(data_type, buf[start_byte:end_byte])[0]
+            except:
+                log.error("error unpacking EEPROM page %d, offset %d, len %d as %s", page, start_byte, length, data_type, exc_info=1)
+
+        if label is None:
+            log.debug("Unpacked [%s]: %s", data_type, unpack_result)
+        else:
+            log.debug("Unpacked [%s]: %s (%s)", data_type, unpack_result, label)
+        return unpack_result
+
+    ## 
+    # Marshall or serialize a single field at a given buffer offset of the given datatype.
+    #
+    # @param address    a tuple of the form (buf, offset, len)
+    # @param data_type  see https://docs.python.org/2/library/struct.html#format-characters
+    # @param value      value to serialize
+    def pack(self, address, data_type, value, label=None):
+        page       = address[0]
+        start_byte = address[1]
+        length     = address[2]
+        end_byte   = start_byte + length
+
+        if page > len(self.write_buffers):
+            log.error("error unpacking EEPROM page %d, offset %d, len %d as %s: invalid page (label %s)", 
+                page, start_byte, length, data_type, label, exc_info=1)
+            return
+
+        # don't try to write negatives to unsigned types
+        if data_type in ["H", "I"] and value < 0:
+            log.error("rounding negative to zero when writing to unsigned field (address %s, data_type %s, value %s)", address, data_type, value)
+            value = 0
+
+        buf = self.write_buffers[page]
+        if buf is None or end_byte > 64:
+            raise Exception("error packing EEPROM page %d, offset %2d, len %2d as %s: buf is %s" % (
+                page, start_byte, length, data_type, buf))
+
+        if data_type == "s":
+            if value is None:
+                value = ""
+            for i in range(min(length, len(value))):
+                if i < len(value):
+                    buf[start_byte + i] = ord(value[i])
+                else:
+                    buf[start_byte + i] = 0
+        else:
+            struct.pack_into(data_type, buf, start_byte, value)
+
+        if True:
+            extra = "" if label is None else (" (%s)" % label)
+            log.debug("Packed (%d, %2d, %2d) '%s' value %s -> %s%s", 
+                page, start_byte, length, data_type, value, buf[start_byte:end_byte], extra)
+
+    ##
+    # If asked to regenerate, return a digest of the contents that WOULD BE 
+    # WRITTEN from current settings in memory.
+    def generate_digest(self, regenerate=False):
+        buffers = self.buffers
+        digest = 'invalid'
+        try:
+            if regenerate:
+                self.generate_write_buffers()
+                buffers = self.write_buffers
+
+            h = hashlib.new("md5")
+            for buf in buffers:
+                h.update(bytes(buf))
+            digest = h.hexdigest()
+        except: 
+            log.error(f"exception generating EEPROM digest...using '{digest}'", exc_info=1)
+
+        log.debug(f"EEPROM MD5 digest {digest} (regenerate {regenerate})")
+        return digest
+
+    def to_dict(self):
+        d = {}
+        for k, v in self.__dict__.items():
+            if k not in ["user_data", "buffers", "write_buffers", "editable"]:
+                d[k] = v
+        return d
+
+    ## render the attributes of this object as a JSON string
+    #
+    # @note some callers may prefer SpectrometerSettings.to_dict() or to_json()
+    def json(self, allow_nan=True):
+        tmp_buf  = self.buffers
+        tmp_data = self.user_data
+
+        self.buffers   = str(self.buffers)
+        self.user_data = str(self.user_data)
+
+        # this does take an allow_nan argument, but it throws an exception on NaN, 
+        # rather than replacing with null :-(
+        # https://stackoverflow.com/questions/6601812/sending-nan-in-json
+        s = json.dumps(self.__dict__, indent=2, sort_keys=True)
+        if not allow_nan:
+            s = re.sub(r"\bNaN\b", "null", s)
+
+        self.buffers   = tmp_buf
+        self.user_data = tmp_data
+
+        return s
+
+    ## log this object
+    def dump(self):
+        log.debug("EEPROM settings:")
+        log.debug("  Model:            %s", self.model)
+        log.debug("  Serial Number:    %s", self.serial_number)
+        log.debug("  Baud Rate:        %d", self.baud_rate)
+        log.debug("  Has Cooling:      %s", self.has_cooling)
+        log.debug("  Has Battery:      %s", self.has_battery)
+        log.debug("  Has Laser:        %s", self.has_laser)
+        log.debug("  Invert X-Axis:    %s", self.invert_x_axis)
+        log.debug("  Bin 2x2:          %s", self.bin_2x2)
+        log.debug("  Gen 1.5:          %s", self.gen15)
+        log.debug("  Cutoff Filter:    %s", self.cutoff_filter_installed)
+        log.debug("  HW Even/Odd:      %s", self.hardware_even_odd)
+        log.debug("  SiG Laser TEC:    %s", self.sig_laser_tec)
+        log.debug("  Int'Lck Feedback: %s", self.has_interlock_feedback)
+        log.debug("  Shutter:          %s", self.has_shutter)
+        log.debug("  Excitation:       %s nm", self.excitation_nm)
+        log.debug("  Excitation (f):   %.2f nm", self.excitation_nm_float)
+        log.debug("  Laser Warmup Sec: %d", self.laser_warmup_sec)
+        log.debug("  Laser Watchdog:   %d", self.laser_watchdog_sec)
+        log.debug("  Light Source:     %d", self.light_source_type)
+        log.debug("  Slit size:        %s um", self.slit_size_um)
+        log.debug("  Start Integ Time: %d ms", self.startup_integration_time_ms)
+        log.debug("  Start Temp:       %.2f degC", self.startup_temp_degC)
+        log.debug("  Start Triggering: 0x%04x", self.startup_triggering_scheme)
+        log.debug("  Det Gain:         %f", self.detector_gain)
+        log.debug("  Det Offset:       %d", self.detector_offset)
+        log.debug("  Det Gain Odd:     %f", self.detector_gain_odd)
+        log.debug("  Det Offset Odd:   %d", self.detector_offset_odd)
+        log.debug("")
+        log.debug("  Wavecal coeffs:   %s", self.wavelength_coeffs)
+        log.debug("  degCToDAC coeffs: %s", self.degC_to_dac_coeffs)
+        log.debug("  adcToDegC coeffs: %s", self.adc_to_degC_coeffs)
+        log.debug("  Det temp max:     %s degC", self.max_temp_degC)
+        log.debug("  Det temp min:     %s degC", self.min_temp_degC)
+        log.debug("  TEC R298:         %s", self.tec_r298)
+        log.debug("  TEC beta:         %s", self.tec_beta)
+        log.debug("  Calibration Date: %s", self.calibration_date)
+        log.debug("  Calibration By:   %s", self.calibrated_by)
+        log.debug("")
+        log.debug("  Detector name:    %s", self.detector)
+        log.debug("  Active horiz:     %d", self.active_pixels_horizontal)
+        log.debug("  Active vertical:  %d", self.active_pixels_vertical)
+        log.debug("  Min integration:  %d ms", self.min_integration_time_ms)
+        log.debug("  Max integration:  %d ms", self.max_integration_time_ms)
+        log.debug("  Actual Horiz:     %d", self.actual_horizontal)
+        log.debug("  ROI Horiz Start:  %d", self.roi_horizontal_start)
+        log.debug("  ROI Horiz End:    %d", self.roi_horizontal_end)
+        log.debug("  ROI Vert Reg 1:   (%d, %d)", self.roi_vertical_region_1_start, self.roi_vertical_region_1_end)
+        log.debug("  ROI Vert Reg 2:   (%d, %d)", self.roi_vertical_region_2_start, self.roi_vertical_region_2_end)
+        log.debug("  ROI Vert Reg 3:   (%d, %d)", self.roi_vertical_region_3_start, self.roi_vertical_region_3_end)
+        log.debug("  Linearity Coeffs: %s", self.linearity_coeffs)
+        log.debug("")
+        log.debug("  Laser coeffs:     %s", self.laser_power_coeffs)
+        log.debug("  Max Laser Power:  %s mW", self.max_laser_power_mW)
+        log.debug("  Min Laser Power:  %s mW", self.min_laser_power_mW)
+        log.debug("  Avg Resolution:   %.2f", self.avg_resolution)
+        log.debug("")
+        log.debug("  User Text:        %s", self.user_text)
+        log.debug("")
+        log.debug("  Bad Pixels:       %s", self.bad_pixels)
+        log.debug("  Product Config:   %s", self.product_configuration)
+
+        if self.subformat == 1:
+            self.dump_raman_intensity_calibration()
+        elif self.subformat == 2:
+            self.dump_spline()
+        elif self.subformat == 3:
+            self.dump_raman_intensity_calibration()
+            self.dump_untethered()
+        elif self.subformat == 4:
+            self.dump_regions()
+
+    # ##########################################################################
+    #                                                                          #
+    #                              Convenience accessors                       #
+    #                                                                          #
+    # ##########################################################################
+
+    def latest_rev(self):
+        return EEPROM.LATEST_REV
+
+    ## pixel frame (end is last index, not last+1),
+    def get_horizontal_roi(self):
+        start  = self.roi_horizontal_start
+        end    = self.roi_horizontal_end
+        pixels = self.active_pixels_horizontal
+
+        if 0 <= start and start < end and end < pixels:
+            return ROI(start, end)
+
+    ## 
+    # On a 1024-pixel detector, note the expected / correct result based on the 
+    # roi_horizontal_start/stop fields:
+    #
+    # - (0, 1024) FALSE (last pixel invalid)
+    # - (0, 1023) TRUE  (even though no vignetting is occuring)
+    # - (0, 1022) TRUE  (crops last pixel)
+    # - (1, 1023) TRUE  (crops first pixel)
+    # - (1, 1024) FALSE (last pixel invalid)
+    # - (1,    1) FALSE (start must < end)
+    # - (1,    2) TRUE  (valid 2-pixel spectrum)
+    # - (2,    1) FALSE (start must < end)
+    #   
+    # @return whether a valid horizontal ROI is configured
+    def has_horizontal_roi(self): # -> bool 
+        return self.get_horizontal_roi() is not None
+
+    def has_laser_power_calibration(self): # -> bool 
+        if self.max_laser_power_mW <= 0:
+            return False
+        return utils.coeffs_look_valid(self.laser_power_coeffs, count=4)
+
+    def has_detector_tec_calibration(self): # -> bool 
+        """ simplified version of WasatchNET.Util.validTECCal """
+
+        if not utils.coeffs_look_valid(self.degC_to_dac_coeffs, count=3):
+            return False
+
+        # check it's not the "default"
+        if self.degC_to_dac_coeffs[0] == 2700 and \
+           self.degC_to_dac_coeffs[1] == 0 and \
+           self.degC_to_dac_coeffs[2] == 0:
+            return False
+
+        return True
+
+    def has_raman_intensity_calibration(self): # -> bool 
+        if self.format < 6:
+            log.debug(f"has_raman_intensity_calibration: false because format {self.format}")
+            return False
+
+        if not (0 < self.raman_intensity_calibration_order <= EEPROM.MAX_RAMAN_INTENSITY_CALIBRATION_ORDER):
+            log.debug(f"has_raman_intensity_calibration: false because invalid order {self.raman_intensity_calibration_order}")
+            return False
+            
+        if not utils.coeffs_look_valid(self.raman_intensity_coeffs, count = self.raman_intensity_calibration_order + 1):
+            log.debug(f"has_raman_intensity_calibration: false because coeffs look weird")
+            return False
+
+        return True
+
+    def has_sml(self):
+        """ @todo include light_source_type """
+        return self.has_laser and self.max_laser_power_mW < 150
+
+    def has_mml(self):
+        """ @todo include light_source_type """
+        return self.has_laser and self.max_laser_power_mW >= 150
+
+    ## convert the given laser output power from milliwatts to percentage
+    #  using the configured calibration
+    def laser_power_mW_to_percent(self, mW):
+        if not self.has_laser_power_calibration():
+            return 0
+
+        perc = self.laser_power_coeffs[0] \
+             + self.laser_power_coeffs[1] * mW \
+             + self.laser_power_coeffs[2] * mW * mW \
+             + self.laser_power_coeffs[3] * mW * mW * mW
+
+        return perc
+
+    def is_valid_serial_number(self):
+        return re.match(r"^[-+a-z0-9_ ]{1,16}$", self.serial_number, re.IGNORECASE)
+
+    # ##########################################################################
+    #                                                                          #
+    #                                 Subformats                               #
+    #                                                                          #
+    # ##########################################################################
+
+    # ##########################################################################
+    # Subformat: Raman Intensity Calibration
+    # ##########################################################################
+
+    def init_raman_intensity_calibration(self):
+        self.raman_intensity_calibration_order = 0
+        self.raman_intensity_coeffs      = []
+
+    def read_raman_intensity_calibration(self):
+        self.raman_intensity_coeffs = []
+        self.raman_intensity_calibration_order = self.unpack((6, 0, 1), "B", "raman_intensity_calibration_order")
+        if 0 == self.raman_intensity_calibration_order:
+            pass
+        elif self.raman_intensity_calibration_order <= EEPROM.MAX_RAMAN_INTENSITY_CALIBRATION_ORDER:
+            order = self.raman_intensity_calibration_order
+            terms = order + 1
+            for i in range(terms):
+                offset = i * 4 + 1
+                self.raman_intensity_coeffs.append(self.unpack((6, offset, 4), "f", "raman_intensity_coeff_%d" % i))
+        else:
+            log.error("Unsupported Raman Intensity Calibration order: %d", self.raman_intensity_calibration_order)
+
+    def write_raman_intensity_calibration(self):
+        self.pack((6, 0,  1), "B", self.raman_intensity_calibration_order)
+        if 0 <= self.raman_intensity_calibration_order <= EEPROM.MAX_RAMAN_INTENSITY_CALIBRATION_ORDER:
+            order = self.raman_intensity_calibration_order
+            terms = order + 1
+            for i in range(EEPROM.MAX_RAMAN_INTENSITY_CALIBRATION_ORDER + 1):
+                offset = i * 4 + 1
+                if i < terms and self.raman_intensity_coeffs is not None and i < len(self.raman_intensity_coeffs):
+                    coeff = self.raman_intensity_coeffs[i]
+                else:
+                    coeff = 0.0
+                # log.debug("packing raman_intensity_coeffs[%d] (offset %d, order %d, terms %d) => %e", i, offset, order, terms, coeff)
+                self.pack((6, offset, 4), "f", coeff)
+        else:
+            log.error("Unsupported Raman Intensity Calibration order: %d", self.raman_intensity_calibration_order)
+            for i in range(EEPROM.MAX_RAMAN_INTENSITY_CALIBRATION_ORDER + 1):
+                offset = i * 4 + 1
+                self.pack((6, offset, 4), "f", 0.0)
+
+    def dump_raman_intensity_calibration(self):
+        log.debug("Raman Intensity Calibration:")
+        log.debug("  Raman Int Order:  %d", self.raman_intensity_calibration_order)
+        log.debug("  Raman Int Coeffs: %s", self.raman_intensity_coeffs)
+
+    # ##########################################################################
+    # Subformat: Spline
+    # ##########################################################################
+
+    def init_spline(self):
+        self.spline_points               = 0
+        self.spline_min                  = 0
+        self.spline_max                  = 0
+        self.spline_wavelengths          = []
+        self.spline_y                    = []
+        self.spline_y2                   = []
+
+    ##
+    # @todo turn into EEPROMSpline
+    def read_spline(self):
+        self.spline_wavelengths = []
+        self.spline_y = []
+        self.splint_y2 = []
+
+        self.spline_points = self.unpack((6, 0, 1), "B", "spline.points")
+        if self.spline_points <= 0:
+            log.debug("empty spline")
+            return
+
+        if self.spline_points > 14:
+            log.error("invalid spline (%d points)", self.spline_points)
+            return
+
+        for i in len(range(self.spline_points)):
+            if i < 5:
+                page = 6
+                base = 4
+                first = 0
+            elif i < 10:
+                page = 7
+                base = 0
+                first = 5
+            else:
+                page = 4
+                base = 0
+                first = 10
+
+            offset = base + (i - first) * 12
+            wavelength = self.unpack((page, offset, 4), "f", "spline.wavelength[%d]" % i)
+            y  = self.unpack((page, offset + 4, 4), "f", "spline.y[%d]" % i)
+            y2 = self.unpack((page, offset + 8, 4), "f", "spline.y2[%d]" % i)
+
+            self.spline_wavelengths.append(wavelength)
+            self.spline_y.append(y)
+            self.spline_y2.append(y2)
+        
+        self.spline_min = self.unpack((4, 56, 4), "f", "spline_wavelength_min")
+        self.spline_max = self.unpack((4, 60, 4), "f", "spline_wavelength_max")
+        if self.spline_min >= self.spline_max:
+            log.error("invalid spline (min %f, max %f)", self.spline_min, self.spline_max)
+            return
+
+    def write_spline(self):
+        log.error("EEPROM.write_spline not implemented")
+
+    def dump_spline(self):
+        return # not implemented
+
+    # ##########################################################################
+    # Subformat: Untethered
+    # ##########################################################################
+
+    def init_untethered(self):
+        self.untethered_library_type     = 0
+        self.untethered_library_id       = 0
+        self.untethered_scans_to_average = 0
+        self.untethered_min_ramp_pixels  = 0
+        self.untethered_min_peak_height  = 0
+        self.untethered_match_threshold  = 0
+        self.untethered_library_count    = 0
+                                         
+    def read_untethered(self):
+        self.untethered_library_type     = self.unpack((7,  0,  1), "B", "library_type")
+        self.untethered_library_id       = self.unpack((7,  1,  2), "H", "library_id")
+        self.untethered_scans_to_average = self.unpack((7,  3,  1), "B", "scans_to_average")
+        self.untethered_min_ramp_pixels  = self.unpack((7,  4,  1), "B", "min_ramp_pixels")
+        self.untethered_min_peak_height  = self.unpack((7,  5,  2), "H", "min_peak_height")
+        self.untethered_match_threshold  = self.unpack((7,  7,  1), "B", "match_threshold")
+        self.untethered_library_count    = self.unpack((7,  8,  1), "B", "library_count")
+
+    def write_untethered(self):
+        self.pack((7, 0, 1), "B", self.untethered_library_type)
+        self.pack((7, 1, 2), "H", self.untethered_library_id)
+        self.pack((7, 3, 1), "B", self.untethered_scans_to_average)
+        self.pack((7, 4, 1), "B", self.untethered_min_ramp_pixels)
+        self.pack((7, 5, 2), "H", self.untethered_min_peak_height)
+        self.pack((7, 7, 1), "B", self.untethered_match_threshold)
+        self.pack((7, 8, 1), "B", self.untethered_library_count)
+
+    def dump_untethered(self):
+        log.debug("Untethered:")
+        log.debug("  Library Type:     %d", self.untethered_library_type)
+        log.debug("  Library ID:       %d", self.untethered_library_id)
+        log.debug("  Scans to Average: %d", self.untethered_scans_to_average)
+        log.debug("  Min Ramp Pixels:  %d", self.untethered_min_ramp_pixels)
+        log.debug("  Min Peak Height:  %d", self.untethered_min_peak_height)
+        log.debug("  Match Threshold:  %d", self.untethered_match_threshold)
+        log.debug("  Library Count:    %d", self.untethered_library_count)
+
+    # ##########################################################################
+    # Subformat: Regions
+    # ##########################################################################
+
+    # Already have names in standard format:
+    #
+    # -	R1C0-3: Wavecal Coeff 0-3       (Region 1)
+    # -	R1X0: ROI Horizontal Start      (Region 1)
+    # -	R1X1: ROI Horizontal End        (Region 1)
+    # -	R1Y0: ROI Vertical Region 1 Start
+    # -	R1Y1: ROI Vertical Region 1 End
+    # -	R2Y0: ROI Vertical Region 2 Start
+    # -	R2Y1: ROI Vertical Region 2 End
+    # -	R3Y0: ROI Vertical Region 3 Start
+    # -	R3Y1: ROI Vertical Region 3 End
+
+    def init_regions(self):
+        self.region_count                   = 0
+        self.roi_horiz_region_2_start       = 0
+        self.roi_horiz_region_2_end         = 0
+        self.roi_horiz_region_3_start       = 0
+        self.roi_horiz_region_3_end         = 0
+        self.roi_horiz_region_4_start       = 0
+        self.roi_horiz_region_4_end         = 0
+        self.roi_vertical_region_4_start    = 0
+        self.roi_vertical_region_4_end      = 0
+        self.roi_wavecal_region_2_coeffs    = [ 0, 1, 0, 0 ]
+        self.roi_wavecal_region_3_coeffs    = [ 0, 1, 0, 0 ]
+        self.roi_wavecal_region_4_coeffs    = [ 0, 1, 0, 0 ]
+
+    def read_regions(self):
+        log.debug("read_regions")
+        self.region_count = self.unpack((7, 0, 1), "B", "region_count")
+
+        self.roi_horiz_region_2_start       = self.unpack((6,  0, 2), "H", "roi_horiz_region_2_start")
+        self.roi_horiz_region_2_end         = self.unpack((6,  2, 2), "H", "roi_horiz_region_2_end")
+        self.roi_horiz_region_3_start       = self.unpack((6, 20, 2), "H", "roi_horiz_region_3_start")
+        self.roi_horiz_region_3_end         = self.unpack((6, 22, 2), "H", "roi_horiz_region_3_end")
+        self.roi_horiz_region_4_start       = self.unpack((6, 44, 2), "H", "roi_horiz_region_4_start")
+        self.roi_horiz_region_4_end         = self.unpack((6, 46, 2), "H", "roi_horiz_region_4_end")
+        self.roi_vertical_region_4_start    = self.unpack((6, 40, 2), "H", "roi_vertical_region_4_start")
+        self.roi_vertical_region_4_end      = self.unpack((6, 42, 2), "H", "roi_vertical_region_4_end")
+
+        for i in range(4):
+            self.roi_wavecal_region_2_coeffs[i] = self.unpack((6,  4 + i * 4, 4), "f", f"roi_wavecal_region_2_coeffs[{i}]")
+            self.roi_wavecal_region_3_coeffs[i] = self.unpack((6, 24 + i * 4, 4), "f", f"roi_wavecal_region_3_coeffs[{i}]")
+            self.roi_wavecal_region_4_coeffs[i] = self.unpack((6, 48 + i * 4, 4), "f", f"roi_wavecal_region_4_coeffs[{i}]")
+
+    def write_regions(self):
+        log.debug("write_regions")
+
+        self.pack((7,  0, 1), "B", self.region_count)
+        self.pack((6,  0, 2), "H", self.roi_horiz_region_2_start)
+        self.pack((6,  2, 2), "H", self.roi_horiz_region_2_end)
+        self.pack((6, 20, 2), "H", self.roi_horiz_region_3_start)
+        self.pack((6, 22, 2), "H", self.roi_horiz_region_3_end)
+        self.pack((6, 44, 2), "H", self.roi_horiz_region_4_start)
+        self.pack((6, 46, 2), "H", self.roi_horiz_region_4_end)
+        self.pack((6, 40, 2), "H", self.roi_vertical_region_4_start)
+        self.pack((6, 42, 2), "H", self.roi_vertical_region_4_end)
+                                    
+        for i in range(4):
+            self.pack((6,  4 + i * 4, 4), "f", self.roi_wavecal_region_2_coeffs[i])
+            self.pack((6, 24 + i * 4, 4), "f", self.roi_wavecal_region_3_coeffs[i])
+            self.pack((6, 48 + i * 4, 4), "f", self.roi_wavecal_region_4_coeffs[i])
+
+    def dump_regions(self):
+        log.debug("Regions:")
+        log.debug("  Region Count:             %d", self.region_count)
+        log.debug("  ROI Horiz Region 2 Start: %d", self.roi_horiz_region_2_start)
+        log.debug("  ROI Horiz Region 2 End:   %d", self.roi_horiz_region_2_end)
+        log.debug("  ROI Horiz Region 3 Start: %d", self.roi_horiz_region_3_start)
+        log.debug("  ROI Horiz Region 3 End:   %d", self.roi_horiz_region_3_end)
+        log.debug("  ROI Horiz Region 4 Start: %d", self.roi_horiz_region_4_start)
+        log.debug("  ROI Horiz Region 4 End:   %d", self.roi_horiz_region_4_end)
+        log.debug("  ROI Vert Region 4 Start:  %d", self.roi_vertical_region_4_start)
+        log.debug("  ROI Vert Region 4 End:    %d", self.roi_vertical_region_4_end)
+        log.debug("  Region 2 Wavecal:         %s", self.roi_wavecal_region_2_coeffs)
+        log.debug("  Region 3 Wavecal:         %s", self.roi_wavecal_region_3_coeffs)
+        log.debug("  Region 4 Wavecal:         %s", self.roi_wavecal_region_4_coeffs)
```

### Comparing `wasatch-2.1.35/wasatch/EEPROM_multical.sav` & `wasatch-2.1.64/wasatch/EEPROM_multical.sav`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/wasatch/FeatureIdentificationDevice.py` & `wasatch-2.1.64/wasatch/FeatureIdentificationDevice.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,9264 +1,9668 @@
-00000000: 696d 706f 7274 2073 7562 7072 6f63 6573  import subproces
-00000010: 730d 0a69 6d70 6f72 7420 706c 6174 666f  s..import platfo
-00000020: 726d 0d0a 696d 706f 7274 2064 6174 6574  rm..import datet
-00000030: 696d 650d 0a69 6d70 6f72 7420 6c6f 6767  ime..import logg
-00000040: 696e 670d 0a69 6d70 6f72 7420 7261 6e64  ing..import rand
-00000050: 6f6d 0d0a 696d 706f 7274 2063 6f70 790d  om..import copy.
-00000060: 0a69 6d70 6f72 7420 6d61 7468 0d0a 696d  .import math..im
-00000070: 706f 7274 2075 7362 0d0a 696d 706f 7274  port usb..import
-00000080: 2075 7362 2e63 6f72 650d 0a69 6d70 6f72   usb.core..impor
-00000090: 7420 7573 622e 7574 696c 0d0a 696d 706f  t usb.util..impo
-000000a0: 7274 206f 730d 0a69 6d70 6f72 7420 7265  rt os..import re
-000000b0: 0d0a 0d0a 6672 6f6d 2074 7970 696e 6720  ....from typing 
-000000c0: 696d 706f 7274 2054 7970 6556 6172 2c20  import TypeVar, 
-000000d0: 416e 792c 2043 616c 6c61 626c 650d 0a66  Any, Callable..f
-000000e0: 726f 6d20 7261 6e64 6f6d 2069 6d70 6f72  rom random impor
-000000f0: 7420 7261 6e64 696e 740d 0a66 726f 6d20  t randint..from 
-00000100: 7469 6d65 2020 2069 6d70 6f72 7420 736c  time   import sl
-00000110: 6565 700d 0a0d 0a66 726f 6d20 2e20 696d  eep....from . im
-00000120: 706f 7274 2075 7469 6c73 0d0a 0d0a 6672  port utils....fr
-00000130: 6f6d 202e 5370 6563 7472 6f6d 6574 6572  om .Spectrometer
-00000140: 5365 7474 696e 6773 2069 6d70 6f72 7420  Settings import 
-00000150: 5370 6563 7472 6f6d 6574 6572 5365 7474  SpectrometerSett
-00000160: 696e 6773 0d0a 6672 6f6d 202e 5370 6563  ings..from .Spec
-00000170: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
-00000180: 2069 6d70 6f72 7420 5370 6563 7472 6f6d   import Spectrom
-00000190: 6574 6572 5265 7370 6f6e 7365 0d0a 6672  eterResponse..fr
-000001a0: 6f6d 202e 5370 6563 7472 6f6d 6574 6572  om .Spectrometer
-000001b0: 5265 7175 6573 7420 2069 6d70 6f72 7420  Request  import 
-000001c0: 5370 6563 7472 6f6d 6574 6572 5265 7175  SpectrometerRequ
-000001d0: 6573 740d 0a66 726f 6d20 2e53 7065 6374  est..from .Spect
-000001e0: 726f 6d65 7465 7252 6573 706f 6e73 6520  rometerResponse 
-000001f0: 696d 706f 7274 2045 7272 6f72 4c65 7665  import ErrorLeve
-00000200: 6c0d 0a66 726f 6d20 2e53 7065 6374 726f  l..from .Spectro
-00000210: 6d65 7465 7253 7461 7465 2020 2020 696d  meterState    im
-00000220: 706f 7274 2053 7065 6374 726f 6d65 7465  port Spectromete
-00000230: 7253 7461 7465 0d0a 6672 6f6d 202e 496e  rState..from .In
-00000240: 7465 7266 6163 6544 6576 6963 6520 2020  terfaceDevice   
-00000250: 2020 2069 6d70 6f72 7420 496e 7465 7266     import Interf
-00000260: 6163 6544 6576 6963 650d 0a66 726f 6d20  aceDevice..from 
-00000270: 2e44 6574 6563 746f 7252 6567 696f 6e73  .DetectorRegions
-00000280: 2020 2020 2020 696d 706f 7274 2044 6574        import Det
-00000290: 6563 746f 7252 6567 696f 6e73 0d0a 6672  ectorRegions..fr
-000002a0: 6f6d 202e 5374 6174 7573 4d65 7373 6167  om .StatusMessag
-000002b0: 6520 2020 2020 2020 2069 6d70 6f72 7420  e        import 
-000002c0: 5374 6174 7573 4d65 7373 6167 650d 0a66  StatusMessage..f
-000002d0: 726f 6d20 2e52 6561 6c55 5342 4465 7669  rom .RealUSBDevi
-000002e0: 6365 2020 2020 2020 2020 696d 706f 7274  ce        import
-000002f0: 2052 6561 6c55 5342 4465 7669 6365 0d0a   RealUSBDevice..
-00000300: 6672 6f6d 202e 4d6f 636b 5553 4244 6576  from .MockUSBDev
-00000310: 6963 6520 2020 2020 2020 2069 6d70 6f72  ice        impor
-00000320: 7420 4d6f 636b 5553 4244 6576 6963 650d  t MockUSBDevice.
-00000330: 0a66 726f 6d20 2e44 6574 6563 746f 7252  .from .DetectorR
-00000340: 4f49 2020 2020 2020 2020 2020 696d 706f  OI          impo
-00000350: 7274 2044 6574 6563 746f 7252 4f49 0d0a  rt DetectorROI..
-00000360: 6672 6f6d 202e 4545 5052 4f4d 2020 2020  from .EEPROM    
-00000370: 2020 2020 2020 2020 2020 2069 6d70 6f72             impor
-00000380: 7420 4545 5052 4f4d 0d0a 0d0a 6c6f 6720  t EEPROM....log 
-00000390: 3d20 6c6f 6767 696e 672e 6765 744c 6f67  = logging.getLog
-000003a0: 6765 7228 5f5f 6e61 6d65 5f5f 290d 0a0d  ger(__name__)...
-000003b0: 0a4d 4943 524f 5345 435f 544f 5f53 4543  .MICROSEC_TO_SEC
-000003c0: 203d 2030 2e30 3030 3030 310d 0a55 4e49   = 0.000001..UNI
-000003d0: 4e49 5449 414c 495a 4544 5f54 454d 5045  NITIALIZED_TEMPE
-000003e0: 5241 5455 5245 5f44 4547 5f43 203d 202d  RATURE_DEG_C = -
-000003f0: 3939 390d 0a0d 0a63 6c61 7373 2053 7065  999....class Spe
-00000400: 6374 7275 6d41 6e64 526f 773a 0d0a 2020  ctrumAndRow:..  
-00000410: 2020 6465 6620 5f5f 696e 6974 5f5f 2873    def __init__(s
-00000420: 656c 662c 2073 7065 6374 7275 6d3d 4e6f  elf, spectrum=No
-00000430: 6e65 2c20 726f 773d 2d31 293a 0d0a 2020  ne, row=-1):..  
-00000440: 2020 2020 2020 7365 6c66 2e73 7065 6374        self.spect
-00000450: 7275 6d20 3d20 4e6f 6e65 0d0a 2020 2020  rum = None..    
-00000460: 2020 2020 7365 6c66 2e72 6f77 203d 2072      self.row = r
-00000470: 6f77 0d0a 0d0a 2020 2020 2020 2020 6966  ow....        if
-00000480: 2073 7065 6374 7275 6d20 6973 206e 6f74   spectrum is not
-00000490: 204e 6f6e 653a 0d0a 2020 2020 2020 2020   None:..        
-000004a0: 2020 2020 7365 6c66 2e73 7065 6374 7275      self.spectru
-000004b0: 6d20 3d20 7370 6563 7472 756d 2e63 6f70  m = spectrum.cop
-000004c0: 7928 290d 0a0d 0a63 6c61 7373 2046 6561  y()....class Fea
-000004d0: 7475 7265 4964 656e 7469 6669 6361 7469  tureIdentificati
-000004e0: 6f6e 4465 7669 6365 2849 6e74 6572 6661  onDevice(Interfa
-000004f0: 6365 4465 7669 6365 293a 0d0a 2020 2020  ceDevice):..    
-00000500: 2222 220d 0a20 2020 2054 6869 7320 6973  """..    This is
-00000510: 2074 6865 2062 6173 6963 2069 6d70 6c65   the basic imple
-00000520: 6d65 6e74 6174 696f 6e20 6f66 206f 7572  mentation of our
-00000530: 2046 6561 7475 7265 4964 656e 7469 6669   FeatureIdentifi
-00000540: 6361 7469 6f6e 4465 7669 6365 2028 4649  cationDevice (FI
-00000550: 4429 0d0a 2020 2020 7370 6563 7472 6f6d  D)..    spectrom
-00000560: 6574 6572 2055 5342 2041 5049 2061 7320  eter USB API as 
-00000570: 6465 6669 6e65 6420 696e 2045 4e47 2d30  defined in ENG-0
-00000580: 3030 312e 0d0a 2020 2020 5468 6973 2063  001...    This c
-00000590: 6c61 7373 2069 7320 726f 7567 686c 7920  lass is roughly 
-000005a0: 636f 6d70 6172 6162 6c65 2074 6f20 5761  comparable to Wa
-000005b0: 7361 7463 682e 4e45 5427 7320 5370 6563  satch.NET's Spec
-000005c0: 7472 6f6d 6574 6572 2e63 732e 0d0a 2020  trometer.cs...  
-000005d0: 2020 0d0a 2020 2020 5468 6973 2063 6c61    ..    This cla
-000005e0: 7373 2069 7320 6e6f 726d 616c 6c79 206e  ss is normally n
-000005f0: 6f74 2061 6363 6573 7365 6420 6469 7265  ot accessed dire
-00000600: 6374 6c79 2c20 6275 7420 7468 726f 7567  ctly, but throug
-00000610: 6820 7468 6520 6869 6768 6572 2d6c 6576  h the higher-lev
-00000620: 656c 0d0a 2020 2020 6162 7374 7261 6374  el..    abstract
-00000630: 696f 6e20 5761 7361 7463 6844 6576 6963  ion WasatchDevic
-00000640: 652e 0d0a 2020 2020 0d0a 2020 2020 4073  e...    ..    @s
-00000650: 6565 2045 4e47 2d30 3030 310d 0a20 2020  ee ENG-0001..   
-00000660: 2023 2323 2323 2323 2323 2323 2323 2323   ###############
-00000670: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000680: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000690: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000006a0: 2323 2323 2323 2323 2323 230d 0a20 2020  ###########..   
-000006b0: 2054 6869 7320 636c 6173 7320 6164 6f70   This class adop
-000006c0: 7473 2074 6865 2065 7874 6572 6e61 6c20  ts the external 
-000006d0: 6465 7669 6365 2069 6e74 6572 6661 6365  device interface
-000006e0: 2073 7472 7563 7475 7265 0d0a 2020 2020   structure..    
-000006f0: 5468 6973 2069 6e76 6c6f 766c 6573 2072  This invlovles r
-00000700: 6563 6569 7669 6e67 2061 2072 6571 7565  eceiving a reque
-00000710: 7374 2074 6872 6f75 6768 2074 6865 2068  st through the h
-00000720: 616e 646c 655f 7265 7175 6573 7420 6675  andle_request fu
-00000730: 6e63 7469 6f6e 0d0a 2020 2020 4120 7265  nction..    A re
-00000740: 7175 6573 7420 6973 2070 726f 6365 7373  quest is process
-00000750: 6564 2062 6173 6564 206f 6e20 7468 6520  ed based on the 
-00000760: 6b65 7920 696e 2074 6865 2072 6571 7565  key in the reque
-00000770: 7374 0d0a 2020 2020 5468 6520 7072 6f63  st..    The proc
-00000780: 6573 7369 6e67 2066 756e 6374 696f 6e20  essing function 
-00000790: 7061 7373 6573 2074 6865 2063 6f6d 6d61  passes the comma
-000007a0: 6e64 7320 746f 2074 6865 2072 6571 7565  nds to the reque
-000007b0: 7374 6564 2064 6576 6963 650d 0a20 2020  sted device..   
-000007c0: 204f 6e63 6520 6974 2072 6563 6576 6965   Once it recevie
-000007d0: 7320 6120 7265 7370 6f6e 7365 2066 726f  s a response fro
-000007e0: 6d20 7468 6520 636f 6e6e 6563 7465 6420  m the connected 
-000007f0: 6465 7669 6365 2069 7420 7468 656e 2070  device it then p
-00000800: 6173 7365 7320 7468 6174 0d0a 2020 2020  asses that..    
-00000810: 6261 636b 2075 7020 7468 6520 6368 6169  back up the chai
-00000820: 6e0d 0a20 2020 2020 2020 2020 2020 2020  n..             
-00000830: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000840: 2020 456e 6c69 6768 7465 6e20 5265 7175    Enlighten Requ
-00000850: 6573 740d 0a20 2020 2020 2020 2020 2020  est..           
-00000860: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000870: 2020 2020 2020 2020 2020 2020 7c0d 0a20              |.. 
-00000880: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000890: 2020 2020 2020 2020 2020 2020 2020 2068                 h
-000008a0: 616e 646c 655f 7265 7175 6573 7473 0d0a  andle_requests..
-000008b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000008c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000008d0: 2020 2020 2020 207c 0d0a 2020 2020 2020         |..      
-000008e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000008f0: 2020 2020 2020 2020 2020 202d 2d2d 2d2d             -----
-00000900: 2d2d 2d2d 2d2d 2d0d 0a20 2020 2020 2020  -------..       
-00000910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000920: 2020 2020 2020 2020 202f 2020 202f 2020           /   /  
-00000930: 7c20 205c 2020 5c0d 0a20 2020 2020 2020  |  \  \..       
-00000940: 2020 2020 2020 7b20 6765 745f 6c61 7365        { get_lase
-00000950: 7220 7374 6174 7573 2c20 6163 7175 6972  r status, acquir
-00000960: 652c 2073 6574 5f6c 6173 6572 5f77 6174  e, set_laser_wat
-00000970: 6368 646f 672c 2065 7463 2e2e 2e2e 7d0d  chdog, etc....}.
-00000980: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00000990: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000009a0: 205c 2020 205c 2020 7c20 202f 2020 2f0d   \   \  |  /  /.
-000009b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000009c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000009d0: 2020 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0d0a    ------------..
-000009e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000009f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000a00: 2020 2020 2020 207c 0d0a 2020 2020 2020         |..      
-00000a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000a20: 2020 2020 2020 2020 2020 2020 205f 7365               _se
-00000a30: 6e64 5f63 6f64 650d 0a20 2020 2023 2323  nd_code..    ###
+00000000: 696d 706f 7274 2070 6c61 7466 6f72 6d0a  import platform.
+00000010: 696d 706f 7274 2064 6174 6574 696d 650a  import datetime.
+00000020: 696d 706f 7274 206c 6f67 6769 6e67 0a69  import logging.i
+00000030: 6d70 6f72 7420 7261 6e64 6f6d 0a69 6d70  mport random.imp
+00000040: 6f72 7420 636f 7079 0a69 6d70 6f72 7420  ort copy.import 
+00000050: 6d61 7468 0a69 6d70 6f72 7420 6f73 0a69  math.import os.i
+00000060: 6d70 6f72 7420 7265 0a0a 6672 6f6d 2072  mport re..from r
+00000070: 616e 646f 6d20 696d 706f 7274 2072 616e  andom import ran
+00000080: 6469 6e74 0a66 726f 6d20 7469 6d65 2020  dint.from time  
+00000090: 2069 6d70 6f72 7420 736c 6565 700a 0a66   import sleep..f
+000000a0: 726f 6d20 2e20 696d 706f 7274 2075 7469  rom . import uti
+000000b0: 6c73 0a0a 6672 6f6d 202e 5370 6563 7472  ls..from .Spectr
+000000c0: 6f6d 6574 6572 5365 7474 696e 6773 2069  ometerSettings i
+000000d0: 6d70 6f72 7420 5370 6563 7472 6f6d 6574  mport Spectromet
+000000e0: 6572 5365 7474 696e 6773 0a66 726f 6d20  erSettings.from 
+000000f0: 2e53 7065 6374 726f 6d65 7465 7252 6573  .SpectrometerRes
+00000100: 706f 6e73 6520 696d 706f 7274 2053 7065  ponse import Spe
+00000110: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
+00000120: 650a 6672 6f6d 202e 5370 6563 7472 6f6d  e.from .Spectrom
+00000130: 6574 6572 5265 7175 6573 7420 2069 6d70  eterRequest  imp
+00000140: 6f72 7420 5370 6563 7472 6f6d 6574 6572  ort Spectrometer
+00000150: 5265 7175 6573 740a 6672 6f6d 202e 5370  Request.from .Sp
+00000160: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
+00000170: 7365 2069 6d70 6f72 7420 4572 726f 724c  se import ErrorL
+00000180: 6576 656c 0a66 726f 6d20 2e53 7065 6374  evel.from .Spect
+00000190: 726f 6d65 7465 7253 7461 7465 2020 2020  rometerState    
+000001a0: 696d 706f 7274 2053 7065 6374 726f 6d65  import Spectrome
+000001b0: 7465 7253 7461 7465 0a66 726f 6d20 2e49  terState.from .I
+000001c0: 6e74 6572 6661 6365 4465 7669 6365 2020  nterfaceDevice  
+000001d0: 2020 2020 696d 706f 7274 2049 6e74 6572      import Inter
+000001e0: 6661 6365 4465 7669 6365 0a66 726f 6d20  faceDevice.from 
+000001f0: 2e44 6574 6563 746f 7252 6567 696f 6e73  .DetectorRegions
+00000200: 2020 2020 2020 696d 706f 7274 2044 6574        import Det
+00000210: 6563 746f 7252 6567 696f 6e73 0a66 726f  ectorRegions.fro
+00000220: 6d20 2e53 7461 7475 734d 6573 7361 6765  m .StatusMessage
+00000230: 2020 2020 2020 2020 696d 706f 7274 2053          import S
+00000240: 7461 7475 734d 6573 7361 6765 0a66 726f  tatusMessage.fro
+00000250: 6d20 2e52 6561 6c55 5342 4465 7669 6365  m .RealUSBDevice
+00000260: 2020 2020 2020 2020 696d 706f 7274 2052          import R
+00000270: 6561 6c55 5342 4465 7669 6365 0a66 726f  ealUSBDevice.fro
+00000280: 6d20 2e4d 6f63 6b55 5342 4465 7669 6365  m .MockUSBDevice
+00000290: 2020 2020 2020 2020 696d 706f 7274 204d          import M
+000002a0: 6f63 6b55 5342 4465 7669 6365 0a66 726f  ockUSBDevice.fro
+000002b0: 6d20 2e44 6574 6563 746f 7252 4f49 2020  m .DetectorROI  
+000002c0: 2020 2020 2020 2020 696d 706f 7274 2044          import D
+000002d0: 6574 6563 746f 7252 4f49 0a66 726f 6d20  etectorROI.from 
+000002e0: 2e50 6f6c 6c53 7461 7475 7320 2020 2020  .PollStatus     
+000002f0: 2020 2020 2020 696d 706f 7274 2050 6f6c        import Pol
+00000300: 6c53 7461 7475 730a 6672 6f6d 202e 4545  lStatus.from .EE
+00000310: 5052 4f4d 2020 2020 2020 2020 2020 2020  PROM            
+00000320: 2020 2069 6d70 6f72 7420 4545 5052 4f4d     import EEPROM
+00000330: 0a0a 6c6f 6720 3d20 6c6f 6767 696e 672e  ..log = logging.
+00000340: 6765 744c 6f67 6765 7228 5f5f 6e61 6d65  getLogger(__name
+00000350: 5f5f 290a 0a4d 4943 524f 5345 435f 544f  __)..MICROSEC_TO
+00000360: 5f53 4543 203d 2030 2e30 3030 3030 310a  _SEC = 0.000001.
+00000370: 554e 494e 4954 4941 4c49 5a45 445f 5445  UNINITIALIZED_TE
+00000380: 4d50 4552 4154 5552 455f 4445 475f 4320  MPERATURE_DEG_C 
+00000390: 3d20 2d39 3939 0a0a 636c 6173 7320 5370  = -999..class Sp
+000003a0: 6563 7472 756d 416e 6452 6f77 3a0a 2020  ectrumAndRow:.  
+000003b0: 2020 6465 6620 5f5f 696e 6974 5f5f 2873    def __init__(s
+000003c0: 656c 662c 2073 7065 6374 7275 6d3d 4e6f  elf, spectrum=No
+000003d0: 6e65 2c20 726f 773d 2d31 293a 0a20 2020  ne, row=-1):.   
+000003e0: 2020 2020 2073 656c 662e 7370 6563 7472       self.spectr
+000003f0: 756d 203d 204e 6f6e 650a 2020 2020 2020  um = None.      
+00000400: 2020 7365 6c66 2e72 6f77 203d 2072 6f77    self.row = row
+00000410: 0a0a 2020 2020 2020 2020 6966 2073 7065  ..        if spe
+00000420: 6374 7275 6d20 6973 206e 6f74 204e 6f6e  ctrum is not Non
+00000430: 653a 0a20 2020 2020 2020 2020 2020 2073  e:.            s
+00000440: 656c 662e 7370 6563 7472 756d 203d 2073  elf.spectrum = s
+00000450: 7065 6374 7275 6d2e 636f 7079 2829 0a0a  pectrum.copy()..
+00000460: 636c 6173 7320 4665 6174 7572 6549 6465  class FeatureIde
+00000470: 6e74 6966 6963 6174 696f 6e44 6576 6963  ntificationDevic
+00000480: 6528 496e 7465 7266 6163 6544 6576 6963  e(InterfaceDevic
+00000490: 6529 3a0a 2020 2020 2222 220a 2020 2020  e):.    """.    
+000004a0: 5468 6973 2069 7320 7468 6520 6261 7369  This is the basi
+000004b0: 6320 696d 706c 656d 656e 7461 7469 6f6e  c implementation
+000004c0: 206f 6620 6f75 7220 4665 6174 7572 6549   of our FeatureI
+000004d0: 6465 6e74 6966 6963 6174 696f 6e44 6576  dentificationDev
+000004e0: 6963 6520 2846 4944 290a 2020 2020 7370  ice (FID).    sp
+000004f0: 6563 7472 6f6d 6574 6572 2055 5342 2041  ectrometer USB A
+00000500: 5049 2061 7320 6465 6669 6e65 6420 696e  PI as defined in
+00000510: 2045 4e47 2d30 3030 312e 0a20 2020 2054   ENG-0001..    T
+00000520: 6869 7320 636c 6173 7320 6973 2072 6f75  his class is rou
+00000530: 6768 6c79 2063 6f6d 7061 7261 626c 6520  ghly comparable 
+00000540: 746f 2057 6173 6174 6368 2e4e 4554 2773  to Wasatch.NET's
+00000550: 2053 7065 6374 726f 6d65 7465 722e 6373   Spectrometer.cs
+00000560: 2e0a 2020 2020 0a20 2020 2054 6869 7320  ..    .    This 
+00000570: 636c 6173 7320 6973 206e 6f72 6d61 6c6c  class is normall
+00000580: 7920 6e6f 7420 6163 6365 7373 6564 2064  y not accessed d
+00000590: 6972 6563 746c 792c 2062 7574 2074 6872  irectly, but thr
+000005a0: 6f75 6768 2074 6865 2068 6967 6865 722d  ough the higher-
+000005b0: 6c65 7665 6c0a 2020 2020 6162 7374 7261  level.    abstra
+000005c0: 6374 696f 6e20 5761 7361 7463 6844 6576  ction WasatchDev
+000005d0: 6963 652e 0a20 2020 200a 2020 2020 4073  ice..    .    @s
+000005e0: 6565 2045 4e47 2d30 3030 310a 2020 2020  ee ENG-0001.    
+000005f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000600: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000610: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000620: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000630: 2323 2323 2323 2323 2323 0a20 2020 2054  ##########.    T
+00000640: 6869 7320 636c 6173 7320 6164 6f70 7473  his class adopts
+00000650: 2074 6865 2065 7874 6572 6e61 6c20 6465   the external de
+00000660: 7669 6365 2069 6e74 6572 6661 6365 2073  vice interface s
+00000670: 7472 7563 7475 7265 0a20 2020 2054 6869  tructure.    Thi
+00000680: 7320 696e 766c 6f76 6c65 7320 7265 6365  s invlovles rece
+00000690: 6976 696e 6720 6120 7265 7175 6573 7420  iving a request 
+000006a0: 7468 726f 7567 6820 7468 6520 6861 6e64  through the hand
+000006b0: 6c65 5f72 6571 7565 7374 2066 756e 6374  le_request funct
+000006c0: 696f 6e0a 2020 2020 4120 7265 7175 6573  ion.    A reques
+000006d0: 7420 6973 2070 726f 6365 7373 6564 2062  t is processed b
+000006e0: 6173 6564 206f 6e20 7468 6520 6b65 7920  ased on the key 
+000006f0: 696e 2074 6865 2072 6571 7565 7374 0a20  in the request. 
+00000700: 2020 2054 6865 2070 726f 6365 7373 696e     The processin
+00000710: 6720 6675 6e63 7469 6f6e 2070 6173 7365  g function passe
+00000720: 7320 7468 6520 636f 6d6d 616e 6473 2074  s the commands t
+00000730: 6f20 7468 6520 7265 7175 6573 7465 6420  o the requested 
+00000740: 6465 7669 6365 0a20 2020 204f 6e63 6520  device.    Once 
+00000750: 6974 2072 6563 6576 6965 7320 6120 7265  it recevies a re
+00000760: 7370 6f6e 7365 2066 726f 6d20 7468 6520  sponse from the 
+00000770: 636f 6e6e 6563 7465 6420 6465 7669 6365  connected device
+00000780: 2069 7420 7468 656e 2070 6173 7365 7320   it then passes 
+00000790: 7468 6174 0a20 2020 2062 6163 6b20 7570  that.    back up
+000007a0: 2074 6865 2063 6861 696e 0a20 2020 2040   the chain.    @
+000007b0: 7665 7262 6174 696d 0a20 2020 2020 2020  verbatim.       
+000007c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000007d0: 2020 2020 2020 2020 456e 6c69 6768 7465          Enlighte
+000007e0: 6e20 5265 7175 6573 740a 2020 2020 2020  n Request.      
+000007f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000800: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000810: 207c 0a20 2020 2020 2020 2020 2020 2020   |.             
+00000820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000830: 2020 2068 616e 646c 655f 7265 7175 6573     handle_reques
+00000840: 7473 0a20 2020 2020 2020 2020 2020 2020  ts.             
+00000850: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000860: 2020 2020 2020 2020 2020 7c0a 2020 2020            |.    
+00000870: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000880: 2020 2020 2020 2020 2020 2020 202d 2d2d               ---
+00000890: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020 2020  ---------.      
+000008a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000008b0: 2020 2020 2020 2020 2020 2f20 2020 2f20            /   / 
+000008c0: 207c 2020 5c20 205c 200a 2020 2020 2020   |  \  \ .      
+000008d0: 2020 2020 2020 207b 2067 6574 5f6c 6173         { get_las
+000008e0: 6572 2073 7461 7475 732c 2061 6371 7569  er status, acqui
+000008f0: 7265 2c20 7365 745f 6c61 7365 725f 7761  re, set_laser_wa
+00000900: 7463 6864 6f67 2c20 6574 632e 2e2e 2e7d  tchdog, etc....}
+00000910: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00000920: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000930: 205c 2020 205c 2020 7c20 202f 2020 2f0a   \   \  |  /  /.
+00000940: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000950: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000960: 202d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0a 2020   ------------.  
+00000970: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000980: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000990: 2020 2020 207c 0a20 2020 2020 2020 2020       |.         
+000009a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000009b0: 2020 2020 2020 2020 2020 5f73 656e 645f            _send_
+000009c0: 636f 6465 0a20 2020 2040 656e 6476 6572  code.    @endver
+000009d0: 6261 7469 6d0a 2020 2020 2323 2323 2323  batim.    ######
+000009e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000009f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000a00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000a10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000a20: 2323 2323 2323 0a20 2020 2022 2222 0a0a  ######.    """..
+00000a30: 2020 2020 2320 2323 2323 2323 2323 2323      # ##########
 00000a40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00000a50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00000a60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00000a70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000a80: 2323 2323 2323 2323 230d 0a20 2020 2022  #########..    "
-00000a90: 2222 0d0a 0d0a 2020 2020 2320 2323 2323  ""....    # ####
+00000a80: 0a20 2020 2023 204c 6966 6563 7963 6c65  .    # Lifecycle
+00000a90: 0a20 2020 2023 2023 2323 2323 2323 2323  .    # #########
 00000aa0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00000ab0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00000ac0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00000ad0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000ae0: 2323 2323 2323 0d0a 2020 2020 2320 4c69  ######..    # Li
-00000af0: 6665 6379 636c 650d 0a20 2020 2023 2023  fecycle..    # #
-00000b00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000b10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000b20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000b30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000b40: 2323 2323 2323 2323 230d 0a0d 0a20 2020  #########....   
-00000b50: 2064 6566 205f 5f69 6e69 745f 5f28 7365   def __init__(se
-00000b60: 6c66 2c20 6465 7669 6365 5f69 643a 2073  lf, device_id: s
-00000b70: 7472 2c20 6d65 7373 6167 655f 7175 6575  tr, message_queu
-00000b80: 653a 206c 6973 7420 3d20 4e6f 6e65 293a  e: list = None):
-00000b90: 2023 202d 3e20 4e6f 6e65 200d 0a20 2020   # -> None ..   
-00000ba0: 2020 2020 2022 2222 0d0a 2020 2020 2020       """..      
-00000bb0: 2020 496e 7374 616e 7469 6174 6520 6120    Instantiate a 
-00000bc0: 4665 6174 7572 6549 6465 6e74 6966 6963  FeatureIdentific
-00000bd0: 6174 696f 6e44 6576 6963 6520 7769 7468  ationDevice with
-00000be0: 2066 726f 6d20 7468 6520 6769 7665 6e20   from the given 
-00000bf0: 6465 7669 6365 5f69 642e 0d0a 2020 2020  device_id...    
-00000c00: 2020 2020 4070 6172 616d 2064 6576 6963      @param devic
-00000c10: 655f 6964 205b 696e 5d20 6465 7669 6365  e_id [in] device
-00000c20: 2049 4420 2822 5553 423a 3078 3234 6161   ID ("USB:0x24aa
-00000c30: 3a30 7831 3030 303a 313a 3234 2229 0d0a  :0x1000:1:24")..
-00000c40: 2020 2020 2020 2020 4070 6172 616d 206d          @param m
-00000c50: 6573 7361 6765 5f71 7565 7565 205b 6f75  essage_queue [ou
-00000c60: 745d 2069 6620 7072 6f76 6964 6564 2c20  t] if provided, 
-00000c70: 7072 6f76 6964 6573 2061 6e20 6f75 7462  provides an outb
-00000c80: 6f75 6e64 2028 6672 6f6d 2046 4944 290d  ound (from FID).
-00000c90: 0a20 2020 2020 2020 2071 7565 7565 2066  .        queue f
-00000ca0: 6f72 2077 7269 7469 6e67 2053 7461 7475  or writing Statu
-00000cb0: 734d 6573 7361 6765 206f 626a 6563 7473  sMessage objects
-00000cc0: 2075 7073 7472 6561 6d0d 0a20 2020 2020   upstream..     
-00000cd0: 2020 2022 2222 0d0a 2020 2020 2020 2020     """..        
-00000ce0: 7375 7065 7228 292e 5f5f 696e 6974 5f5f  super().__init__
-00000cf0: 2829 0d0a 2020 2020 2020 2020 7365 6c66  ()..        self
-00000d00: 2e64 6576 6963 655f 6964 203d 2064 6576  .device_id = dev
-00000d10: 6963 655f 6964 0d0a 2020 2020 2020 2020  ice_id..        
-00000d20: 7365 6c66 2e6d 6573 7361 6765 5f71 7565  self.message_que
-00000d30: 7565 203d 206d 6573 7361 6765 5f71 7565  ue = message_que
-00000d40: 7565 0d0a 0d0a 2020 2020 2020 2020 7365  ue....        se
-00000d50: 6c66 2e64 6576 6963 6520 3d20 4e6f 6e65  lf.device = None
-00000d60: 0d0a 2020 2020 2020 2020 6966 2022 4d4f  ..        if "MO
-00000d70: 434b 2220 696e 2073 7472 2864 6576 6963  CK" in str(devic
-00000d80: 655f 6964 292e 7570 7065 7228 293a 0d0a  e_id).upper():..
-00000d90: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00000da0: 2e64 6576 6963 655f 7479 7065 203d 204d  .device_type = M
-00000db0: 6f63 6b55 5342 4465 7669 6365 2864 6576  ockUSBDevice(dev
-00000dc0: 6963 655f 6964 2e6e 616d 652c 205c 0d0a  ice_id.name, \..
+00000ae0: 230a 0a20 2020 2064 6566 205f 5f69 6e69  #..    def __ini
+00000af0: 745f 5f28 7365 6c66 2c20 6465 7669 6365  t__(self, device
+00000b00: 5f69 643a 2073 7472 2c20 6d65 7373 6167  _id: str, messag
+00000b10: 655f 7175 6575 653a 206c 6973 7420 3d20  e_queue: list = 
+00000b20: 4e6f 6e65 293a 0a20 2020 2020 2020 2022  None):.        "
+00000b30: 2222 0a20 2020 2020 2020 2049 6e73 7461  "".        Insta
+00000b40: 6e74 6961 7465 2061 2046 6561 7475 7265  ntiate a Feature
+00000b50: 4964 656e 7469 6669 6361 7469 6f6e 4465  IdentificationDe
+00000b60: 7669 6365 2077 6974 6820 6672 6f6d 2074  vice with from t
+00000b70: 6865 2067 6976 656e 2064 6576 6963 655f  he given device_
+00000b80: 6964 2e0a 2020 2020 2020 2020 4070 6172  id..        @par
+00000b90: 616d 2064 6576 6963 655f 6964 205b 696e  am device_id [in
+00000ba0: 5d20 6465 7669 6365 2049 4420 2822 5553  ] device ID ("US
+00000bb0: 423a 3078 3234 6161 3a30 7831 3030 303a  B:0x24aa:0x1000:
+00000bc0: 313a 3234 2229 0a20 2020 2020 2020 2040  1:24").        @
+00000bd0: 7061 7261 6d20 6d65 7373 6167 655f 7175  param message_qu
+00000be0: 6575 6520 5b6f 7574 5d20 6966 2070 726f  eue [out] if pro
+00000bf0: 7669 6465 642c 2070 726f 7669 6465 7320  vided, provides 
+00000c00: 616e 206f 7574 626f 756e 6420 2866 726f  an outbound (fro
+00000c10: 6d20 4649 4429 0a20 2020 2020 2020 2071  m FID).        q
+00000c20: 7565 7565 2066 6f72 2077 7269 7469 6e67  ueue for writing
+00000c30: 2053 7461 7475 734d 6573 7361 6765 206f   StatusMessage o
+00000c40: 626a 6563 7473 2075 7073 7472 6561 6d0a  bjects upstream.
+00000c50: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00000c60: 2020 2020 7375 7065 7228 292e 5f5f 696e      super().__in
+00000c70: 6974 5f5f 2829 0a20 2020 2020 2020 2073  it__().        s
+00000c80: 656c 662e 6465 7669 6365 5f69 6420 3d20  elf.device_id = 
+00000c90: 6465 7669 6365 5f69 640a 2020 2020 2020  device_id.      
+00000ca0: 2020 7365 6c66 2e6d 6573 7361 6765 5f71    self.message_q
+00000cb0: 7565 7565 203d 206d 6573 7361 6765 5f71  ueue = message_q
+00000cc0: 7565 7565 0a0a 2020 2020 2020 2020 7365  ueue..        se
+00000cd0: 6c66 2e64 6576 6963 6520 3d20 4e6f 6e65  lf.device = None
+00000ce0: 0a20 2020 2020 2020 2069 6620 224d 4f43  .        if "MOC
+00000cf0: 4b22 2069 6e20 7374 7228 6465 7669 6365  K" in str(device
+00000d00: 5f69 6429 2e75 7070 6572 2829 3a0a 2020  _id).upper():.  
+00000d10: 2020 2020 2020 2020 2020 7365 6c66 2e64            self.d
+00000d20: 6576 6963 655f 7479 7065 203d 204d 6f63  evice_type = Moc
+00000d30: 6b55 5342 4465 7669 6365 2864 6576 6963  kUSBDevice(devic
+00000d40: 655f 6964 2e6e 616d 652c 0a20 2020 2020  e_id.name,.     
+00000d50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000d70: 2020 2020 2020 2020 6465 7669 6365 5f69          device_i
+00000d80: 642e 6469 7265 6374 6f72 792c 0a20 2020  d.directory,.   
+00000d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000db0: 2020 2020 2020 2020 2020 6465 7669 6365            device
+00000dc0: 5f69 642e 6f76 6572 7269 6465 732c 0a20  _id.overrides,. 
 00000dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000de0: 6465 7669 6365 5f69 642e 6469 7265 6374  device_id.direct
-00000df0: 6f72 792c 0d0a 2020 2020 2020 2020 2020  ory,..          
-00000e00: 2020 2020 2020 6465 7669 6365 5f69 642e        device_id.
-00000e10: 6f76 6572 7269 6465 732c 0d0a 2020 2020  overrides,..    
-00000e20: 2020 2020 2020 2020 2020 2020 6465 7669              devi
-00000e30: 6365 5f69 642e 7370 6563 7472 615f 6f70  ce_id.spectra_op
-00000e40: 7469 6f6e 7329 0d0a 2020 2020 2020 2020  tions)..        
-00000e50: 656c 7365 3a0d 0a20 2020 2020 2020 2020  else:..         
-00000e60: 2020 2073 656c 662e 6465 7669 6365 5f74     self.device_t
-00000e70: 7970 6520 3d20 5265 616c 5553 4244 6576  ype = RealUSBDev
-00000e80: 6963 6528 6465 7669 6365 5f69 6429 0d0a  ice(device_id)..
-00000e90: 0d0a 2020 2020 2020 2020 7365 6c66 2e6c  ..        self.l
-00000ea0: 6173 745f 7573 625f 7469 6d65 7374 616d  ast_usb_timestam
-00000eb0: 7020 3d20 4e6f 6e65 0d0a 0d0a 2020 2020  p = None....    
-00000ec0: 2020 2020 7365 6c66 2e6c 6173 6572 5f74      self.laser_t
-00000ed0: 656d 7065 7261 7475 7265 5f69 6e76 616c  emperature_inval
-00000ee0: 6964 203d 2046 616c 7365 0d0a 2020 2020  id = False..    
-00000ef0: 2020 2020 7365 6c66 2e63 6364 5f74 656d      self.ccd_tem
-00000f00: 7065 7261 7475 7265 5f69 6e76 616c 6964  perature_invalid
-00000f10: 203d 2046 616c 7365 0d0a 0d0a 2020 2020   = False....    
-00000f20: 2020 2020 7365 6c66 2e73 6574 7469 6e67      self.setting
-00000f30: 7320 3d20 5370 6563 7472 6f6d 6574 6572  s = Spectrometer
-00000f40: 5365 7474 696e 6773 2864 6576 6963 655f  Settings(device_
-00000f50: 6964 290d 0a20 2020 2020 2020 2073 656c  id)..        sel
-00000f60: 662e 6565 7072 6f6d 5f62 6163 6b75 7020  f.eeprom_backup 
-00000f70: 3d20 4e6f 6e65 0d0a 0d0a 2020 2020 2020  = None....      
-00000f80: 2020 2320 2323 2323 2323 2323 2323 2323    # ############
-00000f90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000fa0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000fb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000fc0: 2323 2323 2323 2323 2323 0d0a 2020 2020  ##########..    
-00000fd0: 2020 2020 2320 7468 6573 6520 6172 6520      # these are 
-00000fe0: 2264 7269 7665 7220 7374 6174 6522 2077  "driver state" w
-00000ff0: 6974 6869 6e20 4665 6174 7572 6549 6465  ithin FeatureIde
-00001000: 6e74 6966 6963 6174 696f 6e44 6576 6963  ntificationDevic
-00001010: 652c 2061 6e64 2064 6f6e 2774 0d0a 2020  e, and don't..  
-00001020: 2020 2020 2020 2320 7265 616c 6c79 2072        # really r
-00001030: 656c 6174 6520 746f 2074 6865 2073 7065  elate to the spe
-00001040: 6374 726f 6d65 7465 7220 6861 7264 7761  ctrometer hardwa
-00001050: 7265 0d0a 2020 2020 2020 2020 2320 2323  re..        # ##
-00001060: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00001070: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00001080: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00001090: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000010a0: 2323 2323 0d0a 0d0a 2020 2020 2020 2020  ####....        
-000010b0: 7365 6c66 2e64 6574 6563 746f 725f 7465  self.detector_te
-000010c0: 635f 7365 7470 6f69 6e74 5f68 6173 5f62  c_setpoint_has_b
-000010d0: 6565 6e5f 7365 7420 3d20 4661 6c73 650d  een_set = False.
-000010e0: 0a20 2020 2020 2020 2073 656c 662e 6c61  .        self.la
-000010f0: 7374 5f61 7070 6c69 6564 5f6c 6173 6572  st_applied_laser
-00001100: 5f70 6f77 6572 203d 2030 2e30 2023 206c  _power = 0.0 # l
-00001110: 6173 7420 706f 7765 7220 6c65 7665 6c20  ast power level 
-00001120: 4150 504c 4945 4420 746f 206c 6173 6572  APPLIED to laser
-00001130: 2c20 6569 7468 6572 2062 7920 7475 726e  , either by turn
-00001140: 696e 6720 6f66 6620 2830 2920 6f72 206f  ing off (0) or o
-00001150: 6e20 0d0a 2020 2020 2020 2020 7365 6c66  n ..        self
-00001160: 2e6e 6578 745f 6170 706c 6965 645f 6c61  .next_applied_la
-00001170: 7365 725f 706f 7765 7220 3d20 4e6f 6e65  ser_power = None
-00001180: 2023 2070 6f77 6572 206c 6576 656c 2074   # power level t
-00001190: 6f20 6265 2061 7070 6c69 6564 204e 4558  o be applied NEX
-000011a0: 5420 7469 6d65 2074 6865 206c 6173 6572  T time the laser
-000011b0: 2069 7320 656e 6162 6c65 640d 0a0d 0a20   is enabled.... 
-000011c0: 2020 2020 2020 2073 656c 662e 7261 6973         self.rais
-000011d0: 655f 6578 6365 7074 696f 6e73 203d 2046  e_exceptions = F
-000011e0: 616c 7365 0d0a 2020 2020 2020 2020 7365  alse..        se
-000011f0: 6c66 2e69 6e6a 6563 745f 7261 6e64 6f6d  lf.inject_random
-00001200: 5f65 7272 6f72 7320 3d20 4661 6c73 650d  _errors = False.
-00001210: 0a20 2020 2020 2020 2073 656c 662e 7261  .        self.ra
-00001220: 6e64 6f6d 5f65 7272 6f72 5f70 6572 6320  ndom_error_perc 
-00001230: 3d20 302e 3030 3120 2020 2320 302e 3125  = 0.001   # 0.1%
-00001240: 0d0a 2020 2020 2020 2020 7365 6c66 2e61  ..        self.a
-00001250: 6c6c 6f77 5f64 6566 6175 6c74 5f67 6169  llow_default_gai
-00001260: 6e5f 7265 7365 7420 3d20 5472 7565 0d0a  n_reset = True..
-00001270: 0d0a 2020 2020 2020 2020 7365 6c66 2e63  ..        self.c
-00001280: 6f6e 6e65 6374 6564 203d 2046 616c 7365  onnected = False
-00001290: 0d0a 2020 2020 2020 2020 7365 6c66 2e63  ..        self.c
-000012a0: 6f6e 6e65 6374 696e 6720 3d20 4661 6c73  onnecting = Fals
-000012b0: 650d 0a20 2020 2020 2020 2073 656c 662e  e..        self.
-000012c0: 7368 7574 646f 776e 5f72 6571 7565 7374  shutdown_request
-000012d0: 6564 203d 2046 616c 7365 0d0a 0d0a 2020  ed = False....  
-000012e0: 2020 2020 2020 7365 6c66 2e6c 6173 745f        self.last_
-000012f0: 7370 6563 7472 756d 203d 204e 6f6e 650d  spectrum = None.
-00001300: 0a20 2020 2020 2020 2073 656c 662e 7370  .        self.sp
-00001310: 6563 7472 756d 5f63 6f75 6e74 203d 2030  ectrum_count = 0
-00001320: 0d0a 2020 2020 2020 2020 7365 6c66 2e70  ..        self.p
-00001330: 7265 765f 7069 7865 6c73 203d 204e 6f6e  rev_pixels = Non
-00001340: 650d 0a0d 0a20 2020 2020 2020 2023 2069  e....        # i
-00001350: 6e20 6361 7365 206f 6620 4932 4320 636f  n case of I2C co
-00001360: 6c6c 6973 696f 6e73 2077 6974 6869 6e20  llisions within 
-00001370: 7468 6520 7370 6563 7472 6f6d 6574 6572  the spectrometer
-00001380: 2c20 652e 672e 2064 7565 2074 6f20 6261  , e.g. due to ba
-00001390: 7474 6572 792d 4c45 4420 7374 6174 7573  ttery-LED status
-000013a0: 0d0a 2020 2020 2020 2020 7365 6c66 2e72  ..        self.r
-000013b0: 6574 7279 5f65 6e61 626c 6564 203d 2054  etry_enabled = T
-000013c0: 7275 650d 0a20 2020 2020 2020 2073 656c  rue..        sel
-000013d0: 662e 7265 7472 795f 6d73 203d 2035 0d0a  f.retry_ms = 5..
-000013e0: 2020 2020 2020 2020 7365 6c66 2e72 6574          self.ret
-000013f0: 7279 5f6d 6178 203d 2033 0d0a 0d0a 2020  ry_max = 3....  
-00001400: 2020 2020 2020 7365 6c66 2e70 726f 6365        self.proce
-00001410: 7373 5f66 203d 2073 656c 662e 5f69 6e69  ss_f = self._ini
-00001420: 745f 7072 6f63 6573 735f 6675 6e63 7328  t_process_funcs(
-00001430: 290d 0a0d 0a20 2020 2064 6566 2068 616e  )....    def han
-00001440: 646c 655f 7265 7175 6573 7473 2873 656c  dle_requests(sel
-00001450: 662c 2072 6571 7565 7374 733a 206c 6973  f, requests: lis
-00001460: 745b 5370 6563 7472 6f6d 6574 6572 5265  t[SpectrometerRe
-00001470: 7175 6573 745d 293a 2023 202d 3e20 6c69  quest]): # -> li
-00001480: 7374 5b53 7065 6374 726f 6d65 7465 7252  st[SpectrometerR
-00001490: 6573 706f 6e73 655d 200d 0a20 2020 2020  esponse] ..     
-000014a0: 2020 2022 2222 0d0a 2020 2020 2020 2020     """..        
-000014b0: 4074 6f64 6f20 636f 6e73 6964 6572 206d  @todo consider m
-000014c0: 616b 696e 6720 2772 6571 7565 7374 7327  aking 'requests'
-000014d0: 2061 6e20 6f62 6a65 6374 2c20 616e 6420   an object, and 
-000014e0: 6479 6e61 6d69 6361 6c6c 7920 6368 6563  dynamically chec
-000014f0: 6b69 6e67 2074 6f20 0d0a 2020 2020 2020  king to ..      
-00001500: 2020 2020 2020 2020 7365 6520 6966 2069          see if i
-00001510: 7420 6973 2061 2073 696e 676c 6520 5370  t is a single Sp
-00001520: 6563 7472 6f6d 6574 6572 5265 7175 6573  ectrometerReques
-00001530: 7420 6f72 2061 206c 6973 745b 5370 6563  t or a list[Spec
-00001540: 7472 6f6d 6574 6572 5265 7175 6573 745d  trometerRequest]
-00001550: 3b0d 0a20 2020 2020 2020 2020 2020 2020  ;..             
-00001560: 2069 6620 7468 6520 666f 726d 6572 2c20   if the former, 
-00001570: 6f6e 6c79 2072 6574 7572 6e20 6120 7369  only return a si
-00001580: 6e67 6c65 2053 7065 6374 726f 6d65 7465  ngle Spectromete
-00001590: 7252 6573 706f 6e73 652e 0d0a 2020 2020  rResponse...    
-000015a0: 2020 2020 2222 220d 0a20 2020 2020 2020      """..       
-000015b0: 2072 6573 706f 6e73 6573 203d 205b 5d0d   responses = [].
-000015c0: 0a20 2020 2020 2020 2066 6f72 2072 6571  .        for req
-000015d0: 7565 7374 2069 6e20 7265 7175 6573 7473  uest in requests
-000015e0: 3a0d 0a20 2020 2020 2020 2020 2020 2074  :..            t
-000015f0: 7279 3a0d 0a20 2020 2020 2020 2020 2020  ry:..           
-00001600: 2020 2020 2063 6d64 203d 2072 6571 7565       cmd = reque
-00001610: 7374 2e63 6d64 0d0a 2020 2020 2020 2020  st.cmd..        
-00001620: 2020 2020 2020 2020 7072 6f63 5f66 756e          proc_fun
-00001630: 6320 3d20 7365 6c66 2e70 726f 6365 7373  c = self.process
-00001640: 5f66 2e67 6574 2863 6d64 2c20 4e6f 6e65  _f.get(cmd, None
-00001650: 290d 0a20 2020 2020 2020 2020 2020 2020  )..             
-00001660: 2020 2069 6620 7072 6f63 5f66 756e 6320     if proc_func 
-00001670: 3d3d 204e 6f6e 653a 0d0a 2020 2020 2020  == None:..      
-00001680: 2020 2020 2020 2020 2020 2020 2020 7265                re
-00001690: 7370 6f6e 7365 732e 6170 7065 6e64 2853  sponses.append(S
-000016a0: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
-000016b0: 6e73 6528 6572 726f 725f 6d73 673d 6622  nse(error_msg=f"
-000016c0: 756e 7375 7070 6f72 7465 6420 636d 6420  unsupported cmd 
-000016d0: 7b72 6571 7565 7374 2e63 6d64 7d22 2c20  {request.cmd}", 
-000016e0: 6572 726f 725f 6c76 6c3d 4572 726f 724c  error_lvl=ErrorL
-000016f0: 6576 656c 2e6c 6f77 2929 0d0a 2020 2020  evel.low))..    
-00001700: 2020 2020 2020 2020 2020 2020 656c 6966              elif
-00001710: 2072 6571 7565 7374 2e61 7267 7320 3d3d   request.args ==
-00001720: 205b 5d20 616e 6420 7265 7175 6573 742e   [] and request.
-00001730: 6b77 6172 6773 203d 3d20 7b7d 3a0d 0a20  kwargs == {}:.. 
-00001740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001750: 2020 2072 6573 706f 6e73 6573 2e61 7070     responses.app
-00001760: 656e 6428 7072 6f63 5f66 756e 6328 2929  end(proc_func())
-00001770: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00001780: 2020 656c 7365 3a0d 0a20 2020 2020 2020    else:..       
-00001790: 2020 2020 2020 2020 2020 2020 2072 6573               res
-000017a0: 706f 6e73 6573 2e61 7070 656e 6428 7072  ponses.append(pr
-000017b0: 6f63 5f66 756e 6328 2a72 6571 7565 7374  oc_func(*request
-000017c0: 2e61 7267 732c 202a 2a72 6571 7565 7374  .args, **request
-000017d0: 2e6b 7761 7267 7329 290d 0a20 2020 2020  .kwargs))..     
-000017e0: 2020 2020 2020 2065 7863 6570 7420 4578         except Ex
-000017f0: 6365 7074 696f 6e20 6173 2065 3a0d 0a20  ception as e:.. 
-00001800: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-00001810: 6f67 2e65 7272 6f72 2866 2265 7272 6f72  og.error(f"error
-00001820: 2069 6e20 6861 6e64 6c69 6e67 2072 6571   in handling req
-00001830: 7565 7374 207b 7265 7175 6573 747d 206f  uest {request} o
-00001840: 6620 7b65 7d22 290d 0a20 2020 2020 2020  f {e}")..       
-00001850: 2020 2020 2020 2020 2072 6573 706f 6e73           respons
-00001860: 6573 2e61 7070 656e 6428 5370 6563 7472  es.append(Spectr
-00001870: 6f6d 6574 6572 5265 7370 6f6e 7365 2865  ometerResponse(e
-00001880: 7272 6f72 5f6d 7367 3d22 6572 726f 7220  rror_msg="error 
-00001890: 7072 6f63 6573 7369 6e67 2063 6d64 222c  processing cmd",
-000018a0: 2065 7272 6f72 5f6c 766c 3d45 7272 6f72   error_lvl=Error
-000018b0: 4c65 7665 6c2e 6d65 6469 756d 2929 0d0a  Level.medium))..
-000018c0: 2020 2020 2020 2020 7265 7475 726e 2072          return r
-000018d0: 6573 706f 6e73 6573 0d0a 0d0a 2020 2020  esponses....    
-000018e0: 6465 6620 636f 6e6e 6563 7428 7365 6c66  def connect(self
-000018f0: 2c20 7265 7472 6965 733d 3029 3a20 2320  , retries=0): # 
-00001900: 2d3e 2053 7065 6374 726f 6d65 7465 7252  -> SpectrometerR
-00001910: 6573 706f 6e73 6520 0d0a 2020 2020 2020  esponse ..      
-00001920: 2020 2222 220d 0a20 2020 2020 2020 2043    """..        C
-00001930: 6f6e 6e65 6374 2074 6f20 7468 6520 6465  onnect to the de
-00001940: 7669 6365 2061 6e64 2069 6e69 7469 616c  vice and initial
-00001950: 697a 6520 6261 7369 6320 7365 7474 696e  ize basic settin
-00001960: 6773 2e0d 0a20 2020 2020 2020 2040 7761  gs...        @wa
-00001970: 726e 696e 6720 7468 6973 2063 6175 7365  rning this cause
-00001980: 7320 6120 7072 6f62 6c65 6d20 696e 206e  s a problem in n
-00001990: 6f6e 2d62 6c6f 636b 696e 6720 6d6f 6465  on-blocking mode
-000019a0: 2028 5761 7361 7463 6844 6576 6963 6557   (WasatchDeviceW
-000019b0: 7261 7070 6572 290d 0a20 2020 2020 2020  rapper)..       
-000019c0: 206f 6e20 4d61 634f 530d 0a20 2020 2020   on MacOS..     
-000019d0: 2020 2022 2222 0d0a 2020 2020 2020 2020     """..        
-000019e0: 7365 6c66 2e63 6f6e 6e65 6374 696e 6720  self.connecting 
-000019f0: 3d20 5472 7565 0d0a 0d0a 2020 2020 2020  = True....      
-00001a00: 2020 2320 2323 2323 2323 2323 2323 2323    # ############
-00001a10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00001a20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00001a30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00001a40: 2323 2323 2323 2323 2323 0d0a 2020 2020  ##########..    
-00001a50: 2020 2020 2320 5553 4220 436f 6e6e 6563      # USB Connec
-00001a60: 7469 6f6e 0d0a 2020 2020 2020 2020 2320  tion..        # 
-00001a70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00001a80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00001a90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00001aa0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00001ab0: 2323 2323 2323 0d0a 0d0a 2020 2020 2020  ######....      
-00001ac0: 2020 2320 4765 6e65 7261 7465 2061 2066    # Generate a f
-00001ad0: 7265 7368 206c 6973 7469 6e67 206f 6620  resh listing of 
-00001ae0: 5553 4220 6465 7669 6365 7320 7769 7468  USB devices with
-00001af0: 2074 6865 2072 6571 7565 7374 6564 2056   the requested V
-00001b00: 4944 2061 6e64 2050 4944 2e0d 0a20 2020  ID and PID...   
-00001b10: 2020 2020 2023 204e 6f74 6520 7468 6174       # Note that
-00001b20: 2074 6869 7320 6973 204e 4f54 2068 6f77   this is NOT how
-00001b30: 2057 6173 6174 6368 4275 7320 7472 6176   WasatchBus trav
-00001b40: 6572 7365 7320 7468 6520 6c69 7374 2e20  erses the list. 
-00001b50: 2049 7420 6163 7475 616c 6c79 0d0a 2020   It actually..  
-00001b60: 2020 2020 2020 2320 6361 6c6c 7320 7573        # calls us
-00001b70: 622e 6275 7373 6573 2829 2c20 7468 656e  b.busses(), then
-00001b80: 2069 7465 7261 7465 7320 6f76 6572 2062   iterates over b
-00001b90: 7573 2e64 6576 6963 6573 2c20 6275 7420  us.devices, but 
-00001ba0: 7468 6174 2773 2062 6563 6175 7365 0d0a  that's because..
-00001bb0: 2020 2020 2020 2020 2320 6974 2064 6f65          # it doe
-00001bc0: 736e 2774 206b 6e6f 7720 7768 6174 2050  sn't know what P
-00001bd0: 4944 7320 6974 206d 6967 6874 2062 6520  IDs it might be 
-00001be0: 6c6f 6f6b 696e 6720 666f 722e 2020 5765  looking for.  We
-00001bf0: 206b 6e6f 772c 2073 6f20 6a75 7374 0d0a   know, so just..
-00001c00: 2020 2020 2020 2020 2320 6e61 7272 6f77          # narrow
-00001c10: 2064 6f77 6e20 7468 6520 7365 6172 6368   down the search
-00001c20: 2074 6f20 7468 6f73 6520 6465 7669 6365   to those device
-00001c30: 732e 0d0a 0d0a 2020 2020 2020 2020 6c6f  s.....        lo
-00001c40: 672e 696e 666f 2866 2246 4944 2e63 6f6e  g.info(f"FID.con
-00001c50: 6e65 6374 3a20 6173 6b65 6420 746f 2063  nect: asked to c
-00001c60: 6f6e 6e65 6374 2074 6f20 6465 7669 6365  onnect to device
-00001c70: 5f74 7970 6520 7b73 656c 662e 6465 7669  _type {self.devi
-00001c80: 6365 5f74 7970 657d 2229 0d0a 2020 2020  ce_type}")..    
-00001c90: 2020 2020 6c6f 672e 696e 666f 2866 2246      log.info(f"F
-00001ca0: 4944 2e63 6f6e 6e65 6374 3a20 6361 6c6c  ID.connect: call
-00001cb0: 696e 6720 6465 7669 6365 5f74 7970 652e  ing device_type.
-00001cc0: 6669 6e64 2c20 6c6f 6f6b 696e 6720 666f  find, looking fo
-00001cd0: 7220 5649 4420 3078 7b73 656c 662e 6465  r VID 0x{self.de
-00001ce0: 7669 6365 5f69 642e 7669 643a 3034 787d  vice_id.vid:04x}
-00001cf0: 2061 6e64 2050 4944 2030 787b 7365 6c66   and PID 0x{self
-00001d00: 2e64 6576 6963 655f 6964 2e70 6964 3a30  .device_id.pid:0
-00001d10: 3478 7d22 290d 0a20 2020 2020 2020 2064  4x}")..        d
-00001d20: 6576 6963 6573 203d 2073 656c 662e 6465  evices = self.de
-00001d30: 7669 6365 5f74 7970 652e 6669 6e64 2866  vice_type.find(f
-00001d40: 696e 645f 616c 6c3d 5472 7565 2c20 6964  ind_all=True, id
-00001d50: 5665 6e64 6f72 3d73 656c 662e 6465 7669  Vendor=self.devi
-00001d60: 6365 5f69 642e 7669 642c 2069 6450 726f  ce_id.vid, idPro
-00001d70: 6475 6374 3d73 656c 662e 6465 7669 6365  duct=self.device
-00001d80: 5f69 642e 7069 6429 0d0a 2020 2020 2020  _id.pid)..      
-00001d90: 2020 6c6f 672e 696e 666f 2866 2246 4944    log.info(f"FID
-00001da0: 2e63 6f6e 6e65 6374 3a20 666f 756e 6420  .connect: found 
-00001db0: 6465 7669 6365 7320 7b64 6576 6963 6573  devices {devices
-00001dc0: 7d22 290d 0a20 2020 2020 2020 2064 6576  }")..        dev
-00001dd0: 5f6c 6973 7420 3d20 6c69 7374 2864 6576  _list = list(dev
-00001de0: 6963 6573 2920 2320 636f 6e76 6572 7420  ices) # convert 
-00001df0: 6672 6f6d 2061 7272 6179 0d0a 0d0a 2020  from array....  
-00001e00: 2020 2020 2020 6465 7669 6365 203d 204e        device = N
-00001e10: 6f6e 650d 0a20 2020 2020 2020 206c 6f67  one..        log
-00001e20: 2e69 6e66 6f28 6622 7365 6172 6368 696e  .info(f"searchin
-00001e30: 6720 666f 7220 7370 6563 6966 6965 6420  g for specified 
-00001e40: 6465 7669 6365 2069 6e20 6465 765f 6c69  device in dev_li
-00001e50: 7374 207b 6465 765f 6c69 7374 7d22 290d  st {dev_list}").
-00001e60: 0a20 2020 2020 2020 2066 6f72 2064 6576  .        for dev
-00001e70: 2069 6e20 6465 765f 6c69 7374 3a0d 0a20   in dev_list:.. 
-00001e80: 2020 2020 2020 2020 2020 2069 6620 6465             if de
-00001e90: 762e 6275 7320 213d 2073 656c 662e 6465  v.bus != self.de
-00001ea0: 7669 6365 5f69 642e 6275 733a 0d0a 2020  vice_id.bus:..  
-00001eb0: 2020 2020 2020 2020 2020 2020 2020 6c6f                lo
-00001ec0: 672e 6465 6275 6728 2246 4944 2e63 6f6e  g.debug("FID.con
-00001ed0: 6e65 6374 3a20 7265 6a65 6374 696e 6720  nect: rejecting 
-00001ee0: 6465 7669 6365 2028 6275 7320 2564 2021  device (bus %d !
-00001ef0: 3d20 7265 7175 6573 7465 6420 2564 2922  = requested %d)"
-00001f00: 2c20 6465 762e 6275 732c 2073 656c 662e  , dev.bus, self.
-00001f10: 6465 7669 6365 5f69 642e 6275 7329 0d0a  device_id.bus)..
-00001f20: 2020 2020 2020 2020 2020 2020 656c 6966              elif
-00001f30: 2064 6576 2e61 6464 7265 7373 2021 3d20   dev.address != 
-00001f40: 7365 6c66 2e64 6576 6963 655f 6964 2e61  self.device_id.a
-00001f50: 6464 7265 7373 3a0d 0a20 2020 2020 2020  ddress:..       
-00001f60: 2020 2020 2020 2020 206c 6f67 2e64 6562           log.deb
-00001f70: 7567 2822 4649 442e 636f 6e6e 6563 743a  ug("FID.connect:
-00001f80: 2072 656a 6563 7469 6e67 2064 6576 6963   rejecting devic
-00001f90: 6520 2861 6464 7265 7373 2025 6420 213d  e (address %d !=
-00001fa0: 2072 6571 7565 7374 6564 2025 6429 222c   requested %d)",
-00001fb0: 2064 6576 2e61 6464 7265 7373 2c20 7365   dev.address, se
-00001fc0: 6c66 2e64 6576 6963 655f 6964 2e61 6464  lf.device_id.add
-00001fd0: 7265 7373 290d 0a20 2020 2020 2020 2020  ress)..         
-00001fe0: 2020 2065 6c73 653a 0d0a 2020 2020 2020     else:..      
-00001ff0: 2020 2020 2020 2020 2020 6465 7669 6365            device
-00002000: 203d 2064 6576 0d0a 2020 2020 2020 2020   = dev..        
-00002010: 2020 2020 2020 2020 6272 6561 6b0d 0a0d          break...
-00002020: 0a20 2020 2020 2020 2069 6620 6465 7669  .        if devi
-00002030: 6365 2069 7320 4e6f 6e65 3a0d 0a20 2020  ce is None:..   
-00002040: 2020 2020 2020 2020 206c 6f67 2e64 6562           log.deb
-00002050: 7567 2866 2246 4944 2e63 6f6e 6e65 6374  ug(f"FID.connect
-00002060: 3a20 756e 6162 6c65 2074 6f20 6669 6e64  : unable to find
-00002070: 2044 6576 6963 6549 4420 7b73 656c 662e   DeviceID {self.
-00002080: 6465 7669 6365 5f69 647d 2229 0d0a 2020  device_id}")..  
-00002090: 2020 2020 2020 2020 2020 7365 6c66 2e63            self.c
-000020a0: 6f6e 6e65 6374 696e 6720 3d20 4661 6c73  onnecting = Fals
-000020b0: 650d 0a20 2020 2020 2020 2020 2020 2072  e..            r
-000020c0: 6574 7572 6e20 5370 6563 7472 6f6d 6574  eturn Spectromet
-000020d0: 6572 5265 7370 6f6e 7365 2864 6174 613d  erResponse(data=
-000020e0: 4661 6c73 652c 2065 7272 6f72 5f6d 7367  False, error_msg
-000020f0: 3d66 2275 6e61 626c 6520 746f 2066 696e  =f"unable to fin
-00002100: 6420 4465 7669 6365 4944 207b 7365 6c66  d DeviceID {self
-00002110: 2e64 6576 6963 655f 6964 7d22 290d 0a20  .device_id}").. 
-00002120: 2020 2020 2020 2065 6c73 653a 0d0a 2020         else:..  
-00002130: 2020 2020 2020 2020 2020 6c6f 672e 6465            log.de
-00002140: 6275 6728 2246 4944 2e63 6f6e 6e65 6374  bug("FID.connect
-00002150: 3a20 6d61 7463 6865 6420 4465 7669 6365  : matched Device
-00002160: 4944 2025 7322 2c20 7374 7228 7365 6c66  ID %s", str(self
-00002170: 2e64 6576 6963 655f 6964 2929 0d0a 0d0a  .device_id))....
-00002180: 2020 2020 2020 2020 6966 206f 732e 6e61          if os.na
-00002190: 6d65 2021 3d20 2270 6f73 6978 223a 0d0a  me != "posix":..
-000021a0: 2020 2020 2020 2020 2020 2020 6c6f 672e              log.
-000021b0: 6465 6275 6728 226f 6e20 5769 6e64 6f77  debug("on Window
-000021c0: 732c 2073 6f20 4e4f 5420 7365 7474 696e  s, so NOT settin
-000021d0: 6720 636f 6e66 6967 7572 6174 696f 6e20  g configuration 
-000021e0: 616e 6420 636c 6169 6d69 6e67 2069 6e74  and claiming int
-000021f0: 6572 6661 6365 2229 0d0a 2020 2020 2020  erface")..      
-00002200: 2020 656c 6966 2022 6d61 634f 5322 2069    elif "macOS" i
-00002210: 6e20 706c 6174 666f 726d 2e70 6c61 7466  n platform.platf
-00002220: 6f72 6d28 293a 0d0a 2020 2020 2020 2020  orm():..        
-00002230: 2020 2020 6c6f 672e 6465 6275 6728 226f      log.debug("o
-00002240: 6e20 4d61 634f 532c 2073 6f20 4e4f 5420  n MacOS, so NOT 
-00002250: 7365 7474 696e 6720 636f 6e66 6967 7572  setting configur
-00002260: 6174 696f 6e20 616e 6420 636c 6169 6d69  ation and claimi
-00002270: 6e67 2069 6e74 6572 6661 6365 2229 0d0a  ng interface")..
-00002280: 2020 2020 2020 2020 656c 7365 3a0d 0a20          else:.. 
-00002290: 2020 2020 2020 2020 2020 206c 6f67 2e64             log.d
-000022a0: 6562 7567 2822 6f6e 2070 6f73 6978 2c20  ebug("on posix, 
-000022b0: 736f 2073 6574 7469 6e67 2063 6f6e 6669  so setting confi
-000022c0: 6775 7261 7469 6f6e 2061 6e64 2063 6c61  guration and cla
-000022d0: 696d 696e 6720 696e 7465 7266 6163 6522  iming interface"
-000022e0: 290d 0a0d 0a20 2020 2020 2020 2020 2020  )....           
-000022f0: 2023 2069 6e20 7468 6520 666f 6c6c 6f77   # in the follow
-00002300: 696e 672c 2072 6574 7572 6e20 5370 6563  ing, return Spec
-00002310: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
-00002320: 206f 626a 6563 7473 2072 6174 6865 7220   objects rather 
-00002330: 7468 616e 200d 0a20 2020 2020 2020 2020  than ..         
-00002340: 2020 2023 2072 6169 7369 6e67 2065 7863     # raising exc
-00002350: 6570 7469 6f6e 7320 736f 2074 6865 2075  eptions so the u
-00002360: 7365 7220 7769 6c6c 2068 6176 6520 6120  ser will have a 
-00002370: 6d6f 7265 2d75 7365 6675 6c20 6572 726f  more-useful erro
-00002380: 7220 0d0a 2020 2020 2020 2020 2020 2020  r ..            
-00002390: 2320 6d65 7373 6167 6520 746f 2072 6570  # message to rep
-000023a0: 6f72 7420 6f72 2075 7365 2069 6e20 7472  ort or use in tr
-000023b0: 6f75 626c 6573 686f 6f74 696e 6720 2865  oubleshooting (e
-000023c0: 7863 6570 7469 6f6e 2073 7469 6c6c 2067  xception still g
-000023d0: 6574 730d 0a20 2020 2020 2020 2020 2020  ets..           
-000023e0: 2023 206c 6f67 6765 6429 0d0a 2020 2020   # logged)..    
-000023f0: 2020 2020 2020 2020 7472 793a 0d0a 2020          try:..  
-00002400: 2020 2020 2020 2020 2020 2020 2020 6c6f                lo
-00002410: 672e 6465 6275 6728 2273 6574 7469 6e67  g.debug("setting
-00002420: 2063 6f6e 6669 6775 7261 7469 6f6e 2229   configuration")
-00002430: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00002440: 2020 7265 7375 6c74 203d 2073 656c 662e    result = self.
-00002450: 6465 7669 6365 5f74 7970 652e 7365 745f  device_type.set_
-00002460: 636f 6e66 6967 7572 6174 696f 6e28 6465  configuration(de
-00002470: 7669 6365 290d 0a20 2020 2020 2020 2020  vice)..         
-00002480: 2020 2065 7863 6570 7420 4578 6365 7074     except Except
-00002490: 696f 6e20 6173 2065 7863 3a0d 0a20 2020  ion as exc:..   
-000024a0: 2020 2020 2020 2020 2020 2020 2023 2323               ###
-000024b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000024c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000024d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000024e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000024f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002500: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002510: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002520: 2323 0d0a 2020 2020 2020 2020 2020 2020  ##..            
-00002530: 2020 2020 2320 5468 6973 2061 6464 6974      # This addit
-00002540: 696f 6e61 6c20 6966 2073 7461 7465 6d65  ional if stateme
-00002550: 6e74 2069 7320 7072 6573 656e 7420 666f  nt is present fo
-00002560: 7220 7468 6520 5261 7370 6265 7272 7920  r the Raspberry 
-00002570: 5069 2e20 5468 6572 6520 6973 2061 6e20  Pi. There is an 
-00002580: 6973 7375 6520 7769 7468 2072 6573 6f75  issue with resou
-00002590: 7263 6520 6275 7379 2065 7272 6f72 732e  rce busy errors.
-000025a0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000025b0: 2020 2320 4164 6469 6e67 2064 6576 2e72    # Adding dev.r
-000025c0: 6573 6574 2829 2073 6f6c 7665 7320 7468  eset() solves th
-000025d0: 6973 2e20 5365 6520 6874 7470 733a 2f2f  is. See https://
-000025e0: 7374 6163 6b6f 7665 7266 6c6f 772e 636f  stackoverflow.co
-000025f0: 6d2f 7175 6573 7469 6f6e 732f 3239 3334  m/questions/2934
-00002600: 3533 3235 2f72 6173 7062 6572 7279 2d70  5325/raspberry-p
-00002610: 7975 7362 2d67 6574 732d 7265 736f 7572  yusb-gets-resour
-00002620: 6365 2d62 7573 790d 0a20 2020 2020 2020  ce-busy..       
-00002630: 2020 2020 2020 2020 2023 2323 2323 2323           #######
-00002640: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002650: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002660: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002670: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002680: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002690: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000026a0: 2323 2323 2323 2323 2323 2323 2323 0d0a  ##############..
-000026b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000026c0: 6966 2022 5265 736f 7572 6365 2062 7573  if "Resource bus
-000026d0: 7922 2069 6e20 7374 7228 6578 6329 2061  y" in str(exc) a
-000026e0: 6e64 2072 6574 7269 6573 203c 3d20 333a  nd retries <= 3:
-000026f0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00002700: 2020 2020 2020 6c6f 672e 7761 726e 2822        log.warn("
-00002710: 4861 7264 7761 7265 2046 6169 6c75 7265  Hardware Failure
-00002720: 2069 6e20 7365 7443 6f6e 6669 6775 7261   in setConfigura
-00002730: 7469 6f6e 2e20 5265 736f 7572 6365 2062  tion. Resource b
-00002740: 7573 7920 6572 726f 722e 2041 7474 656d  usy error. Attem
-00002750: 7074 696e 6720 746f 2072 6561 7474 6163  pting to reattac
-00002760: 6820 6472 6976 6572 2062 7920 7265 7365  h driver by rese
-00002770: 742e 2229 0d0a 2020 2020 2020 2020 2020  t.")..          
-00002780: 2020 2020 2020 2020 2020 7365 6c66 2e64            self.d
-00002790: 6576 6963 655f 7479 7065 2e72 6573 6574  evice_type.reset
-000027a0: 2864 6576 290d 0a20 2020 2020 2020 2020  (dev)..         
-000027b0: 2020 2020 2020 2020 2020 2073 6c65 6570             sleep
-000027c0: 5f6d 7320 3d20 3130 202a 2a20 7265 7472  _ms = 10 ** retr
-000027d0: 6965 7320 2320 3130 5e33 206d 7320 3d20  ies # 10^3 ms = 
-000027e0: 3173 6563 206d 6178 2064 656c 6179 0d0a  1sec max delay..
-000027f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002800: 2020 2020 736c 6565 7028 736c 6565 705f      sleep(sleep_
-00002810: 6d73 202f 2031 3030 302e 3029 200d 0a20  ms / 1000.0) .. 
-00002820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002830: 2020 2072 6574 7572 6e20 7365 6c66 2e63     return self.c
-00002840: 6f6e 6e65 6374 2872 6574 7269 6573 3d72  onnect(retries=r
-00002850: 6574 7269 6573 2b31 2920 0d0a 0d0a 2020  etries+1) ....  
-00002860: 2020 2020 2020 2020 2020 2020 2020 7365                se
-00002870: 6c66 2e63 6f6e 6e65 6374 696e 6720 3d20  lf.connecting = 
-00002880: 4661 6c73 650d 0a20 2020 2020 2020 2020  False..         
-00002890: 2020 2020 2020 206d 7367 203d 2066 2248         msg = f"H
-000028a0: 6172 6477 6172 6520 4661 696c 7572 6520  ardware Failure 
-000028b0: 696e 2073 6574 436f 6e66 6967 7572 6174  in setConfigurat
-000028c0: 696f 6e2c 2067 6976 696e 6720 7570 2061  ion, giving up a
-000028d0: 6674 6572 207b 7265 7472 6965 737d 2072  fter {retries} r
-000028e0: 6574 7269 6573 220d 0a20 2020 2020 2020  etries"..       
-000028f0: 2020 2020 2020 2020 206c 6f67 2e63 7269           log.cri
-00002900: 7469 6361 6c28 6d73 672c 2065 7863 5f69  tical(msg, exc_i
-00002910: 6e66 6f3d 3129 0d0a 2020 2020 2020 2020  nfo=1)..        
-00002920: 2020 2020 2020 2020 7265 7475 726e 2053          return S
-00002930: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
-00002940: 6e73 6528 4661 6c73 652c 2065 7272 6f72  nse(False, error
-00002950: 5f6d 7367 3d6d 7367 290d 0a0d 0a20 2020  _msg=msg)....   
-00002960: 2020 2020 2020 2020 2074 7279 3a0d 0a20           try:.. 
-00002970: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-00002980: 6f67 2e64 6562 7567 2822 636c 6169 6d69  og.debug("claimi
-00002990: 6e67 2069 6e74 6572 6661 6365 2229 0d0a  ng interface")..
-000029a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000029b0: 7265 7375 6c74 203d 2073 656c 662e 6465  result = self.de
-000029c0: 7669 6365 5f74 7970 652e 636c 6169 6d5f  vice_type.claim_
-000029d0: 696e 7465 7266 6163 6528 6465 7669 6365  interface(device
-000029e0: 2c20 3029 0d0a 2020 2020 2020 2020 2020  , 0)..          
-000029f0: 2020 6578 6365 7074 2045 7863 6570 7469    except Excepti
-00002a00: 6f6e 2061 7320 6578 633a 0d0a 2020 2020  on as exc:..    
-00002a10: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00002a20: 2e63 6f6e 6e65 6374 696e 6720 3d20 4661  .connecting = Fa
-00002a30: 6c73 650d 0a20 2020 2020 2020 2020 2020  lse..           
-00002a40: 2020 2020 206d 7367 203d 2022 4861 7264       msg = "Hard
-00002a50: 7761 7265 2046 6169 6c75 7265 2069 6e20  ware Failure in 
-00002a60: 636c 6169 6d49 6e74 6572 6661 6365 220d  claimInterface".
-00002a70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002a80: 206c 6f67 2e63 7269 7469 6361 6c28 6d73   log.critical(ms
-00002a90: 672c 2065 7863 5f69 6e66 6f3d 3129 0d0a  g, exc_info=1)..
-00002aa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002ab0: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
-00002ac0: 7465 7252 6573 706f 6e73 6528 4661 6c73  terResponse(Fals
-00002ad0: 652c 2065 7272 6f72 5f6d 7367 3d6d 7367  e, error_msg=msg
-00002ae0: 290d 0a0d 0a20 2020 2020 2020 2073 656c  )....        sel
-00002af0: 662e 6465 7669 6365 203d 2064 6576 6963  f.device = devic
-00002b00: 650d 0a0d 0a20 2020 2020 2020 2072 6574  e....        ret
-00002b10: 7572 6e20 7365 6c66 2e5f 706f 7374 5f63  urn self._post_c
-00002b20: 6f6e 6e65 6374 2829 0d0a 0d0a 2020 2020  onnect()....    
-00002b30: 6465 6620 5f70 6f73 745f 636f 6e6e 6563  def _post_connec
-00002b40: 7428 7365 6c66 293a 2023 202d 3e20 5370  t(self): # -> Sp
-00002b50: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-00002b60: 7365 200d 0a20 2020 2020 2020 2022 2222  se ..        """
-00002b70: 0d0a 2020 2020 2020 2020 5065 7266 6f72  ..        Perfor
-00002b80: 6d20 6164 6469 7469 6f6e 616c 2073 6574  m additional set
-00002b90: 7570 2061 6674 6572 2069 6e73 7461 6e74  up after instant
-00002ba0: 6961 7469 6e67 2046 4944 2064 6576 6963  iating FID devic
-00002bb0: 652e 0d0a 2020 2020 2020 2020 5370 6c69  e...        Spli
-00002bc0: 742d 6f75 7420 6672 6f6d 2070 6879 7369  t-out from physi
-00002bd0: 6361 6c20 2f20 6275 7320 636f 6e6e 6563  cal / bus connec
-00002be0: 7428 2920 746f 2073 696d 706c 6966 7920  t() to simplify 
-00002bf0: 4d6f 636b 5370 6563 7472 6f6d 6574 6572  MockSpectrometer
-00002c00: 2e0d 0a20 2020 2020 2020 2022 2222 0d0a  ...        """..
-00002c10: 0d0a 2020 2020 2020 2020 2320 2323 2323  ..        # ####
+00000de0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000df0: 2020 2020 2020 2020 2020 2020 6465 7669              devi
+00000e00: 6365 5f69 642e 7370 6563 7472 615f 6f70  ce_id.spectra_op
+00000e10: 7469 6f6e 7329 0a20 2020 2020 2020 2065  tions).        e
+00000e20: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00000e30: 2073 656c 662e 6465 7669 6365 5f74 7970   self.device_typ
+00000e40: 6520 3d20 5265 616c 5553 4244 6576 6963  e = RealUSBDevic
+00000e50: 6528 6465 7669 6365 5f69 6429 0a0a 2020  e(device_id)..  
+00000e60: 2020 2020 2020 7365 6c66 2e6c 6173 745f        self.last_
+00000e70: 7573 625f 7469 6d65 7374 616d 7020 3d20  usb_timestamp = 
+00000e80: 4e6f 6e65 0a0a 2020 2020 2020 2020 7365  None..        se
+00000e90: 6c66 2e6c 6173 6572 5f74 656d 7065 7261  lf.laser_tempera
+00000ea0: 7475 7265 5f69 6e76 616c 6964 203d 2046  ture_invalid = F
+00000eb0: 616c 7365 0a20 2020 2020 2020 2073 656c  alse.        sel
+00000ec0: 662e 6363 645f 7465 6d70 6572 6174 7572  f.ccd_temperatur
+00000ed0: 655f 696e 7661 6c69 6420 3d20 4661 6c73  e_invalid = Fals
+00000ee0: 650a 0a20 2020 2020 2020 2073 656c 662e  e..        self.
+00000ef0: 7365 7474 696e 6773 203d 2053 7065 6374  settings = Spect
+00000f00: 726f 6d65 7465 7253 6574 7469 6e67 7328  rometerSettings(
+00000f10: 6465 7669 6365 5f69 6429 0a20 2020 2020  device_id).     
+00000f20: 2020 2073 656c 662e 6565 7072 6f6d 5f62     self.eeprom_b
+00000f30: 6163 6b75 7020 3d20 4e6f 6e65 0a0a 2020  ackup = None..  
+00000f40: 2020 2020 2020 2320 2323 2323 2323 2323        # ########
+00000f50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000f60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000f70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000f80: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
+00000f90: 2020 2020 2020 2023 2074 6865 7365 2061         # these a
+00000fa0: 7265 2022 6472 6976 6572 2073 7461 7465  re "driver state
+00000fb0: 2220 7769 7468 696e 2046 6561 7475 7265  " within Feature
+00000fc0: 4964 656e 7469 6669 6361 7469 6f6e 4465  IdentificationDe
+00000fd0: 7669 6365 2c20 616e 6420 646f 6e27 740a  vice, and don't.
+00000fe0: 2020 2020 2020 2020 2320 7265 616c 6c79          # really
+00000ff0: 2072 656c 6174 6520 746f 2074 6865 2073   relate to the s
+00001000: 7065 6374 726f 6d65 7465 7220 6861 7264  pectrometer hard
+00001010: 7761 7265 0a20 2020 2020 2020 2023 2023  ware.        # #
+00001020: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00001030: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00001040: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00001050: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00001060: 2323 2323 230a 0a20 2020 2020 2020 2073  #####..        s
+00001070: 656c 662e 6465 7465 6374 6f72 5f74 6563  elf.detector_tec
+00001080: 5f73 6574 706f 696e 745f 6861 735f 6265  _setpoint_has_be
+00001090: 656e 5f73 6574 203d 2046 616c 7365 0a20  en_set = False. 
+000010a0: 2020 2020 2020 2073 656c 662e 6c61 7374         self.last
+000010b0: 5f61 7070 6c69 6564 5f6c 6173 6572 5f70  _applied_laser_p
+000010c0: 6f77 6572 203d 2030 2e30 2023 206c 6173  ower = 0.0 # las
+000010d0: 7420 706f 7765 7220 6c65 7665 6c20 4150  t power level AP
+000010e0: 504c 4945 4420 746f 206c 6173 6572 2c20  PLIED to laser, 
+000010f0: 6569 7468 6572 2062 7920 7475 726e 696e  either by turnin
+00001100: 6720 6f66 6620 2830 2920 6f72 206f 6e20  g off (0) or on 
+00001110: 0a20 2020 2020 2020 2073 656c 662e 6e65  .        self.ne
+00001120: 7874 5f61 7070 6c69 6564 5f6c 6173 6572  xt_applied_laser
+00001130: 5f70 6f77 6572 203d 204e 6f6e 6520 2320  _power = None # 
+00001140: 706f 7765 7220 6c65 7665 6c20 746f 2062  power level to b
+00001150: 6520 6170 706c 6965 6420 4e45 5854 2074  e applied NEXT t
+00001160: 696d 6520 7468 6520 6c61 7365 7220 6973  ime the laser is
+00001170: 2065 6e61 626c 6564 0a0a 2020 2020 2020   enabled..      
+00001180: 2020 7365 6c66 2e72 6169 7365 5f65 7863    self.raise_exc
+00001190: 6570 7469 6f6e 7320 3d20 4661 6c73 650a  eptions = False.
+000011a0: 2020 2020 2020 2020 7365 6c66 2e69 6e6a          self.inj
+000011b0: 6563 745f 7261 6e64 6f6d 5f65 7272 6f72  ect_random_error
+000011c0: 7320 3d20 4661 6c73 650a 2020 2020 2020  s = False.      
+000011d0: 2020 7365 6c66 2e72 616e 646f 6d5f 6572    self.random_er
+000011e0: 726f 725f 7065 7263 203d 2030 2e30 3031  ror_perc = 0.001
+000011f0: 2020 2023 2030 2e31 250a 2020 2020 2020     # 0.1%.      
+00001200: 2020 7365 6c66 2e61 6c6c 6f77 5f64 6566    self.allow_def
+00001210: 6175 6c74 5f67 6169 6e5f 7265 7365 7420  ault_gain_reset 
+00001220: 3d20 5472 7565 0a0a 2020 2020 2020 2020  = True..        
+00001230: 7365 6c66 2e63 6f6e 6e65 6374 6564 203d  self.connected =
+00001240: 2046 616c 7365 0a20 2020 2020 2020 2073   False.        s
+00001250: 656c 662e 636f 6e6e 6563 7469 6e67 203d  elf.connecting =
+00001260: 2046 616c 7365 0a20 2020 2020 2020 2073   False.        s
+00001270: 656c 662e 7368 7574 646f 776e 5f72 6571  elf.shutdown_req
+00001280: 7565 7374 6564 203d 2046 616c 7365 0a0a  uested = False..
+00001290: 2020 2020 2020 2020 7365 6c66 2e6c 6173          self.las
+000012a0: 745f 7370 6563 7472 756d 203d 204e 6f6e  t_spectrum = Non
+000012b0: 650a 2020 2020 2020 2020 7365 6c66 2e73  e.        self.s
+000012c0: 7065 6374 7275 6d5f 636f 756e 7420 3d20  pectrum_count = 
+000012d0: 300a 2020 2020 2020 2020 7365 6c66 2e70  0.        self.p
+000012e0: 7265 765f 7069 7865 6c73 203d 204e 6f6e  rev_pixels = Non
+000012f0: 650a 0a20 2020 2020 2020 2023 2069 6e20  e..        # in 
+00001300: 6361 7365 206f 6620 4932 4320 636f 6c6c  case of I2C coll
+00001310: 6973 696f 6e73 2077 6974 6869 6e20 7468  isions within th
+00001320: 6520 7370 6563 7472 6f6d 6574 6572 2c20  e spectrometer, 
+00001330: 652e 672e 2064 7565 2074 6f20 6261 7474  e.g. due to batt
+00001340: 6572 792d 4c45 4420 7374 6174 7573 0a20  ery-LED status. 
+00001350: 2020 2020 2020 2073 656c 662e 7265 7472         self.retr
+00001360: 795f 656e 6162 6c65 6420 3d20 5472 7565  y_enabled = True
+00001370: 0a20 2020 2020 2020 2073 656c 662e 7265  .        self.re
+00001380: 7472 795f 6d73 203d 2035 0a20 2020 2020  try_ms = 5.     
+00001390: 2020 2073 656c 662e 7265 7472 795f 6d61     self.retry_ma
+000013a0: 7820 3d20 330a 0a20 2020 2020 2020 2073  x = 3..        s
+000013b0: 656c 662e 7072 6f63 6573 735f 6620 3d20  elf.process_f = 
+000013c0: 7365 6c66 2e5f 696e 6974 5f70 726f 6365  self._init_proce
+000013d0: 7373 5f66 756e 6373 2829 0a0a 2020 2020  ss_funcs()..    
+000013e0: 6465 6620 6861 6e64 6c65 5f72 6571 7565  def handle_reque
+000013f0: 7374 7328 7365 6c66 2c20 7265 7175 6573  sts(self, reques
+00001400: 7473 3a20 6c69 7374 5b53 7065 6374 726f  ts: list[Spectro
+00001410: 6d65 7465 7252 6571 7565 7374 5d29 3a0a  meterRequest]):.
+00001420: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00001430: 2020 2020 4074 6f64 6f20 636f 6e73 6964      @todo consid
+00001440: 6572 206d 616b 696e 6720 2772 6571 7565  er making 'reque
+00001450: 7374 7327 2061 6e20 6f62 6a65 6374 2c20  sts' an object, 
+00001460: 616e 6420 6479 6e61 6d69 6361 6c6c 7920  and dynamically 
+00001470: 6368 6563 6b69 6e67 2074 6f20 0a20 2020  checking to .   
+00001480: 2020 2020 2020 2020 2020 2073 6565 2069             see i
+00001490: 6620 6974 2069 7320 6120 7369 6e67 6c65  f it is a single
+000014a0: 2053 7065 6374 726f 6d65 7465 7252 6571   SpectrometerReq
+000014b0: 7565 7374 206f 7220 6120 6c69 7374 5b53  uest or a list[S
+000014c0: 7065 6374 726f 6d65 7465 7252 6571 7565  pectrometerReque
+000014d0: 7374 5d3b 0a20 2020 2020 2020 2020 2020  st];.           
+000014e0: 2020 2069 6620 7468 6520 666f 726d 6572     if the former
+000014f0: 2c20 6f6e 6c79 2072 6574 7572 6e20 6120  , only return a 
+00001500: 7369 6e67 6c65 2053 7065 6374 726f 6d65  single Spectrome
+00001510: 7465 7252 6573 706f 6e73 652e 0a20 2020  terResponse..   
+00001520: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00001530: 2072 6573 706f 6e73 6573 203d 205b 5d0a   responses = [].
+00001540: 2020 2020 2020 2020 666f 7220 7265 7175          for requ
+00001550: 6573 7420 696e 2072 6571 7565 7374 733a  est in requests:
+00001560: 0a20 2020 2020 2020 2020 2020 2074 7279  .            try
+00001570: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00001580: 2020 636d 6420 3d20 7265 7175 6573 742e    cmd = request.
+00001590: 636d 640a 2020 2020 2020 2020 2020 2020  cmd.            
+000015a0: 2020 2020 7072 6f63 5f66 756e 6320 3d20      proc_func = 
+000015b0: 7365 6c66 2e70 726f 6365 7373 5f66 2e67  self.process_f.g
+000015c0: 6574 2863 6d64 2c20 4e6f 6e65 290a 2020  et(cmd, None).  
+000015d0: 2020 2020 2020 2020 2020 2020 2020 6966                if
+000015e0: 2070 726f 635f 6675 6e63 2069 7320 4e6f   proc_func is No
+000015f0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+00001600: 2020 2020 2020 2020 7265 7370 6f6e 7365          response
+00001610: 732e 6170 7065 6e64 2853 7065 6374 726f  s.append(Spectro
+00001620: 6d65 7465 7252 6573 706f 6e73 6528 6572  meterResponse(er
+00001630: 726f 725f 6d73 673d 6622 756e 7375 7070  ror_msg=f"unsupp
+00001640: 6f72 7465 6420 636d 6420 7b72 6571 7565  orted cmd {reque
+00001650: 7374 2e63 6d64 7d22 2c20 6572 726f 725f  st.cmd}", error_
+00001660: 6c76 6c3d 4572 726f 724c 6576 656c 2e6c  lvl=ErrorLevel.l
+00001670: 6f77 2929 0a20 2020 2020 2020 2020 2020  ow)).           
+00001680: 2020 2020 2065 6c69 6620 7265 7175 6573       elif reques
+00001690: 742e 6172 6773 203d 3d20 5b5d 2061 6e64  t.args == [] and
+000016a0: 2072 6571 7565 7374 2e6b 7761 7267 7320   request.kwargs 
+000016b0: 3d3d 207b 7d3a 0a20 2020 2020 2020 2020  == {}:.         
+000016c0: 2020 2020 2020 2020 2020 2072 6573 706f             respo
+000016d0: 6e73 6573 2e61 7070 656e 6428 7072 6f63  nses.append(proc
+000016e0: 5f66 756e 6328 2929 0a20 2020 2020 2020  _func()).       
+000016f0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+00001700: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001710: 2020 2072 6573 706f 6e73 6573 2e61 7070     responses.app
+00001720: 656e 6428 7072 6f63 5f66 756e 6328 2a72  end(proc_func(*r
+00001730: 6571 7565 7374 2e61 7267 732c 202a 2a72  equest.args, **r
+00001740: 6571 7565 7374 2e6b 7761 7267 7329 290a  equest.kwargs)).
+00001750: 2020 2020 2020 2020 2020 2020 6578 6365              exce
+00001760: 7074 2045 7863 6570 7469 6f6e 2061 7320  pt Exception as 
+00001770: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00001780: 2020 206c 6f67 2e65 7272 6f72 2866 2265     log.error(f"e
+00001790: 7272 6f72 2069 6e20 6861 6e64 6c69 6e67  rror in handling
+000017a0: 2072 6571 7565 7374 207b 7265 7175 6573   request {reques
+000017b0: 747d 206f 6620 7b65 7d22 2c20 6578 635f  t} of {e}", exc_
+000017c0: 696e 666f 3d31 290a 2020 2020 2020 2020  info=1).        
+000017d0: 2020 2020 2020 2020 7265 7370 6f6e 7365          response
+000017e0: 732e 6170 7065 6e64 2853 7065 6374 726f  s.append(Spectro
+000017f0: 6d65 7465 7252 6573 706f 6e73 6528 6572  meterResponse(er
+00001800: 726f 725f 6d73 673d 2265 7272 6f72 2070  ror_msg="error p
+00001810: 726f 6365 7373 696e 6720 636d 6422 2c20  rocessing cmd", 
+00001820: 6572 726f 725f 6c76 6c3d 4572 726f 724c  error_lvl=ErrorL
+00001830: 6576 656c 2e6d 6564 6975 6d29 290a 2020  evel.medium)).  
+00001840: 2020 2020 2020 7265 7475 726e 2072 6573        return res
+00001850: 706f 6e73 6573 0a0a 2020 2020 6465 6620  ponses..    def 
+00001860: 636f 6e6e 6563 7428 7365 6c66 2c20 7265  connect(self, re
+00001870: 7472 6965 733d 3029 3a0a 2020 2020 2020  tries=0):.      
+00001880: 2020 2222 220a 2020 2020 2020 2020 436f    """.        Co
+00001890: 6e6e 6563 7420 746f 2074 6865 2064 6576  nnect to the dev
+000018a0: 6963 6520 616e 6420 696e 6974 6961 6c69  ice and initiali
+000018b0: 7a65 2062 6173 6963 2073 6574 7469 6e67  ze basic setting
+000018c0: 732e 0a20 2020 2020 2020 2040 7761 726e  s..        @warn
+000018d0: 696e 6720 7468 6973 2063 6175 7365 7320  ing this causes 
+000018e0: 6120 7072 6f62 6c65 6d20 696e 206e 6f6e  a problem in non
+000018f0: 2d62 6c6f 636b 696e 6720 6d6f 6465 2028  -blocking mode (
+00001900: 5761 7361 7463 6844 6576 6963 6557 7261  WasatchDeviceWra
+00001910: 7070 6572 290a 2020 2020 2020 2020 6f6e  pper).        on
+00001920: 204d 6163 4f53 0a20 2020 2020 2020 2022   MacOS.        "
+00001930: 2222 0a20 2020 2020 2020 2073 656c 662e  "".        self.
+00001940: 636f 6e6e 6563 7469 6e67 203d 2054 7275  connecting = Tru
+00001950: 650a 0a20 2020 2020 2020 2023 2023 2323  e..        # ###
+00001960: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00001970: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00001980: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00001990: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000019a0: 2323 230a 2020 2020 2020 2020 2320 5553  ###.        # US
+000019b0: 4220 436f 6e6e 6563 7469 6f6e 0a20 2020  B Connection.   
+000019c0: 2020 2020 2023 2023 2323 2323 2323 2323       # #########
+000019d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000019e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000019f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00001a00: 2323 2323 2323 2323 2323 2323 230a 0a20  #############.. 
+00001a10: 2020 2020 2020 2023 2047 656e 6572 6174         # Generat
+00001a20: 6520 6120 6672 6573 6820 6c69 7374 696e  e a fresh listin
+00001a30: 6720 6f66 2055 5342 2064 6576 6963 6573  g of USB devices
+00001a40: 2077 6974 6820 7468 6520 7265 7175 6573   with the reques
+00001a50: 7465 6420 5649 4420 616e 6420 5049 442e  ted VID and PID.
+00001a60: 0a20 2020 2020 2020 2023 204e 6f74 6520  .        # Note 
+00001a70: 7468 6174 2074 6869 7320 6973 204e 4f54  that this is NOT
+00001a80: 2068 6f77 2057 6173 6174 6368 4275 7320   how WasatchBus 
+00001a90: 7472 6176 6572 7365 7320 7468 6520 6c69  traverses the li
+00001aa0: 7374 2e20 2049 7420 6163 7475 616c 6c79  st.  It actually
+00001ab0: 0a20 2020 2020 2020 2023 2063 616c 6c73  .        # calls
+00001ac0: 2075 7362 2e62 7573 7365 7328 292c 2074   usb.busses(), t
+00001ad0: 6865 6e20 6974 6572 6174 6573 206f 7665  hen iterates ove
+00001ae0: 7220 6275 732e 6465 7669 6365 732c 2062  r bus.devices, b
+00001af0: 7574 2074 6861 7427 7320 6265 6361 7573  ut that's becaus
+00001b00: 650a 2020 2020 2020 2020 2320 6974 2064  e.        # it d
+00001b10: 6f65 736e 2774 206b 6e6f 7720 7768 6174  oesn't know what
+00001b20: 2050 4944 7320 6974 206d 6967 6874 2062   PIDs it might b
+00001b30: 6520 6c6f 6f6b 696e 6720 666f 722e 2020  e looking for.  
+00001b40: 5765 206b 6e6f 772c 2073 6f20 6a75 7374  We know, so just
+00001b50: 0a20 2020 2020 2020 2023 206e 6172 726f  .        # narro
+00001b60: 7720 646f 776e 2074 6865 2073 6561 7263  w down the searc
+00001b70: 6820 746f 2074 686f 7365 2064 6576 6963  h to those devic
+00001b80: 6573 2e0a 0a20 2020 2020 2020 206c 6f67  es...        log
+00001b90: 2e69 6e66 6f28 6622 4649 442e 636f 6e6e  .info(f"FID.conn
+00001ba0: 6563 743a 2061 736b 6564 2074 6f20 636f  ect: asked to co
+00001bb0: 6e6e 6563 7420 746f 2064 6576 6963 655f  nnect to device_
+00001bc0: 7479 7065 207b 7365 6c66 2e64 6576 6963  type {self.devic
+00001bd0: 655f 7479 7065 7d22 290a 2020 2020 2020  e_type}").      
+00001be0: 2020 6c6f 672e 696e 666f 2866 2246 4944    log.info(f"FID
+00001bf0: 2e63 6f6e 6e65 6374 3a20 6361 6c6c 696e  .connect: callin
+00001c00: 6720 6465 7669 6365 5f74 7970 652e 6669  g device_type.fi
+00001c10: 6e64 2c20 6c6f 6f6b 696e 6720 666f 7220  nd, looking for 
+00001c20: 5649 4420 3078 7b73 656c 662e 6465 7669  VID 0x{self.devi
+00001c30: 6365 5f69 642e 7669 643a 3034 787d 2061  ce_id.vid:04x} a
+00001c40: 6e64 2050 4944 2030 787b 7365 6c66 2e64  nd PID 0x{self.d
+00001c50: 6576 6963 655f 6964 2e70 6964 3a30 3478  evice_id.pid:04x
+00001c60: 7d22 290a 2020 2020 2020 2020 6465 7669  }").        devi
+00001c70: 6365 7320 3d20 7365 6c66 2e64 6576 6963  ces = self.devic
+00001c80: 655f 7479 7065 2e66 696e 6428 6669 6e64  e_type.find(find
+00001c90: 5f61 6c6c 3d54 7275 652c 2069 6456 656e  _all=True, idVen
+00001ca0: 646f 723d 7365 6c66 2e64 6576 6963 655f  dor=self.device_
+00001cb0: 6964 2e76 6964 2c20 6964 5072 6f64 7563  id.vid, idProduc
+00001cc0: 743d 7365 6c66 2e64 6576 6963 655f 6964  t=self.device_id
+00001cd0: 2e70 6964 290a 2020 2020 2020 2020 6c6f  .pid).        lo
+00001ce0: 672e 696e 666f 2866 2246 4944 2e63 6f6e  g.info(f"FID.con
+00001cf0: 6e65 6374 3a20 666f 756e 6420 6465 7669  nect: found devi
+00001d00: 6365 7320 7b64 6576 6963 6573 7d22 290a  ces {devices}").
+00001d10: 2020 2020 2020 2020 6465 765f 6c69 7374          dev_list
+00001d20: 203d 206c 6973 7428 6465 7669 6365 7329   = list(devices)
+00001d30: 2023 2063 6f6e 7665 7274 2066 726f 6d20   # convert from 
+00001d40: 6172 7261 790a 0a20 2020 2020 2020 2064  array..        d
+00001d50: 6576 6963 6520 3d20 4e6f 6e65 0a20 2020  evice = None.   
+00001d60: 2020 2020 206c 6f67 2e69 6e66 6f28 6622       log.info(f"
+00001d70: 7365 6172 6368 696e 6720 666f 7220 7370  searching for sp
+00001d80: 6563 6966 6965 6420 6465 7669 6365 2069  ecified device i
+00001d90: 6e20 6465 765f 6c69 7374 207b 6465 765f  n dev_list {dev_
+00001da0: 6c69 7374 7d22 290a 2020 2020 2020 2020  list}").        
+00001db0: 666f 7220 6465 7620 696e 2064 6576 5f6c  for dev in dev_l
+00001dc0: 6973 743a 0a20 2020 2020 2020 2020 2020  ist:.           
+00001dd0: 2069 6620 6465 762e 6275 7320 213d 2073   if dev.bus != s
+00001de0: 656c 662e 6465 7669 6365 5f69 642e 6275  elf.device_id.bu
+00001df0: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
+00001e00: 2020 206c 6f67 2e64 6562 7567 2822 4649     log.debug("FI
+00001e10: 442e 636f 6e6e 6563 743a 2072 656a 6563  D.connect: rejec
+00001e20: 7469 6e67 2064 6576 6963 6520 2862 7573  ting device (bus
+00001e30: 2025 6420 213d 2072 6571 7565 7374 6564   %d != requested
+00001e40: 2025 6429 222c 2064 6576 2e62 7573 2c20   %d)", dev.bus, 
+00001e50: 7365 6c66 2e64 6576 6963 655f 6964 2e62  self.device_id.b
+00001e60: 7573 290a 2020 2020 2020 2020 2020 2020  us).            
+00001e70: 656c 6966 2064 6576 2e61 6464 7265 7373  elif dev.address
+00001e80: 2021 3d20 7365 6c66 2e64 6576 6963 655f   != self.device_
+00001e90: 6964 2e61 6464 7265 7373 3a0a 2020 2020  id.address:.    
+00001ea0: 2020 2020 2020 2020 2020 2020 6c6f 672e              log.
+00001eb0: 6465 6275 6728 2246 4944 2e63 6f6e 6e65  debug("FID.conne
+00001ec0: 6374 3a20 7265 6a65 6374 696e 6720 6465  ct: rejecting de
+00001ed0: 7669 6365 2028 6164 6472 6573 7320 2564  vice (address %d
+00001ee0: 2021 3d20 7265 7175 6573 7465 6420 2564   != requested %d
+00001ef0: 2922 2c20 6465 762e 6164 6472 6573 732c  )", dev.address,
+00001f00: 2073 656c 662e 6465 7669 6365 5f69 642e   self.device_id.
+00001f10: 6164 6472 6573 7329 0a20 2020 2020 2020  address).       
+00001f20: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00001f30: 2020 2020 2020 2020 2020 2064 6576 6963             devic
+00001f40: 6520 3d20 6465 760a 2020 2020 2020 2020  e = dev.        
+00001f50: 2020 2020 2020 2020 6272 6561 6b0a 0a20          break.. 
+00001f60: 2020 2020 2020 2069 6620 6465 7669 6365         if device
+00001f70: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+00001f80: 2020 2020 2020 6c6f 672e 6465 6275 6728        log.debug(
+00001f90: 6622 4649 442e 636f 6e6e 6563 743a 2075  f"FID.connect: u
+00001fa0: 6e61 626c 6520 746f 2066 696e 6420 4465  nable to find De
+00001fb0: 7669 6365 4944 207b 7365 6c66 2e64 6576  viceID {self.dev
+00001fc0: 6963 655f 6964 7d22 290a 2020 2020 2020  ice_id}").      
+00001fd0: 2020 2020 2020 7365 6c66 2e63 6f6e 6e65        self.conne
+00001fe0: 6374 696e 6720 3d20 4661 6c73 650a 2020  cting = False.  
+00001ff0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00002000: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
+00002010: 706f 6e73 6528 6461 7461 3d46 616c 7365  ponse(data=False
+00002020: 2c20 6572 726f 725f 6d73 673d 6622 756e  , error_msg=f"un
+00002030: 6162 6c65 2074 6f20 6669 6e64 2044 6576  able to find Dev
+00002040: 6963 6549 4420 7b73 656c 662e 6465 7669  iceID {self.devi
+00002050: 6365 5f69 647d 2229 0a20 2020 2020 2020  ce_id}").       
+00002060: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00002070: 2020 206c 6f67 2e64 6562 7567 2822 4649     log.debug("FI
+00002080: 442e 636f 6e6e 6563 743a 206d 6174 6368  D.connect: match
+00002090: 6564 2044 6576 6963 6549 4420 2573 222c  ed DeviceID %s",
+000020a0: 2073 7472 2873 656c 662e 6465 7669 6365   str(self.device
+000020b0: 5f69 6429 290a 0a20 2020 2020 2020 2069  _id))..        i
+000020c0: 6620 6f73 2e6e 616d 6520 213d 2022 706f  f os.name != "po
+000020d0: 7369 7822 3a0a 2020 2020 2020 2020 2020  six":.          
+000020e0: 2020 6c6f 672e 6465 6275 6728 226f 6e20    log.debug("on 
+000020f0: 5769 6e64 6f77 732c 2073 6f20 4e4f 5420  Windows, so NOT 
+00002100: 7365 7474 696e 6720 636f 6e66 6967 7572  setting configur
+00002110: 6174 696f 6e20 616e 6420 636c 6169 6d69  ation and claimi
+00002120: 6e67 2069 6e74 6572 6661 6365 2229 0a20  ng interface"). 
+00002130: 2020 2020 2020 2065 6c69 6620 226d 6163         elif "mac
+00002140: 4f53 2220 696e 2070 6c61 7466 6f72 6d2e  OS" in platform.
+00002150: 706c 6174 666f 726d 2829 3a0a 2020 2020  platform():.    
+00002160: 2020 2020 2020 2020 6c6f 672e 6465 6275          log.debu
+00002170: 6728 226f 6e20 4d61 634f 532c 2073 6f20  g("on MacOS, so 
+00002180: 4e4f 5420 7365 7474 696e 6720 636f 6e66  NOT setting conf
+00002190: 6967 7572 6174 696f 6e20 616e 6420 636c  iguration and cl
+000021a0: 6169 6d69 6e67 2069 6e74 6572 6661 6365  aiming interface
+000021b0: 2229 0a20 2020 2020 2020 2065 6c73 653a  ").        else:
+000021c0: 0a20 2020 2020 2020 2020 2020 206c 6f67  .            log
+000021d0: 2e64 6562 7567 2822 6f6e 2070 6f73 6978  .debug("on posix
+000021e0: 2c20 736f 2073 6574 7469 6e67 2063 6f6e  , so setting con
+000021f0: 6669 6775 7261 7469 6f6e 2061 6e64 2063  figuration and c
+00002200: 6c61 696d 696e 6720 696e 7465 7266 6163  laiming interfac
+00002210: 6522 290a 0a20 2020 2020 2020 2020 2020  e")..           
+00002220: 2023 2069 6e20 7468 6520 666f 6c6c 6f77   # in the follow
+00002230: 696e 672c 2072 6574 7572 6e20 5370 6563  ing, return Spec
+00002240: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
+00002250: 206f 626a 6563 7473 2072 6174 6865 7220   objects rather 
+00002260: 7468 616e 200a 2020 2020 2020 2020 2020  than .          
+00002270: 2020 2320 7261 6973 696e 6720 6578 6365    # raising exce
+00002280: 7074 696f 6e73 2073 6f20 7468 6520 7573  ptions so the us
+00002290: 6572 2077 696c 6c20 6861 7665 2061 206d  er will have a m
+000022a0: 6f72 652d 7573 6566 756c 2065 7272 6f72  ore-useful error
+000022b0: 200a 2020 2020 2020 2020 2020 2020 2320   .            # 
+000022c0: 6d65 7373 6167 6520 746f 2072 6570 6f72  message to repor
+000022d0: 7420 6f72 2075 7365 2069 6e20 7472 6f75  t or use in trou
+000022e0: 626c 6573 686f 6f74 696e 6720 2865 7863  bleshooting (exc
+000022f0: 6570 7469 6f6e 2073 7469 6c6c 2067 6574  eption still get
+00002300: 730a 2020 2020 2020 2020 2020 2020 2320  s.            # 
+00002310: 6c6f 6767 6564 290a 2020 2020 2020 2020  logged).        
+00002320: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
+00002330: 2020 2020 2020 2020 206c 6f67 2e64 6562           log.deb
+00002340: 7567 2822 7365 7474 696e 6720 636f 6e66  ug("setting conf
+00002350: 6967 7572 6174 696f 6e22 290a 2020 2020  iguration").    
+00002360: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00002370: 2e64 6576 6963 655f 7479 7065 2e73 6574  .device_type.set
+00002380: 5f63 6f6e 6669 6775 7261 7469 6f6e 2864  _configuration(d
+00002390: 6576 6963 6529 0a20 2020 2020 2020 2020  evice).         
+000023a0: 2020 2065 7863 6570 7420 4578 6365 7074     except Except
+000023b0: 696f 6e20 6173 2065 7863 3a0a 2020 2020  ion as exc:.    
+000023c0: 2020 2020 2020 2020 2020 2020 2323 2323              ####
+000023d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000023e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000023f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00002400: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00002410: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00002420: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00002430: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00002440: 230a 2020 2020 2020 2020 2020 2020 2020  #.              
+00002450: 2020 2320 5468 6973 2061 6464 6974 696f    # This additio
+00002460: 6e61 6c20 6966 2073 7461 7465 6d65 6e74  nal if statement
+00002470: 2069 7320 7072 6573 656e 7420 666f 7220   is present for 
+00002480: 7468 6520 5261 7370 6265 7272 7920 5069  the Raspberry Pi
+00002490: 2e20 5468 6572 6520 6973 2061 6e20 6973  . There is an is
+000024a0: 7375 6520 7769 7468 2072 6573 6f75 7263  sue with resourc
+000024b0: 6520 6275 7379 2065 7272 6f72 732e 0a20  e busy errors.. 
+000024c0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+000024d0: 2041 6464 696e 6720 6465 762e 7265 7365   Adding dev.rese
+000024e0: 7428 2920 736f 6c76 6573 2074 6869 732e  t() solves this.
+000024f0: 2053 6565 2068 7474 7073 3a2f 2f73 7461   See https://sta
+00002500: 636b 6f76 6572 666c 6f77 2e63 6f6d 2f71  ckoverflow.com/q
+00002510: 7565 7374 696f 6e73 2f32 3933 3435 3332  uestions/2934532
+00002520: 352f 7261 7370 6265 7272 792d 7079 7573  5/raspberry-pyus
+00002530: 622d 6765 7473 2d72 6573 6f75 7263 652d  b-gets-resource-
+00002540: 6275 7379 0a20 2020 2020 2020 2020 2020  busy.           
+00002550: 2020 2020 2023 2323 2323 2323 2323 2323       ###########
+00002560: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00002570: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00002580: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00002590: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000025a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000025b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000025c0: 2323 2323 2323 2323 2323 0a20 2020 2020  ##########.     
+000025d0: 2020 2020 2020 2020 2020 2069 6620 2252             if "R
+000025e0: 6573 6f75 7263 6520 6275 7379 2220 696e  esource busy" in
+000025f0: 2073 7472 2865 7863 2920 616e 6420 7265   str(exc) and re
+00002600: 7472 6965 7320 3c3d 2033 3a0a 2020 2020  tries <= 3:.    
+00002610: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002620: 6c6f 672e 7761 726e 2822 4861 7264 7761  log.warn("Hardwa
+00002630: 7265 2046 6169 6c75 7265 2069 6e20 7365  re Failure in se
+00002640: 7443 6f6e 6669 6775 7261 7469 6f6e 2e20  tConfiguration. 
+00002650: 5265 736f 7572 6365 2062 7573 7920 6572  Resource busy er
+00002660: 726f 722e 2041 7474 656d 7074 696e 6720  ror. Attempting 
+00002670: 746f 2072 6561 7474 6163 6820 6472 6976  to reattach driv
+00002680: 6572 2062 7920 7265 7365 742e 2229 0a20  er by reset."). 
+00002690: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000026a0: 2020 2073 656c 662e 6465 7669 6365 5f74     self.device_t
+000026b0: 7970 652e 7265 7365 7428 6465 7629 0a20  ype.reset(dev). 
+000026c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000026d0: 2020 2073 6c65 6570 5f6d 7320 3d20 3130     sleep_ms = 10
+000026e0: 202a 2a20 7265 7472 6965 7320 2320 3130   ** retries # 10
+000026f0: 5e33 206d 7320 3d20 3173 6563 206d 6178  ^3 ms = 1sec max
+00002700: 2064 656c 6179 0a20 2020 2020 2020 2020   delay.         
+00002710: 2020 2020 2020 2020 2020 2073 6c65 6570             sleep
+00002720: 2873 6c65 6570 5f6d 7320 2f20 3130 3030  (sleep_ms / 1000
+00002730: 2e30 2920 0a20 2020 2020 2020 2020 2020  .0) .           
+00002740: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00002750: 7365 6c66 2e63 6f6e 6e65 6374 2872 6574  self.connect(ret
+00002760: 7269 6573 3d72 6574 7269 6573 2b31 2920  ries=retries+1) 
+00002770: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+00002780: 2020 7365 6c66 2e63 6f6e 6e65 6374 696e    self.connectin
+00002790: 6720 3d20 4661 6c73 650a 2020 2020 2020  g = False.      
+000027a0: 2020 2020 2020 2020 2020 6d73 6720 3d20            msg = 
+000027b0: 6622 4861 7264 7761 7265 2046 6169 6c75  f"Hardware Failu
+000027c0: 7265 2069 6e20 7365 7443 6f6e 6669 6775  re in setConfigu
+000027d0: 7261 7469 6f6e 2c20 6769 7669 6e67 2075  ration, giving u
+000027e0: 7020 6166 7465 7220 7b72 6574 7269 6573  p after {retries
+000027f0: 7d20 7265 7472 6965 7322 0a20 2020 2020  } retries".     
+00002800: 2020 2020 2020 2020 2020 206c 6f67 2e63             log.c
+00002810: 7269 7469 6361 6c28 6d73 672c 2065 7863  ritical(msg, exc
+00002820: 5f69 6e66 6f3d 3129 0a20 2020 2020 2020  _info=1).       
+00002830: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00002840: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
+00002850: 6f6e 7365 2846 616c 7365 2c20 6572 726f  onse(False, erro
+00002860: 725f 6d73 673d 6d73 6729 0a0a 2020 2020  r_msg=msg)..    
+00002870: 2020 2020 2020 2020 7472 793a 0a20 2020          try:.   
+00002880: 2020 2020 2020 2020 2020 2020 206c 6f67               log
+00002890: 2e64 6562 7567 2822 636c 6169 6d69 6e67  .debug("claiming
+000028a0: 2069 6e74 6572 6661 6365 2229 0a20 2020   interface").   
+000028b0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+000028c0: 662e 6465 7669 6365 5f74 7970 652e 636c  f.device_type.cl
+000028d0: 6169 6d5f 696e 7465 7266 6163 6528 6465  aim_interface(de
+000028e0: 7669 6365 2c20 3029 0a20 2020 2020 2020  vice, 0).       
+000028f0: 2020 2020 2065 7863 6570 743a 0a20 2020       except:.   
+00002900: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+00002910: 662e 636f 6e6e 6563 7469 6e67 203d 2046  f.connecting = F
+00002920: 616c 7365 0a20 2020 2020 2020 2020 2020  alse.           
+00002930: 2020 2020 206d 7367 203d 2022 4861 7264       msg = "Hard
+00002940: 7761 7265 2046 6169 6c75 7265 2069 6e20  ware Failure in 
+00002950: 636c 6169 6d49 6e74 6572 6661 6365 220a  claimInterface".
+00002960: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002970: 6c6f 672e 6372 6974 6963 616c 286d 7367  log.critical(msg
+00002980: 2c20 6578 635f 696e 666f 3d31 290a 2020  , exc_info=1).  
+00002990: 2020 2020 2020 2020 2020 2020 2020 7265                re
+000029a0: 7475 726e 2053 7065 6374 726f 6d65 7465  turn Spectromete
+000029b0: 7252 6573 706f 6e73 6528 4661 6c73 652c  rResponse(False,
+000029c0: 2065 7272 6f72 5f6d 7367 3d6d 7367 290a   error_msg=msg).
+000029d0: 0a20 2020 2020 2020 2073 656c 662e 6465  .        self.de
+000029e0: 7669 6365 203d 2064 6576 6963 650a 0a20  vice = device.. 
+000029f0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+00002a00: 6c66 2e5f 706f 7374 5f63 6f6e 6e65 6374  lf._post_connect
+00002a10: 2829 0a0a 2020 2020 6465 6620 5f70 6f73  ()..    def _pos
+00002a20: 745f 636f 6e6e 6563 7428 7365 6c66 293a  t_connect(self):
+00002a30: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00002a40: 2020 2020 2050 6572 666f 726d 2061 6464       Perform add
+00002a50: 6974 696f 6e61 6c20 7365 7475 7020 6166  itional setup af
+00002a60: 7465 7220 696e 7374 616e 7469 6174 696e  ter instantiatin
+00002a70: 6720 4649 4420 6465 7669 6365 2e0a 2020  g FID device..  
+00002a80: 2020 2020 2020 5370 6c69 742d 6f75 7420        Split-out 
+00002a90: 6672 6f6d 2070 6879 7369 6361 6c20 2f20  from physical / 
+00002aa0: 6275 7320 636f 6e6e 6563 7428 2920 746f  bus connect() to
+00002ab0: 2073 696d 706c 6966 7920 4d6f 636b 5370   simplify MockSp
+00002ac0: 6563 7472 6f6d 6574 6572 2e0a 2020 2020  ectrometer..    
+00002ad0: 2020 2020 2222 220a 0a20 2020 2020 2020      """..       
+00002ae0: 2023 2067 7261 6220 6669 726d 7761 7265   # grab firmware
+00002af0: 2076 6572 7369 6f6e 7320 6561 726c 790a   versions early.
+00002b00: 2020 2020 2020 2020 7365 6c66 2e67 6574          self.get
+00002b10: 5f6d 6963 726f 636f 6e74 726f 6c6c 6572  _microcontroller
+00002b20: 5f66 6972 6d77 6172 655f 7665 7273 696f  _firmware_versio
+00002b30: 6e28 290a 2020 2020 2020 2020 7365 6c66  n().        self
+00002b40: 2e67 6574 5f66 7067 615f 6669 726d 7761  .get_fpga_firmwa
+00002b50: 7265 5f76 6572 7369 6f6e 2829 0a20 2020  re_version().   
+00002b60: 2020 2020 2073 656c 662e 6765 745f 6d69       self.get_mi
+00002b70: 6372 6f63 6f6e 7472 6f6c 6c65 725f 7365  crocontroller_se
+00002b80: 7269 616c 5f6e 756d 6265 7228 290a 0a20  rial_number().. 
+00002b90: 2020 2020 2020 2023 2023 2323 2323 2323         # #######
+00002ba0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00002bb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00002bc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00002bd0: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
+00002be0: 2020 2020 2020 2020 2320 6d6f 6465 6c2d          # model-
+00002bf0: 7370 6563 6966 6963 2073 6574 7469 6e67  specific setting
+00002c00: 730a 2020 2020 2020 2020 2320 2323 2323  s.        # ####
+00002c10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00002c20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00002c30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00002c40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002c50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002c60: 2323 0d0a 2020 2020 2020 2020 2320 6d6f  ##..        # mo
-00002c70: 6465 6c2d 7370 6563 6966 6963 2073 6574  del-specific set
-00002c80: 7469 6e67 730d 0a20 2020 2020 2020 2023  tings..        #
-00002c90: 2023 2323 2323 2323 2323 2323 2323 2323   ###############
-00002ca0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002cb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002cc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002cd0: 2323 2323 2323 230d 0a0d 0a20 2020 2020  #######....     
-00002ce0: 2020 206c 6f67 2e64 6562 7567 2822 6d6f     log.debug("mo
-00002cf0: 6465 6c2d 7370 6563 6966 6963 2073 6574  del-specific set
-00002d00: 7469 6e67 7322 290d 0a0d 0a20 2020 2020  tings")....     
-00002d10: 2020 2023 2064 6566 6175 6c74 2068 6967     # default hig
-00002d20: 682d 6761 696e 206d 6f64 6520 666f 7220  h-gain mode for 
-00002d30: 496e 4761 4173 0d0a 2020 2020 2020 2020  InGaAs..        
-00002d40: 6966 2073 656c 662e 7365 7474 696e 6773  if self.settings
-00002d50: 2e69 735f 696e 6761 6173 2829 3a0d 0a20  .is_ingaas():.. 
-00002d60: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00002d70: 7365 745f 6869 6768 5f67 6169 6e5f 6d6f  set_high_gain_mo
-00002d80: 6465 5f65 6e61 626c 6528 5472 7565 290d  de_enable(True).
-00002d90: 0a0d 0a20 2020 2020 2020 2023 2023 2323  ...        # ###
+00002c50: 2323 0a0a 2020 2020 2020 2020 6c6f 672e  ##..        log.
+00002c60: 6465 6275 6728 226d 6f64 656c 2d73 7065  debug("model-spe
+00002c70: 6369 6669 6320 7365 7474 696e 6773 2229  cific settings")
+00002c80: 0a0a 2020 2020 2020 2020 2320 6465 6661  ..        # defa
+00002c90: 756c 7420 6869 6768 2d67 6169 6e20 6d6f  ult high-gain mo
+00002ca0: 6465 2066 6f72 2049 6e47 6141 730a 2020  de for InGaAs.  
+00002cb0: 2020 2020 2020 6966 2073 656c 662e 7365        if self.se
+00002cc0: 7474 696e 6773 2e69 735f 696e 6761 6173  ttings.is_ingaas
+00002cd0: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
+00002ce0: 7365 6c66 2e73 6574 5f68 6967 685f 6761  self.set_high_ga
+00002cf0: 696e 5f6d 6f64 655f 656e 6162 6c65 2854  in_mode_enable(T
+00002d00: 7275 6529 0a0a 2020 2020 2020 2020 2320  rue)..        # 
+00002d10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00002d20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00002d30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00002d40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00002d50: 2323 2323 2323 0a20 2020 2020 2020 2023  ######.        #
+00002d60: 2045 4550 524f 4d0a 2020 2020 2020 2020   EEPROM.        
+00002d70: 2320 2323 2323 2323 2323 2323 2323 2323  # ##############
+00002d80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00002d90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00002da0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002db0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002dc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002dd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002de0: 2323 230d 0a20 2020 2020 2020 2023 2045  ###..        # E
-00002df0: 4550 524f 4d0d 0a20 2020 2020 2020 2023  EPROM..        #
-00002e00: 2023 2323 2323 2323 2323 2323 2323 2323   ###############
-00002e10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002e20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002e30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002e40: 2323 2323 2323 230d 0a0d 0a20 2020 2020  #######....     
-00002e50: 2020 206c 6f67 2e64 6562 7567 2822 7265     log.debug("re
-00002e60: 6164 696e 6720 4545 5052 4f4d 2229 0d0a  ading EEPROM")..
-00002e70: 0d0a 2020 2020 2020 2020 7265 7375 6c74  ..        result
-00002e80: 203d 2073 656c 662e 5f72 6561 645f 6565   = self._read_ee
-00002e90: 7072 6f6d 2829 0d0a 2020 2020 2020 2020  prom()..        
-00002ea0: 6966 2072 6573 756c 742e 6461 7461 203d  if result.data =
-00002eb0: 3d20 4661 6c73 653a 0d0a 2020 2020 2020  = False:..      
-00002ec0: 2020 2020 2020 6c6f 672e 6572 726f 7228        log.error(
-00002ed0: 6622 6661 696c 6564 2074 6f20 7265 6164  f"failed to read
-00002ee0: 2045 4550 524f 4d2c 2067 6f74 2065 7272   EEPROM, got err
-00002ef0: 6f72 206d 6573 7361 6765 206f 6620 7b72  or message of {r
-00002f00: 6573 756c 742e 6572 726f 725f 6d73 677d  esult.error_msg}
-00002f10: 2229 0d0a 2020 2020 2020 2020 2020 2020  ")..            
-00002f20: 7365 6c66 2e63 6f6e 6e65 6374 696e 6720  self.connecting 
-00002f30: 3d20 4661 6c73 650d 0a20 2020 2020 2020  = False..       
-00002f40: 2020 2020 2072 6574 7572 6e20 7265 7375       return resu
-00002f50: 6c74 0d0a 0d0a 2020 2020 2020 2020 2320  lt....        # 
+00002db0: 2323 2323 2323 2323 0a0a 2020 2020 2020  ########..      
+00002dc0: 2020 6c6f 672e 6465 6275 6728 2272 6561    log.debug("rea
+00002dd0: 6469 6e67 2045 4550 524f 4d22 290a 0a20  ding EEPROM").. 
+00002de0: 2020 2020 2020 2072 6573 756c 7420 3d20         result = 
+00002df0: 7365 6c66 2e5f 7265 6164 5f65 6570 726f  self._read_eepro
+00002e00: 6d28 290a 2020 2020 2020 2020 6966 206e  m().        if n
+00002e10: 6f74 2072 6573 756c 742e 6461 7461 3a0a  ot result.data:.
+00002e20: 2020 2020 2020 2020 2020 2020 6c6f 672e              log.
+00002e30: 6572 726f 7228 6622 6661 696c 6564 2074  error(f"failed t
+00002e40: 6f20 7265 6164 2045 4550 524f 4d2c 2067  o read EEPROM, g
+00002e50: 6f74 2065 7272 6f72 206d 6573 7361 6765  ot error message
+00002e60: 206f 6620 7b72 6573 756c 742e 6572 726f   of {result.erro
+00002e70: 725f 6d73 677d 2229 0a20 2020 2020 2020  r_msg}").       
+00002e80: 2020 2020 2073 656c 662e 636f 6e6e 6563       self.connec
+00002e90: 7469 6e67 203d 2046 616c 7365 0a20 2020  ting = False.   
+00002ea0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00002eb0: 7265 7375 6c74 0a0a 2020 2020 2020 2020  result..        
+00002ec0: 2320 2323 2323 2323 2323 2323 2323 2323  # ##############
+00002ed0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00002ee0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00002ef0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00002f00: 2323 2323 2323 2323 0a20 2020 2020 2020  ########.       
+00002f10: 2023 2041 7574 6f6d 6174 6963 616c 6c79   # Automatically
+00002f20: 2064 6973 6162 6c65 206c 6173 6572 2061   disable laser a
+00002f30: 7420 636f 6e6e 6563 7469 6f6e 0a20 2020  t connection.   
+00002f40: 2020 2020 2023 2023 2323 2323 2323 2323       # #########
+00002f50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00002f60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00002f70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002f80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002f90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002fa0: 2323 2323 2323 0d0a 2020 2020 2020 2020  ######..        
-00002fb0: 2320 4c61 7365 720d 0a20 2020 2020 2020  # Laser..       
-00002fc0: 2023 2023 2323 2323 2323 2323 2323 2323   # #############
-00002fd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002fe0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00002f80: 2323 2323 2323 2323 2323 2323 230a 0a20  #############.. 
+00002f90: 2020 2020 2020 2069 6620 7365 6c66 2e73         if self.s
+00002fa0: 6574 7469 6e67 732e 6565 7072 6f6d 2e68  ettings.eeprom.h
+00002fb0: 6173 5f6c 6173 6572 3a0a 2020 2020 2020  as_laser:.      
+00002fc0: 2020 2020 2020 7365 6c66 2e73 6574 5f6c        self.set_l
+00002fd0: 6173 6572 5f65 6e61 626c 6528 4661 6c73  aser_enable(Fals
+00002fe0: 6529 0a0a 2020 2020 2020 2020 2320 2323  e)..        # ##
 00002ff0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00003000: 2323 2323 2323 2323 230d 0a0d 0a20 2020  #########....   
-00003010: 2020 2020 2069 6620 7365 6c66 2e73 6574       if self.set
-00003020: 7469 6e67 732e 6565 7072 6f6d 2e68 6173  tings.eeprom.has
-00003030: 5f6c 6173 6572 3a0d 0a20 2020 2020 2020  _laser:..       
-00003040: 2020 2020 2073 656c 662e 7365 745f 6c61       self.set_la
-00003050: 7365 725f 656e 6162 6c65 2846 616c 7365  ser_enable(False
-00003060: 290d 0a0d 0a20 2020 2020 2020 2023 2023  )....        # #
+00003000: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00003010: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00003020: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00003030: 2323 2323 0a20 2020 2020 2020 2023 2054  ####.        # T
+00003040: 4543 2053 6574 706f 696e 740a 2020 2020  EC Setpoint.    
+00003050: 2020 2020 2320 2323 2323 2323 2323 2323      # ##########
+00003060: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00003070: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00003080: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00003090: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000030a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000030b0: 2323 2323 230d 0a20 2020 2020 2020 2023  #####..        #
-000030c0: 2054 4543 2053 6574 706f 696e 740d 0a20   TEC Setpoint.. 
-000030d0: 2020 2020 2020 2023 2023 2323 2323 2323         # #######
-000030e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000030f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00003100: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00003110: 2323 2323 2323 2323 2323 2323 2323 230d  ###############.
-00003120: 0a0d 0a20 2020 2020 2020 2069 6620 7365  ...        if se
-00003130: 6c66 2e73 6574 7469 6e67 732e 6973 5f78  lf.settings.is_x
-00003140: 7328 293a 0d0a 2020 2020 2020 2020 2020  s():..          
-00003150: 2020 0d0a 2020 2020 2020 2020 2020 2020    ..            
-00003160: 2320 5853 206f 6e6c 7920 7375 7070 6f72  # XS only suppor
-00003170: 7473 2061 2054 4543 206f 6e20 7468 6520  ts a TEC on the 
-00003180: 6c61 7365 722c 206e 6f74 2074 6865 2064  laser, not the d
-00003190: 6574 6563 746f 720d 0a20 2020 2020 2020  etector..       
-000031a0: 2020 2020 2069 6620 7365 6c66 2e73 6574       if self.set
-000031b0: 7469 6e67 732e 6565 7072 6f6d 2e73 6967  tings.eeprom.sig
-000031c0: 5f6c 6173 6572 5f74 6563 3a0d 0a20 2020  _laser_tec:..   
-000031d0: 2020 2020 2020 2020 2020 2020 206c 6f67               log
-000031e0: 2e64 6562 7567 2822 696e 6974 6961 6c69  .debug("initiali
-000031f0: 7a69 6e67 206c 6173 6572 2054 4543 206f  zing laser TEC o
-00003200: 6e20 5853 2229 0d0a 2020 2020 2020 2020  n XS")..        
-00003210: 2020 2020 2020 2020 7365 6c66 2e73 6574          self.set
-00003220: 5f6c 6173 6572 5f74 656d 7065 7261 7475  _laser_temperatu
-00003230: 7265 5f73 6574 706f 696e 745f 7261 7728  re_setpoint_raw(
-00003240: 7365 6c66 2e73 6574 7469 6e67 732e 6565  self.settings.ee
-00003250: 7072 6f6d 2e73 7461 7274 7570 5f74 656d  prom.startup_tem
-00003260: 705f 6465 6743 290d 0a0d 0a20 2020 2020  p_degC)....     
-00003270: 2020 2065 6c73 653a 0d0a 2020 2020 2020     else:..      
-00003280: 2020 2020 2020 0d0a 2020 2020 2020 2020        ..        
-00003290: 2020 2020 2320 582f 584d 206d 6f64 656c      # X/XM model
-000032a0: 7320 646f 6e27 7420 7265 7175 6972 6520  s don't require 
-000032b0: 7275 6e74 696d 6520 636f 6e66 6967 7572  runtime configur
-000032c0: 6174 696f 6e20 6f66 2074 6865 206c 6173  ation of the las
-000032d0: 6572 2054 4543 0d0a 2020 2020 2020 2020  er TEC..        
-000032e0: 2020 2020 2320 2869 7427 7320 7365 7420      # (it's set 
-000032f0: 7669 6120 706f 7473 206f 6e20 3131 3032  via pots on 1102
-00003300: 3830 2028 534d 4c29 206f 7220 3131 3036  80 (SML) or 1106
-00003310: 3133 2028 4d4d 4c29 292c 2062 7574 2064  13 (MML)), but d
-00003320: 6f20 6e65 6564 0d0a 2020 2020 2020 2020  o need..        
-00003330: 2020 2020 2320 746f 2069 6e69 7469 616c      # to initial
-00003340: 697a 6520 7468 6520 6465 7465 6374 6f72  ize the detector
-00003350: 2054 4543 2066 6f72 2052 2061 6e64 2043   TEC for R and C
-00003360: 2075 6e69 7473 2e0d 0a20 2020 2020 2020   units...       
-00003370: 2020 2020 2069 6620 7365 6c66 2e73 6574       if self.set
-00003380: 7469 6e67 732e 6565 7072 6f6d 2e68 6173  tings.eeprom.has
-00003390: 5f63 6f6f 6c69 6e67 3a0d 0a0d 0a20 2020  _cooling:....   
-000033a0: 2020 2020 2020 2020 2020 2020 2064 6567               deg
-000033b0: 4320 3d20 4e6f 6e65 0d0a 2020 2020 2020  C = None..      
-000033c0: 2020 2020 2020 2020 2020 6565 7072 6f6d            eeprom
-000033d0: 203d 2073 656c 662e 7365 7474 696e 6773   = self.settings
-000033e0: 2e65 6570 726f 6d0d 0a0d 0a20 2020 2020  .eeprom....     
-000033f0: 2020 2020 2020 2020 2020 2069 6620 6565             if ee
-00003400: 7072 6f6d 2e6d 696e 5f74 656d 705f 6465  prom.min_temp_de
-00003410: 6743 203c 3d20 6565 7072 6f6d 2e73 7461  gC <= eeprom.sta
-00003420: 7274 7570 5f74 656d 705f 6465 6743 203c  rtup_temp_degC <
-00003430: 3d20 6565 7072 6f6d 2e6d 6178 5f74 656d  = eeprom.max_tem
-00003440: 705f 6465 6743 3a0d 0a20 2020 2020 2020  p_degC:..       
-00003450: 2020 2020 2020 2020 2020 2020 2064 6567               deg
-00003460: 4320 3d20 6565 7072 6f6d 2e73 7461 7274  C = eeprom.start
-00003470: 7570 5f74 656d 705f 6465 6743 0d0a 2020  up_temp_degC..  
-00003480: 2020 2020 2020 2020 2020 2020 2020 656c                el
-00003490: 6966 2072 652e 6d61 7463 6828 7222 3730  if re.match(r"70
-000034a0: 3331 7c31 3031 3431 7c39 3231 3422 2c20  31|10141|9214", 
-000034b0: 6565 7072 6f6d 2e64 6574 6563 746f 7229  eeprom.detector)
-000034c0: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-000034d0: 2020 2020 2020 2064 6567 4320 3d20 2d31         degC = -1
-000034e0: 350d 0a20 2020 2020 2020 2020 2020 2020  5..             
-000034f0: 2020 2065 6c69 6620 7265 2e6d 6174 6368     elif re.match
-00003500: 2872 2231 3630 3131 7c31 3135 3131 7c31  (r"16011|11511|1
-00003510: 3138 3530 7c31 3339 3731 222c 2065 6570  1850|13971", eep
-00003520: 726f 6d2e 6465 7465 6374 6f72 293a 0d0a  rom.detector):..
-00003530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003540: 2020 2020 6465 6743 203d 2031 300d 0a0d      degC = 10...
-00003550: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00003560: 2069 6620 6465 6743 2069 7320 6e6f 7420   if degC is not 
-00003570: 4e6f 6e65 3a0d 0a20 2020 2020 2020 2020  None:..         
-00003580: 2020 2020 2020 2020 2020 2023 2054 4543             # TEC
-00003590: 2064 6f65 736e 2774 2064 6f20 616e 7974   doesn't do anyt
-000035a0: 6869 6e67 2075 6e6c 6573 7320 796f 7520  hing unless you 
-000035b0: 6769 7665 2069 7420 6120 7465 6d70 6572  give it a temper
-000035c0: 6174 7572 6520 6669 7273 740d 0a20 2020  ature first..   
-000035d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000035e0: 206c 6f67 2e64 6562 7567 2866 2273 6574   log.debug(f"set
-000035f0: 7469 6e67 2064 6574 6563 746f 7220 5445  ting detector TE
-00003600: 4320 7365 7470 6f69 6e74 2074 6f20 7b64  C setpoint to {d
-00003610: 6567 437d 2064 6567 2043 2229 0d0a 2020  egC} deg C")..  
-00003620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003630: 2020 7365 6c66 2e64 6574 6563 746f 725f    self.detector_
-00003640: 7465 635f 7365 7470 6f69 6e74 5f64 6567  tec_setpoint_deg
-00003650: 4320 3d20 6465 6743 0d0a 2020 2020 2020  C = degC..      
-00003660: 2020 2020 2020 2020 2020 2020 2020 7365                se
-00003670: 6c66 2e73 6574 5f64 6574 6563 746f 725f  lf.set_detector_
-00003680: 7465 635f 7365 7470 6f69 6e74 5f64 6567  tec_setpoint_deg
-00003690: 4328 7365 6c66 2e64 6574 6563 746f 725f  C(self.detector_
-000036a0: 7465 635f 7365 7470 6f69 6e74 5f64 6567  tec_setpoint_deg
-000036b0: 4329 0d0a 0d0a 2020 2020 2020 2020 2020  C)....          
-000036c0: 2020 2020 2020 2020 2020 6c6f 672e 6465            log.de
-000036d0: 6275 6728 2265 6e61 626c 696e 6720 6465  bug("enabling de
-000036e0: 7465 6374 6f72 2054 4543 2229 0d0a 2020  tector TEC")..  
-000036f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003700: 2020 7365 6c66 2e64 6574 6563 746f 725f    self.detector_
-00003710: 7465 635f 7365 7470 6f69 6e74 5f68 6173  tec_setpoint_has
-00003720: 5f62 6565 6e5f 7365 7420 3d20 5472 7565  _been_set = True
-00003730: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00003740: 2020 2020 2020 7365 6c66 2e73 6574 5f74        self.set_t
-00003750: 6563 5f65 6e61 626c 6528 5472 7565 290d  ec_enable(True).
-00003760: 0a0d 0a20 2020 2020 2020 2023 2023 2323  ...        # ###
-00003770: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00003780: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00003790: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000037a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000037b0: 2323 230d 0a20 2020 2020 2020 2023 2046  ###..        # F
-000037c0: 5047 410d 0a20 2020 2020 2020 2023 2023  PGA..        # #
-000037d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000037e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000037f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00003800: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00003810: 2323 2323 230d 0a0d 0a20 2020 2020 2020  #####....       
-00003820: 206c 6f67 2e64 6562 7567 2822 7265 6164   log.debug("read
-00003830: 696e 6720 4650 4741 2063 6f6d 7069 6c61  ing FPGA compila
-00003840: 7469 6f6e 206f 7074 696f 6e73 2229 0d0a  tion options")..
-00003850: 2020 2020 2020 2020 7365 6c66 2e5f 7265          self._re
-00003860: 6164 5f66 7067 615f 636f 6d70 696c 6174  ad_fpga_compilat
-00003870: 696f 6e5f 6f70 7469 6f6e 7328 290d 0a0d  ion_options()...
-00003880: 0a20 2020 2020 2020 206c 6f67 2e64 6562  .        log.deb
-00003890: 7567 2822 636f 6e66 6967 7572 696e 6720  ug("configuring 
-000038a0: 4650 4741 2229 0d0a 0d0a 2020 2020 2020  FPGA")....      
-000038b0: 2020 2320 6175 746f 6d61 7469 6361 6c6c    # automaticall
-000038c0: 7920 7075 7368 2045 4550 524f 4d20 7661  y push EEPROM va
-000038d0: 6c75 6573 2074 6f20 7468 6520 4650 4741  lues to the FPGA
-000038e0: 2028 6f6e 206d 6f64 6572 6e20 4545 5052   (on modern EEPR
-000038f0: 4f4d 7329 0d0a 2020 2020 2020 2020 2320  OMs)..        # 
-00003900: 2874 6869 7320 7769 6c6c 2077 6f72 6b20  (this will work 
-00003910: 6f6e 2053 6572 6965 732d 5853 2061 7320  on Series-XS as 
-00003920: 7765 6c6c 2c20 6576 656e 2069 6620 7765  well, even if we
-00003930: 2073 7562 7365 7175 656e 746c 7920 7472   subsequently tr
-00003940: 6163 6b20 6974 7320 6761 696e 0d0a 2020  ack its gain..  
-00003950: 2020 2020 2020 2320 2073 6f6d 6577 6861        #  somewha
-00003960: 7420 6469 6666 6572 656e 746c 7920 6173  t differently as
-00003970: 2073 7461 7465 2e67 6169 6e5f 6462 290d   state.gain_db).
-00003980: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-00003990: 2e73 6574 7469 6e67 732e 6565 7072 6f6d  .settings.eeprom
-000039a0: 2e66 6f72 6d61 7420 3e3d 2034 3a0d 0a20  .format >= 4:.. 
-000039b0: 2020 2020 2020 2020 2020 206c 6f67 2e64             log.d
-000039c0: 6562 7567 2822 7365 6e64 696e 6720 6761  ebug("sending ga
-000039d0: 696e 2f6f 6666 7365 7420 746f 2046 5047  in/offset to FPG
-000039e0: 4122 290d 0a20 2020 2020 2020 2020 2020  A")..           
-000039f0: 2073 656c 662e 7365 745f 6465 7465 6374   self.set_detect
-00003a00: 6f72 5f67 6169 6e20 2020 2020 2028 7365  or_gain      (se
-00003a10: 6c66 2e73 6574 7469 6e67 732e 6565 7072  lf.settings.eepr
-00003a20: 6f6d 2e64 6574 6563 746f 725f 6761 696e  om.detector_gain
-00003a30: 290d 0a20 2020 2020 2020 2020 2020 2073  )..            s
-00003a40: 656c 662e 7365 745f 6465 7465 6374 6f72  elf.set_detector
-00003a50: 5f6f 6666 7365 7420 2020 2028 7365 6c66  _offset    (self
-00003a60: 2e73 6574 7469 6e67 732e 6565 7072 6f6d  .settings.eeprom
-00003a70: 2e64 6574 6563 746f 725f 6f66 6673 6574  .detector_offset
-00003a80: 290d 0a20 2020 2020 2020 2020 2020 2073  )..            s
-00003a90: 656c 662e 7365 745f 6465 7465 6374 6f72  elf.set_detector
-00003aa0: 5f67 6169 6e5f 6f64 6420 2028 7365 6c66  _gain_odd  (self
-00003ab0: 2e73 6574 7469 6e67 732e 6565 7072 6f6d  .settings.eeprom
-00003ac0: 2e64 6574 6563 746f 725f 6761 696e 5f6f  .detector_gain_o
-00003ad0: 6464 290d 0a20 2020 2020 2020 2020 2020  dd)..           
-00003ae0: 2073 656c 662e 7365 745f 6465 7465 6374   self.set_detect
-00003af0: 6f72 5f6f 6666 7365 745f 6f64 6428 7365  or_offset_odd(se
-00003b00: 6c66 2e73 6574 7469 6e67 732e 6565 7072  lf.settings.eepr
-00003b10: 6f6d 2e64 6574 6563 746f 725f 6f66 6673  om.detector_offs
-00003b20: 6574 5f6f 6464 290d 0a0d 0a20 2020 2020  et_odd)....     
-00003b30: 2020 2023 2069 6e69 7469 616c 697a 6520     # initialize 
-00003b40: 7374 6174 652e 6761 696e 5f64 6220 6672  state.gain_db fr
-00003b50: 6f6d 2045 4550 524f 4d20 7374 6172 7475  om EEPROM startu
-00003b60: 7020 7661 6c75 650d 0a20 2020 2020 2020  p value..       
-00003b70: 2073 656c 662e 7365 7474 696e 6773 2e73   self.settings.s
-00003b80: 7461 7465 2e67 6169 6e5f 6462 203d 2073  tate.gain_db = s
-00003b90: 656c 662e 7365 7474 696e 6773 2e65 6570  elf.settings.eep
-00003ba0: 726f 6d2e 6465 7465 6374 6f72 5f67 6169  rom.detector_gai
-00003bb0: 6e0d 0a0d 0a20 2020 2020 2020 2069 6620  n....        if 
-00003bc0: 7365 6c66 2e73 6574 7469 6e67 732e 6973  self.settings.is
-00003bd0: 5f6d 6963 726f 2829 3a0d 0a20 2020 2020  _micro():..     
-00003be0: 2020 2020 2020 2072 6f69 203d 2073 656c         roi = sel
-00003bf0: 662e 7365 7474 696e 6773 2e67 6574 5f76  f.settings.get_v
-00003c00: 6572 7469 6361 6c5f 726f 6928 290d 0a20  ertical_roi().. 
-00003c10: 2020 2020 2020 2020 2020 2069 6620 726f             if ro
-00003c20: 6920 6973 206e 6f74 204e 6f6e 653a 0d0a  i is not None:..
-00003c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003c40: 7365 6c66 2e73 6574 5f76 6572 7469 6361  self.set_vertica
-00003c50: 6c5f 6269 6e6e 696e 6728 726f 6929 0d0a  l_binning(roi)..
-00003c60: 0d0a 2020 2020 2020 2020 7365 6c66 2e73  ..        self.s
-00003c70: 6574 7469 6e67 732e 696e 6974 5f72 6567  ettings.init_reg
-00003c80: 696f 6e73 2829 2020 2020 2020 2020 0d0a  ions()        ..
-00003c90: 0d0a 2020 2020 2020 2020 2320 2323 2323  ..        # ####
-00003ca0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00003cb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00003cc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00003cd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00003ce0: 2323 0d0a 2020 2020 2020 2020 2320 706f  ##..        # po
-00003cf0: 7374 2d63 6f6e 6e65 6374 696f 6e20 6465  st-connection de
-00003d00: 6661 756c 7473 0d0a 2020 2020 2020 2020  faults..        
-00003d10: 2320 2323 2323 2323 2323 2323 2323 2323  # ##############
-00003d20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00003d30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00003d40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00003d50: 2323 2323 2323 2323 0d0a 0d0a 2020 2020  ########....    
-00003d60: 2020 2020 2320 6465 6661 756c 7420 746f      # default to
-00003d70: 2069 6e74 6572 6e61 6c20 7472 6967 6765   internal trigge
-00003d80: 7269 6e67 0d0a 2020 2020 2020 2020 7365  ring..        se
-00003d90: 6c66 2e73 6574 5f74 7269 6767 6572 5f73  lf.set_trigger_s
-00003da0: 6f75 7263 6528 5370 6563 7472 6f6d 6574  ource(Spectromet
-00003db0: 6572 5374 6174 652e 5452 4947 4745 525f  erState.TRIGGER_
-00003dc0: 534f 5552 4345 5f49 4e54 4552 4e41 4c29  SOURCE_INTERNAL)
-00003dd0: 0d0a 0d0a 2020 2020 2020 2020 2320 7072  ....        # pr
-00003de0: 6f62 6162 6c79 2074 6865 2064 6566 6175  obably the defau
-00003df0: 6c74 2c20 6275 7420 6a75 7374 2074 6f20  lt, but just to 
-00003e00: 6265 2073 7572 650d 0a20 2020 2020 2020  be sure..       
-00003e10: 2069 6620 7365 6c66 2e73 6574 7469 6e67   if self.setting
-00003e20: 732e 6973 5f6d 6963 726f 2829 3a0d 0a0d  s.is_micro():...
-00003e30: 0a20 2020 2020 2020 2020 2020 2023 2073  .            # s
-00003e40: 6f6d 6520 6b69 6e64 206f 6620 5365 7269  ome kind of Seri
-00003e50: 6573 2d58 530d 0a20 2020 2020 2020 2020  es-XS..         
-00003e60: 2020 2069 6620 7365 6c66 2e73 6574 7469     if self.setti
-00003e70: 6e67 732e 6565 7072 6f6d 2e68 6173 5f6c  ngs.eeprom.has_l
-00003e80: 6173 6572 3a0d 0a20 2020 2020 2020 2020  aser:..         
-00003e90: 2020 2020 2020 206c 6f67 2e64 6562 7567         log.debug
-00003ea0: 2822 6170 706c 7969 6e67 2053 6572 6965  ("applying Serie
-00003eb0: 732d 5853 2073 6574 7469 6e67 7322 290d  s-XS settings").
-00003ec0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00003ed0: 2073 6563 203d 2073 656c 662e 7365 7474   sec = self.sett
-00003ee0: 696e 6773 2e65 6570 726f 6d2e 6c61 7365  ings.eeprom.lase
-00003ef0: 725f 7761 7463 6864 6f67 5f73 6563 0d0a  r_watchdog_sec..
-00003f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003f10: 6966 2073 6563 203c 3d20 303a 0d0a 2020  if sec <= 0:..  
-00003f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003f30: 2020 7365 6320 3d20 4545 5052 4f4d 2e44    sec = EEPROM.D
-00003f40: 4546 4155 4c54 5f4c 4153 4552 5f57 4154  EFAULT_LASER_WAT
-00003f50: 4348 444f 475f 5345 430d 0a20 2020 2020  CHDOG_SEC..     
-00003f60: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-00003f70: 6f67 2e64 6562 7567 2866 2264 6563 6c69  og.debug(f"decli
-00003f80: 6e69 6e67 2074 6f20 6469 7361 626c 6520  ning to disable 
-00003f90: 6c61 7365 7220 7761 7463 6864 6f67 2061  laser watchdog a
-00003fa0: 7420 636f 6e6e 6563 7469 6f6e 2c20 6465  t connection, de
-00003fb0: 6661 756c 7469 6e67 2074 6f20 7b73 6563  faulting to {sec
-00003fc0: 7d73 6563 2229 0d0a 2020 2020 2020 2020  }sec")..        
-00003fd0: 2020 2020 2020 2020 7365 6c66 2e73 6574          self.set
-00003fe0: 5f6c 6173 6572 5f77 6174 6368 646f 675f  _laser_watchdog_
-00003ff0: 7365 6328 7365 6329 0d0a 2020 2020 2020  sec(sec)..      
-00004000: 2020 2020 2020 656c 7365 3a0d 0a20 2020        else:..   
-00004010: 2020 2020 2020 2020 2020 2020 206c 6f67               log
-00004020: 2e64 6562 7567 2822 736b 6970 7069 6e67  .debug("skipping
-00004030: 206c 6173 6572 2066 6561 7475 7265 7320   laser features 
-00004040: 666f 7220 6e6f 6e2d 5261 6d61 6e20 5365  for non-Raman Se
-00004050: 7269 6573 2d58 5322 290d 0a0d 0a20 2020  ries-XS")....   
-00004060: 2020 2020 2073 656c 662e 7365 745f 696e       self.set_in
-00004070: 7465 6772 6174 696f 6e5f 7469 6d65 5f6d  tegration_time_m
-00004080: 7328 7365 6c66 2e73 6574 7469 6e67 732e  s(self.settings.
-00004090: 6565 7072 6f6d 2e73 7461 7274 7570 5f69  eeprom.startup_i
-000040a0: 6e74 6567 7261 7469 6f6e 5f74 696d 655f  ntegration_time_
-000040b0: 6d73 290d 0a0d 0a20 2020 2020 2020 2023  ms)....        #
-000040c0: 2066 6f72 206e 6f77 2c20 656e 6162 6c65   for now, enable
-000040d0: 2047 656e 2031 2e35 2061 6363 6573 736f   Gen 1.5 accesso
-000040e0: 7279 2063 6f6e 6e65 6374 6f72 2062 7920  ry connector by 
-000040f0: 6465 6661 756c 740d 0a20 2020 2020 2020  default..       
-00004100: 2069 6620 7365 6c66 2e73 6574 7469 6e67   if self.setting
-00004110: 732e 6973 5f67 656e 3135 2829 3a0d 0a20  s.is_gen15():.. 
-00004120: 2020 2020 2020 2020 2020 206c 6f67 2e64             log.d
-00004130: 6562 7567 2822 656e 6162 6c69 6e67 2047  ebug("enabling G
-00004140: 656e 2031 2e35 2061 6363 6573 736f 7279  en 1.5 accessory
-00004150: 2063 6f6e 6e65 6374 6f72 2229 0d0a 2020   connector")..  
-00004160: 2020 2020 2020 2020 2020 7365 6c66 2e73            self.s
-00004170: 6574 5f61 6363 6573 736f 7279 5f65 6e61  et_accessory_ena
-00004180: 626c 6528 5472 7565 290d 0a0d 0a20 2020  ble(True)....   
-00004190: 2020 2020 2023 2023 2323 2323 2323 2323       # #########
-000041a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000041b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000041c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000041d0: 2323 2323 2323 2323 2323 2323 230d 0a20  #############.. 
-000041e0: 2020 2020 2020 2023 2044 6f6e 650d 0a20         # Done.. 
-000041f0: 2020 2020 2020 2023 2023 2323 2323 2323         # #######
-00004200: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00004210: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00004220: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00004230: 2323 2323 2323 2323 2323 2323 2323 230d  ###############.
-00004240: 0a0d 0a20 2020 2020 2020 206c 6f67 2e64  ...        log.d
-00004250: 6562 7567 2822 636f 6e6e 6563 7469 6f6e  ebug("connection
-00004260: 2073 7563 6365 7373 6675 6c22 290d 0a20   successful").. 
-00004270: 2020 2020 2020 2073 656c 662e 636f 6e6e         self.conn
-00004280: 6563 7465 6420 3d20 5472 7565 0d0a 2020  ected = True..  
-00004290: 2020 2020 2020 7365 6c66 2e63 6f6e 6e65        self.conne
-000042a0: 6374 696e 6720 3d20 4661 6c73 650d 0a0d  cting = False...
-000042b0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-000042c0: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
-000042d0: 6f6e 7365 2873 656c 662e 636f 6e6e 6563  onse(self.connec
-000042e0: 7465 6429 0d0a 0d0a 2020 2020 6465 6620  ted)....    def 
-000042f0: 6469 7363 6f6e 6e65 6374 2873 656c 6629  disconnect(self)
-00004300: 3a20 2320 2d3e 2053 7065 6374 726f 6d65  : # -> Spectrome
-00004310: 7465 7252 6573 706f 6e73 6520 0d0a 2020  terResponse ..  
-00004320: 2020 2020 2020 6966 2073 656c 662e 6c61        if self.la
-00004330: 7374 5f61 7070 6c69 6564 5f6c 6173 6572  st_applied_laser
-00004340: 5f70 6f77 6572 3a0d 0a20 2020 2020 2020  _power:..       
-00004350: 2020 2020 206c 6f67 2e64 6562 7567 2822       log.debug("
-00004360: 6669 642e 6469 7363 6f6e 6e65 6374 3a20  fid.disconnect: 
-00004370: 6469 7361 626c 696e 6720 6c61 7365 7222  disabling laser"
-00004380: 290d 0a20 2020 2020 2020 2020 2020 2073  )..            s
-00004390: 656c 662e 5f73 6574 5f6c 6173 6572 5f65  elf._set_laser_e
-000043a0: 6e61 626c 655f 696d 6d65 6469 6174 6528  nable_immediate(
-000043b0: 4661 6c73 6529 0d0a 0d0a 2020 2020 2020  False)....      
-000043c0: 2020 7365 6c66 2e63 6f6e 6e65 6374 6564    self.connected
-000043d0: 203d 2046 616c 7365 0d0a 0d0a 2020 2020   = False....    
-000043e0: 2020 2020 6c6f 672e 6372 6974 6963 616c      log.critical
-000043f0: 2822 6669 642e 6469 7363 6f6e 6e65 6374  ("fid.disconnect
-00004400: 3a20 7265 6c65 6173 696e 6720 696e 7465  : releasing inte
-00004410: 7266 6163 6522 290d 0a20 2020 2020 2020  rface")..       
-00004420: 2074 7279 3a0d 0a20 2020 2020 2020 2020   try:..         
-00004430: 2020 2023 7265 7375 6c74 203d 2073 656c     #result = sel
-00004440: 662e 6465 7669 6365 5f74 7970 652e 7265  f.device_type.re
-00004450: 6c65 6173 655f 696e 7465 7266 6163 6528  lease_interface(
-00004460: 7365 6c66 2e64 6576 6963 652c 2030 290d  self.device, 0).
-00004470: 0a20 2020 2020 2020 2020 2020 2074 7279  .            try
-00004480: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-00004490: 2020 2073 656c 662e 6465 7669 6365 5f74     self.device_t
-000044a0: 7970 652e 7265 7365 7428 7365 6c66 2e64  ype.reset(self.d
-000044b0: 6576 6963 6529 0d0a 2020 2020 2020 2020  evice)..        
-000044c0: 2020 2020 6578 6365 7074 3a0d 0a20 2020      except:..   
-000044d0: 2020 2020 2020 2020 2020 2020 206c 6f67               log
-000044e0: 2e65 7272 6f72 2822 436f 756c 646e 2774  .error("Couldn't
-000044f0: 2072 6573 6574 2064 6576 6963 6522 290d   reset device").
-00004500: 0a20 2020 2020 2020 2065 7863 6570 7420  .        except 
-00004510: 4578 6365 7074 696f 6e20 6173 2065 7863  Exception as exc
-00004520: 3a0d 0a20 2020 2020 2020 2020 2020 206c  :..            l
-00004530: 6f67 2e77 6172 6e28 2246 6169 6c75 7265  og.warn("Failure
-00004540: 2069 6e20 7265 6c65 6173 6520 696e 7465   in release inte
-00004550: 7266 6163 6522 2c20 6578 635f 696e 666f  rface", exc_info
-00004560: 3d31 290d 0a20 2020 2020 2020 2020 2020  =1)..           
-00004570: 2072 6169 7365 0d0a 2020 2020 2020 2020   raise..        
-00004580: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
-00004590: 7465 7252 6573 706f 6e73 6528 5472 7565  terResponse(True
-000045a0: 290d 0a0d 0a20 2020 2064 6566 205f 7363  )....    def _sc
-000045b0: 6865 6475 6c65 5f64 6973 636f 6e6e 6563  hedule_disconnec
-000045c0: 7428 7365 6c66 2c20 6578 6329 3a20 2320  t(self, exc): # 
-000045d0: 2d3e 204e 6f6e 6520 0d0a 2020 2020 2020  -> None ..      
-000045e0: 2020 2222 220d 0a20 2020 2020 2020 2053    """..        S
-000045f0: 6f6d 6574 6869 6e67 2069 6e20 7468 6520  omething in the 
-00004600: 6472 6976 6572 2068 6173 2063 6175 7365  driver has cause
-00004610: 6420 6974 2074 6f20 7265 7175 6573 7420  d it to request 
-00004620: 7468 6520 636f 6e74 726f 6c6c 696e 670d  the controlling.
-00004630: 0a20 2020 2020 2020 2061 7070 6c69 6361  .        applica
-00004640: 7469 6f6e 2074 6f20 636c 6f73 6520 7468  tion to close th
-00004650: 6520 7065 7269 7068 6572 616c 2e20 2054  e peripheral.  T
-00004660: 6865 206e 6578 7420 7469 6d65 0d0a 2020  he next time..  
-00004670: 2020 2020 2020 5761 7361 7463 6844 6576        WasatchDev
-00004680: 6963 652e 6163 7175 6972 655f 6461 7461  ice.acquire_data
-00004690: 2069 7320 6361 6c6c 6564 2c20 6974 2077   is called, it w
-000046a0: 696c 6c20 7061 7373 2061 2022 706f 6973  ill pass a "pois
-000046b0: 6f6e 2070 696c 6c22 2062 6163 6b0d 0a20  on pill" back.. 
-000046c0: 2020 2020 2020 2075 7020 7468 6520 7265         up the re
-000046d0: 7370 6f6e 7365 2071 7565 7565 2e0d 0a20  sponse queue... 
-000046e0: 2020 2020 2020 2041 6c74 6572 6e61 7465         Alternate
-000046f0: 6c79 2c20 6e6f 6e2d 454e 4c49 4748 5445  ly, non-ENLIGHTE
-00004700: 4e20 6361 6c6c 6572 7320 6361 6e20 7365  N callers can se
-00004710: 7420 2272 6169 7365 5f65 7863 6570 7469  t "raise_excepti
-00004720: 6f6e 7322 202d 3e20 5472 7565 2066 6f72  ons" -> True for
-00004730: 0d0a 2020 2020 2020 2020 696e 2d70 726f  ..        in-pro
-00004740: 6365 7373 2065 7863 6570 7469 6f6e 2d68  cess exception-h
-00004750: 616e 646c 696e 672e 0d0a 2020 2020 2020  andling...      
-00004760: 2020 2222 220d 0a20 2020 2020 2020 2069    """..        i
-00004770: 6620 7365 6c66 2e72 6169 7365 5f65 7863  f self.raise_exc
-00004780: 6570 7469 6f6e 733a 0d0a 2020 2020 2020  eptions:..      
-00004790: 2020 2020 2020 6c6f 672e 6372 6974 6963        log.critic
-000047a0: 616c 2822 5f73 6368 6564 756c 655f 6469  al("_schedule_di
-000047b0: 7363 6f6e 6e65 6374 3a20 7261 6973 696e  sconnect: raisin
-000047c0: 6720 6578 6365 7074 696f 6e20 2573 222c  g exception %s",
-000047d0: 2065 7863 290d 0a20 2020 2020 2020 2020   exc)..         
-000047e0: 2020 2072 6169 7365 2065 7863 0d0a 2020     raise exc..  
-000047f0: 2020 2020 2020 656c 7365 3a0d 0a20 2020        else:..   
-00004800: 2020 2020 2020 2020 206c 6f67 2e63 7269           log.cri
-00004810: 7469 6361 6c28 2272 6571 7565 7374 696e  tical("requestin
-00004820: 6720 7368 7574 646f 776e 2064 7565 2074  g shutdown due t
-00004830: 6f20 6578 6365 7074 696f 6e20 2573 222c  o exception %s",
-00004840: 2065 7863 290d 0a20 2020 2020 2020 2020   exc)..         
-00004850: 2020 2073 656c 662e 7368 7574 646f 776e     self.shutdown
-00004860: 5f72 6571 7565 7374 6564 203d 2054 7275  _requested = Tru
-00004870: 650d 0a0d 0a20 2020 2064 6566 2072 6573  e....    def res
-00004880: 6574 2873 656c 662c 202a 6172 6773 293a  et(self, *args):
-00004890: 2023 202d 3e20 4e6f 6e65 200d 0a20 2020   # -> None ..   
-000048a0: 2020 2020 206c 6f67 2e64 6562 7567 2822       log.debug("
-000048b0: 4649 4420 7065 7266 6f72 6d69 6e67 2064  FID performing d
-000048c0: 6576 6963 6520 7265 7365 7422 290d 0a20  evice reset").. 
-000048d0: 2020 2020 2020 2023 7365 6c66 2e64 6576         #self.dev
-000048e0: 6963 655f 7479 7065 2e72 656c 6561 7365  ice_type.release
-000048f0: 5f69 6e74 6572 6661 6365 2873 656c 662e  _interface(self.
-00004900: 6465 7669 6365 2c20 3029 0d0a 2020 2020  device, 0)..    
-00004910: 2020 2020 7365 6c66 2e64 6576 6963 655f      self.device_
-00004920: 7479 7065 2e72 6573 6574 2873 656c 662e  type.reset(self.
-00004930: 6465 7669 6365 290d 0a20 2020 2020 2020  device)..       
-00004940: 206c 6f67 2e64 6562 7567 2866 2266 7265   log.debug(f"fre
-00004950: 6564 2069 6e74 6572 6661 6365 2229 0d0a  ed interface")..
-00004960: 2020 2020 2020 2020 2727 270d 0a20 2020          '''..   
-00004970: 2020 2020 2070 7975 7362 5f64 6576 6963       pyusb_devic
-00004980: 6573 203d 206c 6973 7428 7365 6c66 2e64  es = list(self.d
-00004990: 6576 6963 655f 7479 7065 2e66 696e 6428  evice_type.find(
-000049a0: 6669 6e64 5f61 6c6c 3d54 7275 652c 200d  find_all=True, .
-000049b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000049c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000049d0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-000049e0: 6456 656e 646f 723d 7365 6c66 2e64 6576  dVendor=self.dev
-000049f0: 6963 655f 6964 2e76 6964 2c20 0d0a 2020  ice_id.vid, ..  
-00004a00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004a20: 2020 2020 2020 2020 2020 2020 6964 5072              idPr
-00004a30: 6f64 7563 743d 7365 6c66 2e64 6576 6963  oduct=self.devic
-00004a40: 655f 6964 2e70 6964 2c0d 0a20 2020 2020  e_id.pid,..     
-00004a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004a70: 2020 2020 2020 2020 2063 7573 746f 6d5f           custom_
-00004a80: 6d61 7463 6820 3d20 6c61 6d62 6461 2064  match = lambda d
-00004a90: 3a20 642e 6164 6472 6573 7320 3d3d 2073  : d.address == s
-00004aa0: 656c 662e 6465 7669 6365 5f69 642e 6164  elf.device_id.ad
-00004ab0: 6472 6573 7320 616e 6420 642e 6275 7320  dress and d.bus 
-00004ac0: 3d3d 2073 656c 662e 6465 7669 6365 5f69  == self.device_i
-00004ad0: 642e 6275 7329 290d 0a20 2020 2020 2020  d.bus))..       
-00004ae0: 2023 2061 2063 6f75 706c 6520 6e6f 7465   # a couple note
-00004af0: 732c 0d0a 2020 2020 2020 2020 2320 5768  s,..        # Wh
-00004b00: 656e 2079 6f75 2073 6561 7263 6820 686f  en you search ho
-00004b10: 7720 746f 2064 6f20 6120 7265 7365 7420  w to do a reset 
-00004b20: 6279 2065 6e61 626c 652f 6469 7361 626c  by enable/disabl
-00004b30: 6520 6f6e 2077 696e 646f 7773 2077 6861  e on windows wha
-00004b40: 7420 636f 6d65 7320 7570 2069 7320 6465  t comes up is de
-00004b50: 7663 6f6e 0d0a 2020 2020 2020 2020 2320  vcon..        # 
-00004b60: 6465 7663 6f6e 206c 696e 6b73 2074 6f20  devcon links to 
-00004b70: 706e 7075 7469 6c20 6173 2074 6865 2072  pnputil as the r
-00004b80: 6563 6f6d 6d65 6e64 6564 2074 6f6f 6c20  ecommended tool 
-00004b90: 746f 2075 7365 2061 6e64 2063 6f6d 6573  to use and comes
-00004ba0: 2070 7265 696e 7374 616c 6c65 6420 6f6e   preinstalled on
-00004bb0: 2077 696e 646f 7773 0d0a 2020 2020 2020   windows..      
-00004bc0: 2020 2320 706e 7075 7469 6c20 6e65 6564    # pnputil need
-00004bd0: 7320 7468 6520 696e 7374 616e 6365 2049  s the instance I
-00004be0: 442c 2077 6869 6368 2069 7320 7072 6574  D, which is pret
-00004bf0: 7479 2077 656c 6c20 6869 6464 656e 2069  ty well hidden i
-00004c00: 6e20 7079 7573 620d 0a20 2020 2020 2020  n pyusb..       
-00004c10: 2023 2049 2068 6164 2074 6f20 6c6f 6f6b   # I had to look
-00004c20: 2061 7420 7468 6520 6675 6c6c 2063 6f6e   at the full con
-00004c30: 6669 6775 7261 7469 6f6e 2073 7472 696e  figuration strin
-00004c40: 6720 616e 6420 7361 7720 7468 6174 2074  g and saw that t
-00004c50: 6865 2077 6179 2074 6f20 6765 7420 7468  he way to get th
-00004c60: 6520 696e 7374 616e 6365 2069 6420 7761  e instance id wa
-00004c70: 7320 7468 6520 666f 6c6c 6f77 696e 670d  s the following.
-00004c80: 0a20 2020 2020 2020 2023 2075 7369 6e67  .        # using
-00004c90: 205f 7472 795f 6765 745f 7374 7269 6e67   _try_get_string
-00004ca0: 2068 7474 7073 3a2f 2f67 6974 6875 622e   https://github.
-00004cb0: 636f 6d2f 7079 7573 622f 7079 7573 622f  com/pyusb/pyusb/
-00004cc0: 626c 6f62 2f6d 6173 7465 722f 7573 622f  blob/master/usb/
-00004cd0: 636f 7265 2e70 7923 4c31 3232 310d 0a20  core.py#L1221.. 
-00004ce0: 2020 2020 2020 2023 2073 6f20 7465 6368         # so tech
-00004cf0: 696e 6361 6c6c 7920 7765 2073 686f 756c  incally we shoul
-00004d00: 646e 2774 2064 6f20 7468 6973 2062 7920  dn't do this by 
-00004d10: 7468 6520 5f20 6d65 616e 696e 6720 6974  the _ meaning it
-00004d20: 2073 686f 756c 6420 6265 2070 7269 7661   should be priva
-00004d30: 7465 2c20 6275 7420 6974 2773 2074 6865  te, but it's the
-00004d40: 206f 6e6c 7920 7761 7920 4920 7365 650d   only way I see.
-00004d50: 0a20 2020 2020 2020 2064 6576 6963 655f  .        device_
-00004d60: 696e 7374 616e 6365 5f69 6420 3d20 6627  instance_id = f'
-00004d70: 5553 425c 5649 445f 7b73 656c 662e 6465  USB\VID_{self.de
-00004d80: 7669 6365 5f69 642e 7669 643a 3034 587d  vice_id.vid:04X}
-00004d90: 2650 4944 5f7b 7365 6c66 2e64 6576 6963  &PID_{self.devic
-00004da0: 655f 6964 2e70 6964 3a30 3458 7d5c 7b75  e_id.pid:04X}\{u
-00004db0: 7362 2e63 6f72 652e 5f74 7279 5f67 6574  sb.core._try_get
-00004dc0: 5f73 7472 696e 6728 7079 7573 625f 6465  _string(pyusb_de
-00004dd0: 7669 6365 735b 305d 2c20 7079 7573 625f  vices[0], pyusb_
-00004de0: 6465 7669 6365 735b 305d 2e69 5365 7269  devices[0].iSeri
-00004df0: 616c 4e75 6d62 6572 297d 270d 0a20 2020  alNumber)}'..   
-00004e00: 2020 2020 206c 6f67 2e64 6562 7567 2866       log.debug(f
-00004e10: 2249 6e20 7265 7365 7420 616e 6420 7265  "In reset and re
-00004e20: 7374 6172 7420 7472 7969 6e67 2074 6f20  start trying to 
-00004e30: 7265 7365 7420 696e 7374 616e 6365 2069  reset instance i
-00004e40: 6420 7b64 6576 6963 655f 696e 7374 616e  d {device_instan
-00004e50: 6365 5f69 647d 2229 0d0a 2020 2020 2020  ce_id}")..      
-00004e60: 2020 7375 6270 726f 6365 7373 2e72 756e    subprocess.run
-00004e70: 285b 2270 6e70 7574 696c 222c 2072 222f  (["pnputil", r"/
-00004e80: 7265 626f 6f74 222c 2072 222f 6469 7361  reboot", r"/disa
-00004e90: 626c 652d 6465 7669 6365 222c 2064 6576  ble-device", dev
-00004ea0: 6963 655f 696e 7374 616e 6365 5f69 645d  ice_instance_id]
-00004eb0: 290d 0a20 2020 2020 2020 2073 7562 7072  )..        subpr
-00004ec0: 6f63 6573 732e 7275 6e28 5b22 706e 7075  ocess.run(["pnpu
-00004ed0: 7469 6c22 2c20 7222 2f72 6562 6f6f 7422  til", r"/reboot"
-00004ee0: 2c20 7222 2f65 6e61 626c 652d 6465 7669  , r"/enable-devi
-00004ef0: 6365 222c 2064 6576 6963 655f 696e 7374  ce", device_inst
-00004f00: 616e 6365 5f69 645d 290d 0a27 2727 0d0a  ance_id])..'''..
-00004f10: 2020 2020 2320 2323 2323 2323 2323 2323      # ##########
-00004f20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00004f30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00004f40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00004f50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00004f60: 0d0a 2020 2020 2320 5574 696c 6974 7920  ..    # Utility 
-00004f70: 4d65 7468 6f64 730d 0a20 2020 2023 2023  Methods..    # #
-00004f80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00004f90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00004fa0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00004fb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00004fc0: 2323 2323 2323 2323 230d 0a0d 0a20 200d  #########....  .
-00004fd0: 0a20 2020 2064 6566 205f 746f 3430 6269  .    def _to40bi
-00004fe0: 7428 7365 6c66 2c20 7661 6c29 3a0d 0a20  t(self, val):.. 
-00004ff0: 2020 2020 2020 2022 2222 0d0a 2020 2020         """..    
-00005000: 2020 2020 4c61 7365 7220 6d6f 6475 6c61      Laser modula
-00005010: 7469 6f6e 2061 6e64 2063 6f6e 7469 6e75  tion and continu
-00005020: 6f75 732d 7374 726f 6265 2063 6f6d 6d61  ous-strobe comma
-00005030: 6e64 7320 7461 6b65 2061 7267 756d 656e  nds take argumen
-00005040: 7473 2069 6e20 6d69 6372 6f2d 0d0a 2020  ts in micro-..  
-00005050: 2020 2020 2020 7365 636f 6e64 7320 6173        seconds as
-00005060: 2034 302d 6269 7420 7661 6c75 6573 2c20   40-bit values, 
-00005070: 7768 6572 6520 7468 6520 6c65 6173 742d  where the least-
-00005080: 7369 676e 6966 6963 616e 7420 3136 2062  significant 16 b
-00005090: 6974 7320 6172 6520 7061 7373 6564 0d0a  its are passed..
-000050a0: 2020 2020 2020 2020 6173 2077 5661 6c75          as wValu
-000050b0: 652c 2074 6865 206e 6578 742d 7369 676e  e, the next-sign
-000050c0: 6966 6963 616e 7420 3136 2061 7320 7749  ificant 16 as wI
-000050d0: 6e64 6578 2c20 616e 6420 7468 6520 6d6f  ndex, and the mo
-000050e0: 7374 2d73 6967 6e69 6669 6361 6e74 0d0a  st-significant..
-000050f0: 2020 2020 2020 2020 6173 2061 2073 696e          as a sin
-00005100: 676c 6520 6279 7465 206f 6620 7061 796c  gle byte of payl
-00005110: 6f61 642e 2020 5468 6973 2066 756e 6374  oad.  This funct
-00005120: 696f 6e20 7461 6b65 7320 616e 2075 6e73  ion takes an uns
-00005130: 6967 6e65 6420 696e 7465 6772 616c 0d0a  igned integral..
-00005140: 2020 2020 2020 2020 7661 6c75 6520 2870          value (p
-00005150: 7265 7375 6d61 626c 7920 6d69 6372 6f73  resumably micros
-00005160: 6563 6f6e 6473 2920 616e 6420 7265 7475  econds) and retu
-00005170: 726e 7320 6120 7475 706c 6520 6f66 2077  rns a tuple of w
-00005180: 5661 6c75 652c 2077 496e 6465 780d 0a20  Value, wIndex.. 
-00005190: 2020 2020 2020 2061 6e64 2061 2062 7566         and a buf
-000051a0: 6665 7220 746f 2070 6173 7320 6173 2070  fer to pass as p
-000051b0: 6179 6c6f 6164 2e0d 0a20 2020 2020 2020  ayload...       
-000051c0: 2022 2222 0d0a 2020 2020 2020 2020 6c73   """..        ls
-000051d0: 7720 3d20 7661 6c20 2620 3078 6666 6666  w = val & 0xffff
-000051e0: 0d0a 2020 2020 2020 2020 6d73 7720 3d20  ..        msw = 
-000051f0: 2876 616c 203e 3e20 3136 2920 2620 3078  (val >> 16) & 0x
-00005200: 6666 6666 0d0a 2020 2020 2020 2020 6275  ffff..        bu
-00005210: 6620 3d20 5b20 2876 616c 203e 3e20 3332  f = [ (val >> 32
-00005220: 2920 2620 3078 6666 2c20 3020 2a20 3720  ) & 0xff, 0 * 7 
-00005230: 5d0d 0a20 2020 2020 2020 2072 6574 7572  ]..        retur
-00005240: 6e20 286c 7377 2c20 6d73 772c 2062 7566  n (lsw, msw, buf
-00005250: 290d 0a0d 0a20 2020 2064 6566 205f 7761  )....    def _wa
-00005260: 6974 5f66 6f72 5f75 7362 5f61 7661 696c  it_for_usb_avail
-00005270: 6162 6c65 2873 656c 6629 3a20 2320 2d3e  able(self): # ->
-00005280: 204e 6f6e 6520 0d0a 2020 2020 2020 2020   None ..        
-00005290: 2222 220d 0a20 2020 2020 2020 2057 6169  """..        Wai
-000052a0: 7420 756e 7469 6c20 616e 7920 656e 666f  t until any enfo
-000052b0: 7263 6564 2055 5342 2070 6163 6b65 7420  rced USB packet 
-000052c0: 696e 7465 7276 616c 7320 6861 7665 2065  intervals have e
-000052d0: 6c61 7073 6564 2e20 5468 6973 2064 6f65  lapsed. This doe
-000052e0: 730d 0a20 2020 2020 2020 206e 6f74 6869  s..        nothi
-000052f0: 6e67 2069 6e20 6d6f 7374 2063 6173 6573  ng in most cases
-00005300: 202d 2074 6865 2066 756e 6374 696f 6e20   - the function 
-00005310: 6973 206e 6f72 6d61 6c6c 7920 6120 6e6f  is normally a no
-00005320: 2d6f 702e 0d0a 2020 2020 2020 2020 486f  -op...        Ho
-00005330: 7765 7665 722c 2069 6620 7468 6520 6170  wever, if the ap
-00005340: 706c 6963 6174 696f 6e20 6861 7320 6465  plication has de
-00005350: 6669 6e65 6420 6d69 6e2f 6d61 785f 7573  fined min/max_us
-00005360: 625f 696e 7465 7276 616c 5f6d 7320 2873  b_interval_ms (s
-00005370: 6179 0d0a 2020 2020 2020 2020 2832 302c  ay..        (20,
-00005380: 2035 306d 7329 2c20 7468 656e 2070 6963   50ms), then pic
-00005390: 6b20 6120 7261 6e64 6f6d 2064 656c 6179  k a random delay
-000053a0: 2069 6e20 7468 6520 6465 6669 6e65 6420   in the defined 
-000053b0: 7769 6e64 6f77 2028 652e 672e 2033 376d  window (e.g. 37m
-000053c0: 7329 0d0a 2020 2020 2020 2020 616e 6420  s)..        and 
-000053d0: 736c 6565 7020 756e 7469 6c20 6974 2068  sleep until it h
-000053e0: 6173 2062 6565 6e20 6174 206c 6561 7374  as been at least
-000053f0: 2074 6861 7420 6c6f 6e67 2073 696e 6365   that long since
-00005400: 2074 6865 206c 6173 7420 5553 420d 0a20   the last USB.. 
-00005410: 2020 2020 2020 2065 7863 6861 6e67 652e         exchange.
-00005420: 0d0a 2020 2020 2020 2020 5468 6520 7075  ..        The pu
-00005430: 7270 6f73 6520 6f66 2074 6869 7320 6675  rpose of this fu
-00005440: 6e63 7469 6f6e 2077 6173 2074 6f20 7772  nction was to wr
-00005450: 696e 672d 6f75 7420 736f 6d65 2065 6172  ing-out some ear
-00005460: 6c79 2041 524d 206d 6963 726f 2d0d 0a20  ly ARM micro-.. 
-00005470: 2020 2020 2020 2063 6f6e 7472 6f6c 6c65         controlle
-00005480: 7273 2077 6974 6820 6170 7061 7265 6e74  rs with apparent
-00005490: 2074 696d 696e 6720 6973 7375 6573 2075   timing issues u
-000054a0: 6e64 6572 2068 6967 682d 7370 6565 6420  nder high-speed 
-000054b0: 5553 4220 322e 302c 2074 6f20 7365 650d  USB 2.0, to see.
-000054c0: 0a20 2020 2020 2020 2069 6620 636f 6d6d  .        if comm
-000054d0: 756e 6963 6174 696f 6e73 2069 7373 7565  unications issue
-000054e0: 7320 6469 7361 7070 6561 7265 6420 6966  s disappeared if
-000054f0: 2077 6520 656e 666f 7263 6564 2061 2063   we enforced a c
-00005500: 6f6d 6d75 6e69 6361 7469 6f6e 0d0a 2020  ommunication..  
-00005510: 2020 2020 2020 6c61 7465 6e63 7920 6672        latency fr
-00005520: 6f6d 2074 6865 2073 6f66 7477 6172 6520  om the software 
-00005530: 7369 6465 2e0d 0a20 2020 2020 2020 2022  side...        "
-00005540: 2222 0d0a 2020 2020 2020 2020 6966 2073  ""..        if s
-00005550: 656c 662e 7365 7474 696e 6773 2e73 7461  elf.settings.sta
-00005560: 7465 2e6d 6178 5f75 7362 5f69 6e74 6572  te.max_usb_inter
-00005570: 7661 6c5f 6d73 203c 3d20 303a 0d0a 2020  val_ms <= 0:..  
-00005580: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00005590: 0d0a 0d0a 2020 2020 2020 2020 6966 2073  ....        if s
-000055a0: 656c 662e 6c61 7374 5f75 7362 5f74 696d  elf.last_usb_tim
-000055b0: 6573 7461 6d70 2069 7320 6e6f 7420 4e6f  estamp is not No
-000055c0: 6e65 3a0d 0a20 2020 2020 2020 2020 2020  ne:..           
-000055d0: 2064 656c 6179 5f6d 7320 3d20 7261 6e64   delay_ms = rand
-000055e0: 696e 7428 7365 6c66 2e73 6574 7469 6e67  int(self.setting
-000055f0: 732e 7374 6174 652e 6d69 6e5f 7573 625f  s.state.min_usb_
-00005600: 696e 7465 7276 616c 5f6d 732c 2073 656c  interval_ms, sel
-00005610: 662e 7365 7474 696e 6773 2e73 7461 7465  f.settings.state
-00005620: 2e6d 6178 5f75 7362 5f69 6e74 6572 7661  .max_usb_interva
-00005630: 6c5f 6d73 290d 0a20 2020 2020 2020 2020  l_ms)..         
-00005640: 2020 206e 6578 745f 7573 625f 7469 6d65     next_usb_time
-00005650: 7374 616d 7020 3d20 7365 6c66 2e6c 6173  stamp = self.las
-00005660: 745f 7573 625f 7469 6d65 7374 616d 7020  t_usb_timestamp 
-00005670: 2b20 6461 7465 7469 6d65 2e74 696d 6564  + datetime.timed
-00005680: 656c 7461 286d 696c 6c69 7365 636f 6e64  elta(millisecond
-00005690: 733d 6465 6c61 795f 6d73 290d 0a20 2020  s=delay_ms)..   
-000056a0: 2020 2020 2020 2020 206e 6f77 203d 2064           now = d
-000056b0: 6174 6574 696d 652e 6461 7465 7469 6d65  atetime.datetime
-000056c0: 2e6e 6f77 2829 0d0a 2020 2020 2020 2020  .now()..        
-000056d0: 2020 2020 6966 206e 6f77 203c 206e 6578      if now < nex
-000056e0: 745f 7573 625f 7469 6d65 7374 616d 703a  t_usb_timestamp:
-000056f0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00005700: 2020 736c 6565 705f 7365 6320 3d20 286e    sleep_sec = (n
-00005710: 6578 745f 7573 625f 7469 6d65 7374 616d  ext_usb_timestam
-00005720: 7020 2d20 6e6f 7729 2e74 6f74 616c 5f73  p - now).total_s
-00005730: 6563 6f6e 6473 2829 0d0a 2020 2020 2020  econds()..      
-00005740: 2020 2020 2020 2020 2020 6c6f 672e 6465            log.de
-00005750: 6275 6728 2266 6964 3a20 736c 6565 7069  bug("fid: sleepi
-00005760: 6e67 2025 2e33 6620 7365 6320 746f 2065  ng %.3f sec to e
-00005770: 6e66 6f72 6365 2025 6420 6d73 2055 5342  nforce %d ms USB
-00005780: 2069 6e74 6572 7661 6c22 2c20 736c 6565   interval", slee
-00005790: 705f 7365 632c 2064 656c 6179 5f6d 7329  p_sec, delay_ms)
-000057a0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000057b0: 2020 736c 6565 7028 736c 6565 705f 7365    sleep(sleep_se
-000057c0: 6329 0d0a 2020 2020 2020 2020 7365 6c66  c)..        self
-000057d0: 2e6c 6173 745f 7573 625f 7469 6d65 7374  .last_usb_timest
-000057e0: 616d 7020 3d20 6461 7465 7469 6d65 2e64  amp = datetime.d
-000057f0: 6174 6574 696d 652e 6e6f 7728 290d 0a0d  atetime.now()...
-00005800: 0a20 2020 2064 6566 205f 6368 6563 6b5f  .    def _check_
-00005810: 666f 725f 7261 6e64 6f6d 5f65 7272 6f72  for_random_error
-00005820: 2873 656c 6629 3a20 2320 2d3e 2062 6f6f  (self): # -> boo
-00005830: 6c20 0d0a 2020 2020 2020 2020 2222 220d  l ..        """.
-00005840: 0a20 2020 2020 2020 2054 6869 7320 6675  .        This fu
-00005850: 6e63 7469 6f6e 2069 7320 7072 6f76 6964  nction is provid
-00005860: 6564 2074 6f20 7369 6d75 6c61 7465 2072  ed to simulate r
-00005870: 616e 646f 6d20 5553 4220 636f 6d6d 756e  andom USB commun
-00005880: 6963 6174 696f 6e20 6572 726f 7273 0d0a  ication errors..
-00005890: 2020 2020 2020 2020 6475 7269 6e67 2072          during r
-000058a0: 6567 7265 7373 696f 6e20 7465 7374 696e  egression testin
-000058b0: 672c 2061 6e64 2069 7320 6e6f 726d 616c  g, and is normal
-000058c0: 6c79 2061 206e 6f2d 6f70 2e0d 0a20 2020  ly a no-op...   
-000058d0: 2020 2020 2022 2222 0d0a 2020 2020 2020       """..      
-000058e0: 2020 6966 206e 6f74 2073 656c 662e 696e    if not self.in
-000058f0: 6a65 6374 5f72 616e 646f 6d5f 6572 726f  ject_random_erro
-00005900: 7273 3a0d 0a20 2020 2020 2020 2020 2020  rs:..           
-00005910: 2072 6574 7572 6e20 4661 6c73 650d 0a0d   return False...
-00005920: 0a20 2020 2020 2020 2069 6620 7261 6e64  .        if rand
-00005930: 6f6d 2e72 616e 646f 6d28 2920 3c3d 2073  om.random() <= s
-00005940: 656c 662e 7261 6e64 6f6d 5f65 7272 6f72  elf.random_error
-00005950: 5f70 6572 633a 0d0a 2020 2020 2020 2020  _perc:..        
-00005960: 2020 2020 6c6f 672e 6372 6974 6963 616c      log.critical
-00005970: 2822 5261 6e64 6f6d 6c79 2d69 6e6a 6563  ("Randomly-injec
-00005980: 7465 6420 6572 726f 7222 290d 0a20 2020  ted error")..   
-00005990: 2020 2020 2020 2020 2073 656c 662e 5f73           self._s
-000059a0: 6368 6564 756c 655f 6469 7363 6f6e 6e65  chedule_disconne
-000059b0: 6374 2845 7863 6570 7469 6f6e 2822 5261  ct(Exception("Ra
-000059c0: 6e64 6f6d 6c79 2d69 6e6a 6563 7465 6420  ndomly-injected 
-000059d0: 6572 726f 7222 2929 0d0a 2020 2020 2020  error"))..      
-000059e0: 2020 2020 2020 7265 7475 726e 2054 7275        return Tru
-000059f0: 650d 0a20 2020 2020 2020 2072 6574 7572  e..        retur
-00005a00: 6e20 4661 6c73 650d 0a0d 0a20 2020 2023  n False....    #
-00005a10: 230d 0a20 2020 2023 2055 6e74 696c 2073  #..    # Until s
-00005a20: 7570 706f 7274 2066 6f72 2065 7665 6e2f  upport for even/
-00005a30: 6f64 6420 496e 4761 4173 2067 6169 6e20  odd InGaAs gain 
-00005a40: 616e 6420 6f66 6673 6574 2068 6176 6520  and offset have 
-00005a50: 6265 656e 2061 6464 6564 2074 6f20 7468  been added to th
-00005a60: 650d 0a20 2020 2023 2066 6972 6d77 6172  e..    # firmwar
-00005a70: 652c 2061 7070 6c79 2074 6865 2063 6f72  e, apply the cor
-00005a80: 7265 6374 696f 6e20 696e 2073 6f66 7477  rection in softw
-00005a90: 6172 652e 0d0a 2020 2020 6465 6620 5f63  are...    def _c
-00005aa0: 6f72 7265 6374 5f69 6e67 6161 735f 6761  orrect_ingaas_ga
-00005ab0: 696e 5f61 6e64 5f6f 6666 7365 7428 7365  in_and_offset(se
-00005ac0: 6c66 2c20 7370 6563 7472 756d 3a20 6c69  lf, spectrum: li
-00005ad0: 7374 5b66 6c6f 6174 5d29 3a20 2320 2d3e  st[float]): # ->
-00005ae0: 2062 6f6f 6c20 0d0a 2020 2020 2020 2020   bool ..        
-00005af0: 6966 206e 6f74 2073 656c 662e 7365 7474  if not self.sett
-00005b00: 696e 6773 2e69 735f 696e 6761 6173 2829  ings.is_ingaas()
-00005b10: 206f 7220 7365 6c66 2e73 6574 7469 6e67   or self.setting
-00005b20: 732e 6565 7072 6f6d 2e68 6172 6477 6172  s.eeprom.hardwar
-00005b30: 655f 6576 656e 5f6f 6464 3a0d 0a20 2020  e_even_odd:..   
-00005b40: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00005b50: 4661 6c73 650d 0a0d 0a20 2020 2020 2020  False....       
-00005b60: 2023 2069 6620 6576 656e 2061 6e64 206f   # if even and o
-00005b70: 6464 2070 6978 656c 7320 6861 7665 2074  dd pixels have t
-00005b80: 6865 2073 616d 6520 7365 7474 696e 6773  he same settings
-00005b90: 2c20 7468 6572 6527 7320 6e6f 2070 6f69  , there's no poi
-00005ba0: 6e74 2069 6e20 646f 696e 6720 616e 7974  nt in doing anyt
-00005bb0: 6869 6e67 0d0a 2020 2020 2020 2020 6966  hing..        if
-00005bc0: 2073 656c 662e 7365 7474 696e 6773 2e65   self.settings.e
-00005bd0: 6570 726f 6d2e 6465 7465 6374 6f72 5f67  eprom.detector_g
-00005be0: 6169 6e5f 6f64 6420 2020 3d3d 2073 656c  ain_odd   == sel
-00005bf0: 662e 7365 7474 696e 6773 2e65 6570 726f  f.settings.eepro
-00005c00: 6d2e 6465 7465 6374 6f72 5f67 6169 6e20  m.detector_gain 
-00005c10: 616e 6420 5c0d 0a20 2020 2020 2020 2020  and \..         
-00005c20: 2020 7365 6c66 2e73 6574 7469 6e67 732e    self.settings.
-00005c30: 6565 7072 6f6d 2e64 6574 6563 746f 725f  eeprom.detector_
-00005c40: 6f66 6673 6574 5f6f 6464 203d 3d20 7365  offset_odd == se
-00005c50: 6c66 2e73 6574 7469 6e67 732e 6565 7072  lf.settings.eepr
-00005c60: 6f6d 2e64 6574 6563 746f 725f 6f66 6673  om.detector_offs
-00005c70: 6574 3a0d 0a20 2020 2020 2020 2020 2020  et:..           
-00005c80: 2072 6574 7572 6e20 4661 6c73 650d 0a0d   return False...
-00005c90: 0a20 2020 2020 2020 206c 6f67 2e64 6562  .        log.deb
-00005ca0: 7567 2822 7265 7363 616c 696e 6720 496e  ug("rescaling In
-00005cb0: 4761 4173 206f 6464 2070 6978 656c 7320  GaAs odd pixels 
-00005cc0: 6672 6f6d 2065 7665 6e20 6761 696e 2025  from even gain %
-00005cd0: 2e34 662c 206f 6666 7365 7420 2564 2074  .4f, offset %d t
-00005ce0: 6f20 6f64 6420 6761 696e 2025 2e34 662c  o odd gain %.4f,
-00005cf0: 206f 6666 7365 7420 2564 222c 0d0a 2020   offset %d",..  
-00005d00: 2020 2020 2020 2020 2020 7365 6c66 2e73            self.s
-00005d10: 6574 7469 6e67 732e 6565 7072 6f6d 2e64  ettings.eeprom.d
-00005d20: 6574 6563 746f 725f 6761 696e 2c0d 0a20  etector_gain,.. 
-00005d30: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00005d40: 7365 7474 696e 6773 2e65 6570 726f 6d2e  settings.eeprom.
-00005d50: 6465 7465 6374 6f72 5f6f 6666 7365 742c  detector_offset,
-00005d60: 0d0a 2020 2020 2020 2020 2020 2020 7365  ..            se
-00005d70: 6c66 2e73 6574 7469 6e67 732e 6565 7072  lf.settings.eepr
-00005d80: 6f6d 2e64 6574 6563 746f 725f 6761 696e  om.detector_gain
-00005d90: 5f6f 6464 2c0d 0a20 2020 2020 2020 2020  _odd,..         
-00005da0: 2020 2073 656c 662e 7365 7474 696e 6773     self.settings
-00005db0: 2e65 6570 726f 6d2e 6465 7465 6374 6f72  .eeprom.detector
-00005dc0: 5f6f 6666 7365 745f 6f64 6429 0d0a 0d0a  _offset_odd)....
-00005dd0: 2020 2020 2020 2020 6c6f 672e 6465 6275          log.debu
-00005de0: 6728 2262 6566 6f72 653a 2025 642c 2025  g("before: %d, %
-00005df0: 642c 2025 642c 2025 642c 2025 6422 2c20  d, %d, %d, %d", 
-00005e00: 7370 6563 7472 756d 5b30 5d2c 2073 7065  spectrum[0], spe
-00005e10: 6374 7275 6d5b 315d 2c20 7370 6563 7472  ctrum[1], spectr
-00005e20: 756d 5b32 5d2c 2073 7065 6374 7275 6d5b  um[2], spectrum[
-00005e30: 335d 2c20 7370 6563 7472 756d 5b34 5d29  3], spectrum[4])
-00005e40: 0d0a 0d0a 2020 2020 2020 2020 2320 6974  ....        # it
-00005e50: 6572 6174 6520 6f76 6572 2074 6865 204f  erate over the O
-00005e60: 4444 2070 6978 656c 7320 6f66 2074 6865  DD pixels of the
-00005e70: 2073 7065 6374 7275 6d0d 0a20 2020 2020   spectrum..     
-00005e80: 2020 2066 6f72 2069 2069 6e20 7261 6e67     for i in rang
-00005e90: 6528 312c 206c 656e 2873 7065 6374 7275  e(1, len(spectru
-00005ea0: 6d29 2c20 3229 3a0d 0a0d 0a20 2020 2020  m), 2):....     
-00005eb0: 2020 2020 2020 2023 2062 6163 6b2d 6f75         # back-ou
-00005ec0: 7420 7468 6520 696e 636f 7272 6563 746c  t the incorrectl
-00005ed0: 7920 6170 706c 6965 6420 2265 7665 6e22  y applied "even"
-00005ee0: 2067 6169 6e20 616e 6420 6f66 6673 6574   gain and offset
-00005ef0: 0d0a 2020 2020 2020 2020 2020 2020 6f6c  ..            ol
-00005f00: 6420 3d20 666c 6f61 7428 7370 6563 7472  d = float(spectr
-00005f10: 756d 5b69 5d29 0d0a 2020 2020 2020 2020  um[i])..        
-00005f20: 2020 2020 7261 7720 3d20 286f 6c64 202d      raw = (old -
-00005f30: 2073 656c 662e 7365 7474 696e 6773 2e65   self.settings.e
-00005f40: 6570 726f 6d2e 6465 7465 6374 6f72 5f6f  eprom.detector_o
-00005f50: 6666 7365 7429 202f 2073 656c 662e 7365  ffset) / self.se
-00005f60: 7474 696e 6773 2e65 6570 726f 6d2e 6465  ttings.eeprom.de
-00005f70: 7465 6374 6f72 5f67 6169 6e0d 0a0d 0a20  tector_gain.... 
-00005f80: 2020 2020 2020 2020 2020 2023 2061 7070             # app
-00005f90: 6c79 2074 6865 2063 6f72 7265 6374 2022  ly the correct "
-00005fa0: 6f64 6422 2067 6169 6e20 616e 6420 6f66  odd" gain and of
-00005fb0: 6673 6574 0d0a 2020 2020 2020 2020 2020  fset..          
-00005fc0: 2020 7370 6563 7472 756d 5b69 5d20 3d20    spectrum[i] = 
-00005fd0: 2872 6177 202a 2073 656c 662e 7365 7474  (raw * self.sett
-00005fe0: 696e 6773 2e65 6570 726f 6d2e 6465 7465  ings.eeprom.dete
-00005ff0: 6374 6f72 5f67 6169 6e5f 6f64 6429 202b  ctor_gain_odd) +
-00006000: 2073 656c 662e 7365 7474 696e 6773 2e65   self.settings.e
-00006010: 6570 726f 6d2e 6465 7465 6374 6f72 5f6f  eprom.detector_o
-00006020: 6666 7365 745f 6f64 640d 0a0d 0a20 2020  ffset_odd....   
-00006030: 2020 2020 2020 2020 2069 6620 6920 3c20           if i < 
-00006040: 3520 6f72 2069 203e 206c 656e 2873 7065  5 or i > len(spe
-00006050: 6374 7275 6d29 202d 2035 3a0d 0a20 2020  ctrum) - 5:..   
-00006060: 2020 2020 2020 2020 2020 2020 206c 6f67               log
-00006070: 2e64 6562 7567 2822 2020 7069 7865 6c20  .debug("  pixel 
-00006080: 2534 643a 206f 6c64 2025 2e32 6620 7261  %4d: old %.2f ra
-00006090: 7720 252e 3266 206e 6577 2025 2e32 6622  w %.2f new %.2f"
-000060a0: 2c20 692c 206f 6c64 2c20 7261 772c 2073  , i, old, raw, s
-000060b0: 7065 6374 7275 6d5b 695d 290d 0a0d 0a20  pectrum[i]).... 
-000060c0: 2020 2020 2020 206c 6f67 2e64 6562 7567         log.debug
-000060d0: 2822 6166 7465 723a 2025 642c 2025 642c  ("after: %d, %d,
-000060e0: 2025 642c 2025 642c 2025 6422 2c20 7370   %d, %d, %d", sp
-000060f0: 6563 7472 756d 5b30 5d2c 2073 7065 6374  ectrum[0], spect
-00006100: 7275 6d5b 315d 2c20 7370 6563 7472 756d  rum[1], spectrum
-00006110: 5b32 5d2c 2073 7065 6374 7275 6d5b 335d  [2], spectrum[3]
-00006120: 2c20 7370 6563 7472 756d 5b34 5d29 0d0a  , spectrum[4])..
-00006130: 0d0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-00006140: 2054 7275 650d 0a0d 0a20 2020 2064 6566   True....    def
-00006150: 205f 6170 706c 795f 3278 325f 6269 6e6e   _apply_2x2_binn
-00006160: 696e 6728 7365 6c66 2c20 7370 6563 7472  ing(self, spectr
-00006170: 756d 3a20 6c69 7374 5b66 6c6f 6174 5d29  um: list[float])
-00006180: 3a20 2320 2d3e 206c 6973 745b 666c 6f61  : # -> list[floa
-00006190: 745d 200d 0a20 2020 2020 2020 2069 6620  t] ..        if 
-000061a0: 6e6f 7420 7365 6c66 2e73 6574 7469 6e67  not self.setting
-000061b0: 732e 6565 7072 6f6d 2e62 696e 5f32 7832  s.eeprom.bin_2x2
-000061c0: 3a0d 0a20 2020 2020 2020 2020 2020 2072  :..            r
-000061d0: 6574 7572 6e20 7370 6563 7472 756d 0d0a  eturn spectrum..
-000061e0: 0d0a 2020 2020 2020 2020 6465 6620 6269  ..        def bi
-000061f0: 6e32 7832 2861 293a 0d0a 2020 2020 2020  n2x2(a):..      
-00006200: 2020 2020 2020 6966 2061 2069 7320 4e6f        if a is No
-00006210: 6e65 206f 7220 6c65 6e28 6129 203d 3d20  ne or len(a) == 
-00006220: 303a 0d0a 2020 2020 2020 2020 2020 2020  0:..            
-00006230: 2020 2020 7265 7475 726e 2061 0d0a 2020      return a..  
-00006240: 2020 2020 2020 2020 2020 6269 6e6e 6564            binned
-00006250: 203d 205b 5d0d 0a20 2020 2020 2020 2020   = []..         
-00006260: 2020 2066 6f72 2069 2069 6e20 7261 6e67     for i in rang
-00006270: 6528 6c65 6e28 6129 2d31 293a 0d0a 2020  e(len(a)-1):..  
-00006280: 2020 2020 2020 2020 2020 2020 2020 6269                bi
-00006290: 6e6e 6564 2e61 7070 656e 6428 2861 5b69  nned.append((a[i
-000062a0: 5d20 2b20 615b 692b 315d 2920 2f20 322e  ] + a[i+1]) / 2.
-000062b0: 3029 0d0a 2020 2020 2020 2020 2020 2020  0)..            
-000062c0: 6269 6e6e 6564 2e61 7070 656e 6428 615b  binned.append(a[
-000062d0: 2d31 5d29 0d0a 2020 2020 2020 2020 2020  -1])..          
-000062e0: 2020 7265 7475 726e 2062 696e 6e65 640d    return binned.
-000062f0: 0a0d 0a20 2020 2020 2020 2069 6620 7365  ...        if se
-00006300: 6c66 2e73 6574 7469 6e67 732e 7374 6174  lf.settings.stat
-00006310: 652e 6465 7465 6374 6f72 5f72 6567 696f  e.detector_regio
-00006320: 6e73 2069 7320 4e6f 6e65 3a0d 0a20 2020  ns is None:..   
-00006330: 2020 2020 2020 2020 206c 6f67 2e64 6562           log.deb
-00006340: 7567 2822 6170 706c 7969 6e67 2062 696e  ug("applying bin
-00006350: 5f32 7832 2229 0d0a 2020 2020 2020 2020  _2x2")..        
-00006360: 2020 2020 7265 7475 726e 2062 696e 3278      return bin2x
-00006370: 3228 7370 6563 7472 756d 290d 0a0d 0a20  2(spectrum).... 
-00006380: 2020 2020 2020 206c 6f67 2e64 6562 7567         log.debug
-00006390: 2822 6170 706c 7969 6e67 2062 696e 5f32  ("applying bin_2
-000063a0: 7832 2074 6f20 7265 6769 6f6e 7322 290d  x2 to regions").
-000063b0: 0a20 2020 2020 2020 2063 6f6d 6269 6e65  .        combine
-000063c0: 6420 3d20 5b5d 0d0a 2020 2020 2020 2020  d = []..        
-000063d0: 666f 7220 7375 6273 7065 6374 7275 6d20  for subspectrum 
-000063e0: 696e 2073 656c 662e 7365 7474 696e 6773  in self.settings
-000063f0: 2e73 7461 7465 2e64 6574 6563 746f 725f  .state.detector_
-00006400: 7265 6769 6f6e 732e 7370 6c69 7428 7370  regions.split(sp
-00006410: 6563 7472 756d 293a 0d0a 2020 2020 2020  ectrum):..      
-00006420: 2020 2020 2020 636f 6d62 696e 6564 2e65        combined.e
-00006430: 7874 656e 6428 6269 6e32 7832 2873 7562  xtend(bin2x2(sub
-00006440: 7370 6563 7472 756d 2929 0d0a 2020 2020  spectrum))..    
-00006450: 2020 2020 7265 7475 726e 2063 6f6d 6269      return combi
-00006460: 6e65 640d 0a0d 0a20 2020 2064 6566 205f  ned....    def _
-00006470: 636f 7272 6563 745f 6261 645f 7069 7865  correct_bad_pixe
-00006480: 6c73 2873 656c 662c 2073 7065 6374 7275  ls(self, spectru
-00006490: 6d3a 206c 6973 745b 666c 6f61 745d 293a  m: list[float]):
-000064a0: 2023 202d 3e20 626f 6f6c 200d 0a20 2020   # -> bool ..   
-000064b0: 2020 2020 2022 2222 0d0a 2020 2020 2020       """..      
-000064c0: 2020 4966 2061 2073 7065 6374 726f 6d65    If a spectrome
-000064d0: 7465 7220 6861 7320 6261 645f 7069 7865  ter has bad_pixe
-000064e0: 6c73 2063 6f6e 6669 6775 7265 6420 696e  ls configured in
-000064f0: 2074 6865 2045 4550 524f 4d2c 2074 6865   the EEPROM, the
-00006500: 6e20 6176 6572 6167 650d 0a20 2020 2020  n average..     
-00006510: 2020 206f 7665 7220 7468 656d 2069 6e20     over them in 
-00006520: 7468 6520 6472 6976 6572 2e0d 0a20 2020  the driver...   
-00006530: 2020 2020 204e 6f74 6520 7468 6973 2066       Note this f
-00006540: 756e 6374 696f 6e20 6d6f 6469 6669 6573  unction modifies
-00006550: 2074 6865 2070 6173 7365 6420 6172 7261   the passed arra
-00006560: 7920 696e 2d70 6c61 6365 2c20 7261 7468  y in-place, rath
-00006570: 6572 2074 6861 6e0d 0a20 2020 2020 2020  er than..       
-00006580: 2072 6574 7572 6e69 6e67 2061 206d 6f64   returning a mod
-00006590: 6966 6965 6420 636f 7079 2e0d 0a20 2020  ified copy...   
-000065a0: 2020 2020 2040 6e6f 7465 2061 7373 756d       @note assum
-000065b0: 6573 2062 6164 5f70 6978 656c 7320 6973  es bad_pixels is
-000065c0: 2070 7265 7669 6f75 736c 7920 736f 7274   previously sort
-000065d0: 6564 0d0a 2020 2020 2020 2020 2222 220d  ed..        """.
-000065e0: 0a0d 0a20 2020 2020 2020 2069 6620 7365  ...        if se
-000065f0: 6c66 2e73 6574 7469 6e67 7320 6973 204e  lf.settings is N
-00006600: 6f6e 6520 6f72 205c 0d0a 2020 2020 2020  one or \..      
-00006610: 2020 2020 2020 2020 2020 7365 6c66 2e73            self.s
-00006620: 6574 7469 6e67 732e 6565 7072 6f6d 2069  ettings.eeprom i
-00006630: 7320 4e6f 6e65 206f 7220 5c0d 0a20 2020  s None or \..   
-00006640: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-00006650: 662e 7365 7474 696e 6773 2e65 6570 726f  f.settings.eepro
-00006660: 6d2e 6261 645f 7069 7865 6c73 2069 7320  m.bad_pixels is 
-00006670: 4e6f 6e65 206f 7220 5c0d 0a20 2020 2020  None or \..     
-00006680: 2020 2020 2020 2020 2020 206c 656e 2873             len(s
-00006690: 656c 662e 7365 7474 696e 6773 2e65 6570  elf.settings.eep
-000066a0: 726f 6d2e 6261 645f 7069 7865 6c73 2920  rom.bad_pixels) 
-000066b0: 3d3d 2030 206f 7220 5c0d 0a20 2020 2020  == 0 or \..     
-000066c0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-000066d0: 7365 7474 696e 6773 2e73 7461 7465 2e64  settings.state.d
-000066e0: 6574 6563 746f 725f 7265 6769 6f6e 7320  etector_regions 
-000066f0: 6973 206e 6f74 204e 6f6e 653a 0d0a 2020  is not None:..  
-00006700: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00006710: 2046 616c 7365 0d0a 0d0a 2020 2020 2020   False....      
-00006720: 2020 6966 2073 7065 6374 7275 6d20 6973    if spectrum is
-00006730: 204e 6f6e 6520 6f72 206c 656e 2873 7065   None or len(spe
-00006740: 6374 7275 6d29 203d 3d20 303a 0d0a 2020  ctrum) == 0:..  
-00006750: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00006760: 2046 616c 7365 0d0a 0d0a 2020 2020 2020   False....      
-00006770: 2020 7069 7865 6c73 203d 206c 656e 2873    pixels = len(s
-00006780: 7065 6374 7275 6d29 0d0a 2020 2020 2020  pectrum)..      
-00006790: 2020 6261 645f 7069 7865 6c73 203d 2073    bad_pixels = s
-000067a0: 656c 662e 7365 7474 696e 6773 2e65 6570  elf.settings.eep
-000067b0: 726f 6d2e 6261 645f 7069 7865 6c73 0d0a  rom.bad_pixels..
-000067c0: 0d0a 2020 2020 2020 2020 2320 6974 6572  ..        # iter
-000067d0: 6174 6520 6f76 6572 2065 6163 6820 6261  ate over each ba
-000067e0: 6420 7069 7865 6c0d 0a20 2020 2020 2020  d pixel..       
-000067f0: 2069 203d 2030 0d0a 2020 2020 2020 2020   i = 0..        
-00006800: 7768 696c 6520 6920 3c20 6c65 6e28 6261  while i < len(ba
-00006810: 645f 7069 7865 6c73 293a 0d0a 0d0a 2020  d_pixels):....  
-00006820: 2020 2020 2020 2020 2020 6261 645f 7069            bad_pi
-00006830: 7820 3d20 6261 645f 7069 7865 6c73 5b69  x = bad_pixels[i
-00006840: 5d0d 0a0d 0a20 2020 2020 2020 2020 2020  ]....           
-00006850: 2069 6620 6261 645f 7069 7820 3d3d 2030   if bad_pix == 0
-00006860: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-00006870: 2020 2023 2068 616e 646c 6520 7468 6520     # handle the 
-00006880: 6c65 6674 2065 6467 650d 0a20 2020 2020  left edge..     
-00006890: 2020 2020 2020 2020 2020 206e 6578 745f             next_
-000068a0: 676f 6f64 203d 2062 6164 5f70 6978 202b  good = bad_pix +
-000068b0: 2031 0d0a 2020 2020 2020 2020 2020 2020   1..            
-000068c0: 2020 2020 7768 696c 6520 6e65 7874 5f67      while next_g
-000068d0: 6f6f 6420 696e 2062 6164 5f70 6978 656c  ood in bad_pixel
-000068e0: 7320 616e 6420 6e65 7874 5f67 6f6f 6420  s and next_good 
-000068f0: 3c20 7069 7865 6c73 3a0d 0a20 2020 2020  < pixels:..     
-00006900: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-00006910: 6578 745f 676f 6f64 202b 3d20 310d 0a20  ext_good += 1.. 
-00006920: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006930: 2020 2069 202b 3d20 310d 0a20 2020 2020     i += 1..     
-00006940: 2020 2020 2020 2020 2020 2069 6620 6e65             if ne
-00006950: 7874 5f67 6f6f 6420 3c20 7069 7865 6c73  xt_good < pixels
-00006960: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-00006970: 2020 2020 2020 2066 6f72 206a 2069 6e20         for j in 
-00006980: 7261 6e67 6528 6e65 7874 5f67 6f6f 6429  range(next_good)
-00006990: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-000069a0: 2020 2020 2020 2020 2020 2073 7065 6374             spect
-000069b0: 7275 6d5b 6a5d 203d 2073 7065 6374 7275  rum[j] = spectru
-000069c0: 6d5b 6e65 7874 5f67 6f6f 645d 0d0a 2020  m[next_good]..  
-000069d0: 2020 2020 2020 2020 2020 656c 7365 3a0d            else:.
-000069e0: 0a0d 0a20 2020 2020 2020 2020 2020 2020  ...             
-000069f0: 2020 2023 2066 696e 6420 7072 6576 696f     # find previo
-00006a00: 7573 2067 6f6f 6420 7069 7865 6c0d 0a20  us good pixel.. 
-00006a10: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-00006a20: 7265 765f 676f 6f64 203d 2062 6164 5f70  rev_good = bad_p
-00006a30: 6978 202d 2031 0d0a 2020 2020 2020 2020  ix - 1..        
-00006a40: 2020 2020 2020 2020 7768 696c 6520 7072          while pr
-00006a50: 6576 5f67 6f6f 6420 696e 2062 6164 5f70  ev_good in bad_p
-00006a60: 6978 656c 7320 616e 6420 7072 6576 5f67  ixels and prev_g
-00006a70: 6f6f 6420 3e3d 2030 3a0d 0a20 2020 2020  ood >= 0:..     
-00006a80: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-00006a90: 7265 765f 676f 6f64 202d 3d20 310d 0a0d  rev_good -= 1...
-00006aa0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00006ab0: 2069 6620 7072 6576 5f67 6f6f 6420 3e3d   if prev_good >=
-00006ac0: 2030 3a0d 0a20 2020 2020 2020 2020 2020   0:..           
-00006ad0: 2020 2020 2020 2020 2023 2066 696e 6420           # find 
-00006ae0: 6e65 7874 2067 6f6f 6420 7069 7865 6c0d  next good pixel.
-00006af0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00006b00: 2020 2020 206e 6578 745f 676f 6f64 203d       next_good =
-00006b10: 2062 6164 5f70 6978 202b 2031 0d0a 2020   bad_pix + 1..  
-00006b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006b30: 2020 7768 696c 6520 6e65 7874 5f67 6f6f    while next_goo
-00006b40: 6420 696e 2062 6164 5f70 6978 656c 7320  d in bad_pixels 
-00006b50: 616e 6420 6e65 7874 5f67 6f6f 6420 3c20  and next_good < 
-00006b60: 7069 7865 6c73 3a0d 0a20 2020 2020 2020  pixels:..       
-00006b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006b80: 206e 6578 745f 676f 6f64 202b 3d20 310d   next_good += 1.
-00006b90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00006ba0: 2020 2020 2020 2020 2069 202b 3d20 310d           i += 1.
-00006bb0: 0a0d 0a20 2020 2020 2020 2020 2020 2020  ...             
-00006bc0: 2020 2020 2020 2069 6620 6e65 7874 5f67         if next_g
-00006bd0: 6f6f 6420 3c20 7069 7865 6c73 3a0d 0a20  ood < pixels:.. 
-00006be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006bf0: 2020 2020 2020 2023 2066 6f72 206e 6f77         # for now
-00006c00: 2c20 6472 6177 2061 206c 696e 6520 6265  , draw a line be
-00006c10: 7477 6565 6e20 7072 6576 696f 7573 2061  tween previous a
-00006c20: 6e64 206e 6578 745f 676f 6f64 2070 6978  nd next_good pix
-00006c30: 656c 730d 0a20 2020 2020 2020 2020 2020  els..           
-00006c40: 2020 2020 2020 2020 2020 2020 2023 2054               # T
-00006c50: 4f44 4f3a 2063 6f6e 7369 6465 7220 736f  ODO: consider so
-00006c60: 6d65 206b 696e 6420 6f66 2063 7572 7665  me kind of curve
-00006c70: 2d66 6974 0d0a 2020 2020 2020 2020 2020  -fit..          
-00006c80: 2020 2020 2020 2020 2020 2020 2020 6465                de
-00006c90: 6c74 6120 3d20 666c 6f61 7428 7370 6563  lta = float(spec
-00006ca0: 7472 756d 5b6e 6578 745f 676f 6f64 5d20  trum[next_good] 
-00006cb0: 2d20 7370 6563 7472 756d 5b70 7265 765f  - spectrum[prev_
-00006cc0: 676f 6f64 5d29 0d0a 2020 2020 2020 2020  good])..        
-00006cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006ce0: 726e 6720 2020 3d20 6e65 7874 5f67 6f6f  rng   = next_goo
-00006cf0: 6420 2d20 7072 6576 5f67 6f6f 640d 0a20  d - prev_good.. 
-00006d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006d10: 2020 2020 2020 2073 7465 7020 203d 2064         step  = d
-00006d20: 656c 7461 202f 2072 6e67 0d0a 2020 2020  elta / rng..    
-00006d30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006d40: 2020 2020 666f 7220 6a20 696e 2072 616e      for j in ran
-00006d50: 6765 2872 6e67 202d 2031 293a 0d0a 2020  ge(rng - 1):..  
-00006d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006d70: 2020 2020 2020 2020 2020 7370 6563 7472            spectr
-00006d80: 756d 5b70 7265 765f 676f 6f64 202b 206a  um[prev_good + j
-00006d90: 202b 2031 5d20 3d20 7370 6563 7472 756d   + 1] = spectrum
-00006da0: 5b70 7265 765f 676f 6f64 5d20 2b20 7374  [prev_good] + st
-00006db0: 6570 202a 2028 6a20 2b20 3129 0d0a 2020  ep * (j + 1)..  
-00006dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006dd0: 2020 656c 7365 3a0d 0a20 2020 2020 2020    else:..       
-00006de0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006df0: 2023 2077 6520 7261 6e20 6f66 6620 7468   # we ran off th
-00006e00: 6520 6869 6768 2065 6e64 2c20 736f 2063  e high end, so c
-00006e10: 6f70 792d 7269 6768 740d 0a20 2020 2020  opy-right..     
-00006e20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006e30: 2020 2066 6f72 206a 2069 6e20 7261 6e67     for j in rang
-00006e40: 6528 6261 645f 7069 782c 2070 6978 656c  e(bad_pix, pixel
-00006e50: 7329 3a0d 0a20 2020 2020 2020 2020 2020  s):..           
-00006e60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006e70: 2073 7065 6374 7275 6d5b 6a5d 203d 2073   spectrum[j] = s
-00006e80: 7065 6374 7275 6d5b 7072 6576 5f67 6f6f  pectrum[prev_goo
-00006e90: 645d 0d0a 0d0a 2020 2020 2020 2020 2020  d]....          
-00006ea0: 2020 2320 6164 7661 6e63 6520 746f 206e    # advance to n
-00006eb0: 6578 7420 6261 6420 7069 7865 6c0d 0a20  ext bad pixel.. 
-00006ec0: 2020 2020 2020 2020 2020 2069 202b 3d20             i += 
-00006ed0: 310d 0a20 2020 2020 2020 2072 6574 7572  1..        retur
-00006ee0: 6e20 5472 7565 0d0a 0d0a 2020 2020 6465  n True....    de
-00006ef0: 6620 5f73 656e 645f 636f 6465 2873 656c  f _send_code(sel
-00006f00: 662c 200d 0a20 2020 2020 2020 2020 2020  f, ..           
-00006f10: 2020 2020 2020 2062 5265 7175 6573 743a         bRequest:
-00006f20: 2069 6e74 2c20 0d0a 2020 2020 2020 2020   int, ..        
-00006f30: 2020 2020 2020 2020 2020 7756 616c 7565            wValue
-00006f40: 3a20 696e 7420 3d20 302c 200d 0a20 2020  : int = 0, ..   
-00006f50: 2020 2020 2020 2020 2020 2020 2020 2077                 w
-00006f60: 496e 6465 783a 2069 6e74 203d 2030 2c20  Index: int = 0, 
-00006f70: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00006f80: 2020 2020 6461 7461 5f6f 725f 774c 656e      data_or_wLen
-00006f90: 6774 683a 2069 6e74 203d 204e 6f6e 652c  gth: int = None,
-00006fa0: 200d 0a20 2020 2020 2020 2020 2020 2020   ..             
-00006fb0: 2020 2020 206c 6162 656c 3a20 7374 7220       label: str 
-00006fc0: 3d20 2222 2c20 0d0a 2020 2020 2020 2020  = "", ..        
-00006fd0: 2020 2020 2020 2020 2020 6472 795f 7275            dry_ru
-00006fe0: 6e3a 2062 6f6f 6c20 3d20 4661 6c73 652c  n: bool = False,
-00006ff0: 200d 0a20 2020 2020 2020 2020 2020 2020   ..             
-00007000: 2020 2020 2072 6574 7279 5f6f 6e5f 6572       retry_on_er
-00007010: 726f 723a 2062 6f6f 6c20 3d20 4661 6c73  ror: bool = Fals
-00007020: 652c 200d 0a20 2020 2020 2020 2020 2020  e, ..           
-00007030: 2020 2020 2020 2073 7563 6365 7373 5f72         success_r
-00007040: 6573 756c 743a 2069 6e74 203d 2030 7830  esult: int = 0x0
-00007050: 3029 202d 3e20 5370 6563 7472 6f6d 6574  0) -> Spectromet
-00007060: 6572 5265 7370 6f6e 7365 3a0d 0a20 2020  erResponse:..   
-00007070: 2020 2020 2069 6620 7365 6c66 2e73 6875       if self.shu
-00007080: 7464 6f77 6e5f 7265 7175 6573 7465 6420  tdown_requested 
-00007090: 6f72 2028 6e6f 7420 7365 6c66 2e63 6f6e  or (not self.con
-000070a0: 6e65 6374 6564 2061 6e64 206e 6f74 2073  nected and not s
-000070b0: 656c 662e 636f 6e6e 6563 7469 6e67 293a  elf.connecting):
-000070c0: 0d0a 2020 2020 2020 2020 2020 2020 6c6f  ..            lo
-000070d0: 672e 6465 6275 6728 225f 7365 6e64 5f63  g.debug("_send_c
-000070e0: 6f64 653a 206e 6f74 2061 7474 656d 7074  ode: not attempt
-000070f0: 696e 6720 6265 6361 7573 6520 6e6f 7420  ing because not 
-00007100: 636f 6e6e 6563 7465 6422 290d 0a20 2020  connected")..   
-00007110: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00007120: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
-00007130: 6f6e 7365 2846 616c 7365 290d 0a0d 0a20  onse(False).... 
-00007140: 2020 2020 2020 2070 7265 6669 7820 3d20         prefix = 
-00007150: 2222 2069 6620 6e6f 7420 6c61 6265 6c20  "" if not label 
-00007160: 656c 7365 2028 2225 733a 2022 2025 206c  else ("%s: " % l
-00007170: 6162 656c 290d 0a20 2020 2020 2020 2072  abel)..        r
-00007180: 6573 756c 7420 3d20 4e6f 6e65 0d0a 0d0a  esult = None....
-00007190: 2020 2020 2020 2020 6966 2064 6174 615f          if data_
-000071a0: 6f72 5f77 4c65 6e67 7468 2069 7320 4e6f  or_wLength is No
-000071b0: 6e65 3a0d 0a20 2020 2020 2020 2020 2020  ne:..           
-000071c0: 2069 6620 7365 6c66 2e73 6574 7469 6e67   if self.setting
-000071d0: 732e 6973 5f61 726d 2829 3a0d 0a20 2020  s.is_arm():..   
-000071e0: 2020 2020 2020 2020 2020 2020 2064 6174               dat
-000071f0: 615f 6f72 5f77 4c65 6e67 7468 203d 205b  a_or_wLength = [
-00007200: 305d 202a 2038 0d0a 2020 2020 2020 2020  0] * 8..        
-00007210: 2020 2020 656c 7365 3a0d 0a20 2020 2020      else:..     
-00007220: 2020 2020 2020 2020 2020 2064 6174 615f             data_
-00007230: 6f72 5f77 4c65 6e67 7468 203d 2030 0d0a  or_wLength = 0..
-00007240: 0d0a 2020 2020 2020 2020 6c6f 672e 6465  ..        log.de
-00007250: 6275 6728 2225 735f 7365 6e64 5f63 6f64  bug("%s_send_cod
-00007260: 653a 2072 6571 7565 7374 2030 7825 3032  e: request 0x%02
-00007270: 7820 7661 6c75 6520 3078 2530 3478 2069  x value 0x%04x i
-00007280: 6e64 6578 2030 7825 3034 7820 6461 7461  ndex 0x%04x data
-00007290: 2f6c 656e 2025 7322 2c0d 0a20 2020 2020  /len %s",..     
-000072a0: 2020 2020 2020 2070 7265 6669 782c 2062         prefix, b
-000072b0: 5265 7175 6573 742c 2077 5661 6c75 652c  Request, wValue,
-000072c0: 2077 496e 6465 782c 2064 6174 615f 6f72   wIndex, data_or
-000072d0: 5f77 4c65 6e67 7468 290d 0a0d 0a20 2020  _wLength)....   
-000072e0: 2020 2020 2069 6620 6472 795f 7275 6e3a       if dry_run:
-000072f0: 0d0a 2020 2020 2020 2020 2020 2020 7265  ..            re
-00007300: 7475 726e 2053 7065 6374 726f 6d65 7465  turn Spectromete
-00007310: 7252 6573 706f 6e73 6528 6b65 6570 5f61  rResponse(keep_a
-00007320: 6c69 7665 3d54 7275 6529 0d0a 0d0a 2020  live=True)....  
-00007330: 2020 2020 2020 6966 2073 656c 662e 5f63        if self._c
-00007340: 6865 636b 5f66 6f72 5f72 616e 646f 6d5f  heck_for_random_
-00007350: 6572 726f 7228 293a 0d0a 2020 2020 2020  error():..      
-00007360: 2020 2020 2020 7265 7475 726e 2053 7065        return Spe
-00007370: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
-00007380: 6528 706f 6973 6f6e 5f70 696c 6c3d 4661  e(poison_pill=Fa
-00007390: 6c73 6529 0d0a 0d0a 2020 2020 2020 2020  lse)....        
-000073a0: 7265 7472 795f 636f 756e 7420 3d20 300d  retry_count = 0.
-000073b0: 0a20 2020 2020 2020 2077 6869 6c65 2054  .        while T
-000073c0: 7275 653a 0d0a 2020 2020 2020 2020 2020  rue:..          
-000073d0: 2020 7472 793a 0d0a 2020 2020 2020 2020    try:..        
-000073e0: 2020 2020 2020 2020 7365 6c66 2e5f 7761          self._wa
-000073f0: 6974 5f66 6f72 5f75 7362 5f61 7661 696c  it_for_usb_avail
-00007400: 6162 6c65 2829 0d0a 2020 2020 2020 2020  able()..        
-00007410: 2020 2020 2020 2020 7265 7375 6c74 203d          result =
-00007420: 2073 656c 662e 6465 7669 6365 5f74 7970   self.device_typ
-00007430: 652e 6374 726c 5f74 7261 6e73 6665 7228  e.ctrl_transfer(
-00007440: 7365 6c66 2e64 6576 6963 652c 0d0a 2020  self.device,..  
-00007450: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007480: 2030 7834 302c 2020 2020 2020 2020 2320   0x40,        # 
-00007490: 484f 5354 5f54 4f5f 4445 5649 4345 0d0a  HOST_TO_DEVICE..
-000074a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000074b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000074c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000074d0: 2020 2062 5265 7175 6573 742c 0d0a 2020     bRequest,..  
-000074e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000074f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007500: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007510: 2077 5661 6c75 652c 0d0a 2020 2020 2020   wValue,..      
-00007520: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007540: 2020 2020 2020 2020 2020 2020 2077 496e               wIn
-00007550: 6465 782c 0d0a 2020 2020 2020 2020 2020  dex,..          
-00007560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003090: 2323 2323 2323 2323 2323 2323 0a0a 2020  ############..  
+000030a0: 2020 2020 2020 6966 2073 656c 662e 7365        if self.se
+000030b0: 7474 696e 6773 2e69 735f 7873 2829 3a0a  ttings.is_xs():.
+000030c0: 2020 2020 2020 2020 2020 2020 0a20 2020              .   
+000030d0: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
+000030e0: 2e73 6574 7469 6e67 732e 6565 7072 6f6d  .settings.eeprom
+000030f0: 2e73 6967 5f6c 6173 6572 5f74 6563 3a0a  .sig_laser_tec:.
+00003100: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00003110: 2023 2073 616e 6974 792d 6368 6563 6b20   # sanity-check 
+00003120: 666f 7220 7265 6173 6f6e 6162 6c65 2073  for reasonable s
+00003130: 6574 706f 696e 7420 7261 6e67 6520 2872  etpoint range (r
+00003140: 6177 2031 322d 6269 7429 0a20 2020 2020  aw 12-bit).     
+00003150: 2020 2020 2020 2020 2020 2069 6620 3730             if 70
+00003160: 3020 3c3d 2073 656c 662e 7365 7474 696e  0 <= self.settin
+00003170: 6773 2e65 6570 726f 6d2e 7374 6172 7475  gs.eeprom.startu
+00003180: 705f 7465 6d70 5f64 6567 4320 3c3d 2039  p_temp_degC <= 9
+00003190: 3030 3a0a 2020 2020 2020 2020 2020 2020  00:.            
+000031a0: 2020 2020 2020 2020 6c6f 672e 6465 6275          log.debu
+000031b0: 6728 2269 6e69 7469 616c 697a 696e 6720  g("initializing 
+000031c0: 5853 206c 6173 6572 2054 4543 2073 6574  XS laser TEC set
+000031d0: 706f 696e 7422 290a 0a20 2020 2020 2020  point")..       
+000031e0: 2020 2020 2020 2020 2020 2020 2023 206b               # k
+000031f0: 6c75 6467 653a 2066 6f72 206e 6f77 2c20  ludge: for now, 
+00003200: 7573 6520 7468 6520 6465 7465 6374 6f72  use the detector
+00003210: 2054 4543 2073 7461 7274 7570 2073 6574   TEC startup set
+00003220: 706f 696e 7420 666f 7220 6c61 7365 720a  point for laser.
+00003230: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003240: 2020 2020 7365 6c66 2e73 6574 7469 6e67      self.setting
+00003250: 732e 7374 6174 652e 6c61 7365 725f 7465  s.state.laser_te
+00003260: 635f 7365 7470 6f69 6e74 203d 2073 656c  c_setpoint = sel
+00003270: 662e 7365 7474 696e 6773 2e65 6570 726f  f.settings.eepro
+00003280: 6d2e 7374 6172 7475 705f 7465 6d70 5f64  m.startup_temp_d
+00003290: 6567 430a 2020 2020 2020 2020 2020 2020  egC.            
+000032a0: 2020 2020 2020 2020 7365 6c66 2e73 6574          self.set
+000032b0: 5f6c 6173 6572 5f74 656d 7065 7261 7475  _laser_temperatu
+000032c0: 7265 5f73 6574 706f 696e 745f 7261 7728  re_setpoint_raw(
+000032d0: 7365 6c66 2e73 6574 7469 6e67 732e 7374  self.settings.st
+000032e0: 6174 652e 6c61 7365 725f 7465 635f 7365  ate.laser_tec_se
+000032f0: 7470 6f69 6e74 290a 0a20 2020 2020 2020  tpoint)..       
+00003300: 2020 2020 2020 2020 2020 2020 2023 2074               # t
+00003310: 6869 7320 7368 6f75 6c64 2062 6520 7468  his should be th
+00003320: 6520 6465 6661 756c 7420 696e 2066 6972  e default in fir
+00003330: 6d77 6172 652c 2062 7574 2073 6574 2061  mware, but set a
+00003340: 6e79 7761 790a 2020 2020 2020 2020 2020  nyway.          
+00003350: 2020 2020 2020 2020 2020 6c6f 672e 6465            log.de
+00003360: 6275 6728 2269 6e69 7469 616c 697a 696e  bug("initializin
+00003370: 6720 5853 206c 6173 6572 2054 4543 206d  g XS laser TEC m
+00003380: 6f64 6520 2d3e 2041 5554 4f22 290a 2020  ode -> AUTO").  
+00003390: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000033a0: 2020 7365 6c66 2e73 6574 5f6c 6173 6572    self.set_laser
+000033b0: 5f74 6563 5f6d 6f64 6528 2241 5554 4f22  _tec_mode("AUTO"
+000033c0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+000033d0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+000033e0: 2020 2020 2020 2020 2020 2020 2320 646f              # do
+000033f0: 6e27 7420 7365 7420 616e 7974 6869 6e67  n't set anything
+00003400: 2069 6620 6465 6661 756c 7420 7365 7470   if default setp
+00003410: 6f69 6e74 206c 6f6f 6b73 2077 6179 206f  oint looks way o
+00003420: 6666 0a20 2020 2020 2020 2020 2020 2020  ff.             
+00003430: 2020 2020 2020 206c 6f67 2e65 7272 6f72         log.error
+00003440: 2866 226c 6173 6572 2054 4543 2073 6574  (f"laser TEC set
+00003450: 706f 696e 7420 6c6f 6f6b 7320 696e 7661  point looks inva
+00003460: 6c69 643a 207b 7365 6c66 2e73 6574 7469  lid: {self.setti
+00003470: 6e67 732e 6565 7072 6f6d 2e73 7461 7274  ngs.eeprom.start
+00003480: 7570 5f74 656d 705f 6465 6743 7d22 290a  up_temp_degC}").
+00003490: 0a20 2020 2020 2020 2023 2023 2323 2323  .        # #####
+000034a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000034b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000034c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000034d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000034e0: 230a 2020 2020 2020 2020 2320 4465 7465  #.        # Dete
+000034f0: 6374 6f72 2054 4543 0a20 2020 2020 2020  ctor TEC.       
+00003500: 2023 2023 2323 2323 2323 2323 2323 2323   # #############
+00003510: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00003520: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00003530: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00003540: 2323 2323 2323 2323 230a 2020 2020 2020  #########.      
+00003550: 2020 2020 2020 0a20 2020 2020 2020 2069        .        i
+00003560: 6620 6e6f 7420 7365 6c66 2e73 6574 7469  f not self.setti
+00003570: 6e67 732e 6973 5f78 7328 293a 0a0a 2020  ngs.is_xs():..  
+00003580: 2020 2020 2020 2020 2020 2320 582f 584d            # X/XM
+00003590: 206d 6f64 656c 7320 646f 6e27 7420 7265   models don't re
+000035a0: 7175 6972 6520 7275 6e74 696d 6520 636f  quire runtime co
+000035b0: 6e66 6967 7572 6174 696f 6e20 6f66 2074  nfiguration of t
+000035c0: 6865 206c 6173 6572 2054 4543 0a20 2020  he laser TEC.   
+000035d0: 2020 2020 2020 2020 2023 2028 6974 2773           # (it's
+000035e0: 2073 6574 2076 6961 2070 6f74 7320 6f6e   set via pots on
+000035f0: 2031 3130 3238 3020 2853 4d4c 2920 6f72   110280 (SML) or
+00003600: 2031 3130 3631 3320 284d 4d4c 2929 2c20   110613 (MML)), 
+00003610: 6275 7420 646f 206e 6565 640a 2020 2020  but do need.    
+00003620: 2020 2020 2020 2020 2320 746f 2069 6e69          # to ini
+00003630: 7469 616c 697a 6520 7468 6520 6465 7465  tialize the dete
+00003640: 6374 6f72 2054 4543 2066 6f72 2052 2061  ctor TEC for R a
+00003650: 6e64 2043 2075 6e69 7473 2e0a 2020 2020  nd C units..    
+00003660: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+00003670: 7365 7474 696e 6773 2e65 6570 726f 6d2e  settings.eeprom.
+00003680: 6861 735f 636f 6f6c 696e 673a 0a0a 2020  has_cooling:..  
+00003690: 2020 2020 2020 2020 2020 2020 2020 6465                de
+000036a0: 6743 203d 204e 6f6e 650a 2020 2020 2020  gC = None.      
+000036b0: 2020 2020 2020 2020 2020 6565 7072 6f6d            eeprom
+000036c0: 203d 2073 656c 662e 7365 7474 696e 6773   = self.settings
+000036d0: 2e65 6570 726f 6d0a 0a20 2020 2020 2020  .eeprom..       
+000036e0: 2020 2020 2020 2020 2069 6620 6565 7072           if eepr
+000036f0: 6f6d 2e6d 696e 5f74 656d 705f 6465 6743  om.min_temp_degC
+00003700: 203c 3d20 6565 7072 6f6d 2e73 7461 7274   <= eeprom.start
+00003710: 7570 5f74 656d 705f 6465 6743 203c 3d20  up_temp_degC <= 
+00003720: 6565 7072 6f6d 2e6d 6178 5f74 656d 705f  eeprom.max_temp_
+00003730: 6465 6743 3a0a 2020 2020 2020 2020 2020  degC:.          
+00003740: 2020 2020 2020 2020 2020 6465 6743 203d            degC =
+00003750: 2065 6570 726f 6d2e 7374 6172 7475 705f   eeprom.startup_
+00003760: 7465 6d70 5f64 6567 430a 2020 2020 2020  temp_degC.      
+00003770: 2020 2020 2020 2020 2020 656c 6966 2072            elif r
+00003780: 652e 6d61 7463 6828 7222 3730 3331 7c31  e.match(r"7031|1
+00003790: 3031 3431 7c39 3231 3422 2c20 6565 7072  0141|9214", eepr
+000037a0: 6f6d 2e64 6574 6563 746f 7229 3a0a 2020  om.detector):.  
+000037b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000037c0: 2020 6465 6743 203d 202d 3135 0a20 2020    degC = -15.   
+000037d0: 2020 2020 2020 2020 2020 2020 2065 6c69               eli
+000037e0: 6620 7265 2e6d 6174 6368 2872 2231 3630  f re.match(r"160
+000037f0: 3131 7c31 3135 3131 7c31 3138 3530 7c31  11|11511|11850|1
+00003800: 3339 3731 222c 2065 6570 726f 6d2e 6465  3971", eeprom.de
+00003810: 7465 6374 6f72 293a 0a20 2020 2020 2020  tector):.       
+00003820: 2020 2020 2020 2020 2020 2020 2064 6567               deg
+00003830: 4320 3d20 3130 0a0a 2020 2020 2020 2020  C = 10..        
+00003840: 2020 2020 2020 2020 6966 2064 6567 4320          if degC 
+00003850: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
+00003860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003870: 2023 2054 4543 2064 6f65 736e 2774 2064   # TEC doesn't d
+00003880: 6f20 616e 7974 6869 6e67 2075 6e6c 6573  o anything unles
+00003890: 7320 796f 7520 6769 7665 2069 7420 6120  s you give it a 
+000038a0: 7465 6d70 6572 6174 7572 6520 6669 7273  temperature firs
+000038b0: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
+000038c0: 2020 2020 2020 6c6f 672e 6465 6275 6728        log.debug(
+000038d0: 6622 7365 7474 696e 6720 6465 7465 6374  f"setting detect
+000038e0: 6f72 2054 4543 2073 6574 706f 696e 7420  or TEC setpoint 
+000038f0: 746f 207b 6465 6743 7d20 6465 6720 4322  to {degC} deg C"
+00003900: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00003910: 2020 2020 2020 7365 6c66 2e64 6574 6563        self.detec
+00003920: 746f 725f 7465 635f 7365 7470 6f69 6e74  tor_tec_setpoint
+00003930: 5f64 6567 4320 3d20 6465 6743 0a20 2020  _degC = degC.   
+00003940: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003950: 2073 656c 662e 7365 745f 6465 7465 6374   self.set_detect
+00003960: 6f72 5f74 6563 5f73 6574 706f 696e 745f  or_tec_setpoint_
+00003970: 6465 6743 2873 656c 662e 6465 7465 6374  degC(self.detect
+00003980: 6f72 5f74 6563 5f73 6574 706f 696e 745f  or_tec_setpoint_
+00003990: 6465 6743 290a 0a20 2020 2020 2020 2020  degC)..         
+000039a0: 2020 2020 2020 2020 2020 206c 6f67 2e64             log.d
+000039b0: 6562 7567 2822 656e 6162 6c69 6e67 2064  ebug("enabling d
+000039c0: 6574 6563 746f 7220 5445 4322 290a 2020  etector TEC").  
+000039d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000039e0: 2020 7365 6c66 2e64 6574 6563 746f 725f    self.detector_
+000039f0: 7465 635f 7365 7470 6f69 6e74 5f68 6173  tec_setpoint_has
+00003a00: 5f62 6565 6e5f 7365 7420 3d20 5472 7565  _been_set = True
+00003a10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00003a20: 2020 2020 2073 656c 662e 7365 745f 7465       self.set_te
+00003a30: 635f 656e 6162 6c65 2854 7275 6529 0a0a  c_enable(True)..
+00003a40: 2020 2020 2020 2020 2320 2323 2323 2323          # ######
+00003a50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00003a60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00003a70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00003a80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00003a90: 0a20 2020 2020 2020 2023 2046 5047 410a  .        # FPGA.
+00003aa0: 2020 2020 2020 2020 2320 2323 2323 2323          # ######
+00003ab0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00003ac0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00003ad0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00003ae0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00003af0: 0a0a 2020 2020 2020 2020 6c6f 672e 6465  ..        log.de
+00003b00: 6275 6728 2272 6561 6469 6e67 2046 5047  bug("reading FPG
+00003b10: 4120 636f 6d70 696c 6174 696f 6e20 6f70  A compilation op
+00003b20: 7469 6f6e 7322 290a 2020 2020 2020 2020  tions").        
+00003b30: 7365 6c66 2e5f 7265 6164 5f66 7067 615f  self._read_fpga_
+00003b40: 636f 6d70 696c 6174 696f 6e5f 6f70 7469  compilation_opti
+00003b50: 6f6e 7328 290a 0a20 2020 2020 2020 206c  ons()..        l
+00003b60: 6f67 2e64 6562 7567 2822 636f 6e66 6967  og.debug("config
+00003b70: 7572 696e 6720 4650 4741 2229 0a0a 2020  uring FPGA")..  
+00003b80: 2020 2020 2020 2320 6175 746f 6d61 7469        # automati
+00003b90: 6361 6c6c 7920 7075 7368 2045 4550 524f  cally push EEPRO
+00003ba0: 4d20 7661 6c75 6573 2074 6f20 7468 6520  M values to the 
+00003bb0: 4650 4741 2028 6f6e 206d 6f64 6572 6e20  FPGA (on modern 
+00003bc0: 4545 5052 4f4d 7329 0a20 2020 2020 2020  EEPROMs).       
+00003bd0: 2023 2028 7468 6973 2077 696c 6c20 776f   # (this will wo
+00003be0: 726b 206f 6e20 5365 7269 6573 2d58 5320  rk on Series-XS 
+00003bf0: 6173 2077 656c 6c2c 2065 7665 6e20 6966  as well, even if
+00003c00: 2077 6520 7375 6273 6571 7565 6e74 6c79   we subsequently
+00003c10: 2074 7261 636b 2069 7473 2067 6169 6e0a   track its gain.
+00003c20: 2020 2020 2020 2020 2320 2073 6f6d 6577          #  somew
+00003c30: 6861 7420 6469 6666 6572 656e 746c 7920  hat differently 
+00003c40: 6173 2073 7461 7465 2e67 6169 6e5f 6462  as state.gain_db
+00003c50: 290a 2020 2020 2020 2020 6966 2073 656c  ).        if sel
+00003c60: 662e 7365 7474 696e 6773 2e65 6570 726f  f.settings.eepro
+00003c70: 6d2e 666f 726d 6174 203e 3d20 343a 0a20  m.format >= 4:. 
+00003c80: 2020 2020 2020 2020 2020 206c 6f67 2e64             log.d
+00003c90: 6562 7567 2822 7365 6e64 696e 6720 6761  ebug("sending ga
+00003ca0: 696e 2f6f 6666 7365 7420 746f 2046 5047  in/offset to FPG
+00003cb0: 4122 290a 2020 2020 2020 2020 2020 2020  A").            
+00003cc0: 7365 6c66 2e73 6574 5f64 6574 6563 746f  self.set_detecto
+00003cd0: 725f 6761 696e 2020 2020 2020 2873 656c  r_gain      (sel
+00003ce0: 662e 7365 7474 696e 6773 2e65 6570 726f  f.settings.eepro
+00003cf0: 6d2e 6465 7465 6374 6f72 5f67 6169 6e29  m.detector_gain)
+00003d00: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00003d10: 662e 7365 745f 6465 7465 6374 6f72 5f6f  f.set_detector_o
+00003d20: 6666 7365 7420 2020 2028 7365 6c66 2e73  ffset    (self.s
+00003d30: 6574 7469 6e67 732e 6565 7072 6f6d 2e64  ettings.eeprom.d
+00003d40: 6574 6563 746f 725f 6f66 6673 6574 290a  etector_offset).
+00003d50: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00003d60: 2e73 6574 5f64 6574 6563 746f 725f 6761  .set_detector_ga
+00003d70: 696e 5f6f 6464 2020 2873 656c 662e 7365  in_odd  (self.se
+00003d80: 7474 696e 6773 2e65 6570 726f 6d2e 6465  ttings.eeprom.de
+00003d90: 7465 6374 6f72 5f67 6169 6e5f 6f64 6429  tector_gain_odd)
+00003da0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00003db0: 662e 7365 745f 6465 7465 6374 6f72 5f6f  f.set_detector_o
+00003dc0: 6666 7365 745f 6f64 6428 7365 6c66 2e73  ffset_odd(self.s
+00003dd0: 6574 7469 6e67 732e 6565 7072 6f6d 2e64  ettings.eeprom.d
+00003de0: 6574 6563 746f 725f 6f66 6673 6574 5f6f  etector_offset_o
+00003df0: 6464 290a 0a20 2020 2020 2020 2023 2069  dd)..        # i
+00003e00: 6e69 7469 616c 697a 6520 7374 6174 652e  nitialize state.
+00003e10: 6761 696e 5f64 6220 6672 6f6d 2045 4550  gain_db from EEP
+00003e20: 524f 4d20 7374 6172 7475 7020 7661 6c75  ROM startup valu
+00003e30: 650a 2020 2020 2020 2020 7365 6c66 2e73  e.        self.s
+00003e40: 6574 7469 6e67 732e 7374 6174 652e 6761  ettings.state.ga
+00003e50: 696e 5f64 6220 3d20 7365 6c66 2e73 6574  in_db = self.set
+00003e60: 7469 6e67 732e 6565 7072 6f6d 2e64 6574  tings.eeprom.det
+00003e70: 6563 746f 725f 6761 696e 0a0a 2020 2020  ector_gain..    
+00003e80: 2020 2020 6966 2073 656c 662e 7365 7474      if self.sett
+00003e90: 696e 6773 2e69 735f 6d69 6372 6f28 293a  ings.is_micro():
+00003ea0: 0a20 2020 2020 2020 2020 2020 2072 6f69  .            roi
+00003eb0: 203d 2073 656c 662e 7365 7474 696e 6773   = self.settings
+00003ec0: 2e67 6574 5f76 6572 7469 6361 6c5f 726f  .get_vertical_ro
+00003ed0: 6928 290a 2020 2020 2020 2020 2020 2020  i().            
+00003ee0: 6966 2072 6f69 2069 7320 6e6f 7420 4e6f  if roi is not No
+00003ef0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+00003f00: 2020 2020 7365 6c66 2e73 6574 5f76 6572      self.set_ver
+00003f10: 7469 6361 6c5f 6269 6e6e 696e 6728 726f  tical_binning(ro
+00003f20: 6929 0a0a 2020 2020 2020 2020 7365 6c66  i)..        self
+00003f30: 2e73 6574 7469 6e67 732e 696e 6974 5f72  .settings.init_r
+00003f40: 6567 696f 6e73 2829 2020 2020 2020 2020  egions()        
+00003f50: 0a0a 2020 2020 2020 2020 2320 2323 2323  ..        # ####
+00003f60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00003f70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00003f80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00003f90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00003fa0: 2323 0a20 2020 2020 2020 2023 2070 6f73  ##.        # pos
+00003fb0: 742d 636f 6e6e 6563 7469 6f6e 2064 6566  t-connection def
+00003fc0: 6175 6c74 730a 2020 2020 2020 2020 2320  aults.        # 
+00003fd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00003fe0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00003ff0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00004000: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00004010: 2323 2323 2323 0a0a 2020 2020 2020 2020  ######..        
+00004020: 2320 6465 6661 756c 7420 746f 2069 6e74  # default to int
+00004030: 6572 6e61 6c20 7472 6967 6765 7269 6e67  ernal triggering
+00004040: 0a20 2020 2020 2020 2073 656c 662e 7365  .        self.se
+00004050: 745f 7472 6967 6765 725f 736f 7572 6365  t_trigger_source
+00004060: 2853 7065 6374 726f 6d65 7465 7253 7461  (SpectrometerSta
+00004070: 7465 2e54 5249 4747 4552 5f53 4f55 5243  te.TRIGGER_SOURC
+00004080: 455f 494e 5445 524e 414c 290a 0a20 2020  E_INTERNAL)..   
+00004090: 2020 2020 2069 6620 7365 6c66 2e73 6574       if self.set
+000040a0: 7469 6e67 732e 6973 5f78 7328 293a 0a0a  tings.is_xs():..
+000040b0: 2020 2020 2020 2020 2020 2020 6966 2073              if s
+000040c0: 656c 662e 7365 7474 696e 6773 2e65 6570  elf.settings.eep
+000040d0: 726f 6d2e 6861 735f 6c61 7365 723a 0a20  rom.has_laser:. 
+000040e0: 2020 2020 2020 2020 2020 2020 2020 2068                 h
+000040f0: 6173 5f73 6d6c 203d 2073 656c 662e 7365  as_sml = self.se
+00004100: 7474 696e 6773 2e65 6570 726f 6d2e 6861  ttings.eeprom.ha
+00004110: 735f 736d 6c28 290a 2020 2020 2020 2020  s_sml().        
+00004120: 2020 2020 2020 2020 6861 735f 7465 6320          has_tec 
+00004130: 3d20 7365 6c66 2e73 6574 7469 6e67 732e  = self.settings.
+00004140: 6565 7072 6f6d 2e73 6967 5f6c 6173 6572  eeprom.sig_laser
+00004150: 5f74 6563 0a0a 2020 2020 2020 2020 2020  _tec..          
+00004160: 2020 2020 2020 2320 6c61 7365 7220 7761        # laser wa
+00004170: 7463 6864 6f67 0a20 2020 2020 2020 2020  tchdog.         
+00004180: 2020 2020 2020 2073 6563 203d 2073 656c         sec = sel
+00004190: 662e 7365 7474 696e 6773 2e65 6570 726f  f.settings.eepro
+000041a0: 6d2e 6c61 7365 725f 7761 7463 6864 6f67  m.laser_watchdog
+000041b0: 5f73 6563 0a20 2020 2020 2020 2020 2020  _sec.           
+000041c0: 2020 2020 2069 6620 7365 6320 3c3d 2030       if sec <= 0
+000041d0: 2061 6e64 2068 6173 5f73 6d6c 2061 6e64   and has_sml and
+000041e0: 206e 6f74 2068 6173 5f74 6563 3a0a 2020   not has_tec:.  
+000041f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004200: 2020 7365 6320 3d20 4545 5052 4f4d 2e44    sec = EEPROM.D
+00004210: 4546 4155 4c54 5f4c 4153 4552 5f57 4154  EFAULT_LASER_WAT
+00004220: 4348 444f 475f 5345 430a 2020 2020 2020  CHDOG_SEC.      
+00004230: 2020 2020 2020 2020 2020 2020 2020 6c6f                lo
+00004240: 672e 6465 6275 6728 6622 6465 636c 696e  g.debug(f"declin
+00004250: 696e 6720 746f 2064 6973 6162 6c65 206c  ing to disable l
+00004260: 6173 6572 2077 6174 6368 646f 6720 666f  aser watchdog fo
+00004270: 7220 534d 4c20 772f 6f20 5445 432c 2064  r SML w/o TEC, d
+00004280: 6566 6175 6c74 696e 6720 746f 207b 7365  efaulting to {se
+00004290: 637d 7365 6322 290a 2020 2020 2020 2020  c}sec").        
+000042a0: 2020 2020 2020 2020 6c6f 672e 6465 6275          log.debu
+000042b0: 6728 6622 706f 7374 2d63 6f6e 6e65 6374  g(f"post-connect
+000042c0: 3a20 696e 6974 6961 6c69 7a69 6e67 206c  : initializing l
+000042d0: 6173 6572 2077 6174 6368 646f 6720 746f  aser watchdog to
+000042e0: 207b 7365 637d 7365 6322 290a 2020 2020   {sec}sec").    
+000042f0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00004300: 2e73 6574 5f6c 6173 6572 5f77 6174 6368  .set_laser_watch
+00004310: 646f 675f 7365 6328 7365 6329 0a0a 2020  dog_sec(sec)..  
+00004320: 2020 2020 2020 7365 6c66 2e73 6574 5f69        self.set_i
+00004330: 6e74 6567 7261 7469 6f6e 5f74 696d 655f  ntegration_time_
+00004340: 6d73 2873 656c 662e 7365 7474 696e 6773  ms(self.settings
+00004350: 2e65 6570 726f 6d2e 7374 6172 7475 705f  .eeprom.startup_
+00004360: 696e 7465 6772 6174 696f 6e5f 7469 6d65  integration_time
+00004370: 5f6d 7329 0a0a 2020 2020 2020 2020 2320  _ms)..        # 
+00004380: 2320 666f 7220 6e6f 772c 2065 6e61 626c  # for now, enabl
+00004390: 6520 4765 6e20 312e 3520 6163 6365 7373  e Gen 1.5 access
+000043a0: 6f72 7920 636f 6e6e 6563 746f 7220 6279  ory connector by
+000043b0: 2064 6566 6175 6c74 0a20 2020 2020 2020   default.       
+000043c0: 2023 2069 6620 7365 6c66 2e73 6574 7469   # if self.setti
+000043d0: 6e67 732e 6973 5f67 656e 3135 2829 3a0a  ngs.is_gen15():.
+000043e0: 2020 2020 2020 2020 2320 2020 2020 6c6f          #     lo
+000043f0: 672e 6465 6275 6728 2265 6e61 626c 696e  g.debug("enablin
+00004400: 6720 4765 6e20 312e 3520 6163 6365 7373  g Gen 1.5 access
+00004410: 6f72 7920 636f 6e6e 6563 746f 7222 290a  ory connector").
+00004420: 2020 2020 2020 2020 2320 2020 2020 7365          #     se
+00004430: 6c66 2e73 6574 5f61 6363 6573 736f 7279  lf.set_accessory
+00004440: 5f65 6e61 626c 6528 5472 7565 290a 0a20  _enable(True).. 
+00004450: 2020 2020 2020 2023 2023 2323 2323 2323         # #######
+00004460: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00004470: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00004480: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00004490: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
+000044a0: 2020 2020 2020 2020 2320 446f 6e65 0a20          # Done. 
+000044b0: 2020 2020 2020 2023 2023 2323 2323 2323         # #######
+000044c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000044d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000044e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000044f0: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
+00004500: 0a20 2020 2020 2020 206c 6f67 2e64 6562  .        log.deb
+00004510: 7567 2822 636f 6e6e 6563 7469 6f6e 2073  ug("connection s
+00004520: 7563 6365 7373 6675 6c22 290a 2020 2020  uccessful").    
+00004530: 2020 2020 7365 6c66 2e63 6f6e 6e65 6374      self.connect
+00004540: 6564 203d 2054 7275 650a 2020 2020 2020  ed = True.      
+00004550: 2020 7365 6c66 2e63 6f6e 6e65 6374 696e    self.connectin
+00004560: 6720 3d20 4661 6c73 650a 0a20 2020 2020  g = False..     
+00004570: 2020 2073 656c 662e 7365 7474 696e 6773     self.settings
+00004580: 2e73 7461 7465 2e64 756d 7028 2246 4944  .state.dump("FID
+00004590: 2e70 6f73 745f 636f 6e6e 6563 7422 290a  .post_connect").
+000045a0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+000045b0: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
+000045c0: 6f6e 7365 2873 656c 662e 636f 6e6e 6563  onse(self.connec
+000045d0: 7465 6429 0a0a 2020 2020 6465 6620 6469  ted)..    def di
+000045e0: 7363 6f6e 6e65 6374 2873 656c 6629 3a0a  sconnect(self):.
+000045f0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+00004600: 6c61 7374 5f61 7070 6c69 6564 5f6c 6173  last_applied_las
+00004610: 6572 5f70 6f77 6572 3a0a 2020 2020 2020  er_power:.      
+00004620: 2020 2020 2020 6c6f 672e 6465 6275 6728        log.debug(
+00004630: 2266 6964 2e64 6973 636f 6e6e 6563 743a  "fid.disconnect:
+00004640: 2064 6973 6162 6c69 6e67 206c 6173 6572   disabling laser
+00004650: 2229 0a20 2020 2020 2020 2020 2020 2073  ").            s
+00004660: 656c 662e 5f73 6574 5f6c 6173 6572 5f65  elf._set_laser_e
+00004670: 6e61 626c 655f 696d 6d65 6469 6174 6528  nable_immediate(
+00004680: 4661 6c73 6529 0a0a 2020 2020 2020 2020  False)..        
+00004690: 7365 6c66 2e63 6f6e 6e65 6374 6564 203d  self.connected =
+000046a0: 2046 616c 7365 0a0a 2020 2020 2020 2020   False..        
+000046b0: 6c6f 672e 6372 6974 6963 616c 2822 6669  log.critical("fi
+000046c0: 642e 6469 7363 6f6e 6e65 6374 3a20 7265  d.disconnect: re
+000046d0: 6c65 6173 696e 6720 696e 7465 7266 6163  leasing interfac
+000046e0: 6522 290a 2020 2020 2020 2020 7472 793a  e").        try:
+000046f0: 0a20 2020 2020 2020 2020 2020 2023 7265  .            #re
+00004700: 7375 6c74 203d 2073 656c 662e 6465 7669  sult = self.devi
+00004710: 6365 5f74 7970 652e 7265 6c65 6173 655f  ce_type.release_
+00004720: 696e 7465 7266 6163 6528 7365 6c66 2e64  interface(self.d
+00004730: 6576 6963 652c 2030 290a 2020 2020 2020  evice, 0).      
+00004740: 2020 2020 2020 7472 793a 0a20 2020 2020        try:.     
+00004750: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00004760: 6465 7669 6365 5f74 7970 652e 7265 7365  device_type.rese
+00004770: 7428 7365 6c66 2e64 6576 6963 6529 0a20  t(self.device). 
+00004780: 2020 2020 2020 2020 2020 2065 7863 6570             excep
+00004790: 743a 0a20 2020 2020 2020 2020 2020 2020  t:.             
+000047a0: 2020 206c 6f67 2e65 7272 6f72 2822 436f     log.error("Co
+000047b0: 756c 646e 2774 2072 6573 6574 2064 6576  uldn't reset dev
+000047c0: 6963 6522 290a 2020 2020 2020 2020 6578  ice").        ex
+000047d0: 6365 7074 3a0a 2020 2020 2020 2020 2020  cept:.          
+000047e0: 2020 6c6f 672e 7761 726e 2822 4661 696c    log.warn("Fail
+000047f0: 7572 6520 696e 2072 656c 6561 7365 2069  ure in release i
+00004800: 6e74 6572 6661 6365 222c 2065 7863 5f69  nterface", exc_i
+00004810: 6e66 6f3d 3129 0a20 2020 2020 2020 2020  nfo=1).         
+00004820: 2020 2072 6169 7365 0a20 2020 2020 2020     raise.       
+00004830: 2072 6574 7572 6e20 5370 6563 7472 6f6d   return Spectrom
+00004840: 6574 6572 5265 7370 6f6e 7365 2854 7275  eterResponse(Tru
+00004850: 6529 0a0a 2020 2020 6465 6620 5f73 6368  e)..    def _sch
+00004860: 6564 756c 655f 6469 7363 6f6e 6e65 6374  edule_disconnect
+00004870: 2873 656c 662c 2065 7863 293a 0a20 2020  (self, exc):.   
+00004880: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00004890: 2053 6f6d 6574 6869 6e67 2069 6e20 7468   Something in th
+000048a0: 6520 6472 6976 6572 2068 6173 2063 6175  e driver has cau
+000048b0: 7365 6420 6974 2074 6f20 7265 7175 6573  sed it to reques
+000048c0: 7420 7468 6520 636f 6e74 726f 6c6c 696e  t the controllin
+000048d0: 670a 2020 2020 2020 2020 6170 706c 6963  g.        applic
+000048e0: 6174 696f 6e20 746f 2063 6c6f 7365 2074  ation to close t
+000048f0: 6865 2070 6572 6970 6865 7261 6c2e 2020  he peripheral.  
+00004900: 5468 6520 6e65 7874 2074 696d 650a 2020  The next time.  
+00004910: 2020 2020 2020 5761 7361 7463 6844 6576        WasatchDev
+00004920: 6963 652e 6163 7175 6972 655f 6461 7461  ice.acquire_data
+00004930: 2069 7320 6361 6c6c 6564 2c20 6974 2077   is called, it w
+00004940: 696c 6c20 7061 7373 2061 2022 706f 6973  ill pass a "pois
+00004950: 6f6e 2070 696c 6c22 2062 6163 6b0a 2020  on pill" back.  
+00004960: 2020 2020 2020 7570 2074 6865 2072 6573        up the res
+00004970: 706f 6e73 6520 7175 6575 652e 0a20 2020  ponse queue..   
+00004980: 2020 2020 2041 6c74 6572 6e61 7465 6c79       Alternately
+00004990: 2c20 6e6f 6e2d 454e 4c49 4748 5445 4e20  , non-ENLIGHTEN 
+000049a0: 6361 6c6c 6572 7320 6361 6e20 7365 7420  callers can set 
+000049b0: 2272 6169 7365 5f65 7863 6570 7469 6f6e  "raise_exception
+000049c0: 7322 202d 3e20 5472 7565 2066 6f72 0a20  s" -> True for. 
+000049d0: 2020 2020 2020 2069 6e2d 7072 6f63 6573         in-proces
+000049e0: 7320 6578 6365 7074 696f 6e2d 6861 6e64  s exception-hand
+000049f0: 6c69 6e67 2e0a 2020 2020 2020 2020 2222  ling..        ""
+00004a00: 220a 2020 2020 2020 2020 6966 2073 656c  ".        if sel
+00004a10: 662e 7261 6973 655f 6578 6365 7074 696f  f.raise_exceptio
+00004a20: 6e73 3a0a 2020 2020 2020 2020 2020 2020  ns:.            
+00004a30: 6c6f 672e 6372 6974 6963 616c 2822 5f73  log.critical("_s
+00004a40: 6368 6564 756c 655f 6469 7363 6f6e 6e65  chedule_disconne
+00004a50: 6374 3a20 7261 6973 696e 6720 6578 6365  ct: raising exce
+00004a60: 7074 696f 6e20 2573 222c 2065 7863 290a  ption %s", exc).
+00004a70: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+00004a80: 6520 6578 630a 2020 2020 2020 2020 656c  e exc.        el
+00004a90: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00004aa0: 6c6f 672e 6372 6974 6963 616c 2822 7265  log.critical("re
+00004ab0: 7175 6573 7469 6e67 2073 6875 7464 6f77  questing shutdow
+00004ac0: 6e20 6475 6520 746f 2065 7863 6570 7469  n due to excepti
+00004ad0: 6f6e 2025 7322 2c20 6578 6329 0a20 2020  on %s", exc).   
+00004ae0: 2020 2020 2020 2020 2073 656c 662e 7368           self.sh
+00004af0: 7574 646f 776e 5f72 6571 7565 7374 6564  utdown_requested
+00004b00: 203d 2054 7275 650a 0a20 2020 2064 6566   = True..    def
+00004b10: 2072 6573 6574 2873 656c 662c 202a 6172   reset(self, *ar
+00004b20: 6773 293a 0a20 2020 2020 2020 206c 6f67  gs):.        log
+00004b30: 2e64 6562 7567 2822 4649 4420 7065 7266  .debug("FID perf
+00004b40: 6f72 6d69 6e67 2064 6576 6963 6520 7265  orming device re
+00004b50: 7365 7422 290a 2020 2020 2020 2020 2373  set").        #s
+00004b60: 656c 662e 6465 7669 6365 5f74 7970 652e  elf.device_type.
+00004b70: 7265 6c65 6173 655f 696e 7465 7266 6163  release_interfac
+00004b80: 6528 7365 6c66 2e64 6576 6963 652c 2030  e(self.device, 0
+00004b90: 290a 2020 2020 2020 2020 7365 6c66 2e64  ).        self.d
+00004ba0: 6576 6963 655f 7479 7065 2e72 6573 6574  evice_type.reset
+00004bb0: 2873 656c 662e 6465 7669 6365 290a 2020  (self.device).  
+00004bc0: 2020 2020 2020 6c6f 672e 6465 6275 6728        log.debug(
+00004bd0: 6622 6672 6565 6420 696e 7465 7266 6163  f"freed interfac
+00004be0: 6522 290a 2020 2020 2020 2020 2727 270a  e").        '''.
+00004bf0: 2020 2020 2020 2020 7079 7573 625f 6465          pyusb_de
+00004c00: 7669 6365 7320 3d20 6c69 7374 2873 656c  vices = list(sel
+00004c10: 662e 6465 7669 6365 5f74 7970 652e 6669  f.device_type.fi
+00004c20: 6e64 2866 696e 645f 616c 6c3d 5472 7565  nd(find_all=True
+00004c30: 2c20 0a20 2020 2020 2020 2020 2020 2020  , .             
+00004c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004c50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004c60: 2069 6456 656e 646f 723d 7365 6c66 2e64   idVendor=self.d
+00004c70: 6576 6963 655f 6964 2e76 6964 2c20 0a20  evice_id.vid, . 
+00004c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004c90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004ca0: 2020 2020 2020 2020 2020 2020 2069 6450               idP
+00004cb0: 726f 6475 6374 3d73 656c 662e 6465 7669  roduct=self.devi
+00004cc0: 6365 5f69 642e 7069 642c 0a20 2020 2020  ce_id.pid,.     
+00004cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004cf0: 2020 2020 2020 2020 2063 7573 746f 6d5f           custom_
+00004d00: 6d61 7463 6820 3d20 6c61 6d62 6461 2064  match = lambda d
+00004d10: 3a20 642e 6164 6472 6573 7320 3d3d 2073  : d.address == s
+00004d20: 656c 662e 6465 7669 6365 5f69 642e 6164  elf.device_id.ad
+00004d30: 6472 6573 7320 616e 6420 642e 6275 7320  dress and d.bus 
+00004d40: 3d3d 2073 656c 662e 6465 7669 6365 5f69  == self.device_i
+00004d50: 642e 6275 7329 290a 2020 2020 2020 2020  d.bus)).        
+00004d60: 2320 6120 636f 7570 6c65 206e 6f74 6573  # a couple notes
+00004d70: 2c0a 2020 2020 2020 2020 2320 5768 656e  ,.        # When
+00004d80: 2079 6f75 2073 6561 7263 6820 686f 7720   you search how 
+00004d90: 746f 2064 6f20 6120 7265 7365 7420 6279  to do a reset by
+00004da0: 2065 6e61 626c 652f 6469 7361 626c 6520   enable/disable 
+00004db0: 6f6e 2077 696e 646f 7773 2077 6861 7420  on windows what 
+00004dc0: 636f 6d65 7320 7570 2069 7320 6465 7663  comes up is devc
+00004dd0: 6f6e 0a20 2020 2020 2020 2023 2064 6576  on.        # dev
+00004de0: 636f 6e20 6c69 6e6b 7320 746f 2070 6e70  con links to pnp
+00004df0: 7574 696c 2061 7320 7468 6520 7265 636f  util as the reco
+00004e00: 6d6d 656e 6465 6420 746f 6f6c 2074 6f20  mmended tool to 
+00004e10: 7573 6520 616e 6420 636f 6d65 7320 7072  use and comes pr
+00004e20: 6569 6e73 7461 6c6c 6564 206f 6e20 7769  einstalled on wi
+00004e30: 6e64 6f77 730a 2020 2020 2020 2020 2320  ndows.        # 
+00004e40: 706e 7075 7469 6c20 6e65 6564 7320 7468  pnputil needs th
+00004e50: 6520 696e 7374 616e 6365 2049 442c 2077  e instance ID, w
+00004e60: 6869 6368 2069 7320 7072 6574 7479 2077  hich is pretty w
+00004e70: 656c 6c20 6869 6464 656e 2069 6e20 7079  ell hidden in py
+00004e80: 7573 620a 2020 2020 2020 2020 2320 4920  usb.        # I 
+00004e90: 6861 6420 746f 206c 6f6f 6b20 6174 2074  had to look at t
+00004ea0: 6865 2066 756c 6c20 636f 6e66 6967 7572  he full configur
+00004eb0: 6174 696f 6e20 7374 7269 6e67 2061 6e64  ation string and
+00004ec0: 2073 6177 2074 6861 7420 7468 6520 7761   saw that the wa
+00004ed0: 7920 746f 2067 6574 2074 6865 2069 6e73  y to get the ins
+00004ee0: 7461 6e63 6520 6964 2077 6173 2074 6865  tance id was the
+00004ef0: 2066 6f6c 6c6f 7769 6e67 0a20 2020 2020   following.     
+00004f00: 2020 2023 2075 7369 6e67 205f 7472 795f     # using _try_
+00004f10: 6765 745f 7374 7269 6e67 2068 7474 7073  get_string https
+00004f20: 3a2f 2f67 6974 6875 622e 636f 6d2f 7079  ://github.com/py
+00004f30: 7573 622f 7079 7573 622f 626c 6f62 2f6d  usb/pyusb/blob/m
+00004f40: 6173 7465 722f 7573 622f 636f 7265 2e70  aster/usb/core.p
+00004f50: 7923 4c31 3232 310a 2020 2020 2020 2020  y#L1221.        
+00004f60: 2320 736f 2074 6563 6869 6e63 616c 6c79  # so techincally
+00004f70: 2077 6520 7368 6f75 6c64 6e27 7420 646f   we shouldn't do
+00004f80: 2074 6869 7320 6279 2074 6865 205f 206d   this by the _ m
+00004f90: 6561 6e69 6e67 2069 7420 7368 6f75 6c64  eaning it should
+00004fa0: 2062 6520 7072 6976 6174 652c 2062 7574   be private, but
+00004fb0: 2069 7427 7320 7468 6520 6f6e 6c79 2077   it's the only w
+00004fc0: 6179 2049 2073 6565 0a20 2020 2020 2020  ay I see.       
+00004fd0: 2064 6576 6963 655f 696e 7374 616e 6365   device_instance
+00004fe0: 5f69 6420 3d20 6627 5553 425c 5649 445f  _id = f'USB\VID_
+00004ff0: 7b73 656c 662e 6465 7669 6365 5f69 642e  {self.device_id.
+00005000: 7669 643a 3034 587d 2650 4944 5f7b 7365  vid:04X}&PID_{se
+00005010: 6c66 2e64 6576 6963 655f 6964 2e70 6964  lf.device_id.pid
+00005020: 3a30 3458 7d5c 7b75 7362 2e63 6f72 652e  :04X}\{usb.core.
+00005030: 5f74 7279 5f67 6574 5f73 7472 696e 6728  _try_get_string(
+00005040: 7079 7573 625f 6465 7669 6365 735b 305d  pyusb_devices[0]
+00005050: 2c20 7079 7573 625f 6465 7669 6365 735b  , pyusb_devices[
+00005060: 305d 2e69 5365 7269 616c 4e75 6d62 6572  0].iSerialNumber
+00005070: 297d 270a 2020 2020 2020 2020 6c6f 672e  )}'.        log.
+00005080: 6465 6275 6728 6622 496e 2072 6573 6574  debug(f"In reset
+00005090: 2061 6e64 2072 6573 7461 7274 2074 7279   and restart try
+000050a0: 696e 6720 746f 2072 6573 6574 2069 6e73  ing to reset ins
+000050b0: 7461 6e63 6520 6964 207b 6465 7669 6365  tance id {device
+000050c0: 5f69 6e73 7461 6e63 655f 6964 7d22 290a  _instance_id}").
+000050d0: 2020 2020 2020 2020 7375 6270 726f 6365          subproce
+000050e0: 7373 2e72 756e 285b 2270 6e70 7574 696c  ss.run(["pnputil
+000050f0: 222c 2072 222f 7265 626f 6f74 222c 2072  ", r"/reboot", r
+00005100: 222f 6469 7361 626c 652d 6465 7669 6365  "/disable-device
+00005110: 222c 2064 6576 6963 655f 696e 7374 616e  ", device_instan
+00005120: 6365 5f69 645d 290a 2020 2020 2020 2020  ce_id]).        
+00005130: 7375 6270 726f 6365 7373 2e72 756e 285b  subprocess.run([
+00005140: 2270 6e70 7574 696c 222c 2072 222f 7265  "pnputil", r"/re
+00005150: 626f 6f74 222c 2072 222f 656e 6162 6c65  boot", r"/enable
+00005160: 2d64 6576 6963 6522 2c20 6465 7669 6365  -device", device
+00005170: 5f69 6e73 7461 6e63 655f 6964 5d29 0a27  _instance_id]).'
+00005180: 2727 0a20 2020 2023 2023 2323 2323 2323  ''.    # #######
+00005190: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000051a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000051b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000051c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000051d0: 2323 230a 2020 2020 2320 5574 696c 6974  ###.    # Utilit
+000051e0: 7920 4d65 7468 6f64 730a 2020 2020 2320  y Methods.    # 
+000051f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00005200: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00005210: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00005220: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00005230: 2323 2323 2323 2323 2323 0a0a 2020 0a20  ##########..  . 
+00005240: 2020 2064 6566 205f 746f 3430 6269 7428     def _to40bit(
+00005250: 7365 6c66 2c20 7661 6c29 3a0a 2020 2020  self, val):.    
+00005260: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00005270: 4c61 7365 7220 6d6f 6475 6c61 7469 6f6e  Laser modulation
+00005280: 2061 6e64 2063 6f6e 7469 6e75 6f75 732d   and continuous-
+00005290: 7374 726f 6265 2063 6f6d 6d61 6e64 7320  strobe commands 
+000052a0: 7461 6b65 2061 7267 756d 656e 7473 2069  take arguments i
+000052b0: 6e20 6d69 6372 6f2d 0a20 2020 2020 2020  n micro-.       
+000052c0: 2073 6563 6f6e 6473 2061 7320 3430 2d62   seconds as 40-b
+000052d0: 6974 2076 616c 7565 732c 2077 6865 7265  it values, where
+000052e0: 2074 6865 206c 6561 7374 2d73 6967 6e69   the least-signi
+000052f0: 6669 6361 6e74 2031 3620 6269 7473 2061  ficant 16 bits a
+00005300: 7265 2070 6173 7365 640a 2020 2020 2020  re passed.      
+00005310: 2020 6173 2077 5661 6c75 652c 2074 6865    as wValue, the
+00005320: 206e 6578 742d 7369 676e 6966 6963 616e   next-significan
+00005330: 7420 3136 2061 7320 7749 6e64 6578 2c20  t 16 as wIndex, 
+00005340: 616e 6420 7468 6520 6d6f 7374 2d73 6967  and the most-sig
+00005350: 6e69 6669 6361 6e74 0a20 2020 2020 2020  nificant.       
+00005360: 2061 7320 6120 7369 6e67 6c65 2062 7974   as a single byt
+00005370: 6520 6f66 2070 6179 6c6f 6164 2e20 2054  e of payload.  T
+00005380: 6869 7320 6675 6e63 7469 6f6e 2074 616b  his function tak
+00005390: 6573 2061 6e20 756e 7369 676e 6564 2069  es an unsigned i
+000053a0: 6e74 6567 7261 6c0a 2020 2020 2020 2020  ntegral.        
+000053b0: 7661 6c75 6520 2870 7265 7375 6d61 626c  value (presumabl
+000053c0: 7920 6d69 6372 6f73 6563 6f6e 6473 2920  y microseconds) 
+000053d0: 616e 6420 7265 7475 726e 7320 6120 7475  and returns a tu
+000053e0: 706c 6520 6f66 2077 5661 6c75 652c 2077  ple of wValue, w
+000053f0: 496e 6465 780a 2020 2020 2020 2020 616e  Index.        an
+00005400: 6420 6120 6275 6666 6572 2074 6f20 7061  d a buffer to pa
+00005410: 7373 2061 7320 7061 796c 6f61 642e 0a20  ss as payload.. 
+00005420: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+00005430: 2020 206c 7377 203d 2076 616c 2026 2030     lsw = val & 0
+00005440: 7866 6666 660a 2020 2020 2020 2020 6d73  xffff.        ms
+00005450: 7720 3d20 2876 616c 203e 3e20 3136 2920  w = (val >> 16) 
+00005460: 2620 3078 6666 6666 0a20 2020 2020 2020  & 0xffff.       
+00005470: 2062 7566 203d 205b 2028 7661 6c20 3e3e   buf = [ (val >>
+00005480: 2033 3229 2026 2030 7866 6620 5d20 2b20   32) & 0xff ] + 
+00005490: 5b30 5d20 2a20 370a 2020 2020 2020 2020  [0] * 7.        
+000054a0: 7265 7475 726e 2028 6c73 772c 206d 7377  return (lsw, msw
+000054b0: 2c20 6275 6629 0a0a 2020 2020 6465 6620  , buf)..    def 
+000054c0: 5f77 6169 745f 666f 725f 7573 625f 6176  _wait_for_usb_av
+000054d0: 6169 6c61 626c 6528 7365 6c66 293a 0a20  ailable(self):. 
+000054e0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+000054f0: 2020 2057 6169 7420 756e 7469 6c20 616e     Wait until an
+00005500: 7920 656e 666f 7263 6564 2055 5342 2070  y enforced USB p
+00005510: 6163 6b65 7420 696e 7465 7276 616c 7320  acket intervals 
+00005520: 6861 7665 2065 6c61 7073 6564 2e20 5468  have elapsed. Th
+00005530: 6973 2064 6f65 730a 2020 2020 2020 2020  is does.        
+00005540: 6e6f 7468 696e 6720 696e 206d 6f73 7420  nothing in most 
+00005550: 6361 7365 7320 2d20 7468 6520 6675 6e63  cases - the func
+00005560: 7469 6f6e 2069 7320 6e6f 726d 616c 6c79  tion is normally
+00005570: 2061 206e 6f2d 6f70 2e0a 2020 2020 2020   a no-op..      
+00005580: 2020 486f 7765 7665 722c 2069 6620 7468    However, if th
+00005590: 6520 6170 706c 6963 6174 696f 6e20 6861  e application ha
+000055a0: 7320 6465 6669 6e65 6420 6d69 6e2f 6d61  s defined min/ma
+000055b0: 785f 7573 625f 696e 7465 7276 616c 5f6d  x_usb_interval_m
+000055c0: 7320 2873 6179 0a20 2020 2020 2020 2028  s (say.        (
+000055d0: 3230 2c20 3530 6d73 292c 2074 6865 6e20  20, 50ms), then 
+000055e0: 7069 636b 2061 2072 616e 646f 6d20 6465  pick a random de
+000055f0: 6c61 7920 696e 2074 6865 2064 6566 696e  lay in the defin
+00005600: 6564 2077 696e 646f 7720 2865 2e67 2e20  ed window (e.g. 
+00005610: 3337 6d73 290a 2020 2020 2020 2020 616e  37ms).        an
+00005620: 6420 736c 6565 7020 756e 7469 6c20 6974  d sleep until it
+00005630: 2068 6173 2062 6565 6e20 6174 206c 6561   has been at lea
+00005640: 7374 2074 6861 7420 6c6f 6e67 2073 696e  st that long sin
+00005650: 6365 2074 6865 206c 6173 7420 5553 420a  ce the last USB.
+00005660: 2020 2020 2020 2020 6578 6368 616e 6765          exchange
+00005670: 2e0a 2020 2020 2020 2020 5468 6520 7075  ..        The pu
+00005680: 7270 6f73 6520 6f66 2074 6869 7320 6675  rpose of this fu
+00005690: 6e63 7469 6f6e 2077 6173 2074 6f20 7772  nction was to wr
+000056a0: 696e 672d 6f75 7420 736f 6d65 2065 6172  ing-out some ear
+000056b0: 6c79 2041 524d 206d 6963 726f 2d0a 2020  ly ARM micro-.  
+000056c0: 2020 2020 2020 636f 6e74 726f 6c6c 6572        controller
+000056d0: 7320 7769 7468 2061 7070 6172 656e 7420  s with apparent 
+000056e0: 7469 6d69 6e67 2069 7373 7565 7320 756e  timing issues un
+000056f0: 6465 7220 6869 6768 2d73 7065 6564 2055  der high-speed U
+00005700: 5342 2032 2e30 2c20 746f 2073 6565 0a20  SB 2.0, to see. 
+00005710: 2020 2020 2020 2069 6620 636f 6d6d 756e         if commun
+00005720: 6963 6174 696f 6e73 2069 7373 7565 7320  ications issues 
+00005730: 6469 7361 7070 6561 7265 6420 6966 2077  disappeared if w
+00005740: 6520 656e 666f 7263 6564 2061 2063 6f6d  e enforced a com
+00005750: 6d75 6e69 6361 7469 6f6e 0a20 2020 2020  munication.     
+00005760: 2020 206c 6174 656e 6379 2066 726f 6d20     latency from 
+00005770: 7468 6520 736f 6674 7761 7265 2073 6964  the software sid
+00005780: 652e 0a20 2020 2020 2020 2022 2222 0a20  e..        """. 
+00005790: 2020 2020 2020 2069 6620 7365 6c66 2e73         if self.s
+000057a0: 6574 7469 6e67 732e 7374 6174 652e 6d61  ettings.state.ma
+000057b0: 785f 7573 625f 696e 7465 7276 616c 5f6d  x_usb_interval_m
+000057c0: 7320 3c3d 2030 3a0a 2020 2020 2020 2020  s <= 0:.        
+000057d0: 2020 2020 7265 7475 726e 0a0a 2020 2020      return..    
+000057e0: 2020 2020 6966 2073 656c 662e 6c61 7374      if self.last
+000057f0: 5f75 7362 5f74 696d 6573 7461 6d70 2069  _usb_timestamp i
+00005800: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
+00005810: 2020 2020 2020 2020 6465 6c61 795f 6d73          delay_ms
+00005820: 203d 2072 616e 6469 6e74 2873 656c 662e   = randint(self.
+00005830: 7365 7474 696e 6773 2e73 7461 7465 2e6d  settings.state.m
+00005840: 696e 5f75 7362 5f69 6e74 6572 7661 6c5f  in_usb_interval_
+00005850: 6d73 2c20 7365 6c66 2e73 6574 7469 6e67  ms, self.setting
+00005860: 732e 7374 6174 652e 6d61 785f 7573 625f  s.state.max_usb_
+00005870: 696e 7465 7276 616c 5f6d 7329 0a20 2020  interval_ms).   
+00005880: 2020 2020 2020 2020 206e 6578 745f 7573           next_us
+00005890: 625f 7469 6d65 7374 616d 7020 3d20 7365  b_timestamp = se
+000058a0: 6c66 2e6c 6173 745f 7573 625f 7469 6d65  lf.last_usb_time
+000058b0: 7374 616d 7020 2b20 6461 7465 7469 6d65  stamp + datetime
+000058c0: 2e74 696d 6564 656c 7461 286d 696c 6c69  .timedelta(milli
+000058d0: 7365 636f 6e64 733d 6465 6c61 795f 6d73  seconds=delay_ms
+000058e0: 290a 2020 2020 2020 2020 2020 2020 6e6f  ).            no
+000058f0: 7720 3d20 6461 7465 7469 6d65 2e64 6174  w = datetime.dat
+00005900: 6574 696d 652e 6e6f 7728 290a 2020 2020  etime.now().    
+00005910: 2020 2020 2020 2020 6966 206e 6f77 203c          if now <
+00005920: 206e 6578 745f 7573 625f 7469 6d65 7374   next_usb_timest
+00005930: 616d 703a 0a20 2020 2020 2020 2020 2020  amp:.           
+00005940: 2020 2020 2073 6c65 6570 5f73 6563 203d       sleep_sec =
+00005950: 2028 6e65 7874 5f75 7362 5f74 696d 6573   (next_usb_times
+00005960: 7461 6d70 202d 206e 6f77 292e 746f 7461  tamp - now).tota
+00005970: 6c5f 7365 636f 6e64 7328 290a 2020 2020  l_seconds().    
+00005980: 2020 2020 2020 2020 2020 2020 6c6f 672e              log.
+00005990: 6465 6275 6728 2266 6964 3a20 736c 6565  debug("fid: slee
+000059a0: 7069 6e67 2025 2e33 6620 7365 6320 746f  ping %.3f sec to
+000059b0: 2065 6e66 6f72 6365 2025 6420 6d73 2055   enforce %d ms U
+000059c0: 5342 2069 6e74 6572 7661 6c22 2c20 736c  SB interval", sl
+000059d0: 6565 705f 7365 632c 2064 656c 6179 5f6d  eep_sec, delay_m
+000059e0: 7329 0a20 2020 2020 2020 2020 2020 2020  s).             
+000059f0: 2020 2073 6c65 6570 2873 6c65 6570 5f73     sleep(sleep_s
+00005a00: 6563 290a 2020 2020 2020 2020 7365 6c66  ec).        self
+00005a10: 2e6c 6173 745f 7573 625f 7469 6d65 7374  .last_usb_timest
+00005a20: 616d 7020 3d20 6461 7465 7469 6d65 2e64  amp = datetime.d
+00005a30: 6174 6574 696d 652e 6e6f 7728 290a 0a20  atetime.now().. 
+00005a40: 2020 2064 6566 205f 6368 6563 6b5f 666f     def _check_fo
+00005a50: 725f 7261 6e64 6f6d 5f65 7272 6f72 2873  r_random_error(s
+00005a60: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
+00005a70: 220a 2020 2020 2020 2020 5468 6973 2066  ".        This f
+00005a80: 756e 6374 696f 6e20 6973 2070 726f 7669  unction is provi
+00005a90: 6465 6420 746f 2073 696d 756c 6174 6520  ded to simulate 
+00005aa0: 7261 6e64 6f6d 2055 5342 2063 6f6d 6d75  random USB commu
+00005ab0: 6e69 6361 7469 6f6e 2065 7272 6f72 730a  nication errors.
+00005ac0: 2020 2020 2020 2020 6475 7269 6e67 2072          during r
+00005ad0: 6567 7265 7373 696f 6e20 7465 7374 696e  egression testin
+00005ae0: 672c 2061 6e64 2069 7320 6e6f 726d 616c  g, and is normal
+00005af0: 6c79 2061 206e 6f2d 6f70 2e0a 2020 2020  ly a no-op..    
+00005b00: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00005b10: 6966 206e 6f74 2073 656c 662e 696e 6a65  if not self.inje
+00005b20: 6374 5f72 616e 646f 6d5f 6572 726f 7273  ct_random_errors
+00005b30: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00005b40: 7475 726e 2046 616c 7365 0a0a 2020 2020  turn False..    
+00005b50: 2020 2020 6966 2072 616e 646f 6d2e 7261      if random.ra
+00005b60: 6e64 6f6d 2829 203c 3d20 7365 6c66 2e72  ndom() <= self.r
+00005b70: 616e 646f 6d5f 6572 726f 725f 7065 7263  andom_error_perc
+00005b80: 3a0a 2020 2020 2020 2020 2020 2020 6c6f  :.            lo
+00005b90: 672e 6372 6974 6963 616c 2822 5261 6e64  g.critical("Rand
+00005ba0: 6f6d 6c79 2d69 6e6a 6563 7465 6420 6572  omly-injected er
+00005bb0: 726f 7222 290a 2020 2020 2020 2020 2020  ror").          
+00005bc0: 2020 7365 6c66 2e5f 7363 6865 6475 6c65    self._schedule
+00005bd0: 5f64 6973 636f 6e6e 6563 7428 4578 6365  _disconnect(Exce
+00005be0: 7074 696f 6e28 2252 616e 646f 6d6c 792d  ption("Randomly-
+00005bf0: 696e 6a65 6374 6564 2065 7272 6f72 2229  injected error")
+00005c00: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+00005c10: 7475 726e 2054 7275 650a 2020 2020 2020  turn True.      
+00005c20: 2020 7265 7475 726e 2046 616c 7365 0a0a    return False..
+00005c30: 2020 2020 2323 0a20 2020 2023 2055 6e74      ##.    # Unt
+00005c40: 696c 2073 7570 706f 7274 2066 6f72 2065  il support for e
+00005c50: 7665 6e2f 6f64 6420 496e 4761 4173 2067  ven/odd InGaAs g
+00005c60: 6169 6e20 616e 6420 6f66 6673 6574 2068  ain and offset h
+00005c70: 6176 6520 6265 656e 2061 6464 6564 2074  ave been added t
+00005c80: 6f20 7468 650a 2020 2020 2320 6669 726d  o the.    # firm
+00005c90: 7761 7265 2c20 6170 706c 7920 7468 6520  ware, apply the 
+00005ca0: 636f 7272 6563 7469 6f6e 2069 6e20 736f  correction in so
+00005cb0: 6674 7761 7265 2e0a 2020 2020 6465 6620  ftware..    def 
+00005cc0: 5f63 6f72 7265 6374 5f69 6e67 6161 735f  _correct_ingaas_
+00005cd0: 6761 696e 5f61 6e64 5f6f 6666 7365 7428  gain_and_offset(
+00005ce0: 7365 6c66 2c20 7370 6563 7472 756d 3a20  self, spectrum: 
+00005cf0: 6c69 7374 5b66 6c6f 6174 5d29 3a0a 2020  list[float]):.  
+00005d00: 2020 2020 2020 6966 206e 6f74 2073 656c        if not sel
+00005d10: 662e 7365 7474 696e 6773 2e69 735f 696e  f.settings.is_in
+00005d20: 6761 6173 2829 206f 7220 7365 6c66 2e73  gaas() or self.s
+00005d30: 6574 7469 6e67 732e 6565 7072 6f6d 2e68  ettings.eeprom.h
+00005d40: 6172 6477 6172 655f 6576 656e 5f6f 6464  ardware_even_odd
+00005d50: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00005d60: 7475 726e 2046 616c 7365 0a0a 2020 2020  turn False..    
+00005d70: 2020 2020 2320 6966 2065 7665 6e20 616e      # if even an
+00005d80: 6420 6f64 6420 7069 7865 6c73 2068 6176  d odd pixels hav
+00005d90: 6520 7468 6520 7361 6d65 2073 6574 7469  e the same setti
+00005da0: 6e67 732c 2074 6865 7265 2773 206e 6f20  ngs, there's no 
+00005db0: 706f 696e 7420 696e 2064 6f69 6e67 2061  point in doing a
+00005dc0: 6e79 7468 696e 670a 2020 2020 2020 2020  nything.        
+00005dd0: 6966 2073 656c 662e 7365 7474 696e 6773  if self.settings
+00005de0: 2e65 6570 726f 6d2e 6465 7465 6374 6f72  .eeprom.detector
+00005df0: 5f67 6169 6e5f 6f64 6420 2020 3d3d 2073  _gain_odd   == s
+00005e00: 656c 662e 7365 7474 696e 6773 2e65 6570  elf.settings.eep
+00005e10: 726f 6d2e 6465 7465 6374 6f72 5f67 6169  rom.detector_gai
+00005e20: 6e20 616e 6420 5c0a 2020 2020 2020 2020  n and \.        
+00005e30: 2020 2073 656c 662e 7365 7474 696e 6773     self.settings
+00005e40: 2e65 6570 726f 6d2e 6465 7465 6374 6f72  .eeprom.detector
+00005e50: 5f6f 6666 7365 745f 6f64 6420 3d3d 2073  _offset_odd == s
+00005e60: 656c 662e 7365 7474 696e 6773 2e65 6570  elf.settings.eep
+00005e70: 726f 6d2e 6465 7465 6374 6f72 5f6f 6666  rom.detector_off
+00005e80: 7365 743a 0a20 2020 2020 2020 2020 2020  set:.           
+00005e90: 2072 6574 7572 6e20 4661 6c73 650a 0a20   return False.. 
+00005ea0: 2020 2020 2020 2069 6620 3020 3d3d 2073         if 0 == s
+00005eb0: 656c 662e 7365 7474 696e 6773 2e65 6570  elf.settings.eep
+00005ec0: 726f 6d2e 6465 7465 6374 6f72 5f67 6169  rom.detector_gai
+00005ed0: 6e3a 0a20 2020 2020 2020 2020 2020 206c  n:.            l
+00005ee0: 6f67 2e64 6562 7567 2822 6465 636c 696e  og.debug("declin
+00005ef0: 696e 6720 746f 2061 7474 656d 7074 2064  ing to attempt d
+00005f00: 6976 6973 696f 6e20 6279 207a 6572 6f22  ivision by zero"
+00005f10: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+00005f20: 7475 726e 0a0a 2020 2020 2020 2020 6c6f  turn..        lo
+00005f30: 672e 6465 6275 6728 2272 6573 6361 6c69  g.debug("rescali
+00005f40: 6e67 2049 6e47 6141 7320 6f64 6420 7069  ng InGaAs odd pi
+00005f50: 7865 6c73 2066 726f 6d20 6576 656e 2067  xels from even g
+00005f60: 6169 6e20 252e 3466 2c20 6f66 6673 6574  ain %.4f, offset
+00005f70: 2025 6420 746f 206f 6464 2067 6169 6e20   %d to odd gain 
+00005f80: 252e 3466 2c20 6f66 6673 6574 2025 6422  %.4f, offset %d"
+00005f90: 2c0a 2020 2020 2020 2020 2020 2020 7365  ,.            se
+00005fa0: 6c66 2e73 6574 7469 6e67 732e 6565 7072  lf.settings.eepr
+00005fb0: 6f6d 2e64 6574 6563 746f 725f 6761 696e  om.detector_gain
+00005fc0: 2c0a 2020 2020 2020 2020 2020 2020 7365  ,.            se
+00005fd0: 6c66 2e73 6574 7469 6e67 732e 6565 7072  lf.settings.eepr
+00005fe0: 6f6d 2e64 6574 6563 746f 725f 6f66 6673  om.detector_offs
+00005ff0: 6574 2c0a 2020 2020 2020 2020 2020 2020  et,.            
+00006000: 7365 6c66 2e73 6574 7469 6e67 732e 6565  self.settings.ee
+00006010: 7072 6f6d 2e64 6574 6563 746f 725f 6761  prom.detector_ga
+00006020: 696e 5f6f 6464 2c0a 2020 2020 2020 2020  in_odd,.        
+00006030: 2020 2020 7365 6c66 2e73 6574 7469 6e67      self.setting
+00006040: 732e 6565 7072 6f6d 2e64 6574 6563 746f  s.eeprom.detecto
+00006050: 725f 6f66 6673 6574 5f6f 6464 290a 0a20  r_offset_odd).. 
+00006060: 2020 2020 2020 206c 6f67 2e64 6562 7567         log.debug
+00006070: 2822 6265 666f 7265 3a20 2564 2c20 2564  ("before: %d, %d
+00006080: 2c20 2564 2c20 2564 2c20 2564 222c 2073  , %d, %d, %d", s
+00006090: 7065 6374 7275 6d5b 305d 2c20 7370 6563  pectrum[0], spec
+000060a0: 7472 756d 5b31 5d2c 2073 7065 6374 7275  trum[1], spectru
+000060b0: 6d5b 325d 2c20 7370 6563 7472 756d 5b33  m[2], spectrum[3
+000060c0: 5d2c 2073 7065 6374 7275 6d5b 345d 290a  ], spectrum[4]).
+000060d0: 0a20 2020 2020 2020 2023 2069 7465 7261  .        # itera
+000060e0: 7465 206f 7665 7220 7468 6520 4f44 4420  te over the ODD 
+000060f0: 7069 7865 6c73 206f 6620 7468 6520 7370  pixels of the sp
+00006100: 6563 7472 756d 0a20 2020 2020 2020 2066  ectrum.        f
+00006110: 6f72 2069 2069 6e20 7261 6e67 6528 312c  or i in range(1,
+00006120: 206c 656e 2873 7065 6374 7275 6d29 2c20   len(spectrum), 
+00006130: 3229 3a0a 0a20 2020 2020 2020 2020 2020  2):..           
+00006140: 2023 2062 6163 6b2d 6f75 7420 7468 6520   # back-out the 
+00006150: 696e 636f 7272 6563 746c 7920 6170 706c  incorrectly appl
+00006160: 6965 6420 2265 7665 6e22 2067 6169 6e20  ied "even" gain 
+00006170: 616e 6420 6f66 6673 6574 0a20 2020 2020  and offset.     
+00006180: 2020 2020 2020 206f 6c64 203d 2066 6c6f         old = flo
+00006190: 6174 2873 7065 6374 7275 6d5b 695d 290a  at(spectrum[i]).
+000061a0: 2020 2020 2020 2020 2020 2020 7261 7720              raw 
+000061b0: 3d20 286f 6c64 202d 2073 656c 662e 7365  = (old - self.se
+000061c0: 7474 696e 6773 2e65 6570 726f 6d2e 6465  ttings.eeprom.de
+000061d0: 7465 6374 6f72 5f6f 6666 7365 7429 202f  tector_offset) /
+000061e0: 2073 656c 662e 7365 7474 696e 6773 2e65   self.settings.e
+000061f0: 6570 726f 6d2e 6465 7465 6374 6f72 5f67  eprom.detector_g
+00006200: 6169 6e0a 0a20 2020 2020 2020 2020 2020  ain..           
+00006210: 2023 2061 7070 6c79 2074 6865 2063 6f72   # apply the cor
+00006220: 7265 6374 2022 6f64 6422 2067 6169 6e20  rect "odd" gain 
+00006230: 616e 6420 6f66 6673 6574 0a20 2020 2020  and offset.     
+00006240: 2020 2020 2020 2073 7065 6374 7275 6d5b         spectrum[
+00006250: 695d 203d 2028 7261 7720 2a20 7365 6c66  i] = (raw * self
+00006260: 2e73 6574 7469 6e67 732e 6565 7072 6f6d  .settings.eeprom
+00006270: 2e64 6574 6563 746f 725f 6761 696e 5f6f  .detector_gain_o
+00006280: 6464 2920 2b20 7365 6c66 2e73 6574 7469  dd) + self.setti
+00006290: 6e67 732e 6565 7072 6f6d 2e64 6574 6563  ngs.eeprom.detec
+000062a0: 746f 725f 6f66 6673 6574 5f6f 6464 0a0a  tor_offset_odd..
+000062b0: 2020 2020 2020 2020 2020 2020 6966 2069              if i
+000062c0: 203c 2035 206f 7220 6920 3e20 6c65 6e28   < 5 or i > len(
+000062d0: 7370 6563 7472 756d 2920 2d20 353a 0a20  spectrum) - 5:. 
+000062e0: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+000062f0: 6f67 2e64 6562 7567 2822 2020 7069 7865  og.debug("  pixe
+00006300: 6c20 2534 643a 206f 6c64 2025 2e32 6620  l %4d: old %.2f 
+00006310: 7261 7720 252e 3266 206e 6577 2025 2e32  raw %.2f new %.2
+00006320: 6622 2c20 692c 206f 6c64 2c20 7261 772c  f", i, old, raw,
+00006330: 2073 7065 6374 7275 6d5b 695d 290a 0a20   spectrum[i]).. 
+00006340: 2020 2020 2020 206c 6f67 2e64 6562 7567         log.debug
+00006350: 2822 6166 7465 723a 2025 642c 2025 642c  ("after: %d, %d,
+00006360: 2025 642c 2025 642c 2025 6422 2c20 7370   %d, %d, %d", sp
+00006370: 6563 7472 756d 5b30 5d2c 2073 7065 6374  ectrum[0], spect
+00006380: 7275 6d5b 315d 2c20 7370 6563 7472 756d  rum[1], spectrum
+00006390: 5b32 5d2c 2073 7065 6374 7275 6d5b 335d  [2], spectrum[3]
+000063a0: 2c20 7370 6563 7472 756d 5b34 5d29 0a0a  , spectrum[4])..
+000063b0: 2020 2020 2020 2020 7265 7475 726e 2054          return T
+000063c0: 7275 650a 0a20 2020 2064 6566 205f 6170  rue..    def _ap
+000063d0: 706c 795f 3278 325f 6269 6e6e 696e 6728  ply_2x2_binning(
+000063e0: 7365 6c66 2c20 7370 6563 7472 756d 3a20  self, spectrum: 
+000063f0: 6c69 7374 5b66 6c6f 6174 5d29 3a0a 2020  list[float]):.  
+00006400: 2020 2020 2020 6966 206e 6f74 2073 656c        if not sel
+00006410: 662e 7365 7474 696e 6773 2e65 6570 726f  f.settings.eepro
+00006420: 6d2e 6269 6e5f 3278 323a 0a20 2020 2020  m.bin_2x2:.     
+00006430: 2020 2020 2020 2072 6574 7572 6e20 7370         return sp
+00006440: 6563 7472 756d 0a0a 2020 2020 2020 2020  ectrum..        
+00006450: 6465 6620 6269 6e32 7832 2861 293a 0a20  def bin2x2(a):. 
+00006460: 2020 2020 2020 2020 2020 2069 6620 6120             if a 
+00006470: 6973 204e 6f6e 6520 6f72 206c 656e 2861  is None or len(a
+00006480: 2920 3d3d 2030 3a0a 2020 2020 2020 2020  ) == 0:.        
+00006490: 2020 2020 2020 2020 7265 7475 726e 2061          return a
+000064a0: 0a20 2020 2020 2020 2020 2020 2062 696e  .            bin
+000064b0: 6e65 6420 3d20 5b5d 0a20 2020 2020 2020  ned = [].       
+000064c0: 2020 2020 2066 6f72 2069 2069 6e20 7261       for i in ra
+000064d0: 6e67 6528 6c65 6e28 6129 2d31 293a 0a20  nge(len(a)-1):. 
+000064e0: 2020 2020 2020 2020 2020 2020 2020 2062                 b
+000064f0: 696e 6e65 642e 6170 7065 6e64 2828 615b  inned.append((a[
+00006500: 695d 202b 2061 5b69 2b31 5d29 202f 2032  i] + a[i+1]) / 2
+00006510: 2e30 290a 2020 2020 2020 2020 2020 2020  .0).            
+00006520: 6269 6e6e 6564 2e61 7070 656e 6428 615b  binned.append(a[
+00006530: 2d31 5d29 0a20 2020 2020 2020 2020 2020  -1]).           
+00006540: 2072 6574 7572 6e20 6269 6e6e 6564 0a0a   return binned..
+00006550: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+00006560: 7365 7474 696e 6773 2e73 7461 7465 2e64  settings.state.d
+00006570: 6574 6563 746f 725f 7265 6769 6f6e 7320  etector_regions 
+00006580: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
+00006590: 2020 2020 206c 6f67 2e64 6562 7567 2822       log.debug("
+000065a0: 6170 706c 7969 6e67 2062 696e 5f32 7832  applying bin_2x2
+000065b0: 2229 0a20 2020 2020 2020 2020 2020 2072  ").            r
+000065c0: 6574 7572 6e20 6269 6e32 7832 2873 7065  eturn bin2x2(spe
+000065d0: 6374 7275 6d29 0a0a 2020 2020 2020 2020  ctrum)..        
+000065e0: 6c6f 672e 6465 6275 6728 2261 7070 6c79  log.debug("apply
+000065f0: 696e 6720 6269 6e5f 3278 3220 746f 2072  ing bin_2x2 to r
+00006600: 6567 696f 6e73 2229 0a20 2020 2020 2020  egions").       
+00006610: 2063 6f6d 6269 6e65 6420 3d20 5b5d 0a20   combined = []. 
+00006620: 2020 2020 2020 2066 6f72 2073 7562 7370         for subsp
+00006630: 6563 7472 756d 2069 6e20 7365 6c66 2e73  ectrum in self.s
+00006640: 6574 7469 6e67 732e 7374 6174 652e 6465  ettings.state.de
+00006650: 7465 6374 6f72 5f72 6567 696f 6e73 2e73  tector_regions.s
+00006660: 706c 6974 2873 7065 6374 7275 6d29 3a0a  plit(spectrum):.
+00006670: 2020 2020 2020 2020 2020 2020 636f 6d62              comb
+00006680: 696e 6564 2e65 7874 656e 6428 6269 6e32  ined.extend(bin2
+00006690: 7832 2873 7562 7370 6563 7472 756d 2929  x2(subspectrum))
+000066a0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+000066b0: 636f 6d62 696e 6564 0a0a 2020 2020 6465  combined..    de
+000066c0: 6620 5f63 6f72 7265 6374 5f62 6164 5f70  f _correct_bad_p
+000066d0: 6978 656c 7328 7365 6c66 2c20 7370 6563  ixels(self, spec
+000066e0: 7472 756d 3a20 6c69 7374 5b66 6c6f 6174  trum: list[float
+000066f0: 5d29 3a0a 2020 2020 2020 2020 2222 220a  ]):.        """.
+00006700: 2020 2020 2020 2020 4966 2061 2073 7065          If a spe
+00006710: 6374 726f 6d65 7465 7220 6861 7320 6261  ctrometer has ba
+00006720: 645f 7069 7865 6c73 2063 6f6e 6669 6775  d_pixels configu
+00006730: 7265 6420 696e 2074 6865 2045 4550 524f  red in the EEPRO
+00006740: 4d2c 2074 6865 6e20 6176 6572 6167 650a  M, then average.
+00006750: 2020 2020 2020 2020 6f76 6572 2074 6865          over the
+00006760: 6d20 696e 2074 6865 2064 7269 7665 722e  m in the driver.
+00006770: 0a20 2020 2020 2020 204e 6f74 6520 7468  .        Note th
+00006780: 6973 2066 756e 6374 696f 6e20 6d6f 6469  is function modi
+00006790: 6669 6573 2074 6865 2070 6173 7365 6420  fies the passed 
+000067a0: 6172 7261 7920 696e 2d70 6c61 6365 2c20  array in-place, 
+000067b0: 7261 7468 6572 2074 6861 6e0a 2020 2020  rather than.    
+000067c0: 2020 2020 7265 7475 726e 696e 6720 6120      returning a 
+000067d0: 6d6f 6469 6669 6564 2063 6f70 792e 0a20  modified copy.. 
+000067e0: 2020 2020 2020 2040 6e6f 7465 2061 7373         @note ass
+000067f0: 756d 6573 2062 6164 5f70 6978 656c 7320  umes bad_pixels 
+00006800: 6973 2070 7265 7669 6f75 736c 7920 736f  is previously so
+00006810: 7274 6564 0a20 2020 2020 2020 2022 2222  rted.        """
+00006820: 0a0a 2020 2020 2020 2020 6966 2073 656c  ..        if sel
+00006830: 662e 7365 7474 696e 6773 2069 7320 4e6f  f.settings is No
+00006840: 6e65 206f 7220 5c0a 2020 2020 2020 2020  ne or \.        
+00006850: 2020 2020 2020 2020 7365 6c66 2e73 6574          self.set
+00006860: 7469 6e67 732e 6565 7072 6f6d 2069 7320  tings.eeprom is 
+00006870: 4e6f 6e65 206f 7220 5c0a 2020 2020 2020  None or \.      
+00006880: 2020 2020 2020 2020 2020 7365 6c66 2e73            self.s
+00006890: 6574 7469 6e67 732e 6565 7072 6f6d 2e62  ettings.eeprom.b
+000068a0: 6164 5f70 6978 656c 7320 6973 204e 6f6e  ad_pixels is Non
+000068b0: 6520 6f72 205c 0a20 2020 2020 2020 2020  e or \.         
+000068c0: 2020 2020 2020 206c 656e 2873 656c 662e         len(self.
+000068d0: 7365 7474 696e 6773 2e65 6570 726f 6d2e  settings.eeprom.
+000068e0: 6261 645f 7069 7865 6c73 2920 3d3d 2030  bad_pixels) == 0
+000068f0: 206f 7220 5c0a 2020 2020 2020 2020 2020   or \.          
+00006900: 2020 2020 2020 7365 6c66 2e73 6574 7469        self.setti
+00006910: 6e67 732e 7374 6174 652e 6465 7465 6374  ngs.state.detect
+00006920: 6f72 5f72 6567 696f 6e73 2069 7320 6e6f  or_regions is no
+00006930: 7420 4e6f 6e65 3a0a 2020 2020 2020 2020  t None:.        
+00006940: 2020 2020 7265 7475 726e 2046 616c 7365      return False
+00006950: 0a0a 2020 2020 2020 2020 6966 2073 7065  ..        if spe
+00006960: 6374 7275 6d20 6973 204e 6f6e 6520 6f72  ctrum is None or
+00006970: 206c 656e 2873 7065 6374 7275 6d29 203d   len(spectrum) =
+00006980: 3d20 303a 0a20 2020 2020 2020 2020 2020  = 0:.           
+00006990: 2072 6574 7572 6e20 4661 6c73 650a 0a20   return False.. 
+000069a0: 2020 2020 2020 2070 6978 656c 7320 3d20         pixels = 
+000069b0: 6c65 6e28 7370 6563 7472 756d 290a 2020  len(spectrum).  
+000069c0: 2020 2020 2020 6261 645f 7069 7865 6c73        bad_pixels
+000069d0: 203d 2073 656c 662e 7365 7474 696e 6773   = self.settings
+000069e0: 2e65 6570 726f 6d2e 6261 645f 7069 7865  .eeprom.bad_pixe
+000069f0: 6c73 0a0a 2020 2020 2020 2020 2320 6974  ls..        # it
+00006a00: 6572 6174 6520 6f76 6572 2065 6163 6820  erate over each 
+00006a10: 6261 6420 7069 7865 6c0a 2020 2020 2020  bad pixel.      
+00006a20: 2020 6920 3d20 300a 2020 2020 2020 2020    i = 0.        
+00006a30: 7768 696c 6520 6920 3c20 6c65 6e28 6261  while i < len(ba
+00006a40: 645f 7069 7865 6c73 293a 0a0a 2020 2020  d_pixels):..    
+00006a50: 2020 2020 2020 2020 6261 645f 7069 7820          bad_pix 
+00006a60: 3d20 6261 645f 7069 7865 6c73 5b69 5d0a  = bad_pixels[i].
+00006a70: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00006a80: 6261 645f 7069 7820 3d3d 2030 3a0a 2020  bad_pix == 0:.  
+00006a90: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+00006aa0: 6861 6e64 6c65 2074 6865 206c 6566 7420  handle the left 
+00006ab0: 6564 6765 0a20 2020 2020 2020 2020 2020  edge.           
+00006ac0: 2020 2020 206e 6578 745f 676f 6f64 203d       next_good =
+00006ad0: 2062 6164 5f70 6978 202b 2031 0a20 2020   bad_pix + 1.   
+00006ae0: 2020 2020 2020 2020 2020 2020 2077 6869               whi
+00006af0: 6c65 206e 6578 745f 676f 6f64 2069 6e20  le next_good in 
+00006b00: 6261 645f 7069 7865 6c73 2061 6e64 206e  bad_pixels and n
+00006b10: 6578 745f 676f 6f64 203c 2070 6978 656c  ext_good < pixel
+00006b20: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
+00006b30: 2020 2020 2020 206e 6578 745f 676f 6f64         next_good
+00006b40: 202b 3d20 310a 2020 2020 2020 2020 2020   += 1.          
+00006b50: 2020 2020 2020 2020 2020 6920 2b3d 2031            i += 1
+00006b60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006b70: 2069 6620 6e65 7874 5f67 6f6f 6420 3c20   if next_good < 
+00006b80: 7069 7865 6c73 3a0a 2020 2020 2020 2020  pixels:.        
+00006b90: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+00006ba0: 6a20 696e 2072 616e 6765 286e 6578 745f  j in range(next_
+00006bb0: 676f 6f64 293a 0a20 2020 2020 2020 2020  good):.         
+00006bc0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00006bd0: 7065 6374 7275 6d5b 6a5d 203d 2073 7065  pectrum[j] = spe
+00006be0: 6374 7275 6d5b 6e65 7874 5f67 6f6f 645d  ctrum[next_good]
+00006bf0: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
+00006c00: 653a 0a0a 2020 2020 2020 2020 2020 2020  e:..            
+00006c10: 2020 2020 2320 6669 6e64 2070 7265 7669      # find previ
+00006c20: 6f75 7320 676f 6f64 2070 6978 656c 0a20  ous good pixel. 
+00006c30: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+00006c40: 7265 765f 676f 6f64 203d 2062 6164 5f70  rev_good = bad_p
+00006c50: 6978 202d 2031 0a20 2020 2020 2020 2020  ix - 1.         
+00006c60: 2020 2020 2020 2077 6869 6c65 2070 7265         while pre
+00006c70: 765f 676f 6f64 2069 6e20 6261 645f 7069  v_good in bad_pi
+00006c80: 7865 6c73 2061 6e64 2070 7265 765f 676f  xels and prev_go
+00006c90: 6f64 203e 3d20 303a 0a20 2020 2020 2020  od >= 0:.       
+00006ca0: 2020 2020 2020 2020 2020 2020 2070 7265               pre
+00006cb0: 765f 676f 6f64 202d 3d20 310a 0a20 2020  v_good -= 1..   
+00006cc0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00006cd0: 7072 6576 5f67 6f6f 6420 3e3d 2030 3a0a  prev_good >= 0:.
+00006ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006cf0: 2020 2020 2320 6669 6e64 206e 6578 7420      # find next 
+00006d00: 676f 6f64 2070 6978 656c 0a20 2020 2020  good pixel.     
+00006d10: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+00006d20: 6578 745f 676f 6f64 203d 2062 6164 5f70  ext_good = bad_p
+00006d30: 6978 202b 2031 0a20 2020 2020 2020 2020  ix + 1.         
+00006d40: 2020 2020 2020 2020 2020 2077 6869 6c65             while
+00006d50: 206e 6578 745f 676f 6f64 2069 6e20 6261   next_good in ba
+00006d60: 645f 7069 7865 6c73 2061 6e64 206e 6578  d_pixels and nex
+00006d70: 745f 676f 6f64 203c 2070 6978 656c 733a  t_good < pixels:
+00006d80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006d90: 2020 2020 2020 2020 206e 6578 745f 676f           next_go
+00006da0: 6f64 202b 3d20 310a 2020 2020 2020 2020  od += 1.        
+00006db0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006dc0: 6920 2b3d 2031 0a0a 2020 2020 2020 2020  i += 1..        
+00006dd0: 2020 2020 2020 2020 2020 2020 6966 206e              if n
+00006de0: 6578 745f 676f 6f64 203c 2070 6978 656c  ext_good < pixel
+00006df0: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
+00006e00: 2020 2020 2020 2020 2020 2023 2066 6f72             # for
+00006e10: 206e 6f77 2c20 6472 6177 2061 206c 696e   now, draw a lin
+00006e20: 6520 6265 7477 6565 6e20 7072 6576 696f  e between previo
+00006e30: 7573 2061 6e64 206e 6578 745f 676f 6f64  us and next_good
+00006e40: 2070 6978 656c 730a 2020 2020 2020 2020   pixels.        
+00006e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006e60: 2320 544f 444f 3a20 636f 6e73 6964 6572  # TODO: consider
+00006e70: 2073 6f6d 6520 6b69 6e64 206f 6620 6375   some kind of cu
+00006e80: 7276 652d 6669 740a 2020 2020 2020 2020  rve-fit.        
+00006e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006ea0: 6465 6c74 6120 3d20 666c 6f61 7428 7370  delta = float(sp
+00006eb0: 6563 7472 756d 5b6e 6578 745f 676f 6f64  ectrum[next_good
+00006ec0: 5d20 2d20 7370 6563 7472 756d 5b70 7265  ] - spectrum[pre
+00006ed0: 765f 676f 6f64 5d29 0a20 2020 2020 2020  v_good]).       
+00006ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006ef0: 2072 6e67 2020 203d 206e 6578 745f 676f   rng   = next_go
+00006f00: 6f64 202d 2070 7265 765f 676f 6f64 200a  od - prev_good .
+00006f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006f20: 2020 2020 2020 2020 7374 6570 2020 3d20          step  = 
+00006f30: 6465 6c74 6120 2f20 726e 670a 2020 2020  delta / rng.    
+00006f40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006f50: 2020 2020 2320 6c6f 672e 6465 6275 6728      # log.debug(
+00006f60: 6622 636f 7272 6563 745f 6261 645f 7069  f"correct_bad_pi
+00006f70: 7865 6c73 3a20 6261 645f 7069 7820 7b62  xels: bad_pix {b
+00006f80: 6164 5f70 6978 7d2c 2070 7265 765f 676f  ad_pix}, prev_go
+00006f90: 6f64 207b 7072 6576 5f67 6f6f 647d 2028  od {prev_good} (
+00006fa0: 7b73 7065 6374 7275 6d5b 7072 6576 5f67  {spectrum[prev_g
+00006fb0: 6f6f 645d 7d29 2c20 6e65 7874 5f67 6f6f  ood]}), next_goo
+00006fc0: 6420 7b6e 6578 745f 676f 6f64 7d20 287b  d {next_good} ({
+00006fd0: 7370 6563 7472 756d 5b6e 6578 745f 676f  spectrum[next_go
+00006fe0: 6f64 5d7d 292c 2064 656c 7461 207b 6465  od]}), delta {de
+00006ff0: 6c74 613a 2e32 667d 2c20 726e 6720 7b72  lta:.2f}, rng {r
+00007000: 6e67 7d2c 2073 7465 7020 7b73 7465 703a  ng}, step {step:
+00007010: 2e32 667d 2229 0a20 2020 2020 2020 2020  .2f}").         
+00007020: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00007030: 6f72 206a 2069 6e20 7261 6e67 6528 726e  or j in range(rn
+00007040: 6720 2d20 3129 3a0a 2020 2020 2020 2020  g - 1):.        
+00007050: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007060: 2020 2020 6e65 7720 3d20 7370 6563 7472      new = spectr
+00007070: 756d 5b70 7265 765f 676f 6f64 5d20 2b20  um[prev_good] + 
+00007080: 7374 6570 202a 2028 6a20 2b20 3129 0a20  step * (j + 1). 
+00007090: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000070a0: 2020 2020 2020 2020 2020 2073 7065 6374             spect
+000070b0: 7275 6d5b 7072 6576 5f67 6f6f 6420 2b20  rum[prev_good + 
+000070c0: 6a20 2b20 315d 203d 206e 6577 0a20 2020  j + 1] = new.   
+000070d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000070e0: 2020 2020 2020 2020 2023 206c 6f67 2e64           # log.d
+000070f0: 6562 7567 2866 2263 6f72 7265 6374 5f62  ebug(f"correct_b
+00007100: 6164 5f70 6978 656c 733a 2073 746f 6d70  ad_pixels: stomp
+00007110: 696e 6720 7069 7820 7b70 7265 765f 676f  ing pix {prev_go
+00007120: 6f64 202b 206a 202b 2031 7d20 7769 7468  od + j + 1} with
+00007130: 207b 6e65 777d 2229 0a20 2020 2020 2020   {new}").       
+00007140: 2020 2020 2020 2020 2020 2020 2065 6c73               els
+00007150: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00007160: 2020 2020 2020 2020 2020 2023 2077 6520             # we 
+00007170: 7261 6e20 6f66 6620 7468 6520 6869 6768  ran off the high
+00007180: 2065 6e64 2c20 736f 2063 6f70 792d 7269   end, so copy-ri
+00007190: 6768 740a 2020 2020 2020 2020 2020 2020  ght.            
+000071a0: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+000071b0: 6a20 696e 2072 616e 6765 2862 6164 5f70  j in range(bad_p
+000071c0: 6978 2c20 7069 7865 6c73 293a 0a20 2020  ix, pixels):.   
+000071d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000071e0: 2020 2020 2020 2020 2073 7065 6374 7275           spectru
+000071f0: 6d5b 6a5d 203d 2073 7065 6374 7275 6d5b  m[j] = spectrum[
+00007200: 7072 6576 5f67 6f6f 645d 0a0a 2020 2020  prev_good]..    
+00007210: 2020 2020 2020 2020 2320 6164 7661 6e63          # advanc
+00007220: 6520 746f 206e 6578 7420 6261 6420 7069  e to next bad pi
+00007230: 7865 6c0a 2020 2020 2020 2020 2020 2020  xel.            
+00007240: 6920 2b3d 2031 0a20 2020 2020 2020 2072  i += 1.        r
+00007250: 6574 7572 6e20 5472 7565 0a0a 2020 2020  eturn True..    
+00007260: 6465 6620 5f73 656e 645f 636f 6465 2873  def _send_code(s
+00007270: 656c 662c 200a 2020 2020 2020 2020 2020  elf, .          
+00007280: 2020 2020 2020 2020 6252 6571 7565 7374          bRequest
+00007290: 3a20 696e 742c 200a 2020 2020 2020 2020  : int, .        
+000072a0: 2020 2020 2020 2020 2020 7756 616c 7565            wValue
+000072b0: 3a20 696e 7420 3d20 302c 200a 2020 2020  : int = 0, .    
+000072c0: 2020 2020 2020 2020 2020 2020 2020 7749                wI
+000072d0: 6e64 6578 3a20 696e 7420 3d20 302c 200a  ndex: int = 0, .
+000072e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000072f0: 2020 6461 7461 5f6f 725f 774c 656e 6774    data_or_wLengt
+00007300: 683a 2069 6e74 203d 204e 6f6e 652c 200a  h: int = None, .
+00007310: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007320: 2020 6c61 6265 6c3a 2073 7472 203d 2022    label: str = "
+00007330: 222c 200a 2020 2020 2020 2020 2020 2020  ", .            
+00007340: 2020 2020 2020 6472 795f 7275 6e3a 2062        dry_run: b
+00007350: 6f6f 6c20 3d20 4661 6c73 652c 200a 2020  ool = False, .  
+00007360: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007370: 7265 7472 795f 6f6e 5f65 7272 6f72 3a20  retry_on_error: 
+00007380: 626f 6f6c 203d 2046 616c 7365 2c20 0a20  bool = False, . 
+00007390: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000073a0: 2073 7563 6365 7373 5f72 6573 756c 743a   success_result:
+000073b0: 2069 6e74 203d 2030 7830 3029 202d 3e20   int = 0x00) -> 
+000073c0: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
+000073d0: 6f6e 7365 3a0a 2020 2020 2020 2020 6966  onse:.        if
+000073e0: 2073 656c 662e 7368 7574 646f 776e 5f72   self.shutdown_r
+000073f0: 6571 7565 7374 6564 206f 7220 286e 6f74  equested or (not
+00007400: 2073 656c 662e 636f 6e6e 6563 7465 6420   self.connected 
+00007410: 616e 6420 6e6f 7420 7365 6c66 2e63 6f6e  and not self.con
+00007420: 6e65 6374 696e 6729 3a0a 2020 2020 2020  necting):.      
+00007430: 2020 2020 2020 6c6f 672e 6465 6275 6728        log.debug(
+00007440: 225f 7365 6e64 5f63 6f64 653a 206e 6f74  "_send_code: not
+00007450: 2061 7474 656d 7074 696e 6720 6265 6361   attempting beca
+00007460: 7573 6520 6e6f 7420 636f 6e6e 6563 7465  use not connecte
+00007470: 6422 290a 2020 2020 2020 2020 2020 2020  d").            
+00007480: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
+00007490: 7465 7252 6573 706f 6e73 6528 4661 6c73  terResponse(Fals
+000074a0: 6529 0a0a 2020 2020 2020 2020 7072 6566  e)..        pref
+000074b0: 6978 203d 2022 2220 6966 206e 6f74 206c  ix = "" if not l
+000074c0: 6162 656c 2065 6c73 6520 2822 2573 3a20  abel else ("%s: 
+000074d0: 2220 2520 6c61 6265 6c29 0a20 2020 2020  " % label).     
+000074e0: 2020 2072 6573 756c 7420 3d20 4e6f 6e65     result = None
+000074f0: 0a0a 2020 2020 2020 2020 6966 2064 6174  ..        if dat
+00007500: 615f 6f72 5f77 4c65 6e67 7468 2069 7320  a_or_wLength is 
+00007510: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+00007520: 2020 6966 2073 656c 662e 7365 7474 696e    if self.settin
+00007530: 6773 2e69 735f 6172 6d28 293a 0a20 2020  gs.is_arm():.   
+00007540: 2020 2020 2020 2020 2020 2020 2064 6174               dat
+00007550: 615f 6f72 5f77 4c65 6e67 7468 203d 205b  a_or_wLength = [
+00007560: 305d 202a 2038 0a20 2020 2020 2020 2020  0] * 8.         
+00007570: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
 00007580: 2020 2020 2020 2020 2064 6174 615f 6f72           data_or
-00007590: 5f77 4c65 6e67 7468 2920 2320 6164 6420  _wLength) # add 
-000075a0: 5449 4d45 4f55 545f 4d53 2070 6172 616d  TIMEOUT_MS param
-000075b0: 6574 6572 3f0d 0a20 2020 2020 2020 2020  eter?..         
-000075c0: 2020 2065 7863 6570 7420 4578 6365 7074     except Except
-000075d0: 696f 6e20 6173 2065 7863 3a0d 0a20 2020  ion as exc:..   
-000075e0: 2020 2020 2020 2020 2020 2020 206c 6f67               log
-000075f0: 2e63 7269 7469 6361 6c28 2248 6172 6477  .critical("Hardw
-00007600: 6172 6520 4661 696c 7572 6520 4649 4420  are Failure FID 
-00007610: 5365 6e64 2043 6f64 6520 5072 6f62 6c65  Send Code Proble
-00007620: 6d20 7769 7468 2063 7472 6c20 7472 616e  m with ctrl tran
-00007630: 7366 6572 222c 2065 7863 5f69 6e66 6f3d  sfer", exc_info=
-00007640: 3129 0d0a 2020 2020 2020 2020 2020 2020  1)..            
-00007650: 2020 2020 7365 6c66 2e5f 7363 6865 6475      self._schedu
-00007660: 6c65 5f64 6973 636f 6e6e 6563 7428 6578  le_disconnect(ex
-00007670: 6329 0d0a 2020 2020 2020 2020 2020 2020  c)..            
-00007680: 2020 2020 7265 7475 726e 2053 7065 6374      return Spect
-00007690: 726f 6d65 7465 7252 6573 706f 6e73 6528  rometerResponse(
-000076a0: 706f 6973 6f6e 5f70 696c 6c3d 5472 7565  poison_pill=True
-000076b0: 290d 0a0d 0a20 2020 2020 2020 2020 2020  )....           
-000076c0: 206c 6f67 2e64 6562 7567 2822 2573 5f73   log.debug("%s_s
-000076d0: 656e 645f 636f 6465 3a20 7265 7175 6573  end_code: reques
-000076e0: 7420 3078 2530 3278 2076 616c 7565 2030  t 0x%02x value 0
-000076f0: 7825 3034 7820 696e 6465 7820 3078 2530  x%04x index 0x%0
-00007700: 3478 2064 6174 612f 6c65 6e20 2573 3a20  4x data/len %s: 
-00007710: 7265 7375 6c74 2025 7322 2c0d 0a20 2020  result %s",..   
-00007720: 2020 2020 2020 2020 2020 2020 2070 7265               pre
-00007730: 6669 782c 2062 5265 7175 6573 742c 2077  fix, bRequest, w
-00007740: 5661 6c75 652c 2077 496e 6465 782c 2064  Value, wIndex, d
-00007750: 6174 615f 6f72 5f77 4c65 6e67 7468 2c20  ata_or_wLength, 
-00007760: 7265 7375 6c74 290d 0a0d 0a20 2020 2020  result)....     
-00007770: 2020 2020 2020 2069 6620 6e6f 7420 7265         if not re
-00007780: 7472 795f 6f6e 5f65 7272 6f72 3a0d 0a20  try_on_error:.. 
-00007790: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-000077a0: 6574 7572 6e20 5370 6563 7472 6f6d 6574  eturn Spectromet
-000077b0: 6572 5265 7370 6f6e 7365 286b 6565 705f  erResponse(keep_
-000077c0: 616c 6976 653d 5472 7565 290d 0a0d 0a20  alive=True).... 
-000077d0: 2020 2020 2020 2020 2020 2023 2072 6574             # ret
-000077e0: 7279 206c 6f67 6963 2065 6e61 626c 6564  ry logic enabled
-000077f0: 2c20 736f 2063 6f6d 7061 7265 2072 6573  , so compare res
-00007800: 756c 7420 746f 2065 7870 6563 7465 640d  ult to expected.
-00007810: 0a20 2020 2020 2020 2020 2020 206d 6174  .            mat
-00007820: 6368 6564 5f65 7870 6563 7465 6420 3d20  ched_expected = 
-00007830: 5472 7565 0d0a 2020 2020 2020 2020 2020  True..          
-00007840: 2020 6966 206c 656e 2873 7563 6365 7373    if len(success
-00007850: 5f72 6573 756c 7429 203c 206c 656e 2872  _result) < len(r
-00007860: 6573 756c 7429 3a0d 0a20 2020 2020 2020  esult):..       
-00007870: 2020 2020 2020 2020 206d 6174 6368 6564           matched
-00007880: 5f65 7870 6563 7465 6420 3d20 4661 6c73  _expected = Fals
-00007890: 650d 0a20 2020 2020 2020 2020 2020 2065  e..            e
-000078a0: 6c73 653a 0d0a 2020 2020 2020 2020 2020  lse:..          
-000078b0: 2020 2020 2020 666f 7220 6920 696e 2072        for i in r
-000078c0: 616e 6765 286c 656e 2873 7563 6365 7373  ange(len(success
-000078d0: 5f72 6573 756c 7429 293a 0d0a 2020 2020  _result)):..    
-000078e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000078f0: 6966 2072 6573 756c 745b 695d 2021 3d20  if result[i] != 
-00007900: 7375 6363 6573 735f 7265 7375 6c74 5b69  success_result[i
-00007910: 5d3a 0d0a 2020 2020 2020 2020 2020 2020  ]:..            
-00007920: 2020 2020 2020 2020 2020 2020 6d61 7463              matc
-00007930: 6865 645f 6578 7065 6374 6564 203d 2046  hed_expected = F
-00007940: 616c 7365 0d0a 2020 2020 2020 2020 2020  alse..          
-00007950: 2020 2020 2020 2020 2020 2020 2020 6272                br
-00007960: 6561 6b0d 0a0d 0a20 2020 2020 2020 2020  eak....         
-00007970: 2020 2069 6620 6d61 7463 6865 645f 6578     if matched_ex
-00007980: 7065 6374 6564 3a0d 0a20 2020 2020 2020  pected:..       
-00007990: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-000079a0: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
-000079b0: 6f6e 7365 286b 6565 705f 616c 6976 653d  onse(keep_alive=
-000079c0: 5472 7565 290d 0a0d 0a20 2020 2020 2020  True)....       
-000079d0: 2020 2020 2023 2061 7070 6172 656e 746c       # apparentl
-000079e0: 7920 6974 2064 6964 6e27 7420 6d61 7463  y it didn't matc
-000079f0: 6820 6578 7065 6374 6564 0d0a 2020 2020  h expected..    
-00007a00: 2020 2020 2020 2020 7265 7472 795f 636f          retry_co
-00007a10: 756e 7420 2b3d 2031 0d0a 2020 2020 2020  unt += 1..      
-00007a20: 2020 2020 2020 6966 2072 6574 7279 5f63        if retry_c
-00007a30: 6f75 6e74 203e 2073 656c 662e 7265 7472  ount > self.retr
-00007a40: 795f 6d61 783a 0d0a 2020 2020 2020 2020  y_max:..        
-00007a50: 2020 2020 2020 2020 6c6f 672e 6572 726f          log.erro
-00007a60: 7228 2267 6976 696e 6720 7570 2061 6674  r("giving up aft
-00007a70: 6572 2025 6420 7265 7472 6965 7322 2c20  er %d retries", 
-00007a80: 7265 7472 795f 636f 756e 7429 0d0a 2020  retry_count)..  
-00007a90: 2020 2020 2020 2020 2020 2020 2020 7265                re
-00007aa0: 7475 726e 2053 7065 6374 726f 6d65 7465  turn Spectromete
-00007ab0: 7252 6573 706f 6e73 6528 706f 6973 6f6e  rResponse(poison
-00007ac0: 5f70 696c 6c3d 5472 7565 290d 0a0d 0a20  _pill=True).... 
-00007ad0: 2020 2020 2020 2020 2020 2023 2074 7279             # try
-00007ae0: 2061 6761 696e 0d0a 2020 2020 2020 2020   again..        
-00007af0: 2020 2020 6c6f 672e 6572 726f 7228 2272      log.error("r
-00007b00: 6574 7279 696e 6720 2861 7474 656d 7074  etrying (attempt
-00007b10: 2025 6429 222c 2072 6574 7279 5f63 6f75   %d)", retry_cou
-00007b20: 6e74 202b 2031 290d 0a0d 0a20 2020 2023  nt + 1)....    #
-00007b30: 2320 406e 6f74 6520 7765 6972 6420 7468  # @note weird th
-00007b40: 6174 2073 6f20 6665 7720 6361 6c6c 7320  at so few calls 
-00007b50: 746f 2074 6869 7320 6675 6e63 7469 6f6e  to this function
-00007b60: 206f 7665 7272 6964 6520 7468 6520 6465   override the de
-00007b70: 6661 756c 7420 774c 656e 6774 680d 0a20  fault wLength.. 
-00007b80: 2020 2023 2040 746f 646f 2063 6f6e 7369     # @todo consi
-00007b90: 6465 7220 6164 6469 6e67 2072 6574 7279  der adding retry
-00007ba0: 206c 6f67 6963 2061 7320 7765 6c6c 0d0a   logic as well..
-00007bb0: 2020 2020 6465 6620 5f67 6574 5f63 6f64      def _get_cod
-00007bc0: 6528 7365 6c66 2c20 0d0a 2020 2020 2020  e(self, ..      
-00007bd0: 2020 2020 2020 2020 2020 2020 6252 6571              bReq
-00007be0: 7565 7374 3a20 696e 742c 200d 0a20 2020  uest: int, ..   
-00007bf0: 2020 2020 2020 2020 2020 2020 2020 2077                 w
-00007c00: 5661 6c75 653a 2069 6e74 203d 2030 2c20  Value: int = 0, 
-00007c10: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00007c20: 2020 2020 7749 6e64 6578 3a20 696e 7420      wIndex: int 
-00007c30: 3d20 302c 200d 0a20 2020 2020 2020 2020  = 0, ..         
-00007c40: 2020 2020 2020 2020 2077 4c65 6e67 7468           wLength
-00007c50: 3a20 696e 7420 3d20 3634 2c20 0d0a 2020  : int = 64, ..  
-00007c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007c70: 6c61 6265 6c3a 2073 7472 203d 2022 222c  label: str = "",
-00007c80: 200d 0a20 2020 2020 2020 2020 2020 2020   ..             
-00007c90: 2020 2020 206d 7362 5f6c 656e 3a20 696e       msb_len: in
-00007ca0: 7420 3d20 4e6f 6e65 2c20 0d0a 2020 2020  t = None, ..    
-00007cb0: 2020 2020 2020 2020 2020 2020 2020 6c73                ls
-00007cc0: 625f 6c65 6e3a 2069 6e74 203d 204e 6f6e  b_len: int = Non
-00007cd0: 6529 202d 3e20 5370 6563 7472 6f6d 6574  e) -> Spectromet
-00007ce0: 6572 5265 7370 6f6e 7365 3a0d 0a20 2020  erResponse:..   
-00007cf0: 2020 2020 2070 7265 6669 7820 3d20 2222       prefix = ""
-00007d00: 2069 6620 6e6f 7420 6c61 6265 6c20 656c   if not label el
-00007d10: 7365 2028 2225 733a 2022 2025 206c 6162  se ("%s: " % lab
-00007d20: 656c 290d 0a20 2020 2020 2020 2072 6573  el)..        res
-00007d30: 756c 7420 3d20 4e6f 6e65 0d0a 0d0a 2020  ult = None....  
-00007d40: 2020 2020 2020 6966 2073 656c 662e 7368        if self.sh
-00007d50: 7574 646f 776e 5f72 6571 7565 7374 6564  utdown_requested
-00007d60: 206f 7220 286e 6f74 2073 656c 662e 636f   or (not self.co
-00007d70: 6e6e 6563 7465 6420 616e 6420 6e6f 7420  nnected and not 
-00007d80: 7365 6c66 2e63 6f6e 6e65 6374 696e 6729  self.connecting)
-00007d90: 3a0d 0a20 2020 2020 2020 2020 2020 206c  :..            l
-00007da0: 6f67 2e64 6562 7567 2822 5f67 6574 5f63  og.debug("_get_c
-00007db0: 6f64 653a 206e 6f74 2061 7474 656d 7074  ode: not attempt
-00007dc0: 696e 6720 6265 6361 7573 6520 6e6f 7420  ing because not 
-00007dd0: 636f 6e6e 6563 7465 6422 290d 0a20 2020  connected")..   
-00007de0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00007df0: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
-00007e00: 6f6e 7365 2829 0d0a 0d0a 2020 2020 2020  onse()....      
-00007e10: 2020 6966 2073 656c 662e 5f63 6865 636b    if self._check
-00007e20: 5f66 6f72 5f72 616e 646f 6d5f 6572 726f  _for_random_erro
-00007e30: 7228 293a 0d0a 2020 2020 2020 2020 2020  r():..          
-00007e40: 2020 6c6f 672e 6465 6275 6728 2272 616e    log.debug("ran
-00007e50: 646f 6d20 6572 726f 7222 290d 0a20 2020  dom error")..   
-00007e60: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00007e70: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
-00007e80: 6f6e 7365 2870 6f69 736f 6e5f 7069 6c6c  onse(poison_pill
-00007e90: 3d54 7275 6529 0d0a 0d0a 2020 2020 2020  =True)....      
-00007ea0: 2020 7472 793a 0d0a 2020 2020 2020 2020    try:..        
-00007eb0: 2020 2020 7365 6c66 2e5f 7761 6974 5f66      self._wait_f
-00007ec0: 6f72 5f75 7362 5f61 7661 696c 6162 6c65  or_usb_available
-00007ed0: 2829 0d0a 2020 2020 2020 2020 2020 2020  ()..            
-00007ee0: 7265 7375 6c74 203d 2073 656c 662e 6465  result = self.de
-00007ef0: 7669 6365 5f74 7970 652e 6374 726c 5f74  vice_type.ctrl_t
-00007f00: 7261 6e73 6665 7228 7365 6c66 2e64 6576  ransfer(self.dev
-00007f10: 6963 652c 0d0a 2020 2020 2020 2020 2020  ice,..          
-00007f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007f40: 2020 2020 2030 7863 302c 2020 2020 2020       0xc0,      
-00007f50: 2020 2320 4445 5649 4345 5f54 4f5f 484f    # DEVICE_TO_HO
-00007f60: 5354 0d0a 2020 2020 2020 2020 2020 2020  ST..            
-00007f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007590: 5f77 4c65 6e67 7468 203d 2030 0a0a 2020  _wLength = 0..  
+000075a0: 2020 2020 2020 6c6f 672e 6465 6275 6728        log.debug(
+000075b0: 2225 735f 7365 6e64 5f63 6f64 653a 2072  "%s_send_code: r
+000075c0: 6571 7565 7374 2030 7825 3032 7820 7661  equest 0x%02x va
+000075d0: 6c75 6520 3078 2530 3478 2069 6e64 6578  lue 0x%04x index
+000075e0: 2030 7825 3034 7820 6461 7461 2f6c 656e   0x%04x data/len
+000075f0: 2025 7322 2c0a 2020 2020 2020 2020 2020   %s",.          
+00007600: 2020 7072 6566 6978 2c20 6252 6571 7565    prefix, bReque
+00007610: 7374 2c20 7756 616c 7565 2c20 7749 6e64  st, wValue, wInd
+00007620: 6578 2c20 6461 7461 5f6f 725f 774c 656e  ex, data_or_wLen
+00007630: 6774 6829 0a0a 2020 2020 2020 2020 6966  gth)..        if
+00007640: 2064 7279 5f72 756e 3a0a 2020 2020 2020   dry_run:.      
+00007650: 2020 2020 2020 7265 7475 726e 2053 7065        return Spe
+00007660: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
+00007670: 6528 6b65 6570 5f61 6c69 7665 3d54 7275  e(keep_alive=Tru
+00007680: 6529 0a0a 2020 2020 2020 2020 6966 2073  e)..        if s
+00007690: 656c 662e 5f63 6865 636b 5f66 6f72 5f72  elf._check_for_r
+000076a0: 616e 646f 6d5f 6572 726f 7228 293a 0a20  andom_error():. 
+000076b0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+000076c0: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
+000076d0: 7370 6f6e 7365 2870 6f69 736f 6e5f 7069  sponse(poison_pi
+000076e0: 6c6c 3d46 616c 7365 290a 0a20 2020 2020  ll=False)..     
+000076f0: 2020 2072 6574 7279 5f63 6f75 6e74 203d     retry_count =
+00007700: 2030 0a20 2020 2020 2020 2077 6869 6c65   0.        while
+00007710: 2054 7275 653a 0a20 2020 2020 2020 2020   True:.         
+00007720: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
+00007730: 2020 2020 2020 2020 7365 6c66 2e5f 7761          self._wa
+00007740: 6974 5f66 6f72 5f75 7362 5f61 7661 696c  it_for_usb_avail
+00007750: 6162 6c65 2829 0a20 2020 2020 2020 2020  able().         
+00007760: 2020 2020 2020 2072 6573 756c 7420 3d20         result = 
+00007770: 7365 6c66 2e64 6576 6963 655f 7479 7065  self.device_type
+00007780: 2e63 7472 6c5f 7472 616e 7366 6572 2873  .ctrl_transfer(s
+00007790: 656c 662e 6465 7669 6365 2c0a 2020 2020  elf.device,.    
+000077a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000077b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000077c0: 2020 2020 2020 2020 2020 2020 2020 2030                 0
+000077d0: 7834 302c 2020 2020 2020 2020 2320 484f  x40,        # HO
+000077e0: 5354 5f54 4f5f 4445 5649 4345 0a20 2020  ST_TO_DEVICE.   
+000077f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007800: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007810: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007820: 6252 6571 7565 7374 2c0a 2020 2020 2020  bRequest,.      
+00007830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007840: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007850: 2020 2020 2020 2020 2020 2020 2077 5661               wVa
+00007860: 6c75 652c 0a20 2020 2020 2020 2020 2020  lue,.           
+00007870: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007880: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007890: 2020 2020 2020 2020 7749 6e64 6578 2c0a          wIndex,.
+000078a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000078b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000078c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000078d0: 2020 2064 6174 615f 6f72 5f77 4c65 6e67     data_or_wLeng
+000078e0: 7468 2920 2320 6164 6420 5449 4d45 4f55  th) # add TIMEOU
+000078f0: 545f 4d53 2070 6172 616d 6574 6572 3f0a  T_MS parameter?.
+00007900: 2020 2020 2020 2020 2020 2020 6578 6365              exce
+00007910: 7074 2045 7863 6570 7469 6f6e 2061 7320  pt Exception as 
+00007920: 6578 633a 0a20 2020 2020 2020 2020 2020  exc:.           
+00007930: 2020 2020 206c 6f67 2e63 7269 7469 6361       log.critica
+00007940: 6c28 2248 6172 6477 6172 6520 4661 696c  l("Hardware Fail
+00007950: 7572 6520 4649 4420 5365 6e64 2043 6f64  ure FID Send Cod
+00007960: 6520 5072 6f62 6c65 6d20 7769 7468 2063  e Problem with c
+00007970: 7472 6c20 7472 616e 7366 6572 222c 2065  trl transfer", e
+00007980: 7863 5f69 6e66 6f3d 3129 0a20 2020 2020  xc_info=1).     
+00007990: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+000079a0: 5f73 6368 6564 756c 655f 6469 7363 6f6e  _schedule_discon
+000079b0: 6e65 6374 2865 7863 290a 2020 2020 2020  nect(exc).      
+000079c0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+000079d0: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
+000079e0: 706f 6e73 6528 706f 6973 6f6e 5f70 696c  ponse(poison_pil
+000079f0: 6c3d 5472 7565 290a 0a20 2020 2020 2020  l=True)..       
+00007a00: 2020 2020 206c 6f67 2e64 6562 7567 2822       log.debug("
+00007a10: 2573 5f73 656e 645f 636f 6465 3a20 7265  %s_send_code: re
+00007a20: 7175 6573 7420 3078 2530 3278 2076 616c  quest 0x%02x val
+00007a30: 7565 2030 7825 3034 7820 696e 6465 7820  ue 0x%04x index 
+00007a40: 3078 2530 3478 2064 6174 612f 6c65 6e20  0x%04x data/len 
+00007a50: 2573 3a20 7265 7375 6c74 2025 7322 2c0a  %s: result %s",.
+00007a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007a70: 7072 6566 6978 2c20 6252 6571 7565 7374  prefix, bRequest
+00007a80: 2c20 7756 616c 7565 2c20 7749 6e64 6578  , wValue, wIndex
+00007a90: 2c20 6461 7461 5f6f 725f 774c 656e 6774  , data_or_wLengt
+00007aa0: 682c 2072 6573 756c 7429 0a0a 2020 2020  h, result)..    
+00007ab0: 2020 2020 2020 2020 6966 206e 6f74 2072          if not r
+00007ac0: 6574 7279 5f6f 6e5f 6572 726f 723a 0a20  etry_on_error:. 
+00007ad0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00007ae0: 6574 7572 6e20 5370 6563 7472 6f6d 6574  eturn Spectromet
+00007af0: 6572 5265 7370 6f6e 7365 286b 6565 705f  erResponse(keep_
+00007b00: 616c 6976 653d 5472 7565 290a 0a20 2020  alive=True)..   
+00007b10: 2020 2020 2020 2020 2023 2072 6574 7279           # retry
+00007b20: 206c 6f67 6963 2065 6e61 626c 6564 2c20   logic enabled, 
+00007b30: 736f 2063 6f6d 7061 7265 2072 6573 756c  so compare resul
+00007b40: 7420 746f 2065 7870 6563 7465 640a 2020  t to expected.  
+00007b50: 2020 2020 2020 2020 2020 6d61 7463 6865            matche
+00007b60: 645f 6578 7065 6374 6564 203d 2054 7275  d_expected = Tru
+00007b70: 650a 2020 2020 2020 2020 2020 2020 6966  e.            if
+00007b80: 206c 656e 2873 7563 6365 7373 5f72 6573   len(success_res
+00007b90: 756c 7429 203c 206c 656e 2872 6573 756c  ult) < len(resul
+00007ba0: 7429 3a0a 2020 2020 2020 2020 2020 2020  t):.            
+00007bb0: 2020 2020 6d61 7463 6865 645f 6578 7065      matched_expe
+00007bc0: 6374 6564 203d 2046 616c 7365 0a20 2020  cted = False.   
+00007bd0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+00007be0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00007bf0: 6f72 2069 2069 6e20 7261 6e67 6528 6c65  or i in range(le
+00007c00: 6e28 7375 6363 6573 735f 7265 7375 6c74  n(success_result
+00007c10: 2929 3a0a 2020 2020 2020 2020 2020 2020  )):.            
+00007c20: 2020 2020 2020 2020 6966 2072 6573 756c          if resul
+00007c30: 745b 695d 2021 3d20 7375 6363 6573 735f  t[i] != success_
+00007c40: 7265 7375 6c74 5b69 5d3a 0a20 2020 2020  result[i]:.     
+00007c50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007c60: 2020 206d 6174 6368 6564 5f65 7870 6563     matched_expec
+00007c70: 7465 6420 3d20 4661 6c73 650a 2020 2020  ted = False.    
+00007c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007c90: 2020 2020 6272 6561 6b0a 0a20 2020 2020      break..     
+00007ca0: 2020 2020 2020 2069 6620 6d61 7463 6865         if matche
+00007cb0: 645f 6578 7065 6374 6564 3a0a 2020 2020  d_expected:.    
+00007cc0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00007cd0: 726e 2053 7065 6374 726f 6d65 7465 7252  rn SpectrometerR
+00007ce0: 6573 706f 6e73 6528 6b65 6570 5f61 6c69  esponse(keep_ali
+00007cf0: 7665 3d54 7275 6529 0a0a 2020 2020 2020  ve=True)..      
+00007d00: 2020 2020 2020 2320 6170 7061 7265 6e74        # apparent
+00007d10: 6c79 2069 7420 6469 646e 2774 206d 6174  ly it didn't mat
+00007d20: 6368 2065 7870 6563 7465 640a 2020 2020  ch expected.    
+00007d30: 2020 2020 2020 2020 7265 7472 795f 636f          retry_co
+00007d40: 756e 7420 2b3d 2031 0a20 2020 2020 2020  unt += 1.       
+00007d50: 2020 2020 2069 6620 7265 7472 795f 636f       if retry_co
+00007d60: 756e 7420 3e20 7365 6c66 2e72 6574 7279  unt > self.retry
+00007d70: 5f6d 6178 3a0a 2020 2020 2020 2020 2020  _max:.          
+00007d80: 2020 2020 2020 6c6f 672e 6572 726f 7228        log.error(
+00007d90: 2267 6976 696e 6720 7570 2061 6674 6572  "giving up after
+00007da0: 2025 6420 7265 7472 6965 7322 2c20 7265   %d retries", re
+00007db0: 7472 795f 636f 756e 7429 0a20 2020 2020  try_count).     
+00007dc0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00007dd0: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
+00007de0: 7370 6f6e 7365 2870 6f69 736f 6e5f 7069  sponse(poison_pi
+00007df0: 6c6c 3d54 7275 6529 0a0a 2020 2020 2020  ll=True)..      
+00007e00: 2020 2020 2020 2320 7472 7920 6167 6169        # try agai
+00007e10: 6e0a 2020 2020 2020 2020 2020 2020 6c6f  n.            lo
+00007e20: 672e 6572 726f 7228 2272 6574 7279 696e  g.error("retryin
+00007e30: 6720 2861 7474 656d 7074 2025 6429 222c  g (attempt %d)",
+00007e40: 2072 6574 7279 5f63 6f75 6e74 202b 2031   retry_count + 1
+00007e50: 290a 0a20 2020 2023 2320 406e 6f74 6520  )..    ## @note 
+00007e60: 7765 6972 6420 7468 6174 2073 6f20 6665  weird that so fe
+00007e70: 7720 6361 6c6c 7320 746f 2074 6869 7320  w calls to this 
+00007e80: 6675 6e63 7469 6f6e 206f 7665 7272 6964  function overrid
+00007e90: 6520 7468 6520 6465 6661 756c 7420 774c  e the default wL
+00007ea0: 656e 6774 680a 2020 2020 2320 4074 6f64  ength.    # @tod
+00007eb0: 6f20 636f 6e73 6964 6572 2061 6464 696e  o consider addin
+00007ec0: 6720 7265 7472 7920 6c6f 6769 6320 6173  g retry logic as
+00007ed0: 2077 656c 6c0a 2020 2020 6465 6620 5f67   well.    def _g
+00007ee0: 6574 5f63 6f64 6528 7365 6c66 2c20 0a20  et_code(self, . 
+00007ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007f00: 2062 5265 7175 6573 743a 2069 6e74 2c20   bRequest: int, 
+00007f10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007f20: 2020 2077 5661 6c75 653a 2069 6e74 203d     wValue: int =
+00007f30: 2030 2c20 0a20 2020 2020 2020 2020 2020   0, .           
+00007f40: 2020 2020 2020 2077 496e 6465 783a 2069         wIndex: i
+00007f50: 6e74 203d 2030 2c20 0a20 2020 2020 2020  nt = 0, .       
+00007f60: 2020 2020 2020 2020 2020 2077 4c65 6e67             wLeng
+00007f70: 7468 3a20 696e 7420 3d20 3634 2c20 0a20  th: int = 64, . 
 00007f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007f90: 2020 2062 5265 7175 6573 742c 0d0a 2020     bRequest,..  
-00007fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007fc0: 2020 2020 2020 2020 2020 2020 2077 5661               wVa
-00007fd0: 6c75 652c 0d0a 2020 2020 2020 2020 2020  lue,..          
-00007fe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008000: 2020 2020 2077 496e 6465 782c 0d0a 2020       wIndex,..  
-00008010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008030: 2020 2020 2020 2020 2020 2020 2077 4c65               wLe
-00008040: 6e67 7468 290d 0a20 2020 2020 2020 2065  ngth)..        e
-00008050: 7863 6570 7420 4578 6365 7074 696f 6e20  xcept Exception 
-00008060: 6173 2065 7863 3a0d 0a20 2020 2020 2020  as exc:..       
-00008070: 2020 2020 206c 6f67 2e63 7269 7469 6361       log.critica
-00008080: 6c28 2248 6172 6477 6172 6520 4661 696c  l("Hardware Fail
-00008090: 7572 6520 4649 4420 4765 7420 436f 6465  ure FID Get Code
-000080a0: 2050 726f 626c 656d 2077 6974 6820 6374   Problem with ct
-000080b0: 726c 2074 7261 6e73 6665 7222 2c20 6578  rl transfer", ex
-000080c0: 635f 696e 666f 3d31 290d 0a20 2020 2020  c_info=1)..     
-000080d0: 2020 2020 2020 2073 656c 662e 5f73 6368         self._sch
-000080e0: 6564 756c 655f 6469 7363 6f6e 6e65 6374  edule_disconnect
-000080f0: 2865 7863 290d 0a20 2020 2020 2020 2020  (exc)..         
-00008100: 2020 2072 6574 7572 6e20 5370 6563 7472     return Spectr
-00008110: 6f6d 6574 6572 5265 7370 6f6e 7365 2870  ometerResponse(p
-00008120: 6f69 736f 6e5f 7069 6c6c 3d54 7275 6529  oison_pill=True)
-00008130: 0d0a 0d0a 2020 2020 2020 2020 7265 7375  ....        resu
-00008140: 6c74 5f68 6578 203d 2022 2022 2e6a 6f69  lt_hex = " ".joi
-00008150: 6e28 5b66 227b 763a 3032 787d 2220 666f  n([f"{v:02x}" fo
-00008160: 7220 7620 696e 2072 6573 756c 745d 290d  r v in result]).
-00008170: 0a20 2020 2020 2020 206c 6f67 2e64 6562  .        log.deb
-00008180: 7567 2822 2573 5f67 6574 5f63 6f64 653a  ug("%s_get_code:
-00008190: 2072 6571 7565 7374 2030 7825 3032 7820   request 0x%02x 
-000081a0: 7661 6c75 6520 3078 2530 3478 2069 6e64  value 0x%04x ind
-000081b0: 6578 2030 7825 3034 7820 3d20 5b25 735d  ex 0x%04x = [%s]
-000081c0: 222c 0d0a 2020 2020 2020 2020 2020 2020  ",..            
-000081d0: 7072 6566 6978 2c20 6252 6571 7565 7374  prefix, bRequest
-000081e0: 2c20 7756 616c 7565 2c20 7749 6e64 6578  , wValue, wIndex
-000081f0: 2c20 7265 7375 6c74 5f68 6578 290d 0a0d  , result_hex)...
-00008200: 0a20 2020 2020 2020 2069 6620 7265 7375  .        if resu
-00008210: 6c74 2069 7320 4e6f 6e65 3a0d 0a20 2020  lt is None:..   
-00008220: 2020 2020 2020 2020 206c 6f67 2e63 7269           log.cri
-00008230: 7469 6361 6c28 225f 6765 745f 636f 6465  tical("_get_code
-00008240: 5b25 732c 2025 735d 3a20 7265 6365 6976  [%s, %s]: receiv
-00008250: 6564 206e 756c 6c22 2c20 6c61 6265 6c2c  ed null", label,
-00008260: 2073 656c 662e 6465 7669 6365 5f69 6429   self.device_id)
-00008270: 0d0a 2020 2020 2020 2020 2020 2020 7365  ..            se
-00008280: 6c66 2e5f 7363 6865 6475 6c65 5f64 6973  lf._schedule_dis
-00008290: 636f 6e6e 6563 7428 6578 6329 0d0a 2020  connect(exc)..  
-000082a0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-000082b0: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
-000082c0: 706f 6e73 6528 6b65 6570 5f61 6c69 7665  ponse(keep_alive
-000082d0: 3d54 7275 6529 0d0a 0d0a 2020 2020 2020  =True)....      
-000082e0: 2020 2320 6465 6d61 7273 6861 6c6c 206f    # demarshall o
-000082f0: 7220 7265 7475 726e 2072 6177 2061 7272  r return raw arr
-00008300: 6179 0d0a 2020 2020 2020 2020 7661 6c75  ay..        valu
-00008310: 6520 3d20 300d 0a20 2020 2020 2020 2069  e = 0..        i
-00008320: 6620 6d73 625f 6c65 6e20 6973 206e 6f74  f msb_len is not
-00008330: 204e 6f6e 653a 0d0a 2020 2020 2020 2020   None:..        
-00008340: 2020 2020 666f 7220 6920 696e 2072 616e      for i in ran
-00008350: 6765 286d 7362 5f6c 656e 293a 0d0a 2020  ge(msb_len):..  
-00008360: 2020 2020 2020 2020 2020 2020 2020 7661                va
-00008370: 6c75 6520 3d20 7661 6c75 6520 3c3c 2038  lue = value << 8
-00008380: 207c 2072 6573 756c 745b 695d 0d0a 2020   | result[i]..  
-00008390: 2020 2020 2020 2020 2020 7265 7475 726e            return
-000083a0: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
-000083b0: 706f 6e73 6528 6461 7461 3d76 616c 7565  ponse(data=value
-000083c0: 290d 0a20 2020 2020 2020 2065 6c69 6620  )..        elif 
-000083d0: 6c73 625f 6c65 6e20 6973 206e 6f74 204e  lsb_len is not N
-000083e0: 6f6e 653a 0d0a 2020 2020 2020 2020 2020  one:..          
-000083f0: 2020 666f 7220 6920 696e 2072 616e 6765    for i in range
-00008400: 286c 7362 5f6c 656e 293a 0d0a 2020 2020  (lsb_len):..    
-00008410: 2020 2020 2020 2020 2020 2020 7661 6c75              valu
-00008420: 6520 3d20 2872 6573 756c 745b 695d 203c  e = (result[i] <
-00008430: 3c20 2838 202a 2069 2929 207c 2076 616c  < (8 * i)) | val
-00008440: 7565 0d0a 2020 2020 2020 2020 2020 2020  ue..            
-00008450: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
-00008460: 7465 7252 6573 706f 6e73 6528 6461 7461  terResponse(data
-00008470: 3d76 616c 7565 290d 0a20 2020 2020 2020  =value)..       
-00008480: 2065 6c73 653a 0d0a 2020 2020 2020 2020   else:..        
-00008490: 2020 2020 7265 7475 726e 2053 7065 6374      return Spect
-000084a0: 726f 6d65 7465 7252 6573 706f 6e73 6528  rometerResponse(
-000084b0: 6461 7461 3d72 6573 756c 7429 0d0a 0d0a  data=result)....
-000084c0: 2020 2020 6465 6620 6765 745f 7570 7065      def get_uppe
-000084d0: 725f 636f 6465 2873 656c 662c 200d 0a20  r_code(self, .. 
-000084e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000084f0: 2020 2020 2020 7756 616c 7565 3a20 696e        wValue: in
-00008500: 742c 200d 0a20 2020 2020 2020 2020 2020  t, ..           
-00008510: 2020 2020 2020 2020 2020 2020 7749 6e64              wInd
-00008520: 6578 3a20 696e 7420 3d20 302c 200d 0a20  ex: int = 0, .. 
-00008530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008540: 2020 2020 2020 774c 656e 6774 683a 2069        wLength: i
-00008550: 6e74 203d 2036 342c 200d 0a20 2020 2020  nt = 64, ..     
-00008560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008570: 2020 6c61 6265 6c3a 2073 7472 203d 2022    label: str = "
-00008580: 222c 200d 0a20 2020 2020 2020 2020 2020  ", ..           
-00008590: 2020 2020 2020 2020 2020 2020 6d73 625f              msb_
-000085a0: 6c65 6e3a 2069 6e74 203d 204e 6f6e 652c  len: int = None,
-000085b0: 200d 0a20 2020 2020 2020 2020 2020 2020   ..             
-000085c0: 2020 2020 2020 2020 2020 6c73 625f 6c65            lsb_le
-000085d0: 6e3a 2069 6e74 203d 204e 6f6e 6529 202d  n: int = None) -
-000085e0: 3e20 5370 6563 7472 6f6d 6574 6572 5265  > SpectrometerRe
-000085f0: 7370 6f6e 7365 3a0d 0a20 2020 2020 2020  sponse:..       
-00008600: 2072 6574 7572 6e20 7365 6c66 2e5f 6765   return self._ge
-00008610: 745f 636f 6465 2830 7866 662c 2077 5661  t_code(0xff, wVa
-00008620: 6c75 652c 2077 496e 6465 782c 2077 4c65  lue, wIndex, wLe
-00008630: 6e67 7468 2c20 6c61 6265 6c3d 6c61 6265  ngth, label=labe
-00008640: 6c2c 206d 7362 5f6c 656e 3d6d 7362 5f6c  l, msb_len=msb_l
-00008650: 656e 2c20 6c73 625f 6c65 6e3d 6c73 625f  en, lsb_len=lsb_
-00008660: 6c65 6e29 0d0a 0d0a 2020 2020 2320 2323  len)....    # ##
-00008670: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00008680: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00008690: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000086a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000086b0: 2323 2323 2323 2323 0d0a 2020 2020 2320  ########..    # 
-000086c0: 696e 6974 6961 6c69 7a61 7469 6f6e 0d0a  initialization..
-000086d0: 2020 2020 2320 2323 2323 2323 2323 2323      # ##########
-000086e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000086f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00008700: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00008710: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00008720: 0d0a 0d0a 2020 2020 6465 6620 5f72 6561  ....    def _rea
-00008730: 645f 6565 7072 6f6d 2873 656c 6629 3a20  d_eeprom(self): 
-00008740: 2320 2d3e 2053 7065 6374 726f 6d65 7465  # -> Spectromete
-00008750: 7252 6573 706f 6e73 6520 0d0a 2020 2020  rResponse ..    
-00008760: 2020 2020 6275 6666 6572 7320 3d20 5b5d      buffers = []
-00008770: 0d0a 2020 2020 2020 2020 666f 7220 7061  ..        for pa
-00008780: 6765 2069 6e20 7261 6e67 6528 4545 5052  ge in range(EEPR
-00008790: 4f4d 2e4d 4158 5f50 4147 4553 293a 0d0a  OM.MAX_PAGES):..
-000087a0: 2020 2020 2020 2020 2020 2020 6275 6620              buf 
-000087b0: 3d20 4e6f 6e65 0d0a 2020 2020 2020 2020  = None..        
-000087c0: 2020 2020 7472 793a 0d0a 2020 2020 2020      try:..      
-000087d0: 2020 2020 2020 2020 2020 7265 7370 6f6e            respon
-000087e0: 7365 203d 2073 656c 662e 6765 745f 7570  se = self.get_up
-000087f0: 7065 725f 636f 6465 2830 7830 312c 2070  per_code(0x01, p
-00008800: 6167 652c 206c 6162 656c 3d22 4745 545f  age, label="GET_
-00008810: 4d4f 4445 4c5f 434f 4e46 4947 2825 6429  MODEL_CONFIG(%d)
-00008820: 2220 2520 7061 6765 290d 0a20 2020 2020  " % page)..     
-00008830: 2020 2020 2020 2020 2020 2062 7566 203d             buf =
-00008840: 2072 6573 706f 6e73 652e 6461 7461 0d0a   response.data..
-00008850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008860: 6966 2072 6573 706f 6e73 652e 6572 726f  if response.erro
-00008870: 725f 6c76 6c20 213d 2045 7272 6f72 4c65  r_lvl != ErrorLe
-00008880: 7665 6c2e 6f6b 3a0d 0a20 2020 2020 2020  vel.ok:..       
-00008890: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-000088a0: 7572 6e20 7265 7370 6f6e 7365 0d0a 2020  urn response..  
-000088b0: 2020 2020 2020 2020 2020 6578 6365 7074            except
-000088c0: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-000088d0: 2020 206c 6f67 2e65 7272 6f72 2822 6578     log.error("ex
-000088e0: 6365 7074 696f 6e20 7265 6164 696e 6720  ception reading 
-000088f0: 7570 7065 725f 636f 6465 2030 7830 3120  upper_code 0x01 
-00008900: 7769 7468 2070 6167 6520 2564 222c 2070  with page %d", p
-00008910: 6167 652c 2065 7863 5f69 6e66 6f3d 3129  age, exc_info=1)
-00008920: 0d0a 2020 2020 2020 2020 2020 2020 6275  ..            bu
-00008930: 665f 6c65 6e20 3d20 3020 6966 2062 7566  f_len = 0 if buf
-00008940: 2069 7320 4e6f 6e65 2065 6c73 6520 6c65   is None else le
-00008950: 6e28 6275 6629 0d0a 2020 2020 2020 2020  n(buf)..        
-00008960: 2020 2020 6966 2062 7566 2069 7320 4e6f      if buf is No
-00008970: 6e65 3a0d 0a20 2020 2020 2020 2020 2020  ne:..           
-00008980: 2020 2020 206d 7367 203d 2022 756e 6162       msg = "unab
-00008990: 6c65 2074 6f20 7265 6164 2045 4550 524f  le to read EEPRO
-000089a0: 4d20 286e 756c 6c20 6275 6629 220d 0a20  M (null buf)".. 
-000089b0: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-000089c0: 6f67 2e65 7272 6f72 286d 7367 290d 0a20  og.error(msg).. 
-000089d0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-000089e0: 6574 7572 6e20 5370 6563 7472 6f6d 6574  eturn Spectromet
-000089f0: 6572 5265 7370 6f6e 7365 2846 616c 7365  erResponse(False
-00008a00: 2c20 6572 726f 725f 6c76 6c3d 4572 726f  , error_lvl=Erro
-00008a10: 724c 6576 656c 2e6d 6564 6975 6d2c 6572  rLevel.medium,er
-00008a20: 726f 725f 6d73 673d 6d73 6729 0d0a 2020  ror_msg=msg)..  
-00008a30: 2020 2020 2020 2020 2020 656c 6966 206c            elif l
-00008a40: 656e 2862 7566 2920 3c20 3634 3a0d 0a20  en(buf) < 64:.. 
-00008a50: 2020 2020 2020 2020 2020 2020 2020 206d                 m
-00008a60: 7367 203d 2066 2275 6e61 626c 6520 746f  sg = f"unable to
-00008a70: 2072 6561 6420 4545 5052 4f4d 2072 6563   read EEPROM rec
-00008a80: 6569 7665 6420 6275 6620 6f66 207b 6275  eived buf of {bu
-00008a90: 667d 2061 6e64 206c 656e 207b 6c65 6e28  f} and len {len(
-00008aa0: 6275 6629 7d22 0d0a 2020 2020 2020 2020  buf)}"..        
-00008ab0: 2020 2020 2020 2020 6c6f 672e 6572 726f          log.erro
-00008ac0: 7228 6d73 6729 0d0a 2020 2020 2020 2020  r(msg)..        
-00008ad0: 2020 2020 2020 2020 7265 7475 726e 2053          return S
-00008ae0: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
-00008af0: 6e73 6528 4661 6c73 652c 2065 7272 6f72  nse(False, error
-00008b00: 5f6c 766c 3d45 7272 6f72 4c65 7665 6c2e  _lvl=ErrorLevel.
-00008b10: 6d65 6469 756d 2c65 7272 6f72 5f6d 7367  medium,error_msg
-00008b20: 3d6d 7367 290d 0a20 2020 2020 2020 2020  =msg)..         
-00008b30: 2020 2062 7566 6665 7273 2e61 7070 656e     buffers.appen
-00008b40: 6428 6275 6629 0d0a 0d0a 2020 2020 2020  d(buf)....      
-00008b50: 2020 666c 6174 5f62 7566 6665 7273 5f61    flat_buffers_a
-00008b60: 6c6c 5f6f 6e65 7320 3d20 5472 7565 0d0a  ll_ones = True..
-00008b70: 2020 2020 2020 2020 666f 7220 7061 6765          for page
-00008b80: 2069 6e20 6275 6666 6572 733a 0d0a 2020   in buffers:..  
-00008b90: 2020 2020 2020 2020 2020 666f 7220 6279            for by
-00008ba0: 7465 2069 6e20 7061 6765 3a0d 0a20 2020  te in page:..   
-00008bb0: 2020 2020 2020 2020 2020 2020 2066 6c61               fla
-00008bc0: 745f 6275 6666 6572 735f 616c 6c5f 6f6e  t_buffers_all_on
-00008bd0: 6573 203d 2066 6c61 745f 6275 6666 6572  es = flat_buffer
-00008be0: 735f 616c 6c5f 6f6e 6573 2061 6e64 2028  s_all_ones and (
-00008bf0: 6279 7465 203d 3d20 3078 4646 290d 0a0d  byte == 0xFF)...
-00008c00: 0a20 2020 2020 2020 2069 6620 666c 6174  .        if flat
-00008c10: 5f62 7566 6665 7273 5f61 6c6c 5f6f 6e65  _buffers_all_one
-00008c20: 733a 0d0a 2020 2020 2020 2020 2020 2020  s:..            
-00008c30: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
-00008c40: 7465 7252 6573 706f 6e73 6528 6461 7461  terResponse(data
-00008c50: 3d46 616c 7365 2c65 7272 6f72 5f6d 7367  =False,error_msg
-00008c60: 3d22 5361 7720 616c 6c20 4673 2066 6f72  ="Saw all Fs for
-00008c70: 2045 4550 524f 4d2e 2043 6865 636b 2045   EEPROM. Check E
-00008c80: 4550 524f 4d20 5072 6f67 7261 6d6d 6564  EPROM Programmed
-00008c90: 2e22 2c65 7272 6f72 5f6c 766c 3d45 7272  .",error_lvl=Err
-00008ca0: 6f72 4c65 7665 6c2e 6c6f 7729 0d0a 2020  orLevel.low)..  
-00008cb0: 2020 2020 2020 7265 7475 726e 2053 7065        return Spe
-00008cc0: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
-00008cd0: 6528 6461 7461 3d73 656c 662e 7365 7474  e(data=self.sett
-00008ce0: 696e 6773 2e65 6570 726f 6d2e 7061 7273  ings.eeprom.pars
-00008cf0: 6528 6275 6666 6572 7329 290d 0a0d 0a20  e(buffers)).... 
-00008d00: 2020 2064 6566 2068 6173 5f6c 696e 6561     def has_linea
-00008d10: 7269 7479 5f63 6f65 6666 7328 7365 6c66  rity_coeffs(self
-00008d20: 293a 2023 202d 3e20 626f 6f6c 200d 0a20  ): # -> bool .. 
-00008d30: 2020 2020 2020 2022 2222 0d0a 2020 2020         """..    
-00008d40: 2020 2020 4174 206c 6561 7374 206f 6e65      At least one
-00008d50: 206c 696e 6561 7269 7479 2063 6f65 6666   linearity coeff
-00008d60: 2069 7320 6f74 6865 7220 7468 616e 2030   is other than 0
-00008d70: 206f 7220 2d31 2028 616e 6420 6e6f 204e   or -1 (and no N
-00008d80: 614e 292e 0d0a 0d0a 2020 2020 2020 2020  aN).....        
-00008d90: 5075 626c 6963 2062 6563 6175 7365 2075  Public because u
-00008da0: 7365 6420 6279 2077 6173 6174 6368 2d73  sed by wasatch-s
-00008db0: 6865 6c6c 2e0d 0a20 2020 2020 2020 2022  hell...        "
-00008dc0: 2222 0d0a 2020 2020 2020 2020 6966 2073  ""..        if s
-00008dd0: 656c 662e 7365 7474 696e 6773 2e65 6570  elf.settings.eep
-00008de0: 726f 6d2e 6c69 6e65 6172 6974 795f 636f  rom.linearity_co
-00008df0: 6566 6673 3a0d 0a20 2020 2020 2020 2020  effs:..         
-00008e00: 2020 2066 6f72 2063 2069 6e20 7365 6c66     for c in self
-00008e10: 2e73 6574 7469 6e67 732e 6565 7072 6f6d  .settings.eeprom
-00008e20: 2e6c 696e 6561 7269 7479 5f63 6f65 6666  .linearity_coeff
-00008e30: 733a 0d0a 2020 2020 2020 2020 2020 2020  s:..            
-00008e40: 2020 2020 6966 206d 6174 682e 6973 6e61      if math.isna
-00008e50: 6e28 6329 3a0d 0a20 2020 2020 2020 2020  n(c):..         
-00008e60: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00008e70: 6e20 4661 6c73 650d 0a20 2020 2020 2020  n False..       
-00008e80: 2020 2020 2066 6f72 2063 2069 6e20 7365       for c in se
-00008e90: 6c66 2e73 6574 7469 6e67 732e 6565 7072  lf.settings.eepr
-00008ea0: 6f6d 2e6c 696e 6561 7269 7479 5f63 6f65  om.linearity_coe
-00008eb0: 6666 733a 0d0a 2020 2020 2020 2020 2020  ffs:..          
-00008ec0: 2020 2020 2020 6966 2063 2021 3d20 3020        if c != 0 
-00008ed0: 616e 6420 6320 213d 202d 313a 0d0a 2020  and c != -1:..  
-00008ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008ef0: 2020 7265 7475 726e 2054 7275 650d 0a20    return True.. 
-00008f00: 2020 2020 2020 2072 6574 7572 6e20 4661         return Fa
-00008f10: 6c73 650d 0a0d 0a20 2020 2064 6566 205f  lse....    def _
-00008f20: 7265 6164 5f66 7067 615f 636f 6d70 696c  read_fpga_compil
-00008f30: 6174 696f 6e5f 6f70 7469 6f6e 7328 7365  ation_options(se
-00008f40: 6c66 293a 2023 202d 3e20 4e6f 6e65 200d  lf): # -> None .
-00008f50: 0a20 2020 2020 2020 2072 6573 706f 6e73  .        respons
-00008f60: 6520 3d20 7365 6c66 2e67 6574 5f75 7070  e = self.get_upp
-00008f70: 6572 5f63 6f64 6528 3078 3034 2c20 6c61  er_code(0x04, la
-00008f80: 6265 6c3d 2252 4541 445f 434f 4d50 494c  bel="READ_COMPIL
-00008f90: 4154 494f 4e5f 4f50 5449 4f4e 5322 2c20  ATION_OPTIONS", 
-00008fa0: 6c73 625f 6c65 6e3d 3229 0d0a 2020 2020  lsb_len=2)..    
-00008fb0: 2020 2020 776f 7264 203d 2072 6573 706f      word = respo
-00008fc0: 6e73 652e 6461 7461 0d0a 2020 2020 2020  nse.data..      
-00008fd0: 2020 7365 6c66 2e73 6574 7469 6e67 732e    self.settings.
-00008fe0: 6670 6761 5f6f 7074 696f 6e73 2e70 6172  fpga_options.par
-00008ff0: 7365 2877 6f72 6429 0d0a 0d0a 2020 2020  se(word)....    
-00009000: 2320 2323 2323 2323 2323 2323 2323 2323  # ##############
-00009010: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00009020: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00009030: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00009040: 2323 2323 2323 2323 2323 2323 0d0a 2020  ############..  
-00009050: 2020 2320 4163 6365 7373 6f72 730d 0a20    # Accessors.. 
-00009060: 2020 2023 2023 2323 2323 2323 2323 2323     # ###########
-00009070: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00009080: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00009090: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000090a0: 2323 2323 2323 2323 2323 2323 2323 230d  ###############.
-000090b0: 0a0d 0a20 2020 2023 2040 746f 646f 2074  ...    # @todo t
-000090c0: 6573 7420 656e 6469 616e 206f 7264 6572  est endian order
-000090d0: 2028 696e 2061 6e64 206f 7574 290d 0a20   (in and out).. 
-000090e0: 2020 2064 6566 2067 6574 5f62 6174 7465     def get_batte
-000090f0: 7279 5f72 6567 6973 7465 7228 7365 6c66  ry_register(self
-00009100: 2c20 7265 673a 2069 6e74 293a 2023 202d  , reg: int): # -
-00009110: 3e20 5370 6563 7472 6f6d 6574 6572 5265  > SpectrometerRe
-00009120: 7370 6f6e 7365 200d 0a20 2020 2020 2020  sponse ..       
-00009130: 2072 6567 203d 2072 6567 2026 2030 7866   reg = reg & 0xf
-00009140: 6666 660d 0a20 2020 2020 2020 2072 6574  fff..        ret
-00009150: 7572 6e20 7365 6c66 2e67 6574 5f75 7070  urn self.get_upp
-00009160: 6572 5f63 6f64 6528 3078 3134 2c20 7749  er_code(0x14, wI
-00009170: 6e64 6578 3d72 6567 2c20 6c61 6265 6c3d  ndex=reg, label=
-00009180: 2247 4554 5f42 4154 5445 5259 5f52 4547  "GET_BATTERY_REG
-00009190: 222c 206d 7362 5f6c 656e 3d32 290d 0a0d  ", msb_len=2)...
-000091a0: 0a20 2020 2064 6566 2067 6574 5f62 6174  .    def get_bat
-000091b0: 7465 7279 5f73 7461 7465 5f72 6177 2873  tery_state_raw(s
-000091c0: 656c 6629 3a20 2320 2d3e 2053 7065 6374  elf): # -> Spect
-000091d0: 726f 6d65 7465 7252 6573 706f 6e73 6520  rometerResponse 
-000091e0: 0d0a 2020 2020 2020 2020 2222 2252 6574  ..        """Ret
-000091f0: 7269 6576 6573 2074 6865 2072 6177 2062  rieves the raw b
-00009200: 6174 7465 7279 2072 6561 6469 6e67 2061  attery reading a
-00009210: 6e64 2074 6865 6e20 6361 6368 6573 2069  nd then caches i
-00009220: 7420 666f 7220 3120 7365 6322 2222 0d0a  t for 1 sec"""..
-00009230: 2020 2020 2020 2020 6e6f 7720 3d20 6461          now = da
-00009240: 7465 7469 6d65 2e64 6174 6574 696d 652e  tetime.datetime.
-00009250: 6e6f 7728 290d 0a20 2020 2020 2020 2069  now()..        i
-00009260: 6620 7365 6c66 2e73 6574 7469 6e67 732e  f self.settings.
-00009270: 7374 6174 652e 6261 7474 6572 795f 7469  state.battery_ti
-00009280: 6d65 7374 616d 7020 6973 206e 6f74 204e  mestamp is not N
-00009290: 6f6e 6520 616e 6420 286e 6f77 202d 2073  one and (now - s
-000092a0: 656c 662e 7365 7474 696e 6773 2e73 7461  elf.settings.sta
-000092b0: 7465 2e62 6174 7465 7279 5f74 696d 6573  te.battery_times
-000092c0: 7461 6d70 292e 746f 7461 6c5f 7365 636f  tamp).total_seco
-000092d0: 6e64 7328 2920 3c20 313a 0d0a 2020 2020  nds() < 1:..    
-000092e0: 2020 2020 2020 2020 7265 7475 726e 2053          return S
-000092f0: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
-00009300: 6e73 6528 6461 7461 3d73 656c 662e 7365  nse(data=self.se
-00009310: 7474 696e 6773 2e73 7461 7465 2e62 6174  ttings.state.bat
-00009320: 7465 7279 5f72 6177 290d 0a0d 0a20 2020  tery_raw)....   
-00009330: 2020 2020 2073 656c 662e 7365 7474 696e       self.settin
-00009340: 6773 2e73 7461 7465 2e62 6174 7465 7279  gs.state.battery
-00009350: 5f74 696d 6573 7461 6d70 203d 206e 6f77  _timestamp = now
-00009360: 0d0a 2020 2020 2020 2020 7265 7370 6f6e  ..        respon
-00009370: 7365 203d 2073 656c 662e 6765 745f 7570  se = self.get_up
-00009380: 7065 725f 636f 6465 2830 7831 332c 206c  per_code(0x13, l
-00009390: 6162 656c 3d22 4745 545f 4241 5454 4552  abel="GET_BATTER
-000093a0: 595f 5354 4154 4522 2c20 6d73 625f 6c65  Y_STATE", msb_le
-000093b0: 6e3d 3329 0d0a 2020 2020 2020 2020 7365  n=3)..        se
-000093c0: 6c66 2e73 6574 7469 6e67 732e 7374 6174  lf.settings.stat
-000093d0: 652e 6261 7474 6572 795f 7261 7720 3d20  e.battery_raw = 
-000093e0: 7265 7370 6f6e 7365 2e64 6174 610d 0a0d  response.data...
-000093f0: 0a20 2020 2020 2020 206c 6f67 2e64 6562  .        log.deb
-00009400: 7567 2866 2262 6174 7465 7279 5f73 7461  ug(f"battery_sta
-00009410: 7465 5f72 6177 3a20 3078 7b73 656c 662e  te_raw: 0x{self.
-00009420: 7365 7474 696e 6773 2e73 7461 7465 2e62  settings.state.b
-00009430: 6174 7465 7279 5f72 6177 3a30 3478 7d22  attery_raw:04x}"
-00009440: 290d 0a20 2020 2020 2020 2072 6574 7572  )..        retur
-00009450: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
-00009460: 7370 6f6e 7365 2864 6174 613d 7365 6c66  sponse(data=self
-00009470: 2e73 6574 7469 6e67 732e 7374 6174 652e  .settings.state.
-00009480: 6261 7474 6572 795f 7261 7729 0d0a 0d0a  battery_raw)....
-00009490: 2020 2020 6465 6620 6765 745f 6261 7474      def get_batt
-000094a0: 6572 795f 7065 7263 656e 7461 6765 2873  ery_percentage(s
-000094b0: 656c 6629 3a20 2320 2d3e 2053 7065 6374  elf): # -> Spect
-000094c0: 726f 6d65 7465 7252 6573 706f 6e73 6520  rometerResponse 
-000094d0: 0d0a 2020 2020 2020 2020 7265 7370 6f6e  ..        respon
-000094e0: 7365 203d 2073 656c 662e 6765 745f 6261  se = self.get_ba
-000094f0: 7474 6572 795f 7374 6174 655f 7261 7728  ttery_state_raw(
-00009500: 290d 0a20 2020 2020 2020 2077 6f72 6420  )..        word 
-00009510: 3d20 7265 7370 6f6e 7365 2e64 6174 610d  = response.data.
-00009520: 0a20 2020 2020 2020 206c 7362 203d 2028  .        lsb = (
-00009530: 776f 7264 203e 3e20 3136 2920 2620 3078  word >> 16) & 0x
-00009540: 6666 0d0a 2020 2020 2020 2020 6d73 6220  ff..        msb 
-00009550: 3d20 2877 6f72 6420 3e3e 2020 3829 2026  = (word >>  8) &
-00009560: 2030 7866 660d 0a20 2020 2020 2020 2070   0xff..        p
-00009570: 6572 6320 3d20 6d73 6220 2b20 2831 2e30  erc = msb + (1.0
-00009580: 202a 206c 7362 202f 2032 3536 2e30 290d   * lsb / 256.0).
-00009590: 0a20 2020 2020 2020 206c 6f67 2e64 6562  .        log.deb
-000095a0: 7567 2822 6261 7474 6572 795f 7065 7263  ug("battery_perc
-000095b0: 3a20 252e 3266 2525 222c 2070 6572 6329  : %.2f%%", perc)
-000095c0: 0d0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-000095d0: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
-000095e0: 706f 6e73 6528 6461 7461 3d70 6572 6329  ponse(data=perc)
-000095f0: 0d0a 0d0a 2020 2020 6465 6620 6765 745f  ....    def get_
-00009600: 6261 7474 6572 795f 6368 6172 6769 6e67  battery_charging
-00009610: 2873 656c 6629 3a20 2320 2d3e 2053 7065  (self): # -> Spe
-00009620: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
-00009630: 6520 0d0a 2020 2020 2020 2020 7265 7320  e ..        res 
-00009640: 3d20 7365 6c66 2e67 6574 5f62 6174 7465  = self.get_batte
-00009650: 7279 5f73 7461 7465 5f72 6177 2829 0d0a  ry_state_raw()..
-00009660: 2020 2020 2020 2020 776f 7264 203d 2072          word = r
-00009670: 6573 2e64 6174 610d 0a20 2020 2020 2020  es.data..       
-00009680: 2063 6861 7267 696e 6720 3d20 2830 2021   charging = (0 !
-00009690: 3d20 2877 6f72 6420 2620 3078 6666 2929  = (word & 0xff))
-000096a0: 0d0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-000096b0: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
-000096c0: 706f 6e73 6528 6461 7461 3d63 6861 7267  ponse(data=charg
-000096d0: 696e 6729 0d0a 0d0a 2020 2020 6465 6620  ing)....    def 
-000096e0: 6765 745f 696e 7465 6772 6174 696f 6e5f  get_integration_
-000096f0: 7469 6d65 5f6d 7328 7365 6c66 293a 2023  time_ms(self): #
-00009700: 202d 3e20 5370 6563 7472 6f6d 6574 6572   -> Spectrometer
-00009710: 5265 7370 6f6e 7365 200d 0a20 2020 2020  Response ..     
-00009720: 2020 2072 6573 706f 6e73 6520 3d20 7365     response = se
-00009730: 6c66 2e5f 6765 745f 636f 6465 2830 7862  lf._get_code(0xb
-00009740: 662c 206c 6162 656c 3d22 4745 545f 494e  f, label="GET_IN
-00009750: 5445 4752 4154 494f 4e5f 5449 4d45 5f4d  TEGRATION_TIME_M
-00009760: 5322 2c20 6c73 625f 6c65 6e3d 3329 0d0a  S", lsb_len=3)..
-00009770: 2020 2020 2020 2020 6d73 203d 2072 6573          ms = res
-00009780: 706f 6e73 652e 6461 7461 0d0a 0d0a 2020  ponse.data....  
-00009790: 2020 2020 2020 6966 2073 656c 662e 7365        if self.se
-000097a0: 7474 696e 6773 2e73 7461 7465 2e69 6e74  ttings.state.int
-000097b0: 6567 7261 7469 6f6e 5f74 696d 655f 6d73  egration_time_ms
-000097c0: 203e 2030 3a0d 0a20 2020 2020 2020 2020   > 0:..         
-000097d0: 2020 206c 6f67 2e64 6562 7567 2866 2247     log.debug(f"G
-000097e0: 4554 5f49 4e54 4547 5241 5449 4f4e 5f54  ET_INTEGRATION_T
-000097f0: 494d 455f 4d53 3a20 6e6f 7720 7b6d 737d  IME_MS: now {ms}
-00009800: 2229 0d0a 2020 2020 2020 2020 2020 2020  ")..            
-00009810: 7365 6c66 2e73 6574 7469 6e67 732e 7374  self.settings.st
-00009820: 6174 652e 696e 7465 6772 6174 696f 6e5f  ate.integration_
-00009830: 7469 6d65 5f6d 7320 3d20 6d73 0d0a 2020  time_ms = ms..  
-00009840: 2020 2020 2020 656c 7365 3a0d 0a20 2020        else:..   
-00009850: 2020 2020 2020 2020 206c 6f67 2e64 6562           log.deb
-00009860: 7567 2822 6465 636c 696e 696e 6720 746f  ug("declining to
-00009870: 2069 6e69 7469 616c 697a 6520 7365 7373   initialize sess
-00009880: 696f 6e20 696e 7465 6772 6174 696f 6e5f  ion integration_
-00009890: 7469 6d65 5f6d 7320 6672 6f6d 2073 7065  time_ms from spe
-000098a0: 6374 726f 6d65 7465 7222 290d 0a0d 0a20  ctrometer").... 
-000098b0: 2020 2020 2020 2072 6574 7572 6e20 5370         return Sp
-000098c0: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-000098d0: 7365 2864 6174 613d 6d73 290d 0a0d 0a20  se(data=ms).... 
-000098e0: 2020 2064 6566 2073 6574 5f64 6675 5f65     def set_dfu_e
-000098f0: 6e61 626c 6528 7365 6c66 293a 2023 202d  nable(self): # -
-00009900: 3e20 5370 6563 7472 6f6d 6574 6572 5265  > SpectrometerRe
-00009910: 7370 6f6e 7365 200d 0a20 2020 2020 2020  sponse ..       
-00009920: 2022 2222 0d0a 2020 2020 2020 2020 5075   """..        Pu
-00009930: 7473 2041 524d 2d62 6173 6564 2073 7065  ts ARM-based spe
-00009940: 6374 726f 6d65 7465 7273 2069 6e74 6f20  ctrometers into 
-00009950: 4465 7669 6365 2046 6972 6d77 6172 6520  Device Firmware 
-00009960: 5570 6461 7465 2028 4446 5529 206d 6f64  Update (DFU) mod
-00009970: 652e 0d0a 2020 2020 2020 2020 4077 6172  e...        @war
-00009980: 6e69 6e67 2072 6566 6c61 7368 696e 6720  ning reflashing 
-00009990: 7370 6563 7472 6f6d 6574 6572 2066 6972  spectrometer fir
-000099a0: 6d77 6172 6520 7769 7468 6f75 7420 7370  mware without sp
-000099b0: 6563 6966 6963 2069 6e73 7472 7563 7469  ecific instructi
-000099c0: 6f6e 2061 6e64 0d0a 2020 2020 2020 2020  on and..        
-000099d0: 7375 7070 6f72 7420 6672 6f6d 2057 6173  support from Was
-000099e0: 6174 6368 2050 686f 746f 6e69 6373 2077  atch Photonics w
-000099f0: 696c 6c20 766f 6964 2079 6f75 7220 7761  ill void your wa
-00009a00: 7272 616e 7479 0d0a 2020 2020 2020 2020  rranty..        
-00009a10: 2222 220d 0a20 2020 2020 2020 2069 6620  """..        if 
-00009a20: 6e6f 7420 7365 6c66 2e73 6574 7469 6e67  not self.setting
-00009a30: 732e 6973 5f61 726d 2829 3a0d 0a20 2020  s.is_arm():..   
-00009a40: 2020 2020 2020 2020 206d 7367 203d 2022           msg = "
-00009a50: 4446 5520 6d6f 6465 206f 6e6c 7920 7375  DFU mode only su
-00009a60: 7070 6f72 7465 6420 666f 7220 4152 4d2d  pported for ARM-
-00009a70: 6261 7365 6420 7370 6563 7472 6f6d 6574  based spectromet
-00009a80: 6572 7322 0d0a 2020 2020 2020 2020 2020  ers"..          
-00009a90: 2020 6c6f 672e 6572 726f 7228 6d73 6729    log.error(msg)
-00009aa0: 0d0a 2020 2020 2020 2020 2020 2020 7265  ..            re
-00009ab0: 7475 726e 2053 7065 6374 726f 6d65 7465  turn Spectromete
-00009ac0: 7252 6573 706f 6e73 6528 6572 726f 725f  rResponse(error_
-00009ad0: 6c76 6c3d 4572 726f 724c 6576 656c 2e6c  lvl=ErrorLevel.l
-00009ae0: 6f77 2c65 7272 6f72 5f6d 7367 3d6d 7367  ow,error_msg=msg
-00009af0: 2c20 6b65 6570 5f61 6c69 7665 3d54 7275  , keep_alive=Tru
-00009b00: 6529 0d0a 0d0a 2020 2020 2020 2020 7265  e)....        re
-00009b10: 7375 6c74 203d 2073 656c 662e 5f73 656e  sult = self._sen
-00009b20: 645f 636f 6465 2830 7866 652c 206c 6162  d_code(0xfe, lab
-00009b30: 656c 3d22 5345 545f 4446 555f 454e 4142  el="SET_DFU_ENAB
-00009b40: 4c45 2229 0d0a 0d0a 2020 2020 2020 2020  LE")....        
-00009b50: 7365 6c66 2e71 7565 7565 5f6d 6573 7361  self.queue_messa
-00009b60: 6765 2822 6d61 7271 7565 655f 696e 666f  ge("marquee_info
-00009b70: 222c 2022 2573 2069 6e20 4446 5520 6d6f  ", "%s in DFU mo
-00009b80: 6465 2220 2520 7365 6c66 2e73 6574 7469  de" % self.setti
-00009b90: 6e67 732e 6565 7072 6f6d 2e73 6572 6961  ngs.eeprom.seria
-00009ba0: 6c5f 6e75 6d62 6572 290d 0a0d 0a20 2020  l_number)....   
-00009bb0: 2020 2020 2073 656c 662e 5f73 6368 6564       self._sched
-00009bc0: 756c 655f 6469 7363 6f6e 6e65 6374 2845  ule_disconnect(E
-00009bd0: 7863 6570 7469 6f6e 2822 4446 5520 4d6f  xception("DFU Mo
-00009be0: 6465 2229 290d 0a20 2020 2020 2020 2072  de"))..        r
-00009bf0: 6574 7572 6e20 5370 6563 7472 6f6d 6574  eturn Spectromet
-00009c00: 6572 5265 7370 6f6e 7365 2864 6174 613d  erResponse(data=
-00009c10: 7265 7375 6c74 290d 0a0d 0a20 2020 2064  result)....    d
-00009c20: 6566 2073 6574 5f64 6574 6563 746f 725f  ef set_detector_
-00009c30: 6f66 6673 6574 2873 656c 662c 2076 616c  offset(self, val
-00009c40: 7565 3a20 696e 7429 3a20 2320 2d3e 2053  ue: int): # -> S
-00009c50: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
-00009c60: 6e73 6520 0d0a 2020 2020 2020 2020 776f  nse ..        wo
-00009c70: 7264 203d 2075 7469 6c73 2e63 6c61 6d70  rd = utils.clamp
-00009c80: 5f74 6f5f 696e 7431 3628 7661 6c75 6529  _to_int16(value)
-00009c90: 0d0a 2020 2020 2020 2020 7365 6c66 2e73  ..        self.s
-00009ca0: 6574 7469 6e67 732e 6565 7072 6f6d 2e64  ettings.eeprom.d
-00009cb0: 6574 6563 746f 725f 6f66 6673 6574 203d  etector_offset =
-00009cc0: 2077 6f72 640d 0a20 2020 2020 2020 2023   word..        #
-00009cd0: 206c 6f67 2e64 6562 7567 2822 7661 6c75   log.debug("valu
-00009ce0: 6520 2564 2028 2573 2920 3d20 3078 2530  e %d (%s) = 0x%0
-00009cf0: 3478 2028 2573 2922 2c20 7661 6c75 652c  4x (%s)", value,
-00009d00: 2066 6f72 6d61 7428 7661 6c75 652c 2027   format(value, '
-00009d10: 6227 292c 2077 6f72 642c 2066 6f72 6d61  b'), word, forma
-00009d20: 7428 776f 7264 2c20 2762 2729 290d 0a20  t(word, 'b')).. 
-00009d30: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00009d40: 6c66 2e5f 7365 6e64 5f63 6f64 6528 3078  lf._send_code(0x
-00009d50: 6236 2c20 776f 7264 2c20 6c61 6265 6c3d  b6, word, label=
-00009d60: 2253 4554 5f44 4554 4543 544f 525f 4f46  "SET_DETECTOR_OF
-00009d70: 4653 4554 2229 0d0a 0d0a 2020 2020 6465  FSET")....    de
-00009d80: 6620 7365 745f 6465 7465 6374 6f72 5f6f  f set_detector_o
-00009d90: 6666 7365 745f 6f64 6428 7365 6c66 2c20  ffset_odd(self, 
-00009da0: 7661 6c75 653a 2069 6e74 293a 2023 202d  value: int): # -
-00009db0: 3e20 5370 6563 7472 6f6d 6574 6572 5265  > SpectrometerRe
-00009dc0: 7370 6f6e 7365 200d 0a20 2020 2020 2020  sponse ..       
-00009dd0: 2069 6620 6e6f 7420 7365 6c66 2e73 6574   if not self.set
-00009de0: 7469 6e67 732e 6973 5f69 6e67 6161 7328  tings.is_ingaas(
-00009df0: 293a 0d0a 2020 2020 2020 2020 2020 2020  ):..            
-00009e00: 6c6f 672e 6465 6275 6728 2253 4554 5f44  log.debug("SET_D
-00009e10: 4554 4543 544f 525f 4f46 4653 4554 5f4f  ETECTOR_OFFSET_O
-00009e20: 4444 206f 6e6c 7920 7375 7070 6f72 7465  DD only supporte
-00009e30: 6420 6f6e 2049 6e47 6141 7322 290d 0a20  d on InGaAs").. 
-00009e40: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00009e50: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
-00009e60: 7370 6f6e 7365 286b 6565 705f 616c 6976  sponse(keep_aliv
-00009e70: 653d 5472 7565 2c65 7272 6f72 5f6c 766c  e=True,error_lvl
-00009e80: 3d45 7272 6f72 4c65 7665 6c2e 6c6f 7729  =ErrorLevel.low)
-00009e90: 0d0a 0d0a 2020 2020 2020 2020 776f 7264  ....        word
-00009ea0: 203d 2075 7469 6c73 2e63 6c61 6d70 5f74   = utils.clamp_t
-00009eb0: 6f5f 696e 7431 3628 7661 6c75 6529 0d0a  o_int16(value)..
-00009ec0: 2020 2020 2020 2020 7365 6c66 2e73 6574          self.set
-00009ed0: 7469 6e67 732e 6565 7072 6f6d 2e64 6574  tings.eeprom.det
-00009ee0: 6563 746f 725f 6f66 6673 6574 5f6f 6464  ector_offset_odd
-00009ef0: 203d 2077 6f72 640d 0a0d 0a20 2020 2020   = word....     
-00009f00: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
-00009f10: 7365 6e64 5f63 6f64 6528 3078 3963 2c20  send_code(0x9c, 
-00009f20: 776f 7264 2c20 6c61 6265 6c3d 2253 4554  word, label="SET
-00009f30: 5f44 4554 4543 544f 525f 4f46 4653 4554  _DETECTOR_OFFSET
-00009f40: 5f4f 4444 2229 0d0a 0d0a 2020 2020 6465  _ODD")....    de
-00009f50: 6620 6765 745f 6465 7465 6374 6f72 5f67  f get_detector_g
-00009f60: 6169 6e28 7365 6c66 2c20 7570 6461 7465  ain(self, update
-00009f70: 5f73 6573 7369 6f6e 5f65 6570 726f 6d3a  _session_eeprom:
-00009f80: 2062 6f6f 6c20 3d20 4661 6c73 6529 3a20   bool = False): 
-00009f90: 2320 2d3e 2053 7065 6374 726f 6d65 7465  # -> Spectromete
-00009fa0: 7252 6573 706f 6e73 6520 0d0a 2020 2020  rResponse ..    
-00009fb0: 2020 2020 2222 220d 0a20 2020 2020 2020      """..       
-00009fc0: 2052 6561 6420 7468 6520 6465 7669 6365   Read the device
-00009fd0: 2073 746f 7265 6420 6761 696e 2e20 2043   stored gain.  C
-00009fe0: 6f6e 7665 7274 2066 726f 6d20 6269 6e61  onvert from bina
-00009ff0: 7279 2022 6861 6c66 2d70 7265 6369 7369  ry "half-precisi
-0000a000: 6f6e 2220 666c 6f61 742e 0d0a 2020 2020  on" float...    
-0000a010: 2020 2020 2d20 3173 7420 6279 7465 2028      - 1st byte (
-0000a020: 4c53 4229 2069 7320 6269 6e61 7279 2065  LSB) is binary e
-0000a030: 6e63 6f64 6564 3a20 6269 7420 3020 3d20  ncoded: bit 0 = 
-0000a040: 312f 322c 2062 6974 2031 203d 2031 2f34  1/2, bit 1 = 1/4
-0000a050: 2c20 6269 7420 3220 3d20 312f 3820 6574  , bit 2 = 1/8 et
-0000a060: 632e 0d0a 2020 2020 2020 2020 2d20 326e  c...        - 2n
-0000a070: 6420 6279 7465 2028 4d53 4229 2069 7320  d byte (MSB) is 
-0000a080: 7468 6520 696e 7465 6772 616c 2070 6172  the integral par
-0000a090: 7420 746f 2074 6865 206c 6566 7420 6f66  t to the left of
-0000a0a0: 2074 6865 2064 6563 696d 616c 0d0a 2020   the decimal..  
-0000a0b0: 2020 2020 2020 452e 672e 2c20 3233 3120        E.g., 231 
-0000a0c0: 6465 6320 3d3d 2030 7830 3165 3720 3d3d  dec == 0x01e7 ==
-0000a0d0: 2031 2e39 3032 3334 3337 350d 0a20 2020   1.90234375..   
-0000a0e0: 2020 2020 2022 2222 0d0a 2020 2020 2020       """..      
-0000a0f0: 2020 7265 7320 3d20 7365 6c66 2e5f 6765    res = self._ge
-0000a100: 745f 636f 6465 2830 7863 352c 206c 6162  t_code(0xc5, lab
-0000a110: 656c 3d22 4745 545f 4445 5445 4354 4f52  el="GET_DETECTOR
-0000a120: 5f47 4149 4e22 290d 0a20 2020 2020 2020  _GAIN")..       
-0000a130: 2072 6573 756c 7420 3d20 7265 732e 6461   result = res.da
-0000a140: 7461 0d0a 0d0a 2020 2020 2020 2020 6966  ta....        if
-0000a150: 2072 6573 756c 7420 6973 204e 6f6e 653a   result is None:
-0000a160: 0d0a 2020 2020 2020 2020 2020 2020 6d73  ..            ms
-0000a170: 6720 3d20 2247 4554 5f44 4554 4543 544f  g = "GET_DETECTO
-0000a180: 525f 4741 494e 2072 6574 7572 6e65 6420  R_GAIN returned 
-0000a190: 4e55 4c4c 2122 0d0a 2020 2020 2020 2020  NULL!"..        
-0000a1a0: 2020 2020 6c6f 672e 6572 726f 7228 6d73      log.error(ms
-0000a1b0: 6729 0d0a 2020 2020 2020 2020 2020 2020  g)..            
-0000a1c0: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
-0000a1d0: 7465 7252 6573 706f 6e73 6528 6572 726f  terResponse(erro
-0000a1e0: 725f 6c76 6c3d 4572 726f 724c 6576 656c  r_lvl=ErrorLevel
-0000a1f0: 2e6d 6564 6975 6d2c 6572 726f 725f 6d73  .medium,error_ms
-0000a200: 673d 6d73 672c 6b65 6570 5f61 6c69 7665  g=msg,keep_alive
-0000a210: 3d54 7275 6529 0d0a 0d0a 2020 2020 2020  =True)....      
-0000a220: 2020 6c73 6220 3d20 7265 7375 6c74 5b30    lsb = result[0
-0000a230: 5d20 2320 4c53 422d 4d53 420d 0a20 2020  ] # LSB-MSB..   
-0000a240: 2020 2020 206d 7362 203d 2072 6573 756c       msb = resul
-0000a250: 745b 315d 0d0a 2020 2020 2020 2020 7261  t[1]..        ra
-0000a260: 7720 3d20 286d 7362 203c 3c20 3829 207c  w = (msb << 8) |
-0000a270: 206c 7362 0d0a 0d0a 2020 2020 2020 2020   lsb....        
-0000a280: 6761 696e 203d 206d 7362 202b 206c 7362  gain = msb + lsb
-0000a290: 202f 2032 3536 2e30 0d0a 2020 2020 2020   / 256.0..      
-0000a2a0: 2020 6c6f 672e 6465 6275 6728 2267 6574    log.debug("get
-0000a2b0: 5f64 6574 6563 746f 725f 6761 696e 3a20  _detector_gain: 
-0000a2c0: 2566 2028 7261 7720 3078 2530 3478 2920  %f (raw 0x%04x) 
-0000a2d0: 2873 6573 7369 6f6e 2065 6570 726f 6d20  (session eeprom 
-0000a2e0: 2566 2922 2025 2028 0d0a 2020 2020 2020  %f)" % (..      
-0000a2f0: 2020 2020 2020 6761 696e 2c20 7261 772c        gain, raw,
-0000a300: 2073 656c 662e 7365 7474 696e 6773 2e65   self.settings.e
-0000a310: 6570 726f 6d2e 6465 7465 6374 6f72 5f67  eprom.detector_g
-0000a320: 6169 6e29 290d 0a0d 0a20 2020 2020 2020  ain))....       
-0000a330: 2069 6620 7570 6461 7465 5f73 6573 7369   if update_sessi
-0000a340: 6f6e 5f65 6570 726f 6d3a 0d0a 2020 2020  on_eeprom:..    
-0000a350: 2020 2020 2020 2020 7365 6c66 2e73 6574          self.set
-0000a360: 7469 6e67 732e 6565 7072 6f6d 2e64 6574  tings.eeprom.det
-0000a370: 6563 746f 725f 6761 696e 203d 2067 6169  ector_gain = gai
-0000a380: 6e0d 0a0d 0a20 2020 2020 2020 2069 6620  n....        if 
-0000a390: 7365 6c66 2e73 6574 7469 6e67 732e 6973  self.settings.is
-0000a3a0: 5f6d 6963 726f 2829 3a0d 0a20 2020 2020  _micro():..     
-0000a3b0: 2020 2020 2020 2073 656c 662e 7365 7474         self.sett
-0000a3c0: 696e 6773 2e73 7461 7465 2e67 6169 6e5f  ings.state.gain_
-0000a3d0: 6462 203d 2067 6169 6e0d 0a0d 0a20 2020  db = gain....   
-0000a3e0: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
-0000a3f0: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
-0000a400: 2864 6174 613d 6761 696e 290d 0a0d 0a20  (data=gain).... 
-0000a410: 2020 2064 6566 2067 6574 5f64 6574 6563     def get_detec
-0000a420: 746f 725f 6761 696e 5f6f 6464 2873 656c  tor_gain_odd(sel
-0000a430: 662c 2075 7064 6174 655f 7365 7373 696f  f, update_sessio
-0000a440: 6e5f 6565 7072 6f6d 3a20 626f 6f6c 203d  n_eeprom: bool =
-0000a450: 2046 616c 7365 293a 2023 202d 3e20 5370   False): # -> Sp
-0000a460: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-0000a470: 7365 200d 0a20 2020 2020 2020 2069 6620  se ..        if 
-0000a480: 6e6f 7420 7365 6c66 2e73 6574 7469 6e67  not self.setting
-0000a490: 732e 6973 5f69 6e67 6161 7328 293a 0d0a  s.is_ingaas():..
-0000a4a0: 2020 2020 2020 2020 2020 2020 6c6f 672e              log.
-0000a4b0: 6465 6275 6728 2247 4554 5f44 4554 4543  debug("GET_DETEC
-0000a4c0: 544f 525f 4741 494e 5f4f 4444 206f 6e6c  TOR_GAIN_ODD onl
-0000a4d0: 7920 7375 7070 6f72 7465 6420 6f6e 2049  y supported on I
-0000a4e0: 6e47 6141 7322 290d 0a20 2020 2020 2020  nGaAs")..       
-0000a4f0: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
-0000a500: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
-0000a510: 2864 6174 613d 7365 6c66 2e73 6574 7469  (data=self.setti
-0000a520: 6e67 732e 6565 7072 6f6d 2e64 6574 6563  ngs.eeprom.detec
-0000a530: 746f 725f 6761 696e 5f6f 6464 290d 0a0d  tor_gain_odd)...
-0000a540: 0a20 2020 2020 2020 2072 6573 756c 7420  .        result 
-0000a550: 3d20 7365 6c66 2e5f 6765 745f 636f 6465  = self._get_code
-0000a560: 2830 7839 662c 206c 6162 656c 3d22 4745  (0x9f, label="GE
-0000a570: 545f 4445 5445 4354 4f52 5f47 4149 4e5f  T_DETECTOR_GAIN_
-0000a580: 4f44 4422 290d 0a0d 0a20 2020 2020 2020  ODD")....       
-0000a590: 206c 7362 203d 2072 6573 756c 745b 305d   lsb = result[0]
-0000a5a0: 2023 204c 5342 2d4d 5342 0d0a 2020 2020   # LSB-MSB..    
-0000a5b0: 2020 2020 6d73 6220 3d20 7265 7375 6c74      msb = result
-0000a5c0: 5b31 5d0d 0a20 2020 2020 2020 2072 6177  [1]..        raw
-0000a5d0: 203d 2028 6d73 6220 3c3c 2038 2920 7c20   = (msb << 8) | 
-0000a5e0: 6c73 620d 0a0d 0a20 2020 2020 2020 2067  lsb....        g
-0000a5f0: 6169 6e20 3d20 6d73 6220 2b20 6c73 6220  ain = msb + lsb 
-0000a600: 2f20 3235 362e 300d 0a20 2020 2020 2020  / 256.0..       
-0000a610: 206c 6f67 2e64 6562 7567 2822 6765 745f   log.debug("get_
-0000a620: 6465 7465 6374 6f72 5f67 6169 6e5f 6f64  detector_gain_od
-0000a630: 643a 2025 6620 2830 7825 3034 7829 2028  d: %f (0x%04x) (
-0000a640: 7365 7373 696f 6e20 6565 7072 6f6d 2025  session eeprom %
-0000a650: 6629 2220 2520 280d 0a20 2020 2020 2020  f)" % (..       
-0000a660: 2020 2020 2067 6169 6e2c 2072 6177 2c20       gain, raw, 
-0000a670: 7365 6c66 2e73 6574 7469 6e67 732e 6565  self.settings.ee
-0000a680: 7072 6f6d 2e64 6574 6563 746f 725f 6761  prom.detector_ga
-0000a690: 696e 5f6f 6464 2929 0d0a 2020 2020 2020  in_odd))..      
-0000a6a0: 2020 6966 2075 7064 6174 655f 7365 7373    if update_sess
-0000a6b0: 696f 6e5f 6565 7072 6f6d 3a0d 0a20 2020  ion_eeprom:..   
-0000a6c0: 2020 2020 2020 2020 2073 656c 662e 7365           self.se
-0000a6d0: 7474 696e 6773 2e65 6570 726f 6d2e 6465  ttings.eeprom.de
-0000a6e0: 7465 6374 6f72 5f67 6169 6e5f 6f64 6420  tector_gain_odd 
-0000a6f0: 3d20 6761 696e 0d0a 2020 2020 2020 2020  = gain..        
-0000a700: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
-0000a710: 7465 7252 6573 706f 6e73 6528 6461 7461  terResponse(data
-0000a720: 3d67 6169 6e29 0d0a 0d0a 2020 2020 2323  =gain)....    ##
-0000a730: 0d0a 2020 2020 2320 4e6f 7465 2074 6861  ..    # Note tha
-0000a740: 7420 7468 6973 2069 7320 7573 6564 2066  t this is used f
-0000a750: 6f72 2064 6574 6563 746f 7220 7479 7065  or detector type
-0000a760: 732c 2069 6e63 6c75 6469 6e67 3a0d 0a20  s, including:.. 
-0000a770: 2020 2023 0d0a 2020 2020 2320 2d20 4861     #..    # - Ha
-0000a780: 6d61 6d61 7473 7520 7369 6c69 636f 6e20  mamatsu silicon 
-0000a790: 2853 3136 3031 302d 2a2c 2053 3136 3031  (S16010-*, S1601
-0000a7a0: 312d 2a2c 2065 7463 290d 0a20 2020 2023  1-*, etc)..    #
-0000a7b0: 202d 2048 616d 616d 6174 7375 2049 6e47   - Hamamatsu InG
-0000a7c0: 6141 7320 2847 3932 3134 2065 7463 290d  aAs (G9214 etc).
-0000a7d0: 0a20 2020 2023 202d 2053 6f6e 7920 494d  .    # - Sony IM
-0000a7e0: 5820 2849 4d58 3338 3520 6574 6329 0d0a  X (IMX385 etc)..
-0000a7f0: 2020 2020 230d 0a20 2020 2023 2049 7420      #..    # It 
-0000a800: 6973 2069 6d70 6f72 7461 6e74 2074 6f20  is important to 
-0000a810: 756e 6465 7273 7461 6e64 2074 6861 7420  understand that 
-0000a820: 7468 6520 554e 4954 206f 6620 7468 6973  the UNIT of this
-0000a830: 2076 616c 7565 2063 6861 6e67 6573 2062   value changes b
-0000a840: 6574 7765 656e 0d0a 2020 2020 2320 4861  etween..    # Ha
-0000a850: 6d61 6d61 7473 7520 616e 6420 494d 5820  mamatsu and IMX 
-0000a860: 6465 7465 6374 6f72 732c 2062 7574 2074  detectors, but t
-0000a870: 6865 2044 4154 4154 5950 4520 646f 6573  he DATATYPE does
-0000a880: 206e 6f74 2e0d 0a20 2020 2023 0d0a 2020   not...    #..  
-0000a890: 2020 2320 5265 6173 6f6e 6162 6c65 2067    # Reasonable g
-0000a8a0: 6169 6e20 6c65 7665 6c73 2066 6f72 2048  ain levels for H
-0000a8b0: 616d 616d 6174 7375 2061 7265 2061 2066  amamatsu are a f
-0000a8c0: 6c6f 6174 696e 672d 706f 696e 7420 7363  loating-point sc
-0000a8d0: 616c 6172 2c20 6c69 7465 7261 6c6c 790d  alar, literally.
-0000a8e0: 0a20 2020 2023 2075 7365 6420 746f 2073  .    # used to s
-0000a8f0: 6361 6c65 2028 6761 696e 2920 7468 6520  cale (gain) the 
-0000a900: 7369 676e 616c 2c20 616e 6420 6172 6520  signal, and are 
-0000a910: 7573 7561 6c6c 7920 696e 2074 6865 2072  usually in the r
-0000a920: 616e 6765 2028 302e 3820 2e2e 2031 2e32  ange (0.8 .. 1.2
-0000a930: 290d 0a20 2020 2023 206f 7220 7468 6572  )..    # or ther
-0000a940: 6561 626f 7574 732e 0d0a 2020 2020 230d  eabouts...    #.
-0000a950: 0a20 2020 2023 2052 6561 736f 6e61 626c  .    # Reasonabl
-0000a960: 6520 6c65 7665 6c73 2066 6f72 2049 4d58  e levels for IMX
-0000a970: 2073 656e 736f 7273 2061 7265 2069 6e20   sensors are in 
-0000a980: 6442 2061 6e64 2076 6172 7920 6279 2064  dB and vary by d
-0000a990: 6574 6563 746f 722c 2062 7574 2061 7265  etector, but are
-0000a9a0: 0d0a 2020 2020 2320 7573 7561 6c6c 7920  ..    # usually 
-0000a9b0: 696e 2074 6865 2072 616e 6765 2028 302e  in the range (0.
-0000a9c0: 3020 2e2e 2033 312e 3029 2c20 7769 7468  0 .. 31.0), with
-0000a9d0: 2065 7861 6374 6c79 2030 2e31 6442 2070   exactly 0.1dB p
-0000a9e0: 7265 6369 7369 6f6e 2e20 2054 6865 0d0a  recision.  The..
-0000a9f0: 2020 2020 2320 7370 6563 7472 6f6d 6574      # spectromet
-0000aa00: 6572 2773 2046 5720 7769 6c6c 2072 6f75  er's FW will rou
-0000aa10: 6e64 2074 6f20 7468 6520 6e65 6172 6573  nd to the neares
-0000aa20: 7420 7365 7474 696e 6720 2831 2e32 3320  t setting (1.23 
-0000aa30: 7769 6c6c 2062 6520 726f 756e 6465 640d  will be rounded.
-0000aa40: 0a20 2020 2023 2074 6f20 312e 3229 2e20  .    # to 1.2). 
-0000aa50: 2049 4d58 2073 656e 736f 7273 2073 7769   IMX sensors swi
-0000aa60: 7463 6820 6672 6f6d 2022 616e 616c 6f67  tch from "analog
-0000aa70: 2067 6169 6e22 2074 6f20 2264 6967 6974   gain" to "digit
-0000aa80: 616c 2067 6169 6e22 2061 626f 7665 0d0a  al gain" above..
-0000aa90: 2020 2020 2320 6120 6769 7665 6e20 7468      # a given th
-0000aaa0: 7265 7368 6f6c 642e 2e2e 6f6e 2074 6865  reshold...on the
-0000aab0: 2049 4d58 3132 332c 2061 6e61 6c6f 6720   IMX123, analog 
-0000aac0: 6761 696e 2069 7320 302e 3020 2d20 3331  gain is 0.0 - 31
-0000aad0: 2e30 2c20 616e 6420 6469 6769 7461 6c0d  .0, and digital.
-0000aae0: 0a20 2020 2023 2069 7320 3331 2e31 202d  .    # is 31.1 -
-0000aaf0: 2037 322e 3020 2849 2074 6869 6e6b 292e   72.0 (I think).
-0000ab00: 0d0a 2020 2020 230d 0a20 2020 2023 2040  ..    #..    # @
-0000ab10: 7365 6520 6874 7470 733a 2f2f 7761 7361  see https://wasa
-0000ab20: 7463 6870 686f 746f 6e69 6373 2e63 6f6d  tchphotonics.com
-0000ab30: 2f61 7069 2f57 6173 6174 6368 2e4e 4554  /api/Wasatch.NET
-0000ab40: 2f63 6c61 7373 5f77 6173 6174 6368 5f6e  /class_wasatch_n
-0000ab50: 5f65 5f74 5f31 5f31 5f66 756e 6b79 5f66  _e_t_1_1_funky_f
-0000ab60: 6c6f 6174 2e68 746d 6c0d 0a20 2020 2064  loat.html..    d
-0000ab70: 6566 2073 6574 5f64 6574 6563 746f 725f  ef set_detector_
-0000ab80: 6761 696e 2873 656c 662c 2067 6169 6e3a  gain(self, gain:
-0000ab90: 2066 6c6f 6174 293a 2023 202d 3e20 5370   float): # -> Sp
-0000aba0: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-0000abb0: 7365 200d 0a20 2020 2020 2020 2072 6177  se ..        raw
-0000abc0: 203d 2073 656c 662e 7365 7474 696e 6773   = self.settings
-0000abd0: 2e65 6570 726f 6d2e 666c 6f61 745f 746f  .eeprom.float_to
-0000abe0: 5f75 696e 7431 3628 6761 696e 290d 0a0d  _uint16(gain)...
-0000abf0: 0a20 2020 2020 2020 2023 204d 5a3a 206e  .        # MZ: n
-0000ac00: 6f74 6520 7468 6174 2077 6520 5345 4e44  ote that we SEND
-0000ac10: 2067 6169 6e20 4d53 422d 4c53 422c 2062   gain MSB-LSB, b
-0000ac20: 7574 2077 6520 5245 4144 2067 6169 6e20  ut we READ gain 
-0000ac30: 4c53 422d 4d53 423f 210d 0a20 2020 2020  LSB-MSB?!..     
-0000ac40: 2020 206c 6f67 2e64 6562 7567 2822 5365     log.debug("Se
-0000ac50: 6e64 2044 6574 6563 746f 7220 4761 696e  nd Detector Gain
-0000ac60: 3a20 3078 2530 3478 2028 2573 2922 2c20  : 0x%04x (%s)", 
-0000ac70: 7261 772c 2067 6169 6e29 0d0a 2020 2020  raw, gain)..    
-0000ac80: 2020 2020 7365 6c66 2e73 6574 7469 6e67      self.setting
-0000ac90: 732e 6565 7072 6f6d 2e64 6574 6563 746f  s.eeprom.detecto
-0000aca0: 725f 6761 696e 203d 2067 6169 6e0d 0a20  r_gain = gain.. 
-0000acb0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-0000acc0: 6c66 2e5f 7365 6e64 5f63 6f64 6528 3078  lf._send_code(0x
-0000acd0: 6237 2c20 7261 772c 206c 6162 656c 3d22  b7, raw, label="
-0000ace0: 5345 545f 4445 5445 4354 4f52 5f47 4149  SET_DETECTOR_GAI
-0000acf0: 4e22 290d 0a0d 0a20 2020 2064 6566 2073  N")....    def s
-0000ad00: 6574 5f64 6574 6563 746f 725f 6761 696e  et_detector_gain
-0000ad10: 5f6f 6464 2873 656c 662c 2067 6169 6e3a  _odd(self, gain:
-0000ad20: 2066 6c6f 6174 293a 2023 202d 3e20 5370   float): # -> Sp
-0000ad30: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-0000ad40: 7365 200d 0a20 2020 2020 2020 2069 6620  se ..        if 
-0000ad50: 6e6f 7420 7365 6c66 2e73 6574 7469 6e67  not self.setting
-0000ad60: 732e 6973 5f69 6e67 6161 7328 293a 0d0a  s.is_ingaas():..
-0000ad70: 2020 2020 2020 2020 2020 2020 6c6f 672e              log.
-0000ad80: 6465 6275 6728 2253 4554 5f44 4554 4543  debug("SET_DETEC
-0000ad90: 544f 525f 4741 494e 5f4f 4444 206f 6e6c  TOR_GAIN_ODD onl
-0000ada0: 7920 7375 7070 6f72 7465 6420 6f6e 2049  y supported on I
-0000adb0: 6e47 6141 7322 290d 0a20 2020 2020 2020  nGaAs")..       
-0000adc0: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
-0000add0: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
-0000ade0: 2865 7272 6f72 5f6c 766c 3d45 7272 6f72  (error_lvl=Error
-0000adf0: 4c65 7665 6c2e 6c6f 772c 2065 7272 6f72  Level.low, error
-0000ae00: 5f6d 7367 3d22 5345 545f 4445 5445 4354  _msg="SET_DETECT
-0000ae10: 4f52 5f47 4149 4e5f 4f44 4420 6f6e 6c79  OR_GAIN_ODD only
-0000ae20: 2073 7570 706f 7274 6564 206f 6e20 496e   supported on In
-0000ae30: 4761 4173 2229 0d0a 0d0a 2020 2020 2020  GaAs")....      
-0000ae40: 2020 7261 7720 3d20 7365 6c66 2e73 6574    raw = self.set
-0000ae50: 7469 6e67 732e 6565 7072 6f6d 2e66 6c6f  tings.eeprom.flo
-0000ae60: 6174 5f74 6f5f 7569 6e74 3136 2867 6169  at_to_uint16(gai
-0000ae70: 6e29 0d0a 0d0a 2020 2020 2020 2020 2320  n)....        # 
-0000ae80: 4d5a 3a20 6e6f 7465 2074 6861 7420 7765  MZ: note that we
-0000ae90: 2053 454e 4420 6761 696e 204d 5342 2d4c   SEND gain MSB-L
-0000aea0: 5342 2c20 6275 7420 7765 2052 4541 4420  SB, but we READ 
-0000aeb0: 6761 696e 204c 5342 2d4d 5342 3f21 0d0a  gain LSB-MSB?!..
-0000aec0: 2020 2020 2020 2020 6c6f 672e 6465 6275          log.debu
-0000aed0: 6728 2253 656e 6420 4465 7465 6374 6f72  g("Send Detector
-0000aee0: 2047 6169 6e20 4f64 643a 2030 7825 3034   Gain Odd: 0x%04
-0000aef0: 7820 2825 7329 222c 2072 6177 2c20 6761  x (%s)", raw, ga
-0000af00: 696e 290d 0a20 2020 2020 2020 2073 656c  in)..        sel
-0000af10: 662e 7365 7474 696e 6773 2e65 6570 726f  f.settings.eepro
-0000af20: 6d2e 6465 7465 6374 6f72 5f67 6169 6e5f  m.detector_gain_
-0000af30: 6f64 6420 3d20 6761 696e 0d0a 2020 2020  odd = gain..    
-0000af40: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-0000af50: 5f73 656e 645f 636f 6465 2830 7839 642c  _send_code(0x9d,
-0000af60: 2072 6177 2c20 6c61 6265 6c3d 2253 4554   raw, label="SET
-0000af70: 5f44 4554 4543 544f 525f 4741 494e 5f4f  _DETECTOR_GAIN_O
-0000af80: 4444 2229 0d0a 0d0a 2020 2020 2323 0d0a  DD")....    ##..
-0000af90: 2020 2020 2320 4869 7374 6f72 6963 616c      # Historical
-0000afa0: 6c79 2c20 7468 6973 206f 7063 6f64 6520  ly, this opcode 
-0000afb0: 6d6f 7665 6420 6172 6f75 6e64 2061 2062  moved around a b
-0000afc0: 6974 2e20 2041 7420 6f6e 6520 706f 696e  it.  At one poin
-0000afd0: 7420 6974 2077 6173 2030 7865 620d 0a20  t it was 0xeb.. 
-0000afe0: 2020 2023 2028 616e 6420 6973 206e 6f77     # (and is now
-0000aff0: 2061 6761 696e 292c 2077 6869 6368 2063   again), which c
-0000b000: 6f6e 666c 6963 7473 2077 6974 6820 4346  onflicts with CF
-0000b010: 5f53 454c 4543 5429 2e20 2041 7420 6f74  _SELECT).  At ot
-0000b020: 6865 7220 7469 6d65 7320 6974 0d0a 2020  her times it..  
-0000b030: 2020 2320 7761 7320 3078 6539 2c20 7768    # was 0xe9, wh
-0000b040: 6963 6820 636f 6e66 6c69 6374 6564 2077  ich conflicted w
-0000b050: 6974 6820 4c41 5345 525f 5241 4d50 5f45  ith LASER_RAMP_E
-0000b060: 4e41 424c 452e 2020 5468 6973 2073 6565  NABLE.  This see
-0000b070: 6d73 2074 6f20 6265 2077 6861 740d 0a20  ms to be what.. 
-0000b080: 2020 2023 2077 6527 7265 2073 7461 6e64     # we're stand
-0000b090: 6172 6469 7a69 6e67 206f 6e20 6865 6e63  ardizing on henc
-0000b0a0: 6566 6f72 7468 2e0d 0a20 2020 2064 6566  eforth...    def
-0000b0b0: 2073 6574 5f61 7265 615f 7363 616e 5f65   set_area_scan_e
-0000b0c0: 6e61 626c 6528 7365 6c66 2c20 666c 6167  nable(self, flag
-0000b0d0: 3a20 626f 6f6c 293a 2023 202d 3e20 5370  : bool): # -> Sp
-0000b0e0: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-0000b0f0: 7365 200d 0a20 2020 2020 2020 2069 6620  se ..        if 
-0000b100: 7365 6c66 2e73 6574 7469 6e67 732e 6973  self.settings.is
-0000b110: 5f69 6e67 6161 7328 293a 0d0a 2020 2020  _ingaas():..    
-0000b120: 2020 2020 2020 2020 6c6f 672e 6572 726f          log.erro
-0000b130: 7228 2261 7265 6120 7363 616e 2069 7320  r("area scan is 
-0000b140: 6e6f 7420 7375 7070 6f72 7465 6420 6f6e  not supported on
-0000b150: 2049 6e47 6141 7320 6465 7465 6374 6f72   InGaAs detector
-0000b160: 7320 2873 696e 676c 6520 6c69 6e65 2061  s (single line a
-0000b170: 7272 6179 2922 290d 0a20 2020 2020 2020  rray)")..       
-0000b180: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
-0000b190: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
-0000b1a0: 2865 7272 6f72 5f6c 766c 3d45 7272 6f72  (error_lvl=Error
-0000b1b0: 4c65 7665 6c2e 6c6f 772c 2065 7272 6f72  Level.low, error
-0000b1c0: 5f6d 7367 3d22 6172 6561 2073 6361 6e20  _msg="area scan 
-0000b1d0: 6973 206e 6f74 2073 7570 706f 7274 6564  is not supported
-0000b1e0: 206f 6e20 496e 4761 4173 2064 6574 6563   on InGaAs detec
-0000b1f0: 746f 7273 2028 7369 6e67 6c65 206c 696e  tors (single lin
-0000b200: 6520 6172 7261 7929 2229 0d0a 0d0a 2020  e array)")....  
-0000b210: 2020 2020 2020 7661 6c75 6520 3d20 3120        value = 1 
-0000b220: 6966 2066 6c61 6720 656c 7365 2030 0d0a  if flag else 0..
-0000b230: 2020 2020 2020 2020 7365 6c66 2e73 6574          self.set
-0000b240: 7469 6e67 732e 7374 6174 652e 6172 6561  tings.state.area
-0000b250: 5f73 6361 6e5f 656e 6162 6c65 6420 3d20  _scan_enabled = 
-0000b260: 666c 6167 0d0a 2020 2020 2020 2020 7265  flag..        re
-0000b270: 7475 726e 2073 656c 662e 5f73 656e 645f  turn self._send_
-0000b280: 636f 6465 2830 7865 622c 2076 616c 7565  code(0xeb, value
-0000b290: 2c20 6c61 6265 6c3d 2253 4554 5f41 5245  , label="SET_ARE
-0000b2a0: 415f 5343 414e 5f45 4e41 424c 4522 290d  A_SCAN_ENABLE").
-0000b2b0: 0a0d 0a20 2020 2064 6566 2067 6574 5f73  ...    def get_s
-0000b2c0: 656e 736f 725f 6c69 6e65 5f6c 656e 6774  ensor_line_lengt
-0000b2d0: 6828 7365 6c66 293a 2023 202d 3e20 5370  h(self): # -> Sp
-0000b2e0: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-0000b2f0: 7365 200d 0a20 2020 2020 2020 2076 616c  se ..        val
-0000b300: 7565 203d 2073 656c 662e 6765 745f 7570  ue = self.get_up
-0000b310: 7065 725f 636f 6465 2830 7830 332c 206c  per_code(0x03, l
-0000b320: 6162 656c 3d22 4745 545f 4c49 4e45 5f4c  abel="GET_LINE_L
-0000b330: 454e 4754 4822 2c20 6c73 625f 6c65 6e3d  ENGTH", lsb_len=
-0000b340: 3229 0d0a 2020 2020 2020 2020 6966 2076  2)..        if v
-0000b350: 616c 7565 2021 3d20 7365 6c66 2e73 6574  alue != self.set
-0000b360: 7469 6e67 732e 7069 7865 6c73 2829 3a0d  tings.pixels():.
-0000b370: 0a20 2020 2020 2020 2020 2020 206c 6f67  .            log
-0000b380: 2e65 7272 6f72 2822 4745 545f 4c49 4e45  .error("GET_LINE
-0000b390: 5f4c 454e 4754 4820 6f70 636f 6465 2072  _LENGTH opcode r
-0000b3a0: 6573 756c 7420 2564 2021 3d20 5370 6563  esult %d != Spec
-0000b3b0: 7472 6f6d 6574 6572 5365 7474 696e 6773  trometerSettings
-0000b3c0: 2e70 6978 656c 7320 2564 2028 7573 696e  .pixels %d (usin
-0000b3d0: 6720 6f70 636f 6465 2072 6573 756c 7429  g opcode result)
-0000b3e0: 222c 0d0a 2020 2020 2020 2020 2020 2020  ",..            
-0000b3f0: 2020 2020 7661 6c75 652c 2073 656c 662e      value, self.
-0000b400: 7365 7474 696e 6773 2e70 6978 656c 7328  settings.pixels(
-0000b410: 2929 0d0a 2020 2020 2020 2020 7265 7475  ))..        retu
-0000b420: 726e 2053 7065 6374 726f 6d65 7465 7252  rn SpectrometerR
-0000b430: 6573 706f 6e73 6528 6461 7461 3d76 616c  esponse(data=val
-0000b440: 7565 290d 0a0d 0a20 2020 2064 6566 2067  ue)....    def g
-0000b450: 6574 5f6d 6963 726f 636f 6e74 726f 6c6c  et_microcontroll
-0000b460: 6572 5f66 6972 6d77 6172 655f 7665 7273  er_firmware_vers
-0000b470: 696f 6e28 7365 6c66 293a 2023 202d 3e20  ion(self): # -> 
-0000b480: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
-0000b490: 6f6e 7365 200d 0a20 2020 2020 2020 2072  onse ..        r
-0000b4a0: 6573 203d 2073 656c 662e 5f67 6574 5f63  es = self._get_c
-0000b4b0: 6f64 6528 3078 6330 2c20 6c61 6265 6c3d  ode(0xc0, label=
-0000b4c0: 2247 4554 5f43 4f44 455f 5245 5649 5349  "GET_CODE_REVISI
-0000b4d0: 4f4e 2229 0d0a 2020 2020 2020 2020 7265  ON")..        re
-0000b4e0: 7375 6c74 203d 2072 6573 2e64 6174 610d  sult = res.data.
-0000b4f0: 0a20 2020 2020 2020 2076 6572 7369 6f6e  .        version
-0000b500: 203d 2022 3f2e 3f2e 3f2e 3f22 0d0a 2020   = "?.?.?.?"..  
-0000b510: 2020 2020 2020 6966 2072 6573 756c 7420        if result 
-0000b520: 6973 206e 6f74 204e 6f6e 6520 616e 6420  is not None and 
-0000b530: 6c65 6e28 7265 7375 6c74 2920 3e3d 2034  len(result) >= 4
-0000b540: 3a0d 0a20 2020 2020 2020 2020 2020 2076  :..            v
-0000b550: 6572 7369 6f6e 203d 2022 2564 2e25 642e  ersion = "%d.%d.
-0000b560: 2564 2e25 6422 2025 2028 7265 7375 6c74  %d.%d" % (result
-0000b570: 5b33 5d2c 2072 6573 756c 745b 325d 2c20  [3], result[2], 
-0000b580: 7265 7375 6c74 5b31 5d2c 2072 6573 756c  result[1], resul
-0000b590: 745b 305d 2920 2320 4d53 422d 4c53 420d  t[0]) # MSB-LSB.
-0000b5a0: 0a20 2020 2020 2020 2073 656c 662e 7365  .        self.se
-0000b5b0: 7474 696e 6773 2e6d 6963 726f 636f 6e74  ttings.microcont
-0000b5c0: 726f 6c6c 6572 5f66 6972 6d77 6172 655f  roller_firmware_
-0000b5d0: 7665 7273 696f 6e20 3d20 7665 7273 696f  version = versio
-0000b5e0: 6e0d 0a20 2020 2020 2020 2072 6574 7572  n..        retur
-0000b5f0: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
-0000b600: 7370 6f6e 7365 2864 6174 613d 7665 7273  sponse(data=vers
-0000b610: 696f 6e29 0d0a 0d0a 2020 2020 6465 6620  ion)....    def 
-0000b620: 6765 745f 6670 6761 5f66 6972 6d77 6172  get_fpga_firmwar
-0000b630: 655f 7665 7273 696f 6e28 7365 6c66 293a  e_version(self):
-0000b640: 2023 202d 3e20 5370 6563 7472 6f6d 6574   # -> Spectromet
-0000b650: 6572 5265 7370 6f6e 7365 200d 0a20 2020  erResponse ..   
-0000b660: 2020 2020 2073 203d 2022 220d 0a20 2020       s = ""..   
-0000b670: 2020 2020 2072 6573 203d 2073 656c 662e       res = self.
-0000b680: 5f67 6574 5f63 6f64 6528 3078 6234 2c20  _get_code(0xb4, 
-0000b690: 774c 656e 6774 683d 372c 206c 6162 656c  wLength=7, label
-0000b6a0: 3d22 4745 545f 4650 4741 5f52 4556 2229  ="GET_FPGA_REV")
-0000b6b0: 0d0a 2020 2020 2020 2020 7265 7375 6c74  ..        result
-0000b6c0: 203d 2072 6573 2e64 6174 610d 0a20 2020   = res.data..   
-0000b6d0: 2020 2020 2069 6620 7265 7375 6c74 2069       if result i
-0000b6e0: 7320 6e6f 7420 4e6f 6e65 3a0d 0a20 2020  s not None:..   
-0000b6f0: 2020 2020 2020 2020 2066 6f72 2069 2069           for i i
-0000b700: 6e20 7261 6e67 6528 6c65 6e28 7265 7375  n range(len(resu
-0000b710: 6c74 2929 3a0d 0a20 2020 2020 2020 2020  lt)):..         
-0000b720: 2020 2020 2020 2063 203d 2072 6573 756c         c = resul
-0000b730: 745b 695d 0d0a 2020 2020 2020 2020 2020  t[i]..          
-0000b740: 2020 2020 2020 6966 2030 7832 3020 3c3d        if 0x20 <=
-0000b750: 2063 203c 2030 7837 663a 2023 2076 6973   c < 0x7f: # vis
-0000b760: 6962 6c65 2041 5343 4949 0d0a 2020 2020  ible ASCII..    
-0000b770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b780: 7320 2b3d 2063 6872 2863 290d 0a20 2020  s += chr(c)..   
-0000b790: 2020 2020 2073 656c 662e 7365 7474 696e       self.settin
-0000b7a0: 6773 2e66 7067 615f 6669 726d 7761 7265  gs.fpga_firmware
-0000b7b0: 5f76 6572 7369 6f6e 203d 2073 0d0a 2020  _version = s..  
-0000b7c0: 2020 2020 2020 7265 7475 726e 2053 7065        return Spe
-0000b7d0: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
-0000b7e0: 6528 6461 7461 3d73 290d 0a0d 0a20 2020  e(data=s)....   
-0000b7f0: 2064 6566 2067 6574 5f6c 696e 6528 7365   def get_line(se
-0000b800: 6c66 2c20 7472 6967 6765 723a 2062 6f6f  lf, trigger: boo
-0000b810: 6c20 3d20 5472 7565 293a 2023 202d 3e20  l = True): # -> 
-0000b820: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
-0000b830: 6f6e 7365 200d 0a20 2020 2020 2020 2022  onse ..        "
-0000b840: 2222 0d0a 2020 2020 2020 2020 5365 6e64  ""..        Send
-0000b850: 2022 6163 7175 6972 6522 2c20 7468 656e   "acquire", then
-0000b860: 2069 6d6d 6564 6961 7465 6c79 2072 6561   immediately rea
-0000b870: 6420 7468 6520 6275 6c6b 2065 6e64 706f  d the bulk endpo
-0000b880: 696e 7428 7329 2e0d 0a20 2020 2020 2020  int(s)...       
-0000b890: 2050 726f 6261 626c 7920 7468 6520 6d6f   Probably the mo
-0000b8a0: 7374 2069 6d70 6f72 7461 6e74 206d 6574  st important met
-0000b8b0: 686f 6420 696e 2074 6869 7320 636c 6173  hod in this clas
-0000b8c0: 732c 206d 6f72 6520 636f 6d6d 6f6e 6c79  s, more commonly
-0000b8d0: 2063 616c 6c65 640d 0a20 2020 2020 2020   called..       
-0000b8e0: 2022 6765 7453 7065 6374 7275 6d22 2069   "getSpectrum" i
-0000b8f0: 6e20 6d6f 7374 2064 7269 7665 7273 2e0d  n most drivers..
-0000b900: 0a20 2020 2020 2020 2040 7061 7261 6d20  .        @param 
-0000b910: 7472 6967 6765 7220 2849 6e70 7574 2920  trigger (Input) 
-0000b920: 7365 6e64 2061 6e20 696e 6974 6961 6c20  send an initial 
-0000b930: 4143 5155 4952 450d 0a20 2020 2020 2020  ACQUIRE..       
-0000b940: 2040 7265 7475 726e 7320 7475 706c 6520   @returns tuple 
-0000b950: 6f66 2028 7370 6563 7472 756d 5b5d 2c20  of (spectrum[], 
-0000b960: 6172 6561 5f73 6361 6e5f 726f 775f 636f  area_scan_row_co
-0000b970: 756e 7429 2066 6f72 2073 7563 6365 7373  unt) for success
-0000b980: 0d0a 2020 2020 2020 2020 4072 6574 7572  ..        @retur
-0000b990: 6e73 204e 6f6e 6520 7768 656e 2069 7420  ns None when it 
-0000b9a0: 7469 6d65 732d 6f75 7420 7768 696c 6520  times-out while 
-0000b9b0: 7761 6974 696e 6720 666f 7220 616e 2065  waiting for an e
-0000b9c0: 7874 6572 6e61 6c20 7472 6967 6765 720d  xternal trigger.
-0000b9d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000b9e0: 2020 2869 6e74 6572 7072 6574 2061 732c    (interpret as,
-0000b9f0: 2022 6469 646e 2774 2066 696e 6420 616e   "didn't find an
-0000ba00: 7920 6669 7368 2074 6869 7320 7469 6d65  y fish this time
-0000ba10: 2c20 7472 7920 6167 6169 6e20 696e 2061  , try again in a
-0000ba20: 2062 6974 2229 0d0a 2020 2020 2020 2020   bit")..        
-0000ba30: 4072 6574 7572 6e73 2046 616c 7365 2028  @returns False (
-0000ba40: 626f 6f6c 2920 7768 656e 2069 7420 7469  bool) when it ti
-0000ba50: 6d65 732d 6f75 7420 6f72 2065 6e63 6f75  mes-out or encou
-0000ba60: 6e74 6572 7320 616e 2065 7863 6570 7469  nters an excepti
-0000ba70: 6f6e 0d0a 2020 2020 2020 2020 2020 2020  on..            
-0000ba80: 2020 2020 2077 6865 6e20 4e4f 5420 696e       when NOT in
-0000ba90: 2065 7874 6572 6e61 6c2d 7472 6967 6765   external-trigge
-0000baa0: 7265 6420 6d6f 6465 0d0a 2020 2020 2020  red mode..      
-0000bab0: 2020 4074 6872 6f77 7320 6578 6365 7074    @throws except
-0000bac0: 696f 6e20 6f6e 2074 696d 656f 7574 2028  ion on timeout (
-0000bad0: 756e 6c65 7373 2065 7874 6572 6e61 6c20  unless external 
-0000bae0: 7472 6967 6765 7269 6e67 2065 6e61 626c  triggering enabl
-0000baf0: 6564 290d 0a20 2020 2020 2020 2022 2222  ed)..        """
-0000bb00: 0d0a 0d0a 2020 2020 2020 2020 2323 2323  ....        ####
-0000bb10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000bb20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000bb30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000bb40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000bb50: 2323 2323 0d0a 2020 2020 2020 2020 2320  ####..        # 
-0000bb60: 7365 6e64 2074 6865 2041 4351 5549 5245  send the ACQUIRE
-0000bb70: 0d0a 2020 2020 2020 2020 2323 2323 2323  ..        ######
-0000bb80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000bb90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000bba0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000bbb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000bbc0: 2323 0d0a 2020 2020 2020 2020 7265 7370  ##..        resp
-0000bbd0: 6f6e 7365 203d 2053 7065 6374 726f 6d65  onse = Spectrome
-0000bbe0: 7465 7252 6573 706f 6e73 6528 290d 0a0d  terResponse()...
-0000bbf0: 0a20 2020 2020 2020 2023 206d 6169 6e20  .        # main 
-0000bc00: 7573 652d 6361 7365 2066 6f72 204e 4f54  use-case for NOT
-0000bc10: 2073 656e 6469 6e67 2061 2074 7269 6767   sending a trigg
-0000bc20: 6572 2077 6f75 6c64 2062 6520 7768 656e  er would be when
-0000bc30: 2072 6561 6469 6e67 0d0a 2020 2020 2020   reading..      
-0000bc40: 2020 2320 7375 6273 6571 7565 6e74 206c    # subsequent l
-0000bc50: 696e 6573 206f 6620 6461 7461 2066 726f  ines of data fro
-0000bc60: 6d20 6172 6561 2073 6361 6e20 2266 6173  m area scan "fas
-0000bc70: 7422 206d 6f64 650d 0a0d 0a20 2020 2020  t" mode....     
-0000bc80: 2020 2061 6371 7569 7369 7469 6f6e 5f74     acquisition_t
-0000bc90: 696d 6573 7461 6d70 203d 2064 6174 6574  imestamp = datet
-0000bca0: 696d 652e 6461 7465 7469 6d65 2e6e 6f77  ime.datetime.now
-0000bcb0: 2829 0d0a 2020 2020 2020 2020 6966 2074  ()..        if t
-0000bcc0: 7269 6767 6572 2061 6e64 2073 656c 662e  rigger and self.
-0000bcd0: 7365 7474 696e 6773 2e73 7461 7465 2e74  settings.state.t
-0000bce0: 7269 6767 6572 5f73 6f75 7263 6520 3d3d  rigger_source ==
-0000bcf0: 2053 7065 6374 726f 6d65 7465 7253 7461   SpectrometerSta
-0000bd00: 7465 2e54 5249 4747 4552 5f53 4f55 5243  te.TRIGGER_SOURC
-0000bd10: 455f 494e 5445 524e 414c 3a0d 0a20 2020  E_INTERNAL:..   
-0000bd20: 2020 2020 2020 2020 2023 204f 6e6c 7920           # Only 
-0000bd30: 7365 6e64 2041 4351 5549 5245 2028 696e  send ACQUIRE (in
-0000bd40: 7465 726e 616c 2053 5720 7472 6967 6765  ternal SW trigge
-0000bd50: 7229 2069 6620 6578 7465 726e 616c 2048  r) if external H
-0000bd60: 5720 7472 6967 6765 7220 6973 2064 6973  W trigger is dis
-0000bd70: 6162 6c65 6420 2864 6566 6175 6c74 290d  abled (default).
-0000bd80: 0a20 2020 2020 2020 2020 2020 206c 6f67  .            log
-0000bd90: 2e64 6562 7567 2822 6765 745f 6c69 6e65  .debug("get_line
-0000bda0: 3a20 7265 7175 6573 7469 6e67 2073 7065  : requesting spe
-0000bdb0: 6374 7275 6d22 290d 0a20 2020 2020 2020  ctrum")..       
-0000bdc0: 2020 2020 2073 656c 662e 5f73 656e 645f       self._send_
-0000bdd0: 636f 6465 2830 7861 642c 206c 6162 656c  code(0xad, label
-0000bde0: 3d22 4143 5155 4952 455f 5350 4543 5452  ="ACQUIRE_SPECTR
-0000bdf0: 554d 2229 0d0a 0d0a 2020 2020 2020 2020  UM")....        
-0000be00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000be10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000be20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000be30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000be40: 2323 2323 2323 2323 0d0a 2020 2020 2020  ########..      
-0000be50: 2020 2320 7072 6570 6172 6520 746f 2072    # prepare to r
-0000be60: 6561 6420 7370 6563 7472 756d 0d0a 2020  ead spectrum..  
-0000be70: 2020 2020 2020 2323 2323 2323 2323 2323        ##########
-0000be80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000be90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000bea0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000beb0: 2323 2323 2323 2323 2323 2323 2323 0d0a  ##############..
-0000bec0: 0d0a 2020 2020 2020 2020 7069 7865 6c73  ..        pixels
-0000bed0: 203d 2073 656c 662e 7365 7474 696e 6773   = self.settings
-0000bee0: 2e70 6978 656c 7328 290d 0a0d 0a20 2020  .pixels()....   
-0000bef0: 2020 2020 2023 2077 6865 6e20 6368 616e       # when chan
-0000bf00: 6769 6e67 2064 6574 6563 746f 7220 524f  ging detector RO
-0000bf10: 492c 2065 7861 6374 6c79 204f 4e45 2052  I, exactly ONE R
-0000bf20: 4541 4420 7368 6f75 6c64 2062 6520 6174  EAD should be at
-0000bf30: 2074 6865 2070 7265 7669 6f75 7320 6c65   the previous le
-0000bf40: 6e67 7468 0d0a 2020 2020 2020 2020 2320  ngth..        # 
-0000bf50: 6966 2073 656c 662e 7072 6576 5f70 6978  if self.prev_pix
-0000bf60: 656c 7320 6973 206e 6f74 204e 6f6e 653a  els is not None:
-0000bf70: 0d0a 2020 2020 2020 2020 2320 2020 2020  ..        #     
-0000bf80: 6c6f 672e 6465 6275 6728 6622 6765 745f  log.debug(f"get_
-0000bf90: 6c69 6e65 3a20 7573 696e 6720 6f6e 652d  line: using one-
-0000bfa0: 7469 6d65 2070 7265 765f 7069 7865 6c73  time prev_pixels
-0000bfb0: 2076 616c 7565 206f 6620 7b73 656c 662e   value of {self.
-0000bfc0: 7072 6576 5f70 6978 656c 737d 2072 6174  prev_pixels} rat
-0000bfd0: 6865 7220 7468 616e 207b 7069 7865 6c73  her than {pixels
-0000bfe0: 7d22 290d 0a20 2020 2020 2020 2023 2020  }")..        #  
-0000bff0: 2020 2070 6978 656c 7320 3d20 7365 6c66     pixels = self
-0000c000: 2e70 7265 765f 7069 7865 6c73 0d0a 2020  .prev_pixels..  
-0000c010: 2020 2020 2020 2320 2020 2020 7365 6c66        #     self
-0000c020: 2e70 7265 765f 7069 7865 6c73 203d 204e  .prev_pixels = N
-0000c030: 6f6e 650d 0a0d 0a20 2020 2020 2020 2023  one....        #
-0000c040: 2061 6c6c 206d 6f64 656c 7320 7265 7475   all models retu
-0000c050: 726e 2073 7065 6374 7261 2061 7320 5b75  rn spectra as [u
-0000c060: 696e 7431 365d 0d0a 2020 2020 2020 2020  int16]..        
-0000c070: 656e 6470 6f69 6e74 7320 3d20 5b30 7838  endpoints = [0x8
-0000c080: 325d 0d0a 2020 2020 2020 2020 626c 6f63  2]..        bloc
-0000c090: 6b5f 6c65 6e5f 6279 7465 7320 3d20 7069  k_len_bytes = pi
-0000c0a0: 7865 6c73 202a 2032 0d0a 2020 2020 2020  xels * 2..      
-0000c0b0: 2020 6966 2070 6978 656c 7320 3d3d 2032    if pixels == 2
-0000c0c0: 3034 3820 616e 6420 6e6f 7420 7365 6c66  048 and not self
-0000c0d0: 2e73 6574 7469 6e67 732e 6973 5f61 726d  .settings.is_arm
-0000c0e0: 2829 3a0d 0a20 2020 2020 2020 2020 2020  ():..           
-0000c0f0: 2065 6e64 706f 696e 7473 203d 205b 3078   endpoints = [0x
-0000c100: 3832 2c20 3078 3836 5d0d 0a20 2020 2020  82, 0x86]..     
-0000c110: 2020 2020 2020 2062 6c6f 636b 5f6c 656e         block_len
-0000c120: 5f62 7974 6573 203d 2032 3034 3820 2320  _bytes = 2048 # 
-0000c130: 3130 3234 2070 6978 656c 7320 6170 6965  1024 pixels apie
-0000c140: 6365 2066 726f 6d20 7477 6f20 656e 6470  ce from two endp
-0000c150: 6f69 6e74 730d 0a0d 0a20 2020 2020 2020  oints....       
-0000c160: 2069 6620 7365 6c66 2e73 6574 7469 6e67   if self.setting
-0000c170: 732e 6973 5f6d 6963 726f 2829 3a0d 0a20  s.is_micro():.. 
-0000c180: 2020 2020 2020 2020 2020 2023 2077 6520             # we 
-0000c190: 6861 7665 206e 6f20 6964 6561 2069 6620  have no idea if 
-0000c1a0: 5365 7269 6573 2d58 5320 6861 7320 746f  Series-XS has to
-0000c1b0: 2022 7761 6b65 2075 7022 2074 6865 2073   "wake up" the s
-0000c1c0: 656e 736f 722c 2073 6f20 7761 6974 0d0a  ensor, so wait..
-0000c1d0: 2020 2020 2020 2020 2020 2020 2320 6c6f              # lo
-0000c1e0: 6e67 2065 6e6f 7567 6820 666f 7220 3620  ng enough for 6 
-0000c1f0: 7468 726f 7761 7761 7920 6672 616d 6573  throwaway frames
-0000c200: 2069 6620 6e65 6564 2062 650d 0a20 2020   if need be..   
-0000c210: 2020 2020 2020 2020 2074 696d 656f 7574           timeout
-0000c220: 5f6d 7320 3d20 7365 6c66 2e73 6574 7469  _ms = self.setti
-0000c230: 6e67 732e 7374 6174 652e 696e 7465 6772  ngs.state.integr
-0000c240: 6174 696f 6e5f 7469 6d65 5f6d 7320 2a20  ation_time_ms * 
-0000c250: 3820 2b20 3530 3020 2a20 7365 6c66 2e73  8 + 500 * self.s
-0000c260: 6574 7469 6e67 732e 6e75 6d5f 636f 6e6e  ettings.num_conn
-0000c270: 6563 7465 645f 6465 7669 6365 730d 0a20  ected_devices.. 
-0000c280: 2020 2020 2020 2065 6c73 653a 0d0a 2020         else:..  
-0000c290: 2020 2020 2020 2020 2020 7469 6d65 6f75            timeou
-0000c2a0: 745f 6d73 203d 2073 656c 662e 7365 7474  t_ms = self.sett
-0000c2b0: 696e 6773 2e73 7461 7465 2e69 6e74 6567  ings.state.integ
-0000c2c0: 7261 7469 6f6e 5f74 696d 655f 6d73 202a  ration_time_ms *
-0000c2d0: 2032 202b 2031 3030 3020 2a20 7365 6c66   2 + 1000 * self
-0000c2e0: 2e73 6574 7469 6e67 732e 6e75 6d5f 636f  .settings.num_co
-0000c2f0: 6e6e 6563 7465 645f 6465 7669 6365 730d  nnected_devices.
-0000c300: 0a0d 0a20 2020 2020 2020 2023 2064 7565  ...        # due
-0000c310: 2074 6f20 6164 6469 7469 6f6e 616c 2066   to additional f
-0000c320: 6972 6d77 6172 6520 7072 6f63 6573 7369  irmware processi
-0000c330: 6e67 2074 696d 6520 666f 7220 6172 6561  ng time for area
-0000c340: 2073 6361 6e3f 0d0a 2020 2020 2020 2020   scan?..        
-0000c350: 6966 2073 656c 662e 7365 7474 696e 6773  if self.settings
-0000c360: 2e73 7461 7465 2e61 7265 615f 7363 616e  .state.area_scan
-0000c370: 5f65 6e61 626c 6564 3a0d 0a20 2020 2020  _enabled:..     
-0000c380: 2020 2020 2020 2069 6620 7472 6967 6765         if trigge
-0000c390: 723a 0d0a 2020 2020 2020 2020 2020 2020  r:..            
-0000c3a0: 2020 2020 7469 6d65 6f75 745f 6d73 202b      timeout_ms +
-0000c3b0: 3d20 3235 300d 0a20 2020 2020 2020 2020  = 250..         
-0000c3c0: 2020 2065 6c73 653a 0d0a 2020 2020 2020     else:..      
-0000c3d0: 2020 2020 2020 2020 2020 2320 6b6c 7564            # klud
-0000c3e0: 6765 3a20 6a75 7374 2075 7365 2074 7269  ge: just use tri
-0000c3f0: 706c 6520 7468 6520 696e 7472 612d 6c69  ple the intra-li
-0000c400: 6e65 2064 656c 6179 0d0a 2020 2020 2020  ne delay..      
-0000c410: 2020 2020 2020 2020 2020 7469 6d65 6f75            timeou
-0000c420: 745f 6d73 203d 2073 656c 662e 7365 7474  t_ms = self.sett
-0000c430: 696e 6773 2e65 6570 726f 6d2e 6465 7465  ings.eeprom.dete
-0000c440: 6374 6f72 5f6f 6666 7365 7420 2a20 330d  ctor_offset * 3.
-0000c450: 0a0d 0a20 2020 2020 2020 2073 656c 662e  ...        self.
-0000c460: 5f77 6169 745f 666f 725f 7573 625f 6176  _wait_for_usb_av
-0000c470: 6169 6c61 626c 6528 290d 0a0d 0a20 2020  ailable()....   
-0000c480: 2020 2020 2023 2323 2323 2323 2323 2323       ###########
-0000c490: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000c4a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000c4b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000c4c0: 2323 2323 2323 2323 2323 2323 230d 0a20  #############.. 
-0000c4d0: 2020 2020 2020 2023 2072 6561 6420 7468         # read th
-0000c4e0: 6520 6461 7461 2066 726f 6d20 6275 6c6b  e data from bulk
-0000c4f0: 2065 6e64 706f 696e 7428 7329 0d0a 2020   endpoint(s)..  
-0000c500: 2020 2020 2020 2323 2323 2323 2323 2323        ##########
-0000c510: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000c520: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000c530: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000c540: 2323 2323 2323 2323 2323 2323 2323 0d0a  ##############..
-0000c550: 0d0a 2020 2020 2020 2020 7370 6563 7472  ..        spectr
-0000c560: 756d 203d 205b 5d0d 0a20 2020 2020 2020  um = []..       
-0000c570: 2066 6f72 2065 6e64 706f 696e 7420 696e   for endpoint in
-0000c580: 2065 6e64 706f 696e 7473 3a0d 0a20 2020   endpoints:..   
-0000c590: 2020 2020 2020 2020 2064 6174 6120 3d20           data = 
-0000c5a0: 4e6f 6e65 0d0a 2020 2020 2020 2020 2020  None..          
-0000c5b0: 2020 7768 696c 6520 6461 7461 2069 7320    while data is 
-0000c5c0: 4e6f 6e65 3a0d 0a20 2020 2020 2020 2020  None:..         
-0000c5d0: 2020 2020 2020 2074 7279 3a0d 0a20 2020         try:..   
-0000c5e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c5f0: 206c 6f67 2e64 6562 7567 2822 7761 6974   log.debug("wait
-0000c600: 696e 6720 666f 7220 2564 2062 7974 6573  ing for %d bytes
-0000c610: 2028 7469 6d65 6f75 7420 2564 6d73 2922   (timeout %dms)"
-0000c620: 2c20 626c 6f63 6b5f 6c65 6e5f 6279 7465  , block_len_byte
-0000c630: 732c 2074 696d 656f 7574 5f6d 7329 0d0a  s, timeout_ms)..
-0000c640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c650: 2020 2020 6461 7461 203d 2073 656c 662e      data = self.
-0000c660: 6465 7669 6365 5f74 7970 652e 7265 6164  device_type.read
-0000c670: 2873 656c 662e 6465 7669 6365 2c20 656e  (self.device, en
-0000c680: 6470 6f69 6e74 2c20 626c 6f63 6b5f 6c65  dpoint, block_le
-0000c690: 6e5f 6279 7465 732c 2074 696d 656f 7574  n_bytes, timeout
-0000c6a0: 3d74 696d 656f 7574 5f6d 7329 0d0a 2020  =timeout_ms)..  
-0000c6b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c6c0: 2020 6c6f 672e 6465 6275 6728 2272 6561    log.debug("rea
-0000c6d0: 6420 2564 2062 7974 6573 222c 206c 656e  d %d bytes", len
-0000c6e0: 2864 6174 6129 290d 0a20 2020 2020 2020  (data))..       
-0000c6f0: 2020 2020 2020 2020 2065 7863 6570 7420           except 
-0000c700: 4578 6365 7074 696f 6e20 6173 2065 7863  Exception as exc
-0000c710: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-0000c720: 2020 2020 2020 2069 6620 7365 6c66 2e64         if self.d
-0000c730: 6576 6963 655f 7479 7065 2069 7320 4e6f  evice_type is No
-0000c740: 6e65 3a0d 0a20 2020 2020 2020 2020 2020  ne:..           
-0000c750: 2020 2020 2020 2020 2020 2020 206c 6f67               log
-0000c760: 2e65 7272 6f72 2866 224e 6f20 6465 7669  .error(f"No devi
-0000c770: 6365 5f74 7970 6522 290d 0a20 2020 2020  ce_type")..     
-0000c780: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c790: 2020 2072 6573 706f 6e73 652e 6572 726f     response.erro
-0000c7a0: 725f 6d73 6720 3d20 6622 456e 636f 756e  r_msg = f"Encoun
-0000c7b0: 7465 7265 6420 6572 726f 7220 6f6e 2072  tered error on r
-0000c7c0: 6561 6422 0d0a 2020 2020 2020 2020 2020  ead"..          
-0000c7d0: 2020 2020 2020 2020 2020 2020 2020 7265                re
-0000c7e0: 7370 6f6e 7365 2e65 7272 6f72 5f6c 766c  sponse.error_lvl
-0000c7f0: 203d 2045 7272 6f72 4c65 7665 6c2e 6869   = ErrorLevel.hi
-0000c800: 6768 0d0a 2020 2020 2020 2020 2020 2020  gh..            
-0000c810: 2020 2020 2020 2020 2020 2020 7265 7370              resp
-0000c820: 6f6e 7365 2e70 6f69 736f 6e5f 7069 6c6c  onse.poison_pill
-0000c830: 203d 2054 7275 6520 2320 756e 7265 636f   = True # unreco
-0000c840: 7665 7261 626c 650d 0a20 2020 2020 2020  verable..       
-0000c850: 2020 2020 2020 2020 2020 2020 2065 6c69               eli
-0000c860: 6620 7365 6c66 2e73 6574 7469 6e67 732e  f self.settings.
-0000c870: 7374 6174 652e 7472 6967 6765 725f 736f  state.trigger_so
-0000c880: 7572 6365 203d 3d20 5370 6563 7472 6f6d  urce == Spectrom
-0000c890: 6574 6572 5374 6174 652e 5452 4947 4745  eterState.TRIGGE
-0000c8a0: 525f 534f 5552 4345 5f45 5854 4552 4e41  R_SOURCE_EXTERNA
-0000c8b0: 4c3a 0d0a 2020 2020 2020 2020 2020 2020  L:..            
-0000c8c0: 2020 2020 2020 2020 2020 2020 2320 7765              # we
-0000c8d0: 2064 6f6e 2774 206b 6e6f 7720 686f 7720   don't know how 
-0000c8e0: 6c6f 6e67 2077 6527 6c6c 2068 6176 6520  long we'll have 
-0000c8f0: 746f 2077 6169 7420 666f 7220 7468 6520  to wait for the 
-0000c900: 7472 6967 6765 722c 2073 6f0d 0a20 2020  trigger, so..   
-0000c910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c920: 2020 2020 2023 206a 7573 7420 6c6f 6f70       # just loop
-0000c930: 2061 6e64 2068 6f70 650d 0a20 2020 2020   and hope..     
-0000c940: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c950: 2020 2023 206c 6f67 2e64 6562 7567 2822     # log.debug("
-0000c960: 7374 696c 6c20 7761 6974 696e 6720 666f  still waiting fo
-0000c970: 7220 6578 7465 726e 616c 2074 7269 6767  r external trigg
-0000c980: 6572 2229 0d0a 2020 2020 2020 2020 2020  er")..          
-0000c990: 2020 2020 2020 2020 2020 2020 2020 7061                pa
-0000c9a0: 7373 0d0a 2020 2020 2020 2020 2020 2020  ss..            
-0000c9b0: 2020 2020 2020 2020 656c 7365 3a0d 0a20          else:.. 
-0000c9c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c9d0: 2020 2020 2020 206c 6f67 2e65 7272 6f72         log.error
-0000c9e0: 2866 2245 6e63 6f75 6e74 6572 6564 2065  (f"Encountered e
-0000c9f0: 7272 6f72 206f 6e20 7265 6164 206f 6620  rror on read of 
-0000ca00: 7b65 7863 7d22 290d 0a20 2020 2020 2020  {exc}")..       
-0000ca10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ca20: 2072 6573 706f 6e73 652e 6572 726f 725f   response.error_
-0000ca30: 6d73 6720 3d20 6622 456e 636f 756e 7465  msg = f"Encounte
-0000ca40: 7265 6420 6572 726f 7220 6f6e 2072 6561  red error on rea
-0000ca50: 6422 0d0a 2020 2020 2020 2020 2020 2020  d"..            
-0000ca60: 2020 2020 2020 2020 2020 2020 7265 7370              resp
-0000ca70: 6f6e 7365 2e65 7272 6f72 5f6c 766c 203d  onse.error_lvl =
-0000ca80: 2045 7272 6f72 4c65 7665 6c2e 6869 6768   ErrorLevel.high
-0000ca90: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000caa0: 2020 2020 2020 7265 7475 726e 2072 6573        return res
-0000cab0: 706f 6e73 650d 0a0d 0a20 2020 2020 2020  ponse....       
-0000cac0: 2020 2020 2023 2054 6869 7320 6973 2061       # This is a
-0000cad0: 2063 6f6e 766f 6c75 7465 6420 7761 7920   convoluted way 
-0000cae0: 746f 2069 7465 7261 7465 2061 6372 6f73  to iterate acros
-0000caf0: 7320 7468 6520 7265 6365 6976 6564 2062  s the received b
-0000cb00: 7974 6573 2069 6e20 2764 6174 6127 2061  ytes in 'data' a
-0000cb10: 730d 0a20 2020 2020 2020 2020 2020 2023  s..            #
-0000cb20: 2074 776f 2069 6e74 6572 6c65 6176 6564   two interleaved
-0000cb30: 2061 7272 6179 732c 2062 6f74 6820 6f6e   arrays, both on
-0000cb40: 6c79 2070 726f 6365 7373 696e 6720 616c  ly processing al
-0000cb50: 7465 726e 6174 696e 6720 6279 7465 732c  ternating bytes,
-0000cb60: 2062 7574 206f 6e65 2028 6929 0d0a 2020   but one (i)..  
-0000cb70: 2020 2020 2020 2020 2020 2320 7374 6172            # star
-0000cb80: 7469 6e67 2061 7420 7a65 726f 2028 6576  ting at zero (ev
-0000cb90: 656e 2062 7974 6573 2920 616e 6420 7468  en bytes) and th
-0000cba0: 6520 6f74 6865 7220 286a 2920 7374 6172  e other (j) star
-0000cbb0: 7469 6e67 2061 7420 3120 286f 6464 2062  ting at 1 (odd b
-0000cbc0: 7974 6573 292e 0d0a 2020 2020 2020 2020  ytes)...        
-0000cbd0: 2020 2020 7375 6273 7065 6374 7275 6d20      subspectrum 
-0000cbe0: 3d20 5b69 6e74 2869 207c 2028 6a20 3c3c  = [int(i | (j <<
-0000cbf0: 2038 2929 2066 6f72 2069 2c20 6a20 696e   8)) for i, j in
-0000cc00: 207a 6970 2864 6174 615b 3a3a 325d 2c20   zip(data[::2], 
-0000cc10: 6461 7461 5b31 3a3a 325d 295d 2023 204c  data[1::2])] # L
-0000cc20: 5342 2d4d 5342 0d0a 0d0a 2020 2020 2020  SB-MSB....      
-0000cc30: 2020 2020 2020 7370 6563 7472 756d 2e65        spectrum.e
-0000cc40: 7874 656e 6428 7375 6273 7065 6374 7275  xtend(subspectru
-0000cc50: 6d29 0d0a 0d0a 2020 2020 2020 2020 2020  m)....          
-0000cc60: 2020 2320 656d 7069 7269 6361 6c6c 7920    # empirically 
-0000cc70: 6465 7465 726d 696e 6564 206e 6565 6420  determined need 
-0000cc80: 666f 7220 356d 7320 6465 6c61 7920 7768  for 5ms delay wh
-0000cc90: 656e 2073 7769 7463 6869 6e67 2065 6e64  en switching end
-0000cca0: 706f 696e 7473 0d0a 2020 2020 2020 2020  points..        
-0000ccb0: 2020 2020 2320 6f6e 2032 3034 3870 7820      # on 2048px 
-0000ccc0: 6465 7465 6374 6f72 7320 6475 7269 6e67  detectors during
-0000ccd0: 2061 7265 6120 7363 616e 0d0a 2020 2020   area scan..    
-0000cce0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-0000ccf0: 7365 7474 696e 6773 2e73 7461 7465 2e61  settings.state.a
-0000cd00: 7265 615f 7363 616e 5f65 6e61 626c 6564  rea_scan_enabled
-0000cd10: 2061 6e64 2070 6978 656c 7320 3d3d 2032   and pixels == 2
-0000cd20: 3034 383a 2023 2061 6e64 2065 6e64 706f  048: # and endpo
-0000cd30: 696e 7420 3d3d 2030 7838 323a 0d0a 2020  int == 0x82:..  
-0000cd40: 2020 2020 2020 2020 2020 2020 2020 6c6f                lo
-0000cd50: 672e 6465 6275 6728 2273 6c65 6570 696e  g.debug("sleepin
-0000cd60: 6720 356d 7320 6265 7477 6565 6e20 656e  g 5ms between en
-0000cd70: 6470 6f69 6e74 7322 290d 0a20 2020 2020  dpoints")..     
-0000cd80: 2020 2020 2020 2020 2020 2073 6c65 6570             sleep
-0000cd90: 2830 2e30 3035 290d 0a0d 0a20 2020 2020  (0.005)....     
-0000cda0: 2020 2023 2323 2323 2323 2323 2323 2323     #############
+00007f90: 206c 6162 656c 3a20 7374 7220 3d20 2222   label: str = ""
+00007fa0: 2c20 0a20 2020 2020 2020 2020 2020 2020  , .             
+00007fb0: 2020 2020 206d 7362 5f6c 656e 3a20 696e       msb_len: in
+00007fc0: 7420 3d20 4e6f 6e65 2c20 0a20 2020 2020  t = None, .     
+00007fd0: 2020 2020 2020 2020 2020 2020 206c 7362               lsb
+00007fe0: 5f6c 656e 3a20 696e 7420 3d20 4e6f 6e65  _len: int = None
+00007ff0: 2920 2d3e 2053 7065 6374 726f 6d65 7465  ) -> Spectromete
+00008000: 7252 6573 706f 6e73 653a 0a20 2020 2020  rResponse:.     
+00008010: 2020 2070 7265 6669 7820 3d20 2222 2069     prefix = "" i
+00008020: 6620 6e6f 7420 6c61 6265 6c20 656c 7365  f not label else
+00008030: 2028 2225 733a 2022 2025 206c 6162 656c   ("%s: " % label
+00008040: 290a 2020 2020 2020 2020 7265 7375 6c74  ).        result
+00008050: 203d 204e 6f6e 650a 0a20 2020 2020 2020   = None..       
+00008060: 2069 6620 7365 6c66 2e73 6875 7464 6f77   if self.shutdow
+00008070: 6e5f 7265 7175 6573 7465 6420 6f72 2028  n_requested or (
+00008080: 6e6f 7420 7365 6c66 2e63 6f6e 6e65 6374  not self.connect
+00008090: 6564 2061 6e64 206e 6f74 2073 656c 662e  ed and not self.
+000080a0: 636f 6e6e 6563 7469 6e67 293a 0a20 2020  connecting):.   
+000080b0: 2020 2020 2020 2020 206c 6f67 2e64 6562           log.deb
+000080c0: 7567 2822 5f67 6574 5f63 6f64 653a 206e  ug("_get_code: n
+000080d0: 6f74 2061 7474 656d 7074 696e 6720 6265  ot attempting be
+000080e0: 6361 7573 6520 6e6f 7420 636f 6e6e 6563  cause not connec
+000080f0: 7465 6422 290a 2020 2020 2020 2020 2020  ted").          
+00008100: 2020 7265 7475 726e 2053 7065 6374 726f    return Spectro
+00008110: 6d65 7465 7252 6573 706f 6e73 6528 290a  meterResponse().
+00008120: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
+00008130: 2e5f 6368 6563 6b5f 666f 725f 7261 6e64  ._check_for_rand
+00008140: 6f6d 5f65 7272 6f72 2829 3a0a 2020 2020  om_error():.    
+00008150: 2020 2020 2020 2020 6c6f 672e 6465 6275          log.debu
+00008160: 6728 2272 616e 646f 6d20 6572 726f 7222  g("random error"
+00008170: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+00008180: 7475 726e 2053 7065 6374 726f 6d65 7465  turn Spectromete
+00008190: 7252 6573 706f 6e73 6528 706f 6973 6f6e  rResponse(poison
+000081a0: 5f70 696c 6c3d 5472 7565 290a 0a20 2020  _pill=True)..   
+000081b0: 2020 2020 2074 7279 3a0a 2020 2020 2020       try:.      
+000081c0: 2020 2020 2020 7365 6c66 2e5f 7761 6974        self._wait
+000081d0: 5f66 6f72 5f75 7362 5f61 7661 696c 6162  _for_usb_availab
+000081e0: 6c65 2829 0a20 2020 2020 2020 2020 2020  le().           
+000081f0: 2072 6573 756c 7420 3d20 7365 6c66 2e64   result = self.d
+00008200: 6576 6963 655f 7479 7065 2e63 7472 6c5f  evice_type.ctrl_
+00008210: 7472 616e 7366 6572 2873 656c 662e 6465  transfer(self.de
+00008220: 7669 6365 2c0a 2020 2020 2020 2020 2020  vice,.          
+00008230: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008240: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008250: 2020 2020 2030 7863 302c 2020 2020 2020       0xc0,      
+00008260: 2020 2320 4445 5649 4345 5f54 4f5f 484f    # DEVICE_TO_HO
+00008270: 5354 0a20 2020 2020 2020 2020 2020 2020  ST.             
+00008280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008290: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000082a0: 2020 6252 6571 7565 7374 2c0a 2020 2020    bRequest,.    
+000082b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000082c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000082d0: 2020 2020 2020 2020 2020 2077 5661 6c75             wValu
+000082e0: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
+000082f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008300: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008310: 2020 7749 6e64 6578 2c0a 2020 2020 2020    wIndex,.      
+00008320: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008330: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008340: 2020 2020 2020 2020 2077 4c65 6e67 7468           wLength
+00008350: 290a 2020 2020 2020 2020 6578 6365 7074  ).        except
+00008360: 2045 7863 6570 7469 6f6e 2061 7320 6578   Exception as ex
+00008370: 633a 0a20 2020 2020 2020 2020 2020 206c  c:.            l
+00008380: 6f67 2e63 7269 7469 6361 6c28 6622 4861  og.critical(f"Ha
+00008390: 7264 7761 7265 2046 6169 6c75 7265 2046  rdware Failure F
+000083a0: 4944 2047 6574 2043 6f64 6520 5072 6f62  ID Get Code Prob
+000083b0: 6c65 6d20 7769 7468 2063 7472 6c20 7472  lem with ctrl tr
+000083c0: 616e 7366 6572 2028 6252 6571 7565 7374  ansfer (bRequest
+000083d0: 2030 787b 6252 6571 7565 7374 3a30 3278   0x{bRequest:02x
+000083e0: 7d2c 2077 5661 6c75 6520 3078 7b77 5661  }, wValue 0x{wVa
+000083f0: 6c75 653a 3034 787d 2c20 7749 6e64 6578  lue:04x}, wIndex
+00008400: 2030 787b 7749 6e64 6578 3a30 3478 7d2c   0x{wIndex:04x},
+00008410: 206c 6162 656c 207b 6c61 6265 6c7d 2922   label {label})"
+00008420: 2c20 6578 635f 696e 666f 3d31 290a 2020  , exc_info=1).  
+00008430: 2020 2020 2020 2020 2020 7365 6c66 2e5f            self._
+00008440: 7363 6865 6475 6c65 5f64 6973 636f 6e6e  schedule_disconn
+00008450: 6563 7428 6578 6329 0a20 2020 2020 2020  ect(exc).       
+00008460: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
+00008470: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
+00008480: 2870 6f69 736f 6e5f 7069 6c6c 3d54 7275  (poison_pill=Tru
+00008490: 6529 0a0a 2020 2020 2020 2020 7265 7375  e)..        resu
+000084a0: 6c74 5f68 6578 203d 2022 2022 2e6a 6f69  lt_hex = " ".joi
+000084b0: 6e28 5b66 227b 763a 3032 787d 2220 666f  n([f"{v:02x}" fo
+000084c0: 7220 7620 696e 2072 6573 756c 745d 290a  r v in result]).
+000084d0: 2020 2020 2020 2020 6c6f 672e 6465 6275          log.debu
+000084e0: 6728 2225 735f 6765 745f 636f 6465 3a20  g("%s_get_code: 
+000084f0: 7265 7175 6573 7420 3078 2530 3278 2076  request 0x%02x v
+00008500: 616c 7565 2030 7825 3034 7820 696e 6465  alue 0x%04x inde
+00008510: 7820 3078 2530 3478 203d 205b 2573 5d22  x 0x%04x = [%s]"
+00008520: 2c0a 2020 2020 2020 2020 2020 2020 7072  ,.            pr
+00008530: 6566 6978 2c20 6252 6571 7565 7374 2c20  efix, bRequest, 
+00008540: 7756 616c 7565 2c20 7749 6e64 6578 2c20  wValue, wIndex, 
+00008550: 7265 7375 6c74 5f68 6578 290a 0a20 2020  result_hex)..   
+00008560: 2020 2020 2069 6620 7265 7375 6c74 2069       if result i
+00008570: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
+00008580: 2020 2020 6c6f 672e 6372 6974 6963 616c      log.critical
+00008590: 2822 5f67 6574 5f63 6f64 655b 2573 2c20  ("_get_code[%s, 
+000085a0: 2573 5d3a 2072 6563 6569 7665 6420 6e75  %s]: received nu
+000085b0: 6c6c 222c 206c 6162 656c 2c20 7365 6c66  ll", label, self
+000085c0: 2e64 6576 6963 655f 6964 290a 2020 2020  .device_id).    
+000085d0: 2020 2020 2020 2020 7365 6c66 2e5f 7363          self._sc
+000085e0: 6865 6475 6c65 5f64 6973 636f 6e6e 6563  hedule_disconnec
+000085f0: 7428 6622 5f67 6574 5f63 6f64 655b 7b6c  t(f"_get_code[{l
+00008600: 6162 656c 7d5d 2072 6563 6569 7665 6420  abel}] received 
+00008610: 4e55 4c4c 2229 0a20 2020 2020 2020 2020  NULL").         
+00008620: 2020 2072 6574 7572 6e20 5370 6563 7472     return Spectr
+00008630: 6f6d 6574 6572 5265 7370 6f6e 7365 286b  ometerResponse(k
+00008640: 6565 705f 616c 6976 653d 5472 7565 290a  eep_alive=True).
+00008650: 0a20 2020 2020 2020 2023 2064 656d 6172  .        # demar
+00008660: 7368 616c 6c20 6f72 2072 6574 7572 6e20  shall or return 
+00008670: 7261 7720 6172 7261 790a 2020 2020 2020  raw array.      
+00008680: 2020 7661 6c75 6520 3d20 300a 2020 2020    value = 0.    
+00008690: 2020 2020 6966 206d 7362 5f6c 656e 2069      if msb_len i
+000086a0: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
+000086b0: 2020 2020 2020 2020 666f 7220 6920 696e          for i in
+000086c0: 2072 616e 6765 286d 7362 5f6c 656e 293a   range(msb_len):
+000086d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000086e0: 2076 616c 7565 203d 2076 616c 7565 203c   value = value <
+000086f0: 3c20 3820 7c20 7265 7375 6c74 5b69 5d0a  < 8 | result[i].
+00008700: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00008710: 726e 2053 7065 6374 726f 6d65 7465 7252  rn SpectrometerR
+00008720: 6573 706f 6e73 6528 6461 7461 3d76 616c  esponse(data=val
+00008730: 7565 290a 2020 2020 2020 2020 656c 6966  ue).        elif
+00008740: 206c 7362 5f6c 656e 2069 7320 6e6f 7420   lsb_len is not 
+00008750: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+00008760: 2020 666f 7220 6920 696e 2072 616e 6765    for i in range
+00008770: 286c 7362 5f6c 656e 293a 0a20 2020 2020  (lsb_len):.     
+00008780: 2020 2020 2020 2020 2020 2069 6620 6920             if i 
+00008790: 3c20 6c65 6e28 7265 7375 6c74 293a 0a20  < len(result):. 
+000087a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000087b0: 2020 2076 616c 7565 203d 2028 7265 7375     value = (resu
+000087c0: 6c74 5b69 5d20 3c3c 2028 3820 2a20 6929  lt[i] << (8 * i)
+000087d0: 2920 7c20 7661 6c75 650a 2020 2020 2020  ) | value.      
+000087e0: 2020 2020 2020 7265 7475 726e 2053 7065        return Spe
+000087f0: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
+00008800: 6528 6461 7461 3d76 616c 7565 290a 2020  e(data=value).  
+00008810: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00008820: 2020 2020 2020 2020 7265 7475 726e 2053          return S
+00008830: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
+00008840: 6e73 6528 6461 7461 3d72 6573 756c 7429  nse(data=result)
+00008850: 0a0a 2020 2020 6465 6620 6765 745f 7570  ..    def get_up
+00008860: 7065 725f 636f 6465 2873 656c 662c 200a  per_code(self, .
+00008870: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008880: 2020 2020 2020 2077 5661 6c75 653a 2069         wValue: i
+00008890: 6e74 2c20 0a20 2020 2020 2020 2020 2020  nt, .           
+000088a0: 2020 2020 2020 2020 2020 2020 7749 6e64              wInd
+000088b0: 6578 3a20 696e 7420 3d20 302c 200a 2020  ex: int = 0, .  
+000088c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000088d0: 2020 2020 2077 4c65 6e67 7468 3a20 696e       wLength: in
+000088e0: 7420 3d20 3634 2c20 0a20 2020 2020 2020  t = 64, .       
+000088f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008900: 6c61 6265 6c3a 2073 7472 203d 2022 222c  label: str = "",
+00008910: 200a 2020 2020 2020 2020 2020 2020 2020   .              
+00008920: 2020 2020 2020 2020 206d 7362 5f6c 656e           msb_len
+00008930: 3a20 696e 7420 3d20 4e6f 6e65 2c20 0a20  : int = None, . 
+00008940: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008950: 2020 2020 2020 6c73 625f 6c65 6e3a 2069        lsb_len: i
+00008960: 6e74 203d 204e 6f6e 6529 202d 3e20 5370  nt = None) -> Sp
+00008970: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
+00008980: 7365 3a0a 2020 2020 2020 2020 7265 7475  se:.        retu
+00008990: 726e 2073 656c 662e 5f67 6574 5f63 6f64  rn self._get_cod
+000089a0: 6528 3078 6666 2c20 7756 616c 7565 2c20  e(0xff, wValue, 
+000089b0: 7749 6e64 6578 2c20 774c 656e 6774 682c  wIndex, wLength,
+000089c0: 206c 6162 656c 3d6c 6162 656c 2c20 6d73   label=label, ms
+000089d0: 625f 6c65 6e3d 6d73 625f 6c65 6e2c 206c  b_len=msb_len, l
+000089e0: 7362 5f6c 656e 3d6c 7362 5f6c 656e 290a  sb_len=lsb_len).
+000089f0: 0a20 2020 2023 2023 2323 2323 2323 2323  .    # #########
+00008a00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00008a10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00008a20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00008a30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00008a40: 230a 2020 2020 2320 696e 6974 6961 6c69  #.    # initiali
+00008a50: 7a61 7469 6f6e 0a20 2020 2023 2023 2323  zation.    # ###
+00008a60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00008a70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00008a80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00008a90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00008aa0: 2323 2323 2323 230a 0a20 2020 2064 6566  #######..    def
+00008ab0: 205f 7265 6164 5f65 6570 726f 6d28 7365   _read_eeprom(se
+00008ac0: 6c66 293a 0a20 2020 2020 2020 2062 7566  lf):.        buf
+00008ad0: 6665 7273 203d 205b 5d0a 2020 2020 2020  fers = [].      
+00008ae0: 2020 666f 7220 7061 6765 2069 6e20 7261    for page in ra
+00008af0: 6e67 6528 4545 5052 4f4d 2e4d 4158 5f50  nge(EEPROM.MAX_P
+00008b00: 4147 4553 293a 0a20 2020 2020 2020 2020  AGES):.         
+00008b10: 2020 2062 7566 203d 204e 6f6e 650a 2020     buf = None.  
+00008b20: 2020 2020 2020 2020 2020 7472 793a 0a20            try:. 
+00008b30: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00008b40: 6573 706f 6e73 6520 3d20 7365 6c66 2e67  esponse = self.g
+00008b50: 6574 5f75 7070 6572 5f63 6f64 6528 3078  et_upper_code(0x
+00008b60: 3031 2c20 7061 6765 2c20 6c61 6265 6c3d  01, page, label=
+00008b70: 2247 4554 5f4d 4f44 454c 5f43 4f4e 4649  "GET_MODEL_CONFI
+00008b80: 4728 2564 2922 2025 2070 6167 6529 0a20  G(%d)" % page). 
+00008b90: 2020 2020 2020 2020 2020 2020 2020 2062                 b
+00008ba0: 7566 203d 2072 6573 706f 6e73 652e 6461  uf = response.da
+00008bb0: 7461 0a20 2020 2020 2020 2020 2020 2020  ta.             
+00008bc0: 2020 2069 6620 7265 7370 6f6e 7365 2e65     if response.e
+00008bd0: 7272 6f72 5f6c 766c 2021 3d20 4572 726f  rror_lvl != Erro
+00008be0: 724c 6576 656c 2e6f 6b3a 0a20 2020 2020  rLevel.ok:.     
+00008bf0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00008c00: 6574 7572 6e20 7265 7370 6f6e 7365 0a20  eturn response. 
+00008c10: 2020 2020 2020 2020 2020 2065 7863 6570             excep
+00008c20: 743a 0a20 2020 2020 2020 2020 2020 2020  t:.             
+00008c30: 2020 206c 6f67 2e65 7272 6f72 2822 6578     log.error("ex
+00008c40: 6365 7074 696f 6e20 7265 6164 696e 6720  ception reading 
+00008c50: 7570 7065 725f 636f 6465 2030 7830 3120  upper_code 0x01 
+00008c60: 7769 7468 2070 6167 6520 2564 222c 2070  with page %d", p
+00008c70: 6167 652c 2065 7863 5f69 6e66 6f3d 3129  age, exc_info=1)
+00008c80: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00008c90: 6275 6620 6973 204e 6f6e 653a 0a20 2020  buf is None:.   
+00008ca0: 2020 2020 2020 2020 2020 2020 206d 7367               msg
+00008cb0: 203d 2022 756e 6162 6c65 2074 6f20 7265   = "unable to re
+00008cc0: 6164 2045 4550 524f 4d20 286e 756c 6c20  ad EEPROM (null 
+00008cd0: 6275 6629 220a 2020 2020 2020 2020 2020  buf)".          
+00008ce0: 2020 2020 2020 6c6f 672e 6572 726f 7228        log.error(
+00008cf0: 6d73 6729 0a20 2020 2020 2020 2020 2020  msg).           
+00008d00: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
+00008d10: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
+00008d20: 2846 616c 7365 2c20 6572 726f 725f 6c76  (False, error_lv
+00008d30: 6c3d 4572 726f 724c 6576 656c 2e6d 6564  l=ErrorLevel.med
+00008d40: 6975 6d2c 6572 726f 725f 6d73 673d 6d73  ium,error_msg=ms
+00008d50: 6729 0a20 2020 2020 2020 2020 2020 2065  g).            e
+00008d60: 6c69 6620 6c65 6e28 6275 6629 203c 2036  lif len(buf) < 6
+00008d70: 343a 0a20 2020 2020 2020 2020 2020 2020  4:.             
+00008d80: 2020 206d 7367 203d 2066 2275 6e61 626c     msg = f"unabl
+00008d90: 6520 746f 2072 6561 6420 4545 5052 4f4d  e to read EEPROM
+00008da0: 2072 6563 6569 7665 6420 6275 6620 6f66   received buf of
+00008db0: 207b 6275 667d 2061 6e64 206c 656e 207b   {buf} and len {
+00008dc0: 6c65 6e28 6275 6629 7d22 0a20 2020 2020  len(buf)}".     
+00008dd0: 2020 2020 2020 2020 2020 206c 6f67 2e65             log.e
+00008de0: 7272 6f72 286d 7367 290a 2020 2020 2020  rror(msg).      
+00008df0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00008e00: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
+00008e10: 706f 6e73 6528 4661 6c73 652c 2065 7272  ponse(False, err
+00008e20: 6f72 5f6c 766c 3d45 7272 6f72 4c65 7665  or_lvl=ErrorLeve
+00008e30: 6c2e 6d65 6469 756d 2c65 7272 6f72 5f6d  l.medium,error_m
+00008e40: 7367 3d6d 7367 290a 2020 2020 2020 2020  sg=msg).        
+00008e50: 2020 2020 6275 6666 6572 732e 6170 7065      buffers.appe
+00008e60: 6e64 2862 7566 290a 0a20 2020 2020 2020  nd(buf)..       
+00008e70: 2066 6c61 745f 6275 6666 6572 735f 616c   flat_buffers_al
+00008e80: 6c5f 6f6e 6573 203d 2054 7275 650a 2020  l_ones = True.  
+00008e90: 2020 2020 2020 666f 7220 7061 6765 2069        for page i
+00008ea0: 6e20 6275 6666 6572 733a 0a20 2020 2020  n buffers:.     
+00008eb0: 2020 2020 2020 2066 6f72 2062 7974 6520         for byte 
+00008ec0: 696e 2070 6167 653a 0a20 2020 2020 2020  in page:.       
+00008ed0: 2020 2020 2020 2020 2066 6c61 745f 6275           flat_bu
+00008ee0: 6666 6572 735f 616c 6c5f 6f6e 6573 203d  ffers_all_ones =
+00008ef0: 2066 6c61 745f 6275 6666 6572 735f 616c   flat_buffers_al
+00008f00: 6c5f 6f6e 6573 2061 6e64 2028 6279 7465  l_ones and (byte
+00008f10: 203d 3d20 3078 4646 290a 0a20 2020 2020   == 0xFF)..     
+00008f20: 2020 2069 6620 666c 6174 5f62 7566 6665     if flat_buffe
+00008f30: 7273 5f61 6c6c 5f6f 6e65 733a 0a20 2020  rs_all_ones:.   
+00008f40: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00008f50: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
+00008f60: 6f6e 7365 2864 6174 613d 4661 6c73 652c  onse(data=False,
+00008f70: 6572 726f 725f 6d73 673d 2253 6177 2061  error_msg="Saw a
+00008f80: 6c6c 2046 7320 666f 7220 4545 5052 4f4d  ll Fs for EEPROM
+00008f90: 2e20 4368 6563 6b20 4545 5052 4f4d 2050  . Check EEPROM P
+00008fa0: 726f 6772 616d 6d65 642e 222c 6572 726f  rogrammed.",erro
+00008fb0: 725f 6c76 6c3d 4572 726f 724c 6576 656c  r_lvl=ErrorLevel
+00008fc0: 2e6c 6f77 290a 2020 2020 2020 2020 7265  .low).        re
+00008fd0: 7475 726e 2053 7065 6374 726f 6d65 7465  turn Spectromete
+00008fe0: 7252 6573 706f 6e73 6528 6461 7461 3d73  rResponse(data=s
+00008ff0: 656c 662e 7365 7474 696e 6773 2e65 6570  elf.settings.eep
+00009000: 726f 6d2e 7061 7273 6528 6275 6666 6572  rom.parse(buffer
+00009010: 7329 290a 0a20 2020 2064 6566 2068 6173  s))..    def has
+00009020: 5f6c 696e 6561 7269 7479 5f63 6f65 6666  _linearity_coeff
+00009030: 7328 7365 6c66 293a 0a20 2020 2020 2020  s(self):.       
+00009040: 2022 2222 0a20 2020 2020 2020 2041 7420   """.        At 
+00009050: 6c65 6173 7420 6f6e 6520 6c69 6e65 6172  least one linear
+00009060: 6974 7920 636f 6566 6620 6973 206f 7468  ity coeff is oth
+00009070: 6572 2074 6861 6e20 3020 6f72 202d 3120  er than 0 or -1 
+00009080: 2861 6e64 206e 6f20 4e61 4e29 2e0a 0a20  (and no NaN)... 
+00009090: 2020 2020 2020 2050 7562 6c69 6320 6265         Public be
+000090a0: 6361 7573 6520 7573 6564 2062 7920 7761  cause used by wa
+000090b0: 7361 7463 682d 7368 656c 6c2e 0a20 2020  satch-shell..   
+000090c0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+000090d0: 2069 6620 7365 6c66 2e73 6574 7469 6e67   if self.setting
+000090e0: 732e 6565 7072 6f6d 2e6c 696e 6561 7269  s.eeprom.lineari
+000090f0: 7479 5f63 6f65 6666 733a 0a20 2020 2020  ty_coeffs:.     
+00009100: 2020 2020 2020 2066 6f72 2063 2069 6e20         for c in 
+00009110: 7365 6c66 2e73 6574 7469 6e67 732e 6565  self.settings.ee
+00009120: 7072 6f6d 2e6c 696e 6561 7269 7479 5f63  prom.linearity_c
+00009130: 6f65 6666 733a 0a20 2020 2020 2020 2020  oeffs:.         
+00009140: 2020 2020 2020 2069 6620 6d61 7468 2e69         if math.i
+00009150: 736e 616e 2863 293a 0a20 2020 2020 2020  snan(c):.       
+00009160: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+00009170: 7572 6e20 4661 6c73 650a 2020 2020 2020  urn False.      
+00009180: 2020 2020 2020 666f 7220 6320 696e 2073        for c in s
+00009190: 656c 662e 7365 7474 696e 6773 2e65 6570  elf.settings.eep
+000091a0: 726f 6d2e 6c69 6e65 6172 6974 795f 636f  rom.linearity_co
+000091b0: 6566 6673 3a0a 2020 2020 2020 2020 2020  effs:.          
+000091c0: 2020 2020 2020 6966 2063 2021 3d20 3020        if c != 0 
+000091d0: 616e 6420 6320 213d 202d 313a 0a20 2020  and c != -1:.   
+000091e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000091f0: 2072 6574 7572 6e20 5472 7565 0a20 2020   return True.   
+00009200: 2020 2020 2072 6574 7572 6e20 4661 6c73       return Fals
+00009210: 650a 0a20 2020 2064 6566 205f 7265 6164  e..    def _read
+00009220: 5f66 7067 615f 636f 6d70 696c 6174 696f  _fpga_compilatio
+00009230: 6e5f 6f70 7469 6f6e 7328 7365 6c66 293a  n_options(self):
+00009240: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
+00009250: 2e73 6574 7469 6e67 732e 6973 5f61 726d  .settings.is_arm
+00009260: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
+00009270: 6c6f 672e 6465 6275 6728 2241 524d 2073  log.debug("ARM s
+00009280: 7065 6374 726f 6d65 7465 7273 206e 6f20  pectrometers no 
+00009290: 6c6f 6e67 6572 2073 7570 706f 7274 696e  longer supportin
+000092a0: 6720 4650 4741 2063 6f6d 7069 6c61 7469  g FPGA compilati
+000092b0: 6f6e 206f 7074 696f 6e73 2229 0a20 2020  on options").   
+000092c0: 2020 2020 2020 2020 2072 6574 7572 6e0a           return.
+000092d0: 2020 2020 2020 2020 2020 2020 0a20 2020              .   
+000092e0: 2020 2020 2072 6573 706f 6e73 6520 3d20       response = 
+000092f0: 7365 6c66 2e67 6574 5f75 7070 6572 5f63  self.get_upper_c
+00009300: 6f64 6528 3078 3034 2c20 6c61 6265 6c3d  ode(0x04, label=
+00009310: 2252 4541 445f 434f 4d50 494c 4154 494f  "READ_COMPILATIO
+00009320: 4e5f 4f50 5449 4f4e 5322 2c20 6c73 625f  N_OPTIONS", lsb_
+00009330: 6c65 6e3d 3329 0a20 2020 2020 2020 2077  len=3).        w
+00009340: 6f72 6420 3d20 7265 7370 6f6e 7365 2e64  ord = response.d
+00009350: 6174 610a 2020 2020 2020 2020 7365 6c66  ata.        self
+00009360: 2e73 6574 7469 6e67 732e 6670 6761 5f6f  .settings.fpga_o
+00009370: 7074 696f 6e73 2e70 6172 7365 2877 6f72  ptions.parse(wor
+00009380: 6429 0a0a 2020 2020 2320 2323 2323 2323  d)..    # ######
+00009390: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000093a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000093b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000093c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000093d0: 2323 2323 0a20 2020 2023 2041 6363 6573  ####.    # Acces
+000093e0: 736f 7273 0a20 2020 2023 2023 2323 2323  sors.    # #####
+000093f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00009400: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00009410: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00009420: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00009430: 2323 2323 230a 0a20 2020 2023 2040 746f  #####..    # @to
+00009440: 646f 2074 6573 7420 656e 6469 616e 206f  do test endian o
+00009450: 7264 6572 2028 696e 2061 6e64 206f 7574  rder (in and out
+00009460: 290a 2020 2020 6465 6620 6765 745f 6261  ).    def get_ba
+00009470: 7474 6572 795f 7265 6769 7374 6572 2873  ttery_register(s
+00009480: 656c 662c 2072 6567 3a20 696e 7429 3a0a  elf, reg: int):.
+00009490: 2020 2020 2020 2020 7265 6720 3d20 7265          reg = re
+000094a0: 6720 2620 3078 6666 6666 0a20 2020 2020  g & 0xffff.     
+000094b0: 2020 2072 6574 7572 6e20 7365 6c66 2e67     return self.g
+000094c0: 6574 5f75 7070 6572 5f63 6f64 6528 3078  et_upper_code(0x
+000094d0: 3134 2c20 7749 6e64 6578 3d72 6567 2c20  14, wIndex=reg, 
+000094e0: 6c61 6265 6c3d 2247 4554 5f42 4154 5445  label="GET_BATTE
+000094f0: 5259 5f52 4547 222c 206d 7362 5f6c 656e  RY_REG", msb_len
+00009500: 3d32 290a 0a20 2020 2064 6566 2067 6574  =2)..    def get
+00009510: 5f62 6174 7465 7279 5f73 7461 7465 5f72  _battery_state_r
+00009520: 6177 2873 656c 6629 3a0a 2020 2020 2020  aw(self):.      
+00009530: 2020 2222 2252 6574 7269 6576 6573 2074    """Retrieves t
+00009540: 6865 2072 6177 2062 6174 7465 7279 2072  he raw battery r
+00009550: 6561 6469 6e67 2061 6e64 2074 6865 6e20  eading and then 
+00009560: 6361 6368 6573 2069 7420 666f 7220 3120  caches it for 1 
+00009570: 7365 6322 2222 0a20 2020 2020 2020 206e  sec""".        n
+00009580: 6f77 203d 2064 6174 6574 696d 652e 6461  ow = datetime.da
+00009590: 7465 7469 6d65 2e6e 6f77 2829 0a20 2020  tetime.now().   
+000095a0: 2020 2020 2069 6620 7365 6c66 2e73 6574       if self.set
+000095b0: 7469 6e67 732e 7374 6174 652e 6261 7474  tings.state.batt
+000095c0: 6572 795f 7469 6d65 7374 616d 7020 6973  ery_timestamp is
+000095d0: 206e 6f74 204e 6f6e 6520 616e 6420 286e   not None and (n
+000095e0: 6f77 202d 2073 656c 662e 7365 7474 696e  ow - self.settin
+000095f0: 6773 2e73 7461 7465 2e62 6174 7465 7279  gs.state.battery
+00009600: 5f74 696d 6573 7461 6d70 292e 746f 7461  _timestamp).tota
+00009610: 6c5f 7365 636f 6e64 7328 2920 3c20 313a  l_seconds() < 1:
+00009620: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00009630: 7572 6e20 5370 6563 7472 6f6d 6574 6572  urn Spectrometer
+00009640: 5265 7370 6f6e 7365 2864 6174 613d 7365  Response(data=se
+00009650: 6c66 2e73 6574 7469 6e67 732e 7374 6174  lf.settings.stat
+00009660: 652e 6261 7474 6572 795f 7261 7729 0a0a  e.battery_raw)..
+00009670: 2020 2020 2020 2020 7365 6c66 2e73 6574          self.set
+00009680: 7469 6e67 732e 7374 6174 652e 6261 7474  tings.state.batt
+00009690: 6572 795f 7469 6d65 7374 616d 7020 3d20  ery_timestamp = 
+000096a0: 6e6f 770a 2020 2020 2020 2020 7265 7370  now.        resp
+000096b0: 6f6e 7365 203d 2073 656c 662e 6765 745f  onse = self.get_
+000096c0: 7570 7065 725f 636f 6465 2830 7831 332c  upper_code(0x13,
+000096d0: 206c 6162 656c 3d22 4745 545f 4241 5454   label="GET_BATT
+000096e0: 4552 595f 5354 4154 4522 2c20 6d73 625f  ERY_STATE", msb_
+000096f0: 6c65 6e3d 3329 0a20 2020 2020 2020 2073  len=3).        s
+00009700: 656c 662e 7365 7474 696e 6773 2e73 7461  elf.settings.sta
+00009710: 7465 2e62 6174 7465 7279 5f72 6177 203d  te.battery_raw =
+00009720: 2072 6573 706f 6e73 652e 6461 7461 0a0a   response.data..
+00009730: 2020 2020 2020 2020 6c6f 672e 6465 6275          log.debu
+00009740: 6728 6622 6261 7474 6572 795f 7374 6174  g(f"battery_stat
+00009750: 655f 7261 773a 2030 787b 7365 6c66 2e73  e_raw: 0x{self.s
+00009760: 6574 7469 6e67 732e 7374 6174 652e 6261  ettings.state.ba
+00009770: 7474 6572 795f 7261 773a 3034 787d 2229  ttery_raw:04x}")
+00009780: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00009790: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
+000097a0: 6f6e 7365 2864 6174 613d 7365 6c66 2e73  onse(data=self.s
+000097b0: 6574 7469 6e67 732e 7374 6174 652e 6261  ettings.state.ba
+000097c0: 7474 6572 795f 7261 7729 0a0a 2020 2020  ttery_raw)..    
+000097d0: 6465 6620 6765 745f 6261 7474 6572 795f  def get_battery_
+000097e0: 7065 7263 656e 7461 6765 2873 656c 6629  percentage(self)
+000097f0: 3a0a 2020 2020 2020 2020 7265 7370 6f6e  :.        respon
+00009800: 7365 203d 2073 656c 662e 6765 745f 6261  se = self.get_ba
+00009810: 7474 6572 795f 7374 6174 655f 7261 7728  ttery_state_raw(
+00009820: 290a 2020 2020 2020 2020 776f 7264 203d  ).        word =
+00009830: 2072 6573 706f 6e73 652e 6461 7461 0a20   response.data. 
+00009840: 2020 2020 2020 206c 7362 203d 2028 776f         lsb = (wo
+00009850: 7264 203e 3e20 3136 2920 2620 3078 6666  rd >> 16) & 0xff
+00009860: 0a20 2020 2020 2020 206d 7362 203d 2028  .        msb = (
+00009870: 776f 7264 203e 3e20 2038 2920 2620 3078  word >>  8) & 0x
+00009880: 6666 0a20 2020 2020 2020 2070 6572 6320  ff.        perc 
+00009890: 3d20 6d73 6220 2b20 2831 2e30 202a 206c  = msb + (1.0 * l
+000098a0: 7362 202f 2032 3536 2e30 290a 2020 2020  sb / 256.0).    
+000098b0: 2020 2020 6c6f 672e 6465 6275 6728 2262      log.debug("b
+000098c0: 6174 7465 7279 5f70 6572 633a 2025 2e32  attery_perc: %.2
+000098d0: 6625 2522 2c20 7065 7263 290a 2020 2020  f%%", perc).    
+000098e0: 2020 2020 7265 7475 726e 2053 7065 6374      return Spect
+000098f0: 726f 6d65 7465 7252 6573 706f 6e73 6528  rometerResponse(
+00009900: 6461 7461 3d70 6572 6329 0a0a 2020 2020  data=perc)..    
+00009910: 6465 6620 6765 745f 6261 7474 6572 795f  def get_battery_
+00009920: 6368 6172 6769 6e67 2873 656c 6629 3a0a  charging(self):.
+00009930: 2020 2020 2020 2020 7265 7320 3d20 7365          res = se
+00009940: 6c66 2e67 6574 5f62 6174 7465 7279 5f73  lf.get_battery_s
+00009950: 7461 7465 5f72 6177 2829 0a20 2020 2020  tate_raw().     
+00009960: 2020 2077 6f72 6420 3d20 7265 732e 6461     word = res.da
+00009970: 7461 0a20 2020 2020 2020 2063 6861 7267  ta.        charg
+00009980: 696e 6720 3d20 2830 2021 3d20 2877 6f72  ing = (0 != (wor
+00009990: 6420 2620 3078 6666 2929 0a20 2020 2020  d & 0xff)).     
+000099a0: 2020 2072 6574 7572 6e20 5370 6563 7472     return Spectr
+000099b0: 6f6d 6574 6572 5265 7370 6f6e 7365 2864  ometerResponse(d
+000099c0: 6174 613d 6368 6172 6769 6e67 290a 0a20  ata=charging).. 
+000099d0: 2020 2064 6566 2067 6574 5f69 6e74 6567     def get_integ
+000099e0: 7261 7469 6f6e 5f74 696d 655f 6d73 2873  ration_time_ms(s
+000099f0: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+00009a00: 7370 6f6e 7365 203d 2073 656c 662e 5f67  sponse = self._g
+00009a10: 6574 5f63 6f64 6528 3078 6266 2c20 6c61  et_code(0xbf, la
+00009a20: 6265 6c3d 2247 4554 5f49 4e54 4547 5241  bel="GET_INTEGRA
+00009a30: 5449 4f4e 5f54 494d 455f 4d53 222c 206c  TION_TIME_MS", l
+00009a40: 7362 5f6c 656e 3d33 290a 2020 2020 2020  sb_len=3).      
+00009a50: 2020 6d73 203d 2072 6573 706f 6e73 652e    ms = response.
+00009a60: 6461 7461 0a0a 2020 2020 2020 2020 6966  data..        if
+00009a70: 2073 656c 662e 7365 7474 696e 6773 2e73   self.settings.s
+00009a80: 7461 7465 2e69 6e74 6567 7261 7469 6f6e  tate.integration
+00009a90: 5f74 696d 655f 6d73 203e 2030 3a0a 2020  _time_ms > 0:.  
+00009aa0: 2020 2020 2020 2020 2020 6c6f 672e 6465            log.de
+00009ab0: 6275 6728 6622 4745 545f 494e 5445 4752  bug(f"GET_INTEGR
+00009ac0: 4154 494f 4e5f 5449 4d45 5f4d 533a 206e  ATION_TIME_MS: n
+00009ad0: 6f77 207b 6d73 7d22 290a 2020 2020 2020  ow {ms}").      
+00009ae0: 2020 2020 2020 7365 6c66 2e73 6574 7469        self.setti
+00009af0: 6e67 732e 7374 6174 652e 696e 7465 6772  ngs.state.integr
+00009b00: 6174 696f 6e5f 7469 6d65 5f6d 7320 3d20  ation_time_ms = 
+00009b10: 6d73 0a20 2020 2020 2020 2065 6c73 653a  ms.        else:
+00009b20: 0a20 2020 2020 2020 2020 2020 206c 6f67  .            log
+00009b30: 2e64 6562 7567 2822 6465 636c 696e 696e  .debug("declinin
+00009b40: 6720 746f 2069 6e69 7469 616c 697a 6520  g to initialize 
+00009b50: 7365 7373 696f 6e20 696e 7465 6772 6174  session integrat
+00009b60: 696f 6e5f 7469 6d65 5f6d 7320 6672 6f6d  ion_time_ms from
+00009b70: 2073 7065 6374 726f 6d65 7465 7222 290a   spectrometer").
+00009b80: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00009b90: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
+00009ba0: 6f6e 7365 2864 6174 613d 6d73 290a 0a20  onse(data=ms).. 
+00009bb0: 2020 2064 6566 2073 6574 5f64 6675 5f65     def set_dfu_e
+00009bc0: 6e61 626c 6528 7365 6c66 293a 0a20 2020  nable(self):.   
+00009bd0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00009be0: 2050 7574 7320 4152 4d2d 6261 7365 6420   Puts ARM-based 
+00009bf0: 7370 6563 7472 6f6d 6574 6572 7320 696e  spectrometers in
+00009c00: 746f 2044 6576 6963 6520 4669 726d 7761  to Device Firmwa
+00009c10: 7265 2055 7064 6174 6520 2844 4655 2920  re Update (DFU) 
+00009c20: 6d6f 6465 2e0a 2020 2020 2020 2020 4077  mode..        @w
+00009c30: 6172 6e69 6e67 2072 6566 6c61 7368 696e  arning reflashin
+00009c40: 6720 7370 6563 7472 6f6d 6574 6572 2066  g spectrometer f
+00009c50: 6972 6d77 6172 6520 7769 7468 6f75 7420  irmware without 
+00009c60: 7370 6563 6966 6963 2069 6e73 7472 7563  specific instruc
+00009c70: 7469 6f6e 2061 6e64 0a20 2020 2020 2020  tion and.       
+00009c80: 2073 7570 706f 7274 2066 726f 6d20 5761   support from Wa
+00009c90: 7361 7463 6820 5068 6f74 6f6e 6963 7320  satch Photonics 
+00009ca0: 7769 6c6c 2076 6f69 6420 796f 7572 2077  will void your w
+00009cb0: 6172 7261 6e74 790a 2020 2020 2020 2020  arranty.        
+00009cc0: 2222 220a 2020 2020 2020 2020 6966 206e  """.        if n
+00009cd0: 6f74 2073 656c 662e 7365 7474 696e 6773  ot self.settings
+00009ce0: 2e69 735f 6172 6d28 293a 0a20 2020 2020  .is_arm():.     
+00009cf0: 2020 2020 2020 206d 7367 203d 2022 4446         msg = "DF
+00009d00: 5520 6d6f 6465 206f 6e6c 7920 7375 7070  U mode only supp
+00009d10: 6f72 7465 6420 666f 7220 4152 4d2d 6261  orted for ARM-ba
+00009d20: 7365 6420 7370 6563 7472 6f6d 6574 6572  sed spectrometer
+00009d30: 7322 0a20 2020 2020 2020 2020 2020 206c  s".            l
+00009d40: 6f67 2e65 7272 6f72 286d 7367 290a 2020  og.error(msg).  
+00009d50: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00009d60: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
+00009d70: 706f 6e73 6528 6572 726f 725f 6c76 6c3d  ponse(error_lvl=
+00009d80: 4572 726f 724c 6576 656c 2e6c 6f77 2c65  ErrorLevel.low,e
+00009d90: 7272 6f72 5f6d 7367 3d6d 7367 2c20 6b65  rror_msg=msg, ke
+00009da0: 6570 5f61 6c69 7665 3d54 7275 6529 0a0a  ep_alive=True)..
+00009db0: 2020 2020 2020 2020 7265 7375 6c74 203d          result =
+00009dc0: 2073 656c 662e 5f73 656e 645f 636f 6465   self._send_code
+00009dd0: 2830 7866 652c 206c 6162 656c 3d22 5345  (0xfe, label="SE
+00009de0: 545f 4446 555f 454e 4142 4c45 2229 0a0a  T_DFU_ENABLE")..
+00009df0: 2020 2020 2020 2020 7365 6c66 2e71 7565          self.que
+00009e00: 7565 5f6d 6573 7361 6765 2822 6d61 7271  ue_message("marq
+00009e10: 7565 655f 696e 666f 222c 2022 2573 2069  uee_info", "%s i
+00009e20: 6e20 4446 5520 6d6f 6465 2220 2520 7365  n DFU mode" % se
+00009e30: 6c66 2e73 6574 7469 6e67 732e 6565 7072  lf.settings.eepr
+00009e40: 6f6d 2e73 6572 6961 6c5f 6e75 6d62 6572  om.serial_number
+00009e50: 290a 0a20 2020 2020 2020 2073 656c 662e  )..        self.
+00009e60: 5f73 6368 6564 756c 655f 6469 7363 6f6e  _schedule_discon
+00009e70: 6e65 6374 2845 7863 6570 7469 6f6e 2822  nect(Exception("
+00009e80: 4446 5520 4d6f 6465 2229 290a 2020 2020  DFU Mode")).    
+00009e90: 2020 2020 7265 7475 726e 2053 7065 6374      return Spect
+00009ea0: 726f 6d65 7465 7252 6573 706f 6e73 6528  rometerResponse(
+00009eb0: 6461 7461 3d72 6573 756c 7429 0a0a 2020  data=result)..  
+00009ec0: 2020 6465 6620 7365 745f 6465 7465 6374    def set_detect
+00009ed0: 6f72 5f6f 6666 7365 7428 7365 6c66 2c20  or_offset(self, 
+00009ee0: 7661 6c75 653a 2069 6e74 293a 0a20 2020  value: int):.   
+00009ef0: 2020 2020 2077 6f72 6420 3d20 7574 696c       word = util
+00009f00: 732e 636c 616d 705f 746f 5f69 6e74 3136  s.clamp_to_int16
+00009f10: 2876 616c 7565 290a 2020 2020 2020 2020  (value).        
+00009f20: 7365 6c66 2e73 6574 7469 6e67 732e 6565  self.settings.ee
+00009f30: 7072 6f6d 2e64 6574 6563 746f 725f 6f66  prom.detector_of
+00009f40: 6673 6574 203d 2077 6f72 640a 2020 2020  fset = word.    
+00009f50: 2020 2020 2320 6c6f 672e 6465 6275 6728      # log.debug(
+00009f60: 2276 616c 7565 2025 6420 2825 7329 203d  "value %d (%s) =
+00009f70: 2030 7825 3034 7820 2825 7329 222c 2076   0x%04x (%s)", v
+00009f80: 616c 7565 2c20 666f 726d 6174 2876 616c  alue, format(val
+00009f90: 7565 2c20 2762 2729 2c20 776f 7264 2c20  ue, 'b'), word, 
+00009fa0: 666f 726d 6174 2877 6f72 642c 2027 6227  format(word, 'b'
+00009fb0: 2929 0a20 2020 2020 2020 2072 6574 7572  )).        retur
+00009fc0: 6e20 7365 6c66 2e5f 7365 6e64 5f63 6f64  n self._send_cod
+00009fd0: 6528 3078 6236 2c20 776f 7264 2c20 6c61  e(0xb6, word, la
+00009fe0: 6265 6c3d 2253 4554 5f44 4554 4543 544f  bel="SET_DETECTO
+00009ff0: 525f 4f46 4653 4554 2229 0a0a 2020 2020  R_OFFSET")..    
+0000a000: 6465 6620 7365 745f 6465 7465 6374 6f72  def set_detector
+0000a010: 5f6f 6666 7365 745f 6f64 6428 7365 6c66  _offset_odd(self
+0000a020: 2c20 7661 6c75 653a 2069 6e74 293a 0a20  , value: int):. 
+0000a030: 2020 2020 2020 2069 6620 6e6f 7420 7365         if not se
+0000a040: 6c66 2e73 6574 7469 6e67 732e 6973 5f69  lf.settings.is_i
+0000a050: 6e67 6161 7328 293a 0a20 2020 2020 2020  ngaas():.       
+0000a060: 2020 2020 206c 6f67 2e64 6562 7567 2822       log.debug("
+0000a070: 5345 545f 4445 5445 4354 4f52 5f4f 4646  SET_DETECTOR_OFF
+0000a080: 5345 545f 4f44 4420 6f6e 6c79 2073 7570  SET_ODD only sup
+0000a090: 706f 7274 6564 206f 6e20 496e 4761 4173  ported on InGaAs
+0000a0a0: 2229 0a20 2020 2020 2020 2020 2020 2072  ").            r
+0000a0b0: 6574 7572 6e20 5370 6563 7472 6f6d 6574  eturn Spectromet
+0000a0c0: 6572 5265 7370 6f6e 7365 286b 6565 705f  erResponse(keep_
+0000a0d0: 616c 6976 653d 5472 7565 2c65 7272 6f72  alive=True,error
+0000a0e0: 5f6c 766c 3d45 7272 6f72 4c65 7665 6c2e  _lvl=ErrorLevel.
+0000a0f0: 6c6f 7729 0a0a 2020 2020 2020 2020 776f  low)..        wo
+0000a100: 7264 203d 2075 7469 6c73 2e63 6c61 6d70  rd = utils.clamp
+0000a110: 5f74 6f5f 696e 7431 3628 7661 6c75 6529  _to_int16(value)
+0000a120: 0a20 2020 2020 2020 2073 656c 662e 7365  .        self.se
+0000a130: 7474 696e 6773 2e65 6570 726f 6d2e 6465  ttings.eeprom.de
+0000a140: 7465 6374 6f72 5f6f 6666 7365 745f 6f64  tector_offset_od
+0000a150: 6420 3d20 776f 7264 0a0a 2020 2020 2020  d = word..      
+0000a160: 2020 7265 7475 726e 2073 656c 662e 5f73    return self._s
+0000a170: 656e 645f 636f 6465 2830 7839 632c 2077  end_code(0x9c, w
+0000a180: 6f72 642c 206c 6162 656c 3d22 5345 545f  ord, label="SET_
+0000a190: 4445 5445 4354 4f52 5f4f 4646 5345 545f  DETECTOR_OFFSET_
+0000a1a0: 4f44 4422 290a 0a20 2020 2064 6566 2067  ODD")..    def g
+0000a1b0: 6574 5f64 6574 6563 746f 725f 6761 696e  et_detector_gain
+0000a1c0: 2873 656c 662c 2075 7064 6174 655f 7365  (self, update_se
+0000a1d0: 7373 696f 6e5f 6565 7072 6f6d 3a20 626f  ssion_eeprom: bo
+0000a1e0: 6f6c 203d 2046 616c 7365 293a 0a20 2020  ol = False):.   
+0000a1f0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+0000a200: 2052 6561 6420 7468 6520 6465 7669 6365   Read the device
+0000a210: 2073 746f 7265 6420 6761 696e 2e20 2043   stored gain.  C
+0000a220: 6f6e 7665 7274 2066 726f 6d20 6269 6e61  onvert from bina
+0000a230: 7279 2022 6861 6c66 2d70 7265 6369 7369  ry "half-precisi
+0000a240: 6f6e 2220 666c 6f61 742e 0a20 2020 2020  on" float..     
+0000a250: 2020 202d 2031 7374 2062 7974 6520 284c     - 1st byte (L
+0000a260: 5342 2920 6973 2062 696e 6172 7920 656e  SB) is binary en
+0000a270: 636f 6465 643a 2062 6974 2030 203d 2031  coded: bit 0 = 1
+0000a280: 2f32 2c20 6269 7420 3120 3d20 312f 342c  /2, bit 1 = 1/4,
+0000a290: 2062 6974 2032 203d 2031 2f38 2065 7463   bit 2 = 1/8 etc
+0000a2a0: 2e0a 2020 2020 2020 2020 2d20 326e 6420  ..        - 2nd 
+0000a2b0: 6279 7465 2028 4d53 4229 2069 7320 7468  byte (MSB) is th
+0000a2c0: 6520 696e 7465 6772 616c 2070 6172 7420  e integral part 
+0000a2d0: 746f 2074 6865 206c 6566 7420 6f66 2074  to the left of t
+0000a2e0: 6865 2064 6563 696d 616c 0a20 2020 2020  he decimal.     
+0000a2f0: 2020 2045 2e67 2e2c 2032 3331 2064 6563     E.g., 231 dec
+0000a300: 203d 3d20 3078 3031 6537 203d 3d20 312e   == 0x01e7 == 1.
+0000a310: 3930 3233 3433 3735 0a20 2020 2020 2020  90234375.       
+0000a320: 2022 2222 0a20 2020 2020 2020 2072 6573   """.        res
+0000a330: 203d 2073 656c 662e 5f67 6574 5f63 6f64   = self._get_cod
+0000a340: 6528 3078 6335 2c20 6c61 6265 6c3d 2247  e(0xc5, label="G
+0000a350: 4554 5f44 4554 4543 544f 525f 4741 494e  ET_DETECTOR_GAIN
+0000a360: 2229 0a0a 2020 2020 2020 2020 7265 7375  ")..        resu
+0000a370: 6c74 203d 2072 6573 2e64 6174 610a 0a20  lt = res.data.. 
+0000a380: 2020 2020 2020 2069 6620 7265 7375 6c74         if result
+0000a390: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+0000a3a0: 2020 2020 2020 6d73 6720 3d20 2247 4554        msg = "GET
+0000a3b0: 5f44 4554 4543 544f 525f 4741 494e 2072  _DETECTOR_GAIN r
+0000a3c0: 6574 7572 6e65 6420 4e55 4c4c 2122 0a20  eturned NULL!". 
+0000a3d0: 2020 2020 2020 2020 2020 206c 6f67 2e65             log.e
+0000a3e0: 7272 6f72 286d 7367 290a 2020 2020 2020  rror(msg).      
+0000a3f0: 2020 2020 2020 7265 7475 726e 2053 7065        return Spe
+0000a400: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
+0000a410: 6528 6572 726f 725f 6c76 6c3d 4572 726f  e(error_lvl=Erro
+0000a420: 724c 6576 656c 2e6d 6564 6975 6d2c 6572  rLevel.medium,er
+0000a430: 726f 725f 6d73 673d 6d73 672c 6b65 6570  ror_msg=msg,keep
+0000a440: 5f61 6c69 7665 3d54 7275 6529 0a0a 2020  _alive=True)..  
+0000a450: 2020 2020 2020 6966 2073 656c 662e 7365        if self.se
+0000a460: 7474 696e 6773 2e69 735f 7873 2829 3a0a  ttings.is_xs():.
+0000a470: 2020 2020 2020 2020 2020 2020 6d73 6220              msb 
+0000a480: 3d20 7265 7375 6c74 5b30 5d20 2320 6269  = result[0] # bi
+0000a490: 672d 656e 6469 616e 2c20 5341 4d45 2061  g-endian, SAME a
+0000a4a0: 7320 7365 745f 6465 7465 6374 6f72 5f67  s set_detector_g
+0000a4b0: 6169 6e0a 2020 2020 2020 2020 2020 2020  ain.            
+0000a4c0: 6c73 6220 3d20 7265 7375 6c74 5b31 5d20  lsb = result[1] 
+0000a4d0: 2320 7468 6973 2061 6464 7320 636f 6e66  # this adds conf
+0000a4e0: 7573 696f 6e2c 2062 7574 2069 7320 616e  usion, but is an
+0000a4f0: 2069 6d70 726f 7665 6d65 6e74 203a 2d2f   improvement :-/
+0000a500: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+0000a510: 2020 2020 2020 2020 2020 206c 7362 203d             lsb =
+0000a520: 2072 6573 756c 745b 305d 2023 206c 6974   result[0] # lit
+0000a530: 746c 652d 656e 6469 616e 2c20 4f50 504f  tle-endian, OPPO
+0000a540: 5349 5445 206f 6620 7365 745f 6465 7465  SITE of set_dete
+0000a550: 6374 6f72 5f67 6169 6e0a 2020 2020 2020  ctor_gain.      
+0000a560: 2020 2020 2020 6d73 6220 3d20 7265 7375        msb = resu
+0000a570: 6c74 5b31 5d0a 0a20 2020 2020 2020 2072  lt[1]..        r
+0000a580: 6177 203d 2028 6d73 6220 3c3c 2038 2920  aw = (msb << 8) 
+0000a590: 7c20 6c73 620a 0a20 2020 2020 2020 2067  | lsb..        g
+0000a5a0: 6169 6e20 3d20 6d73 6220 2b20 6c73 6220  ain = msb + lsb 
+0000a5b0: 2f20 3235 362e 300a 2020 2020 2020 2020  / 256.0.        
+0000a5c0: 6c6f 672e 6465 6275 6728 2267 6574 5f64  log.debug("get_d
+0000a5d0: 6574 6563 746f 725f 6761 696e 3a20 2566  etector_gain: %f
+0000a5e0: 2028 7261 7720 3078 2530 3478 2920 2873   (raw 0x%04x) (s
+0000a5f0: 6573 7369 6f6e 2065 6570 726f 6d20 2566  ession eeprom %f
+0000a600: 2922 2025 2028 0a20 2020 2020 2020 2020  )" % (.         
+0000a610: 2020 2067 6169 6e2c 2072 6177 2c20 7365     gain, raw, se
+0000a620: 6c66 2e73 6574 7469 6e67 732e 6565 7072  lf.settings.eepr
+0000a630: 6f6d 2e64 6574 6563 746f 725f 6761 696e  om.detector_gain
+0000a640: 2929 0a0a 2020 2020 2020 2020 6966 2075  ))..        if u
+0000a650: 7064 6174 655f 7365 7373 696f 6e5f 6565  pdate_session_ee
+0000a660: 7072 6f6d 3a0a 2020 2020 2020 2020 2020  prom:.          
+0000a670: 2020 7365 6c66 2e73 6574 7469 6e67 732e    self.settings.
+0000a680: 6565 7072 6f6d 2e64 6574 6563 746f 725f  eeprom.detector_
+0000a690: 6761 696e 203d 2067 6169 6e0a 0a20 2020  gain = gain..   
+0000a6a0: 2020 2020 2069 6620 7365 6c66 2e73 6574       if self.set
+0000a6b0: 7469 6e67 732e 6973 5f6d 6963 726f 2829  tings.is_micro()
+0000a6c0: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
+0000a6d0: 6c66 2e73 6574 7469 6e67 732e 7374 6174  lf.settings.stat
+0000a6e0: 652e 6761 696e 5f64 6220 3d20 6761 696e  e.gain_db = gain
+0000a6f0: 0a0a 2020 2020 2020 2020 7265 7475 726e  ..        return
+0000a700: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
+0000a710: 706f 6e73 6528 6461 7461 3d67 6169 6e29  ponse(data=gain)
+0000a720: 0a0a 2020 2020 6465 6620 6765 745f 6465  ..    def get_de
+0000a730: 7465 6374 6f72 5f67 6169 6e5f 6f64 6428  tector_gain_odd(
+0000a740: 7365 6c66 2c20 7570 6461 7465 5f73 6573  self, update_ses
+0000a750: 7369 6f6e 5f65 6570 726f 6d3a 2062 6f6f  sion_eeprom: boo
+0000a760: 6c20 3d20 4661 6c73 6529 3a0a 2020 2020  l = False):.    
+0000a770: 2020 2020 6966 206e 6f74 2073 656c 662e      if not self.
+0000a780: 7365 7474 696e 6773 2e69 735f 696e 6761  settings.is_inga
+0000a790: 6173 2829 3a0a 2020 2020 2020 2020 2020  as():.          
+0000a7a0: 2020 6c6f 672e 6465 6275 6728 2247 4554    log.debug("GET
+0000a7b0: 5f44 4554 4543 544f 525f 4741 494e 5f4f  _DETECTOR_GAIN_O
+0000a7c0: 4444 206f 6e6c 7920 7375 7070 6f72 7465  DD only supporte
+0000a7d0: 6420 6f6e 2049 6e47 6141 7322 290a 2020  d on InGaAs").  
+0000a7e0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+0000a7f0: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
+0000a800: 706f 6e73 6528 6461 7461 3d73 656c 662e  ponse(data=self.
+0000a810: 7365 7474 696e 6773 2e65 6570 726f 6d2e  settings.eeprom.
+0000a820: 6465 7465 6374 6f72 5f67 6169 6e5f 6f64  detector_gain_od
+0000a830: 6429 0a0a 2020 2020 2020 2020 7265 7375  d)..        resu
+0000a840: 6c74 203d 2073 656c 662e 5f67 6574 5f63  lt = self._get_c
+0000a850: 6f64 6528 3078 3966 2c20 6c61 6265 6c3d  ode(0x9f, label=
+0000a860: 2247 4554 5f44 4554 4543 544f 525f 4741  "GET_DETECTOR_GA
+0000a870: 494e 5f4f 4444 2229 0a0a 2020 2020 2020  IN_ODD")..      
+0000a880: 2020 2320 6e6f 7420 7265 7665 7273 696e    # not reversin
+0000a890: 6720 7468 6973 2066 6f72 2058 532c 2062  g this for XS, b
+0000a8a0: 6563 6175 7365 2077 6520 646f 6e27 7420  ecause we don't 
+0000a8b0: 6375 7272 656e 746c 7920 6861 7665 2061  currently have a
+0000a8c0: 6e20 5853 2d4e 4952 0a20 2020 2020 2020  n XS-NIR.       
+0000a8d0: 206c 7362 203d 2072 6573 756c 745b 305d   lsb = result[0]
+0000a8e0: 2023 204c 5342 2d4d 5342 0a20 2020 2020   # LSB-MSB.     
+0000a8f0: 2020 206d 7362 203d 2072 6573 756c 745b     msb = result[
+0000a900: 315d 0a20 2020 2020 2020 2072 6177 203d  1].        raw =
+0000a910: 2028 6d73 6220 3c3c 2038 2920 7c20 6c73   (msb << 8) | ls
+0000a920: 620a 0a20 2020 2020 2020 2067 6169 6e20  b..        gain 
+0000a930: 3d20 6d73 6220 2b20 6c73 6220 2f20 3235  = msb + lsb / 25
+0000a940: 362e 300a 2020 2020 2020 2020 6c6f 672e  6.0.        log.
+0000a950: 6465 6275 6728 2267 6574 5f64 6574 6563  debug("get_detec
+0000a960: 746f 725f 6761 696e 5f6f 6464 3a20 2566  tor_gain_odd: %f
+0000a970: 2028 3078 2530 3478 2920 2873 6573 7369   (0x%04x) (sessi
+0000a980: 6f6e 2065 6570 726f 6d20 2566 2922 2025  on eeprom %f)" %
+0000a990: 2028 0a20 2020 2020 2020 2020 2020 2067   (.            g
+0000a9a0: 6169 6e2c 2072 6177 2c20 7365 6c66 2e73  ain, raw, self.s
+0000a9b0: 6574 7469 6e67 732e 6565 7072 6f6d 2e64  ettings.eeprom.d
+0000a9c0: 6574 6563 746f 725f 6761 696e 5f6f 6464  etector_gain_odd
+0000a9d0: 2929 0a20 2020 2020 2020 2069 6620 7570  )).        if up
+0000a9e0: 6461 7465 5f73 6573 7369 6f6e 5f65 6570  date_session_eep
+0000a9f0: 726f 6d3a 0a20 2020 2020 2020 2020 2020  rom:.           
+0000aa00: 2073 656c 662e 7365 7474 696e 6773 2e65   self.settings.e
+0000aa10: 6570 726f 6d2e 6465 7465 6374 6f72 5f67  eprom.detector_g
+0000aa20: 6169 6e5f 6f64 6420 3d20 6761 696e 0a20  ain_odd = gain. 
+0000aa30: 2020 2020 2020 2072 6574 7572 6e20 5370         return Sp
+0000aa40: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
+0000aa50: 7365 2864 6174 613d 6761 696e 290a 0a20  se(data=gain).. 
+0000aa60: 2020 2023 230a 2020 2020 2320 4e6f 7465     ##.    # Note
+0000aa70: 2074 6861 7420 7468 6973 2069 7320 7573   that this is us
+0000aa80: 6564 2066 6f72 2064 6574 6563 746f 7220  ed for detector 
+0000aa90: 7479 7065 732c 2069 6e63 6c75 6469 6e67  types, including
+0000aaa0: 3a0a 2020 2020 230a 2020 2020 2320 2d20  :.    #.    # - 
+0000aab0: 4861 6d61 6d61 7473 7520 7369 6c69 636f  Hamamatsu silico
+0000aac0: 6e20 2853 3136 3031 302d 2a2c 2053 3136  n (S16010-*, S16
+0000aad0: 3031 312d 2a2c 2065 7463 290a 2020 2020  011-*, etc).    
+0000aae0: 2320 2d20 4861 6d61 6d61 7473 7520 496e  # - Hamamatsu In
+0000aaf0: 4761 4173 2028 4739 3231 3420 6574 6329  GaAs (G9214 etc)
+0000ab00: 0a20 2020 2023 202d 2053 6f6e 7920 494d  .    # - Sony IM
+0000ab10: 5820 2849 4d58 3338 3520 6574 6329 0a20  X (IMX385 etc). 
+0000ab20: 2020 2023 0a20 2020 2023 2049 7420 6973     #.    # It is
+0000ab30: 2069 6d70 6f72 7461 6e74 2074 6f20 756e   important to un
+0000ab40: 6465 7273 7461 6e64 2074 6861 7420 7468  derstand that th
+0000ab50: 6520 554e 4954 206f 6620 7468 6973 2076  e UNIT of this v
+0000ab60: 616c 7565 2063 6861 6e67 6573 2062 6574  alue changes bet
+0000ab70: 7765 656e 0a20 2020 2023 2048 616d 616d  ween.    # Hamam
+0000ab80: 6174 7375 2061 6e64 2049 4d58 2064 6574  atsu and IMX det
+0000ab90: 6563 746f 7273 2c20 6275 7420 7468 6520  ectors, but the 
+0000aba0: 4441 5441 5459 5045 2064 6f65 7320 6e6f  DATATYPE does no
+0000abb0: 742e 0a20 2020 2023 0a20 2020 2023 2052  t..    #.    # R
+0000abc0: 6561 736f 6e61 626c 6520 6761 696e 206c  easonable gain l
+0000abd0: 6576 656c 7320 666f 7220 4861 6d61 6d61  evels for Hamama
+0000abe0: 7473 7520 6172 6520 6120 666c 6f61 7469  tsu are a floati
+0000abf0: 6e67 2d70 6f69 6e74 2073 6361 6c61 722c  ng-point scalar,
+0000ac00: 206c 6974 6572 616c 6c79 0a20 2020 2023   literally.    #
+0000ac10: 2075 7365 6420 746f 2073 6361 6c65 2028   used to scale (
+0000ac20: 6761 696e 2920 7468 6520 7369 676e 616c  gain) the signal
+0000ac30: 2c20 616e 6420 6172 6520 7573 7561 6c6c  , and are usuall
+0000ac40: 7920 696e 2074 6865 2072 616e 6765 2028  y in the range (
+0000ac50: 302e 3820 2e2e 2031 2e32 290a 2020 2020  0.8 .. 1.2).    
+0000ac60: 2320 6f72 2074 6865 7265 6162 6f75 7473  # or thereabouts
+0000ac70: 2e0a 2020 2020 230a 2020 2020 2320 5265  ..    #.    # Re
+0000ac80: 6173 6f6e 6162 6c65 206c 6576 656c 7320  asonable levels 
+0000ac90: 666f 7220 494d 5820 7365 6e73 6f72 7320  for IMX sensors 
+0000aca0: 6172 6520 696e 2064 4220 616e 6420 7661  are in dB and va
+0000acb0: 7279 2062 7920 6465 7465 6374 6f72 2c20  ry by detector, 
+0000acc0: 6275 7420 6172 650a 2020 2020 2320 7573  but are.    # us
+0000acd0: 7561 6c6c 7920 696e 2074 6865 2072 616e  ually in the ran
+0000ace0: 6765 2028 302e 3020 2e2e 2033 312e 3029  ge (0.0 .. 31.0)
+0000acf0: 2c20 7769 7468 2065 7861 6374 6c79 2030  , with exactly 0
+0000ad00: 2e31 6442 2070 7265 6369 7369 6f6e 2e20  .1dB precision. 
+0000ad10: 2054 6865 0a20 2020 2023 2073 7065 6374   The.    # spect
+0000ad20: 726f 6d65 7465 7227 7320 4657 2077 696c  rometer's FW wil
+0000ad30: 6c20 726f 756e 6420 746f 2074 6865 206e  l round to the n
+0000ad40: 6561 7265 7374 2073 6574 7469 6e67 2028  earest setting (
+0000ad50: 312e 3233 2077 696c 6c20 6265 2072 6f75  1.23 will be rou
+0000ad60: 6e64 6564 0a20 2020 2023 2074 6f20 312e  nded.    # to 1.
+0000ad70: 3229 2e20 2049 4d58 2073 656e 736f 7273  2).  IMX sensors
+0000ad80: 2073 7769 7463 6820 6672 6f6d 2022 616e   switch from "an
+0000ad90: 616c 6f67 2067 6169 6e22 2074 6f20 2264  alog gain" to "d
+0000ada0: 6967 6974 616c 2067 6169 6e22 2061 626f  igital gain" abo
+0000adb0: 7665 0a20 2020 2023 2061 2067 6976 656e  ve.    # a given
+0000adc0: 2074 6872 6573 686f 6c64 2e2e 2e6f 6e20   threshold...on 
+0000add0: 7468 6520 494d 5831 3233 2c20 616e 616c  the IMX123, anal
+0000ade0: 6f67 2067 6169 6e20 6973 2030 2e30 202d  og gain is 0.0 -
+0000adf0: 2033 312e 302c 2061 6e64 2064 6967 6974   31.0, and digit
+0000ae00: 616c 0a20 2020 2023 2069 7320 3331 2e31  al.    # is 31.1
+0000ae10: 202d 2037 322e 3020 2849 2074 6869 6e6b   - 72.0 (I think
+0000ae20: 292e 0a20 2020 2023 0a20 2020 2023 2040  )..    #.    # @
+0000ae30: 7365 6520 6874 7470 733a 2f2f 7761 7361  see https://wasa
+0000ae40: 7463 6870 686f 746f 6e69 6373 2e63 6f6d  tchphotonics.com
+0000ae50: 2f61 7069 2f57 6173 6174 6368 2e4e 4554  /api/Wasatch.NET
+0000ae60: 2f63 6c61 7373 5f77 6173 6174 6368 5f6e  /class_wasatch_n
+0000ae70: 5f65 5f74 5f31 5f31 5f66 756e 6b79 5f66  _e_t_1_1_funky_f
+0000ae80: 6c6f 6174 2e68 746d 6c0a 2020 2020 2320  loat.html.    # 
+0000ae90: 4074 6f64 6f20 7765 2073 686f 756c 6420  @todo we should 
+0000aea0: 7072 6f62 6162 6c79 2074 7261 636b 2072  probably track r
+0000aeb0: 756e 7469 6d65 2068 6172 6477 6172 6520  untime hardware 
+0000aec0: 6761 696e 2069 6e20 5370 6563 7472 6f6d  gain in Spectrom
+0000aed0: 6574 6572 5374 6174 652c 0a20 2020 2023  eterState,.    #
+0000aee0: 2020 2020 2020 206e 6f74 2045 4550 524f         not EEPRO
+0000aef0: 4d0a 2020 2020 6465 6620 7365 745f 6465  M.    def set_de
+0000af00: 7465 6374 6f72 5f67 6169 6e28 7365 6c66  tector_gain(self
+0000af10: 2c20 6761 696e 3a20 666c 6f61 7429 3a0a  , gain: float):.
+0000af20: 2020 2020 2020 2020 6966 206e 6f74 2073          if not s
+0000af30: 656c 662e 6973 5f73 656e 736f 725f 7374  elf.is_sensor_st
+0000af40: 6162 6c65 2829 3a0a 2020 2020 2020 2020  able():.        
+0000af50: 2020 2020 6c6f 672e 6572 726f 7228 2264      log.error("d
+0000af60: 6563 6c69 6e69 6e67 2074 6f20 6368 616e  eclining to chan
+0000af70: 6765 2073 656e 736f 7220 7365 7474 696e  ge sensor settin
+0000af80: 6773 2077 6869 6c65 2073 7461 6269 6c69  gs while stabili
+0000af90: 7a69 6e67 2229 0a20 2020 2020 2020 2020  zing").         
+0000afa0: 2020 2072 6574 7572 6e0a 0a20 2020 2020     return..     
+0000afb0: 2020 2072 6177 203d 2073 656c 662e 7365     raw = self.se
+0000afc0: 7474 696e 6773 2e65 6570 726f 6d2e 666c  ttings.eeprom.fl
+0000afd0: 6f61 745f 746f 5f75 696e 7431 3628 6761  oat_to_uint16(ga
+0000afe0: 696e 290a 0a20 2020 2020 2020 2023 204d  in)..        # M
+0000aff0: 5a3a 206e 6f74 6520 7468 6174 2077 6520  Z: note that we 
+0000b000: 5345 4e44 2067 6169 6e20 4d53 422d 4c53  SEND gain MSB-LS
+0000b010: 422c 2062 7574 2077 6520 5245 4144 2067  B, but we READ g
+0000b020: 6169 6e20 4c53 422d 4d53 423f 210a 2020  ain LSB-MSB?!.  
+0000b030: 2020 2020 2020 6c6f 672e 6465 6275 6728        log.debug(
+0000b040: 2253 656e 6420 4465 7465 6374 6f72 2047  "Send Detector G
+0000b050: 6169 6e3a 2030 7825 3034 7820 2825 7329  ain: 0x%04x (%s)
+0000b060: 222c 2072 6177 2c20 6761 696e 290a 2020  ", raw, gain).  
+0000b070: 2020 2020 2020 7265 7375 6c74 203d 2073        result = s
+0000b080: 656c 662e 5f73 656e 645f 636f 6465 2830  elf._send_code(0
+0000b090: 7862 372c 2072 6177 2c20 6c61 6265 6c3d  xb7, raw, label=
+0000b0a0: 2253 4554 5f44 4554 4543 544f 525f 4741  "SET_DETECTOR_GA
+0000b0b0: 494e 2229 0a0a 2020 2020 2020 2020 7365  IN")..        se
+0000b0c0: 6c66 2e61 6464 5f74 6872 6f77 6177 6179  lf.add_throwaway
+0000b0d0: 2867 6169 6e20 213d 2073 656c 662e 7365  (gain != self.se
+0000b0e0: 7474 696e 6773 2e65 6570 726f 6d2e 6465  ttings.eeprom.de
+0000b0f0: 7465 6374 6f72 5f67 6169 6e29 0a20 2020  tector_gain).   
+0000b100: 2020 2020 2073 656c 662e 7365 7474 696e       self.settin
+0000b110: 6773 2e65 6570 726f 6d2e 6465 7465 6374  gs.eeprom.detect
+0000b120: 6f72 5f67 6169 6e20 3d20 6761 696e 0a0a  or_gain = gain..
+0000b130: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+0000b140: 7365 7474 696e 6773 2e69 735f 7873 2829  settings.is_xs()
+0000b150: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
+0000b160: 6c66 2e71 7565 7565 5f6d 6573 7361 6765  lf.queue_message
+0000b170: 2822 6d61 7271 7565 655f 696e 666f 222c  ("marquee_info",
+0000b180: 2022 7365 6e73 6f72 2069 7320 7374 6162   "sensor is stab
+0000b190: 696c 697a 696e 6722 290a 0a20 2020 2020  ilizing")..     
+0000b1a0: 2020 2072 6574 7572 6e20 7265 7375 6c74     return result
+0000b1b0: 0a0a 2020 2020 6465 6620 7365 745f 6465  ..    def set_de
+0000b1c0: 7465 6374 6f72 5f67 6169 6e5f 6f64 6428  tector_gain_odd(
+0000b1d0: 7365 6c66 2c20 6761 696e 3a20 666c 6f61  self, gain: floa
+0000b1e0: 7429 3a0a 2020 2020 2020 2020 6966 206e  t):.        if n
+0000b1f0: 6f74 2073 656c 662e 7365 7474 696e 6773  ot self.settings
+0000b200: 2e69 735f 696e 6761 6173 2829 3a0a 2020  .is_ingaas():.  
+0000b210: 2020 2020 2020 2020 2020 6c6f 672e 6465            log.de
+0000b220: 6275 6728 2253 4554 5f44 4554 4543 544f  bug("SET_DETECTO
+0000b230: 525f 4741 494e 5f4f 4444 206f 6e6c 7920  R_GAIN_ODD only 
+0000b240: 7375 7070 6f72 7465 6420 6f6e 2049 6e47  supported on InG
+0000b250: 6141 7322 290a 2020 2020 2020 2020 2020  aAs").          
+0000b260: 2020 7265 7475 726e 2053 7065 6374 726f    return Spectro
+0000b270: 6d65 7465 7252 6573 706f 6e73 6528 6572  meterResponse(er
+0000b280: 726f 725f 6c76 6c3d 4572 726f 724c 6576  ror_lvl=ErrorLev
+0000b290: 656c 2e6c 6f77 2c20 6572 726f 725f 6d73  el.low, error_ms
+0000b2a0: 673d 2253 4554 5f44 4554 4543 544f 525f  g="SET_DETECTOR_
+0000b2b0: 4741 494e 5f4f 4444 206f 6e6c 7920 7375  GAIN_ODD only su
+0000b2c0: 7070 6f72 7465 6420 6f6e 2049 6e47 6141  pported on InGaA
+0000b2d0: 7322 290a 0a20 2020 2020 2020 2072 6177  s")..        raw
+0000b2e0: 203d 2073 656c 662e 7365 7474 696e 6773   = self.settings
+0000b2f0: 2e65 6570 726f 6d2e 666c 6f61 745f 746f  .eeprom.float_to
+0000b300: 5f75 696e 7431 3628 6761 696e 290a 0a20  _uint16(gain).. 
+0000b310: 2020 2020 2020 2023 204d 5a3a 206e 6f74         # MZ: not
+0000b320: 6520 7468 6174 2077 6520 5345 4e44 2067  e that we SEND g
+0000b330: 6169 6e20 4d53 422d 4c53 422c 2062 7574  ain MSB-LSB, but
+0000b340: 2077 6520 5245 4144 2067 6169 6e20 4c53   we READ gain LS
+0000b350: 422d 4d53 423f 210a 2020 2020 2020 2020  B-MSB?!.        
+0000b360: 6c6f 672e 6465 6275 6728 2253 656e 6420  log.debug("Send 
+0000b370: 4465 7465 6374 6f72 2047 6169 6e20 4f64  Detector Gain Od
+0000b380: 643a 2030 7825 3034 7820 2825 7329 222c  d: 0x%04x (%s)",
+0000b390: 2072 6177 2c20 6761 696e 290a 2020 2020   raw, gain).    
+0000b3a0: 2020 2020 7365 6c66 2e73 6574 7469 6e67      self.setting
+0000b3b0: 732e 6565 7072 6f6d 2e64 6574 6563 746f  s.eeprom.detecto
+0000b3c0: 725f 6761 696e 5f6f 6464 203d 2067 6169  r_gain_odd = gai
+0000b3d0: 6e0a 2020 2020 2020 2020 7265 7475 726e  n.        return
+0000b3e0: 2073 656c 662e 5f73 656e 645f 636f 6465   self._send_code
+0000b3f0: 2830 7839 642c 2072 6177 2c20 6c61 6265  (0x9d, raw, labe
+0000b400: 6c3d 2253 4554 5f44 4554 4543 544f 525f  l="SET_DETECTOR_
+0000b410: 4741 494e 5f4f 4444 2229 0a0a 2020 2020  GAIN_ODD")..    
+0000b420: 2323 0a20 2020 2023 2048 6973 746f 7269  ##.    # Histori
+0000b430: 6361 6c6c 792c 2074 6869 7320 6f70 636f  cally, this opco
+0000b440: 6465 206d 6f76 6564 2061 726f 756e 6420  de moved around 
+0000b450: 6120 6269 742e 2020 4174 206f 6e65 2070  a bit.  At one p
+0000b460: 6f69 6e74 2069 7420 7761 7320 3078 6562  oint it was 0xeb
+0000b470: 0a20 2020 2023 2028 616e 6420 6973 206e  .    # (and is n
+0000b480: 6f77 2061 6761 696e 292c 2077 6869 6368  ow again), which
+0000b490: 2063 6f6e 666c 6963 7473 2077 6974 6820   conflicts with 
+0000b4a0: 4346 5f53 454c 4543 5429 2e20 2041 7420  CF_SELECT).  At 
+0000b4b0: 6f74 6865 7220 7469 6d65 7320 6974 0a20  other times it. 
+0000b4c0: 2020 2023 2077 6173 2030 7865 392c 2077     # was 0xe9, w
+0000b4d0: 6869 6368 2063 6f6e 666c 6963 7465 6420  hich conflicted 
+0000b4e0: 7769 7468 204c 4153 4552 5f52 414d 505f  with LASER_RAMP_
+0000b4f0: 454e 4142 4c45 2e20 2054 6869 7320 7365  ENABLE.  This se
+0000b500: 656d 7320 746f 2062 6520 7768 6174 0a20  ems to be what. 
+0000b510: 2020 2023 2077 6527 7265 2073 7461 6e64     # we're stand
+0000b520: 6172 6469 7a69 6e67 206f 6e20 6865 6e63  ardizing on henc
+0000b530: 6566 6f72 7468 2e0a 2020 2020 6465 6620  eforth..    def 
+0000b540: 7365 745f 6172 6561 5f73 6361 6e5f 656e  set_area_scan_en
+0000b550: 6162 6c65 2873 656c 662c 2066 6c61 673a  able(self, flag:
+0000b560: 2062 6f6f 6c29 3a0a 2020 2020 2020 2020   bool):.        
+0000b570: 6966 2073 656c 662e 7365 7474 696e 6773  if self.settings
+0000b580: 2e69 735f 696e 6761 6173 2829 3a0a 2020  .is_ingaas():.  
+0000b590: 2020 2020 2020 2020 2020 6c6f 672e 6572            log.er
+0000b5a0: 726f 7228 2261 7265 6120 7363 616e 2069  ror("area scan i
+0000b5b0: 7320 6e6f 7420 7375 7070 6f72 7465 6420  s not supported 
+0000b5c0: 6f6e 2049 6e47 6141 7320 6465 7465 6374  on InGaAs detect
+0000b5d0: 6f72 7320 2873 696e 676c 6520 6c69 6e65  ors (single line
+0000b5e0: 2061 7272 6179 2922 290a 2020 2020 2020   array)").      
+0000b5f0: 2020 2020 2020 7265 7475 726e 2053 7065        return Spe
+0000b600: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
+0000b610: 6528 6572 726f 725f 6c76 6c3d 4572 726f  e(error_lvl=Erro
+0000b620: 724c 6576 656c 2e6c 6f77 2c20 6572 726f  rLevel.low, erro
+0000b630: 725f 6d73 673d 2261 7265 6120 7363 616e  r_msg="area scan
+0000b640: 2069 7320 6e6f 7420 7375 7070 6f72 7465   is not supporte
+0000b650: 6420 6f6e 2049 6e47 6141 7320 6465 7465  d on InGaAs dete
+0000b660: 6374 6f72 7320 2873 696e 676c 6520 6c69  ctors (single li
+0000b670: 6e65 2061 7272 6179 2922 290a 0a20 2020  ne array)")..   
+0000b680: 2020 2020 2076 616c 7565 203d 2031 2069       value = 1 i
+0000b690: 6620 666c 6167 2065 6c73 6520 300a 2020  f flag else 0.  
+0000b6a0: 2020 2020 2020 7365 6c66 2e73 6574 7469        self.setti
+0000b6b0: 6e67 732e 7374 6174 652e 6172 6561 5f73  ngs.state.area_s
+0000b6c0: 6361 6e5f 656e 6162 6c65 6420 3d20 666c  can_enabled = fl
+0000b6d0: 6167 0a20 2020 2020 2020 2072 6574 7572  ag.        retur
+0000b6e0: 6e20 7365 6c66 2e5f 7365 6e64 5f63 6f64  n self._send_cod
+0000b6f0: 6528 3078 6562 2c20 7661 6c75 652c 206c  e(0xeb, value, l
+0000b700: 6162 656c 3d22 5345 545f 4152 4541 5f53  abel="SET_AREA_S
+0000b710: 4341 4e5f 454e 4142 4c45 2229 0a0a 2020  CAN_ENABLE")..  
+0000b720: 2020 6465 6620 6765 745f 7365 6e73 6f72    def get_sensor
+0000b730: 5f6c 696e 655f 6c65 6e67 7468 2873 656c  _line_length(sel
+0000b740: 6629 3a0a 2020 2020 2020 2020 7661 6c75  f):.        valu
+0000b750: 6520 3d20 7365 6c66 2e67 6574 5f75 7070  e = self.get_upp
+0000b760: 6572 5f63 6f64 6528 3078 3033 2c20 6c61  er_code(0x03, la
+0000b770: 6265 6c3d 2247 4554 5f4c 494e 455f 4c45  bel="GET_LINE_LE
+0000b780: 4e47 5448 222c 206c 7362 5f6c 656e 3d32  NGTH", lsb_len=2
+0000b790: 290a 2020 2020 2020 2020 6966 2076 616c  ).        if val
+0000b7a0: 7565 2021 3d20 7365 6c66 2e73 6574 7469  ue != self.setti
+0000b7b0: 6e67 732e 7069 7865 6c73 2829 3a0a 2020  ngs.pixels():.  
+0000b7c0: 2020 2020 2020 2020 2020 6c6f 672e 6572            log.er
+0000b7d0: 726f 7228 2247 4554 5f4c 494e 455f 4c45  ror("GET_LINE_LE
+0000b7e0: 4e47 5448 206f 7063 6f64 6520 7265 7375  NGTH opcode resu
+0000b7f0: 6c74 2025 6420 213d 2053 7065 6374 726f  lt %d != Spectro
+0000b800: 6d65 7465 7253 6574 7469 6e67 732e 7069  meterSettings.pi
+0000b810: 7865 6c73 2025 6420 2875 7369 6e67 206f  xels %d (using o
+0000b820: 7063 6f64 6520 7265 7375 6c74 2922 2c0a  pcode result)",.
+0000b830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b840: 7661 6c75 652c 2073 656c 662e 7365 7474  value, self.sett
+0000b850: 696e 6773 2e70 6978 656c 7328 2929 0a20  ings.pixels()). 
+0000b860: 2020 2020 2020 2072 6574 7572 6e20 5370         return Sp
+0000b870: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
+0000b880: 7365 2864 6174 613d 7661 6c75 6529 0a0a  se(data=value)..
+0000b890: 2020 2020 6465 6620 6765 745f 6d69 6372      def get_micr
+0000b8a0: 6f63 6f6e 7472 6f6c 6c65 725f 6669 726d  ocontroller_firm
+0000b8b0: 7761 7265 5f76 6572 7369 6f6e 2873 656c  ware_version(sel
+0000b8c0: 6629 3a0a 2020 2020 2020 2020 6966 2073  f):.        if s
+0000b8d0: 656c 662e 7365 7474 696e 6773 2e6d 6963  elf.settings.mic
+0000b8e0: 726f 636f 6e74 726f 6c6c 6572 5f66 6972  rocontroller_fir
+0000b8f0: 6d77 6172 655f 7665 7273 696f 6e20 6973  mware_version is
+0000b900: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
+0000b910: 2020 2020 2020 2072 6574 7572 6e20 5370         return Sp
+0000b920: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
+0000b930: 7365 2864 6174 613d 7365 6c66 2e73 6574  se(data=self.set
+0000b940: 7469 6e67 732e 6d69 6372 6f63 6f6e 7472  tings.microcontr
+0000b950: 6f6c 6c65 725f 6669 726d 7761 7265 5f76  oller_firmware_v
+0000b960: 6572 7369 6f6e 290a 0a20 2020 2020 2020  ersion)..       
+0000b970: 2072 6573 203d 2073 656c 662e 5f67 6574   res = self._get
+0000b980: 5f63 6f64 6528 3078 6330 2c20 6c61 6265  _code(0xc0, labe
+0000b990: 6c3d 2247 4554 5f43 4f44 455f 5245 5649  l="GET_CODE_REVI
+0000b9a0: 5349 4f4e 2229 0a20 2020 2020 2020 2072  SION").        r
+0000b9b0: 6573 756c 7420 3d20 7265 732e 6461 7461  esult = res.data
+0000b9c0: 0a20 2020 2020 2020 2076 6572 7369 6f6e  .        version
+0000b9d0: 203d 2022 3f2e 3f2e 3f2e 3f22 0a20 2020   = "?.?.?.?".   
+0000b9e0: 2020 2020 2069 6620 7265 7375 6c74 2069       if result i
+0000b9f0: 7320 6e6f 7420 4e6f 6e65 2061 6e64 206c  s not None and l
+0000ba00: 656e 2872 6573 756c 7429 203e 3d20 343a  en(result) >= 4:
+0000ba10: 0a20 2020 2020 2020 2020 2020 2076 6572  .            ver
+0000ba20: 7369 6f6e 203d 2022 2564 2e25 642e 2564  sion = "%d.%d.%d
+0000ba30: 2e25 6422 2025 2028 7265 7375 6c74 5b33  .%d" % (result[3
+0000ba40: 5d2c 2072 6573 756c 745b 325d 2c20 7265  ], result[2], re
+0000ba50: 7375 6c74 5b31 5d2c 2072 6573 756c 745b  sult[1], result[
+0000ba60: 305d 2920 2320 4d53 422d 4c53 420a 0a20  0]) # MSB-LSB.. 
+0000ba70: 2020 2020 2020 2073 656c 662e 7365 7474         self.sett
+0000ba80: 696e 6773 2e6d 6963 726f 636f 6e74 726f  ings.microcontro
+0000ba90: 6c6c 6572 5f66 6972 6d77 6172 655f 7665  ller_firmware_ve
+0000baa0: 7273 696f 6e20 3d20 7665 7273 696f 6e0a  rsion = version.
+0000bab0: 2020 2020 2020 2020 7265 7475 726e 2053          return S
+0000bac0: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
+0000bad0: 6e73 6528 6461 7461 3d76 6572 7369 6f6e  nse(data=version
+0000bae0: 290a 0a20 2020 2064 6566 2067 6574 5f66  )..    def get_f
+0000baf0: 7067 615f 6669 726d 7761 7265 5f76 6572  pga_firmware_ver
+0000bb00: 7369 6f6e 2873 656c 6629 3a0a 2020 2020  sion(self):.    
+0000bb10: 2020 2020 6966 2073 656c 662e 7365 7474      if self.sett
+0000bb20: 696e 6773 2e66 7067 615f 6669 726d 7761  ings.fpga_firmwa
+0000bb30: 7265 5f76 6572 7369 6f6e 2069 7320 6e6f  re_version is no
+0000bb40: 7420 4e6f 6e65 3a0a 2020 2020 2020 2020  t None:.        
+0000bb50: 2020 2020 7265 7475 726e 2053 7065 6374      return Spect
+0000bb60: 726f 6d65 7465 7252 6573 706f 6e73 6528  rometerResponse(
+0000bb70: 6461 7461 3d73 656c 662e 7365 7474 696e  data=self.settin
+0000bb80: 6773 2e66 7067 615f 6669 726d 7761 7265  gs.fpga_firmware
+0000bb90: 5f76 6572 7369 6f6e 290a 0a20 2020 2020  _version)..     
+0000bba0: 2020 2073 203d 2022 220a 2020 2020 2020     s = "".      
+0000bbb0: 2020 7265 7320 3d20 7365 6c66 2e5f 6765    res = self._ge
+0000bbc0: 745f 636f 6465 2830 7862 342c 2077 4c65  t_code(0xb4, wLe
+0000bbd0: 6e67 7468 3d37 2c20 6c61 6265 6c3d 2247  ngth=7, label="G
+0000bbe0: 4554 5f46 5047 415f 5245 5622 290a 2020  ET_FPGA_REV").  
+0000bbf0: 2020 2020 2020 7265 7375 6c74 203d 2072        result = r
+0000bc00: 6573 2e64 6174 610a 2020 2020 2020 2020  es.data.        
+0000bc10: 6966 2072 6573 756c 7420 6973 206e 6f74  if result is not
+0000bc20: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+0000bc30: 2020 2066 6f72 2069 2069 6e20 7261 6e67     for i in rang
+0000bc40: 6528 6c65 6e28 7265 7375 6c74 2929 3a0a  e(len(result)):.
+0000bc50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bc60: 6320 3d20 7265 7375 6c74 5b69 5d0a 2020  c = result[i].  
+0000bc70: 2020 2020 2020 2020 2020 2020 2020 6966                if
+0000bc80: 2030 7832 3020 3c3d 2063 203c 2030 7837   0x20 <= c < 0x7
+0000bc90: 663a 2023 2076 6973 6962 6c65 2041 5343  f: # visible ASC
+0000bca0: 4949 0a20 2020 2020 2020 2020 2020 2020  II.             
+0000bcb0: 2020 2020 2020 2073 202b 3d20 6368 7228         s += chr(
+0000bcc0: 6329 0a0a 2020 2020 2020 2020 7365 6c66  c)..        self
+0000bcd0: 2e73 6574 7469 6e67 732e 6670 6761 5f66  .settings.fpga_f
+0000bce0: 6972 6d77 6172 655f 7665 7273 696f 6e20  irmware_version 
+0000bcf0: 3d20 730a 2020 2020 2020 2020 7265 7475  = s.        retu
+0000bd00: 726e 2053 7065 6374 726f 6d65 7465 7252  rn SpectrometerR
+0000bd10: 6573 706f 6e73 6528 6461 7461 3d73 290a  esponse(data=s).
+0000bd20: 0a20 2020 2064 6566 2067 6574 5f6d 6963  .    def get_mic
+0000bd30: 726f 636f 6e74 726f 6c6c 6572 5f73 6572  rocontroller_ser
+0000bd40: 6961 6c5f 6e75 6d62 6572 2873 656c 6629  ial_number(self)
+0000bd50: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+0000bd60: 204e 6f6e 6520 2320 6469 7361 626c 696e   None # disablin
+0000bd70: 6720 756e 7469 6c20 7765 2077 6f72 6b20  g until we work 
+0000bd80: 6f75 7420 616e 6f74 6865 7220 4265 7461  out another Beta
+0000bd90: 2053 6947 2063 6f6e 666c 6963 740a 0a20   SiG conflict.. 
+0000bda0: 2020 2020 2020 2069 6620 6e6f 7420 7365         if not se
+0000bdb0: 6c66 2e73 6574 7469 6e67 732e 6973 5f61  lf.settings.is_a
+0000bdc0: 726d 2829 3a0a 2020 2020 2020 2020 2020  rm():.          
+0000bdd0: 2020 6c6f 672e 6465 6275 6728 2247 4554    log.debug("GET
+0000bde0: 5f4d 4943 524f 434f 4e54 524f 4c4c 4552  _MICROCONTROLLER
+0000bdf0: 5f53 4552 4941 4c5f 4e55 4d42 4552 2072  _SERIAL_NUMBER r
+0000be00: 6571 7569 7265 7320 4152 4d22 290a 2020  equires ARM").  
+0000be10: 2020 2020 2020 2020 2020 7265 7475 726e            return
+0000be20: 204e 6f6e 650a 0a20 2020 2020 2020 2069   None..        i
+0000be30: 6620 6e6f 7420 7365 6c66 2e73 6574 7469  f not self.setti
+0000be40: 6e67 732e 7375 7070 6f72 7473 5f66 6561  ngs.supports_fea
+0000be50: 7475 7265 2822 6d69 6372 6f63 6f6e 7472  ture("microcontr
+0000be60: 6f6c 6c65 725f 7365 7269 616c 5f6e 756d  oller_serial_num
+0000be70: 6265 7222 293a 0a20 2020 2020 2020 2020  ber"):.         
+0000be80: 2020 206c 6f67 2e64 6562 7567 2822 4745     log.debug("GE
+0000be90: 545f 4d49 4352 4f43 4f4e 5452 4f4c 4c45  T_MICROCONTROLLE
+0000bea0: 525f 5345 5249 414c 5f4e 554d 4245 5220  R_SERIAL_NUMBER 
+0000beb0: 6e6f 7420 7375 7070 6f72 7465 6420 6f6e  not supported on
+0000bec0: 2074 6869 7320 6669 726d 7761 7265 2229   this firmware")
+0000bed0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0000bee0: 7572 6e20 4e6f 6e65 0a0a 2020 2020 2020  urn None..      
+0000bef0: 2020 7265 7375 6c74 203d 2073 656c 662e    result = self.
+0000bf00: 5f67 6574 5f63 6f64 6528 3078 6666 2c20  _get_code(0xff, 
+0000bf10: 7756 616c 7565 3d30 7832 632c 2077 4c65  wValue=0x2c, wLe
+0000bf20: 6e67 7468 3d31 322c 206c 6162 656c 3d22  ngth=12, label="
+0000bf30: 4745 545f 4d49 4352 4f43 4f4e 5452 4f4c  GET_MICROCONTROL
+0000bf40: 4c45 525f 5345 5249 414c 5f4e 554d 4245  LER_SERIAL_NUMBE
+0000bf50: 5222 290a 2020 2020 2020 2020 6966 2072  R").        if r
+0000bf60: 6573 756c 7420 6973 204e 6f6e 653a 0a20  esult is None:. 
+0000bf70: 2020 2020 2020 2020 2020 206c 6f67 2e65             log.e
+0000bf80: 7272 6f72 2822 4745 545f 4d49 4352 4f43  rror("GET_MICROC
+0000bf90: 4f4e 5452 4f4c 4c45 525f 5345 5249 414c  ONTROLLER_SERIAL
+0000bfa0: 5f4e 554d 4245 5220 7265 7475 726e 6564  _NUMBER returned
+0000bfb0: 204e 6f6e 6522 290a 2020 2020 2020 2020   None").        
+0000bfc0: 2020 2020 7265 7475 726e 204e 6f6e 650a      return None.
+0000bfd0: 0a20 2020 2020 2020 2064 6174 6120 3d20  .        data = 
+0000bfe0: 7265 7375 6c74 2e64 6174 610a 2020 2020  result.data.    
+0000bff0: 2020 2020 6966 2064 6174 6120 6973 204e      if data is N
+0000c000: 6f6e 6520 6f72 206c 656e 2864 6174 6129  one or len(data)
+0000c010: 2021 3d20 3132 3a0a 2020 2020 2020 2020   != 12:.        
+0000c020: 2020 2020 6c6f 672e 6572 726f 7228 2247      log.error("G
+0000c030: 4554 5f4d 4943 524f 434f 4e54 524f 4c4c  ET_MICROCONTROLL
+0000c040: 4552 5f53 4552 4941 4c5f 4e55 4d42 4552  ER_SERIAL_NUMBER
+0000c050: 2065 7870 6563 7465 6420 3132 2062 7974   expected 12 byt
+0000c060: 6573 2028 7265 6365 6976 6564 207b 6c65  es (received {le
+0000c070: 6e28 6461 7461 297d 2922 290a 2020 2020  n(data)})").    
+0000c080: 2020 2020 2020 2020 7265 7475 726e 204e          return N
+0000c090: 6f6e 650a 0a20 2020 2020 2020 2064 6573  one..        des
+0000c0a0: 203d 2022 222e 6a6f 696e 2866 227b 763a   = "".join(f"{v:
+0000c0b0: 3032 787d 2220 666f 7220 7620 696e 2064  02x}" for v in d
+0000c0c0: 6174 6129 2023 2044 6576 6963 6520 456c  ata) # Device El
+0000c0d0: 6563 7472 6f6e 6963 2053 6967 6e61 7475  ectronic Signatu
+0000c0e0: 7265 0a20 2020 2020 2020 2073 656c 662e  re.        self.
+0000c0f0: 7365 7474 696e 6773 2e6d 6963 726f 636f  settings.microco
+0000c100: 6e74 726f 6c6c 6572 5f73 6572 6961 6c5f  ntroller_serial_
+0000c110: 6e75 6d62 6572 203d 2064 6573 0a20 2020  number = des.   
+0000c120: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
+0000c130: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
+0000c140: 2864 6174 613d 6465 7329 0a0a 2020 2020  (data=des)..    
+0000c150: 6465 6620 6170 706c 795f 6564 6328 7365  def apply_edc(se
+0000c160: 6c66 2c20 7370 6563 7472 756d 293a 0a20  lf, spectrum):. 
+0000c170: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+0000c180: 2020 2055 7365 2074 6865 2022 7069 7865     Use the "pixe
+0000c190: 6c20 7369 6465 2069 676e 6f72 6564 2061  l side ignored a
+0000c1a0: 7265 6122 2066 6f72 2065 6c65 6374 7269  rea" for electri
+0000c1b0: 6361 6c20 6461 726b 2063 6f72 7265 6374  cal dark correct
+0000c1c0: 696f 6e20 2845 4443 292e 0a0a 2020 2020  ion (EDC)...    
+0000c1d0: 2020 2020 4070 6172 2049 4d58 3338 354c      @par IMX385L
+0000c1e0: 5152 2d43 2064 6174 6173 6865 6574 2028  QR-C datasheet (
+0000c1f0: 7038 290a 0a20 2020 2020 2020 2040 7665  p8)..        @ve
+0000c200: 7262 6174 696d 0a20 2020 2020 2020 2050  rbatim.        P
+0000c210: 6978 656c 7320 2020 2043 6f75 6e74 2044  ixels    Count D
+0000c220: 6573 6372 6970 7469 6f6e 0a20 2020 2020  escription.     
+0000c230: 2020 2030 2d33 2020 2020 2020 2034 2020     0-3       4  
+0000c240: 2020 204f 4220 7369 6465 2069 676e 6f72     OB side ignor
+0000c250: 6564 2061 7265 610a 2020 2020 2020 2020  ed area.        
+0000c260: 342d 3820 2020 2020 2020 3420 2020 2020  4-8       4     
+0000c270: 4566 6665 6374 6976 6520 7069 7865 6c20  Effective pixel 
+0000c280: 7369 6465 2069 676e 6f72 6564 2061 7265  side ignored are
+0000c290: 6120 2020 2020 2020 3c2d 2d20 2273 6865  a       <-- "she
+0000c2a0: 6c66 2220 636f 6d70 6c69 6361 7465 730a  lf" complicates.
+0000c2b0: 2020 2020 2020 2020 392d 3136 2020 2020          9-16    
+0000c2c0: 2020 3820 2020 2020 4566 6665 6374 6976    8     Effectiv
+0000c2d0: 6520 6d61 7267 696e 2066 6f72 2063 6f6c  e margin for col
+0000c2e0: 6f72 2070 726f 6365 7373 696e 670a 2020  or processing.  
+0000c2f0: 2020 2020 2020 3137 2d31 3933 3620 2020        17-1936   
+0000c300: 3139 3230 2020 5265 636f 7264 696e 6720  1920  Recording 
+0000c310: 7069 7865 6c20 6172 6561 0a20 2020 2020  pixel area.     
+0000c320: 2020 2031 3933 372d 3139 3435 2039 2020     1937-1945 9  
+0000c330: 2020 2045 6666 6563 7469 7665 206d 6172     Effective mar
+0000c340: 6769 6e20 666f 7220 636f 6c6f 7220 7072  gin for color pr
+0000c350: 6f63 6573 7369 6e67 0a20 2020 2020 2020  ocessing.       
+0000c360: 2031 3934 362d 3139 3439 2034 2020 2020   1946-1949 4    
+0000c370: 2045 6666 6563 7469 7665 2070 6978 656c   Effective pixel
+0000c380: 2073 6964 6520 6967 6e6f 7265 6420 6172   side ignored ar
+0000c390: 6561 2020 2020 2020 203c 2d2d 2075 7369  ea       <-- usi
+0000c3a0: 6e67 2074 6865 7365 0a20 2020 2020 2020  ng these.       
+0000c3b0: 2031 3935 302d 3139 3532 2033 2020 2020   1950-1952 3    
+0000c3c0: 2044 756d 6d79 0a20 2020 2020 2020 2040   Dummy.        @
+0000c3d0: 656e 6476 6572 6261 7469 6d0a 0a20 2020  endverbatim..   
+0000c3e0: 2020 2020 2040 746f 646f 2077 6520 6d69       @todo we mi
+0000c3f0: 6768 7420 7761 6e74 2074 6f20 6d61 6b65  ght want to make
+0000c400: 2062 7566 6665 7220 6c65 6e67 7468 2063   buffer length c
+0000c410: 6f6e 6669 6775 7261 626c 652c 2065 6974  onfigurable, eit
+0000c420: 6865 7220 696e 2073 7065 6374 7261 0a20  her in spectra. 
+0000c430: 2020 2020 2020 2020 2020 2020 206f 7220               or 
+0000c440: 6279 2074 696d 6520 2863 6f6e 7369 6465  by time (conside
+0000c450: 7220 3130 6d73 2076 7320 3173 6563 2069  r 10ms vs 1sec i
+0000c460: 6e74 6567 7261 7469 6f6e 2074 696d 6529  ntegration time)
+0000c470: 0a20 2020 2020 2020 2022 2222 2020 2020  .        """    
+0000c480: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
+0000c490: 2069 6620 6e6f 7420 7365 6c66 2e73 6574   if not self.set
+0000c4a0: 7469 6e67 732e 7374 6174 652e 6564 635f  tings.state.edc_
+0000c4b0: 656e 6162 6c65 643a 0a20 2020 2020 2020  enabled:.       
+0000c4c0: 2020 2020 2072 6574 7572 6e20 7370 6563       return spec
+0000c4d0: 7472 756d 0a0a 2020 2020 2020 2020 6966  trum..        if
+0000c4e0: 206e 6f74 2073 656c 662e 7365 7474 696e   not self.settin
+0000c4f0: 6773 2e69 735f 696d 7828 293a 0a20 2020  gs.is_imx():.   
+0000c500: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0000c510: 7370 6563 7472 756d 0a0a 2020 2020 2020  spectrum..      
+0000c520: 2020 6966 206c 656e 2873 7065 6374 7275    if len(spectru
+0000c530: 6d29 2021 3d20 3139 3532 3a0a 2020 2020  m) != 1952:.    
+0000c540: 2020 2020 2020 2020 6c6f 672e 6572 726f          log.erro
+0000c550: 7228 2249 4d58 2045 4443 2068 6172 642d  r("IMX EDC hard-
+0000c560: 636f 6465 6420 746f 2031 3935 3270 7822  coded to 1952px"
+0000c570: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+0000c580: 7475 726e 2073 7065 6374 7275 6d0a 0a20  turn spectrum.. 
+0000c590: 2020 2020 2020 2023 2040 746f 646f 3a20         # @todo: 
+0000c5a0: 6672 6f6d 2046 5047 4120 3031 2e34 2e30  from FPGA 01.4.0
+0000c5b0: 392b 2c20 7765 2073 686f 756c 6420 6265  9+, we should be
+0000c5c0: 2061 626c 6520 746f 2075 7365 2073 7065   able to use spe
+0000c5d0: 6374 7275 6d20 5b30 3a34 5d20 6173 200a  ctrum [0:4] as .
+0000c5e0: 2020 2020 2020 2020 2320 2020 2020 2020          #       
+0000c5f0: 2054 5255 4520 6f70 7469 6361 6c20 6461   TRUE optical da
+0000c600: 726b 3b20 616c 736f 2c20 7468 6520 2273  rk; also, the "s
+0000c610: 6865 6c66 2220 7368 6f75 6c64 2062 6520  helf" should be 
+0000c620: 6669 7865 642c 2073 6f20 7468 650a 2020  fixed, so the.  
+0000c630: 2020 2020 2020 2320 2020 2020 2020 2065        #        e
+0000c640: 6e74 6972 6520 6c65 6674 2065 6467 6520  ntire left edge 
+0000c650: 6265 636f 6d65 7320 7573 6162 6c65 2e0a  becomes usable..
+0000c660: 0a20 2020 2020 2020 2023 2074 6869 7320  .        # this 
+0000c670: 6176 6572 6167 6573 2065 6c65 6374 7269  averages electri
+0000c680: 6361 6c20 6461 726b 206f 7665 7220 5350  cal dark over SP
+0000c690: 4143 450a 2020 2020 2020 2020 656c 6563  ACE.        elec
+0000c6a0: 7472 6963 616c 5f64 6172 6b20 3d20 7375  trical_dark = su
+0000c6b0: 6d28 7370 6563 7472 756d 5b31 3934 363a  m(spectrum[1946:
+0000c6c0: 3139 3530 5d29 202f 2034 2e30 200a 0a20  1950]) / 4.0 .. 
+0000c6d0: 2020 2020 2020 2023 2074 6869 7320 6176         # this av
+0000c6e0: 6572 6167 6573 2065 6c65 6374 7269 6361  erages electrica
+0000c6f0: 6c20 6461 726b 206f 7665 7220 7468 6520  l dark over the 
+0000c700: 6c61 7374 204f 4e45 2053 4543 0a20 2020  last ONE SEC.   
+0000c710: 2020 2020 206e 6f77 203d 2064 6174 6574       now = datet
+0000c720: 696d 652e 6461 7465 7469 6d65 2e6e 6f77  ime.datetime.now
+0000c730: 2829 0a20 2020 2020 2020 2074 6f6f 5f6f  ().        too_o
+0000c740: 6c64 203d 206e 6f77 202d 2064 6174 6574  ld = now - datet
+0000c750: 696d 652e 7469 6d65 6465 6c74 6128 7365  ime.timedelta(se
+0000c760: 636f 6e64 733d 3129 0a0a 2020 2020 2020  conds=1)..      
+0000c770: 2020 746f 7461 6c20 3d20 656c 6563 7472    total = electr
+0000c780: 6963 616c 5f64 6172 6b0a 2020 2020 2020  ical_dark.      
+0000c790: 2020 6e65 775f 6275 6620 3d20 5b20 286e    new_buf = [ (n
+0000c7a0: 6f77 2c20 656c 6563 7472 6963 616c 5f64  ow, electrical_d
+0000c7b0: 6172 6b29 205d 0a20 2020 2020 2020 2066  ark) ].        f
+0000c7c0: 6f72 2070 6169 7220 696e 2073 656c 662e  or pair in self.
+0000c7d0: 7365 7474 696e 6773 2e73 7461 7465 2e65  settings.state.e
+0000c7e0: 6463 5f62 7566 6665 723a 0a20 2020 2020  dc_buffer:.     
+0000c7f0: 2020 2020 2020 2074 732c 2076 616c 7565         ts, value
+0000c800: 203d 2070 6169 720a 2020 2020 2020 2020   = pair.        
+0000c810: 2020 2020 6966 2074 7320 3e3d 2074 6f6f      if ts >= too
+0000c820: 5f6f 6c64 3a0a 2020 2020 2020 2020 2020  _old:.          
+0000c830: 2020 2020 2020 746f 7461 6c20 2b3d 2076        total += v
+0000c840: 616c 7565 0a20 2020 2020 2020 2020 2020  alue.           
+0000c850: 2020 2020 206e 6577 5f62 7566 2e61 7070       new_buf.app
+0000c860: 656e 6428 2028 7473 2c20 7661 6c75 6529  end( (ts, value)
+0000c870: 2029 0a20 2020 2020 2020 2073 656c 662e   ).        self.
+0000c880: 7365 7474 696e 6773 2e73 7461 7465 2e65  settings.state.e
+0000c890: 6463 5f62 7566 6665 7220 3d20 6e65 775f  dc_buffer = new_
+0000c8a0: 6275 660a 0a20 2020 2020 2020 2061 7667  buf..        avg
+0000c8b0: 5f64 6172 6b20 3d20 726f 756e 6428 746f  _dark = round(to
+0000c8c0: 7461 6c20 2f20 6c65 6e28 6e65 775f 6275  tal / len(new_bu
+0000c8d0: 6629 2c20 3229 0a20 2020 2020 2020 2072  f), 2).        r
+0000c8e0: 6574 7572 6e20 5b20 7620 2d20 6176 675f  eturn [ v - avg_
+0000c8f0: 6461 726b 2066 6f72 2076 2069 6e20 7370  dark for v in sp
+0000c900: 6563 7472 756d 205d 0a0a 2020 2020 6465  ectrum ]..    de
+0000c910: 6620 6765 745f 6c69 6e65 2873 656c 662c  f get_line(self,
+0000c920: 2074 7269 6767 6572 3a20 626f 6f6c 203d   trigger: bool =
+0000c930: 2054 7275 6529 3a0a 2020 2020 2020 2020   True):.        
+0000c940: 2222 220a 2020 2020 2020 2020 5365 6e64  """.        Send
+0000c950: 2022 6163 7175 6972 6522 2c20 7468 656e   "acquire", then
+0000c960: 2069 6d6d 6564 6961 7465 6c79 2072 6561   immediately rea
+0000c970: 6420 7468 6520 6275 6c6b 2065 6e64 706f  d the bulk endpo
+0000c980: 696e 7428 7329 2e0a 2020 2020 2020 2020  int(s)..        
+0000c990: 5072 6f62 6162 6c79 2074 6865 206d 6f73  Probably the mos
+0000c9a0: 7420 696d 706f 7274 616e 7420 6d65 7468  t important meth
+0000c9b0: 6f64 2069 6e20 7468 6973 2063 6c61 7373  od in this class
+0000c9c0: 2c20 6d6f 7265 2063 6f6d 6d6f 6e6c 7920  , more commonly 
+0000c9d0: 6361 6c6c 6564 0a20 2020 2020 2020 2022  called.        "
+0000c9e0: 6765 7453 7065 6374 7275 6d22 2069 6e20  getSpectrum" in 
+0000c9f0: 6d6f 7374 2064 7269 7665 7273 2e0a 2020  most drivers..  
+0000ca00: 2020 2020 2020 4070 6172 616d 2074 7269        @param tri
+0000ca10: 6767 6572 2028 496e 7075 7429 2073 656e  gger (Input) sen
+0000ca20: 6420 616e 2069 6e69 7469 616c 2041 4351  d an initial ACQ
+0000ca30: 5549 5245 0a20 2020 2020 2020 2040 7265  UIRE.        @re
+0000ca40: 7475 726e 7320 7475 706c 6520 6f66 2028  turns tuple of (
+0000ca50: 7370 6563 7472 756d 5b5d 2c20 6172 6561  spectrum[], area
+0000ca60: 5f73 6361 6e5f 726f 775f 636f 756e 7429  _scan_row_count)
+0000ca70: 2066 6f72 2073 7563 6365 7373 0a20 2020   for success.   
+0000ca80: 2020 2020 2040 7265 7475 726e 7320 4e6f       @returns No
+0000ca90: 6e65 2077 6865 6e20 6974 2074 696d 6573  ne when it times
+0000caa0: 2d6f 7574 2077 6869 6c65 2077 6169 7469  -out while waiti
+0000cab0: 6e67 2066 6f72 2061 6e20 6578 7465 726e  ng for an extern
+0000cac0: 616c 2074 7269 6767 6572 0a20 2020 2020  al trigger.     
+0000cad0: 2020 2020 2020 2020 2020 2020 2869 6e74              (int
+0000cae0: 6572 7072 6574 2061 732c 2022 6469 646e  erpret as, "didn
+0000caf0: 2774 2066 696e 6420 616e 7920 6669 7368  't find any fish
+0000cb00: 2074 6869 7320 7469 6d65 2c20 7472 7920   this time, try 
+0000cb10: 6167 6169 6e20 696e 2061 2062 6974 2229  again in a bit")
+0000cb20: 0a20 2020 2020 2020 2040 7265 7475 726e  .        @return
+0000cb30: 7320 4661 6c73 6520 2862 6f6f 6c29 2077  s False (bool) w
+0000cb40: 6865 6e20 6974 2074 696d 6573 2d6f 7574  hen it times-out
+0000cb50: 206f 7220 656e 636f 756e 7465 7273 2061   or encounters a
+0000cb60: 6e20 6578 6365 7074 696f 6e0a 2020 2020  n exception.    
+0000cb70: 2020 2020 2020 2020 2020 2020 2077 6865               whe
+0000cb80: 6e20 4e4f 5420 696e 2065 7874 6572 6e61  n NOT in externa
+0000cb90: 6c2d 7472 6967 6765 7265 6420 6d6f 6465  l-triggered mode
+0000cba0: 0a20 2020 2020 2020 2040 7468 726f 7773  .        @throws
+0000cbb0: 2065 7863 6570 7469 6f6e 206f 6e20 7469   exception on ti
+0000cbc0: 6d65 6f75 7420 2875 6e6c 6573 7320 6578  meout (unless ex
+0000cbd0: 7465 726e 616c 2074 7269 6767 6572 696e  ternal triggerin
+0000cbe0: 6720 656e 6162 6c65 6429 0a20 2020 2020  g enabled).     
+0000cbf0: 2020 2022 2222 0a20 2020 2020 2020 2072     """.        r
+0000cc00: 6573 706f 6e73 6520 3d20 5370 6563 7472  esponse = Spectr
+0000cc10: 6f6d 6574 6572 5265 7370 6f6e 7365 2829  ometerResponse()
+0000cc20: 0a0a 2020 2020 2020 2020 6966 206e 6f74  ..        if not
+0000cc30: 2073 656c 662e 6973 5f73 656e 736f 725f   self.is_sensor_
+0000cc40: 7374 6162 6c65 2829 3a0a 2020 2020 2020  stable():.      
+0000cc50: 2020 2020 2020 7265 7370 6f6e 7365 2e65        response.e
+0000cc60: 7272 6f72 5f6d 7367 203d 2022 6765 745f  rror_msg = "get_
+0000cc70: 6c69 6e65 3a20 6c65 6176 696e 6720 7365  line: leaving se
+0000cc80: 6e73 6f72 2061 6c6f 6e65 2077 6869 6c65  nsor alone while
+0000cc90: 2073 7461 6269 6c69 7a69 6e67 220a 2020   stabilizing".  
+0000cca0: 2020 2020 2020 2020 2020 7265 7370 6f6e            respon
+0000ccb0: 7365 2e65 7272 6f72 5f6c 766c 203d 2045  se.error_lvl = E
+0000ccc0: 7272 6f72 4c65 7665 6c2e 6c6f 770a 2020  rrorLevel.low.  
+0000ccd0: 2020 2020 2020 2020 2020 7265 7370 6f6e            respon
+0000cce0: 7365 2e6b 6565 705f 616c 6976 6520 3d20  se.keep_alive = 
+0000ccf0: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
+0000cd00: 206c 6f67 2e64 6562 7567 2872 6573 706f   log.debug(respo
+0000cd10: 6e73 652e 6572 726f 725f 6d73 6729 0a20  nse.error_msg). 
+0000cd20: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0000cd30: 7175 6575 655f 6d65 7373 6167 6528 226d  queue_message("m
+0000cd40: 6172 7175 6565 5f69 6e66 6f22 2c20 2273  arquee_info", "s
+0000cd50: 656e 736f 7220 6973 2073 7461 6269 6c69  ensor is stabili
+0000cd60: 7a69 6e67 2229 0a20 2020 2020 2020 2020  zing").         
+0000cd70: 2020 2072 6574 7572 6e20 7265 7370 6f6e     return respon
+0000cd80: 7365 0a0a 2020 2020 2020 2020 2323 2323  se..        ####
+0000cd90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000cda0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0000cdb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0000cdc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000cdd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000cde0: 2323 2323 2323 2323 2323 230d 0a20 2020  ###########..   
-0000cdf0: 2020 2020 2023 2065 7272 6f72 2d63 6865       # error-che
-0000ce00: 636b 2074 6865 2072 6563 6569 7665 6420  ck the received 
-0000ce10: 7370 6563 7472 756d 0d0a 2020 2020 2020  spectrum..      
-0000ce20: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
+0000cdd0: 2323 2323 0a20 2020 2020 2020 2023 2073  ####.        # s
+0000cde0: 656e 6420 7468 6520 4143 5155 4952 450a  end the ACQUIRE.
+0000cdf0: 2020 2020 2020 2020 2323 2323 2323 2323          ########
+0000ce00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ce10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ce20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0000ce30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ce40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ce50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ce60: 2323 2323 2323 2323 2323 0d0a 0d0a 2020  ##########....  
-0000ce70: 2020 2020 2020 6c6f 672e 6465 6275 6728        log.debug(
-0000ce80: 2267 6574 5f6c 696e 653a 2063 6f6d 706c  "get_line: compl
-0000ce90: 6574 6564 2069 6e20 252e 3266 2073 6563  eted in %.2f sec
-0000cea0: 2028 7673 2069 6e74 6567 7261 7469 6f6e   (vs integration
-0000ceb0: 2074 696d 6520 2564 206d 7329 222c 0d0a   time %d ms)",..
-0000cec0: 2020 2020 2020 2020 2020 2020 2864 6174              (dat
-0000ced0: 6574 696d 652e 6461 7465 7469 6d65 2e6e  etime.datetime.n
-0000cee0: 6f77 2829 202d 2061 6371 7569 7369 7469  ow() - acquisiti
-0000cef0: 6f6e 5f74 696d 6573 7461 6d70 292e 746f  on_timestamp).to
-0000cf00: 7461 6c5f 7365 636f 6e64 7328 292c 0d0a  tal_seconds(),..
-0000cf10: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0000cf20: 2e73 6574 7469 6e67 732e 7374 6174 652e  .settings.state.
-0000cf30: 696e 7465 6772 6174 696f 6e5f 7469 6d65  integration_time
-0000cf40: 5f6d 7329 0d0a 0d0a 2020 2020 2020 2020  _ms)....        
-0000cf50: 6c6f 672e 6465 6275 6728 2267 6574 5f6c  log.debug("get_l
-0000cf60: 696e 653a 2070 6978 656c 7320 2564 2c20  ine: pixels %d, 
-0000cf70: 656e 6470 6f69 6e74 7320 2573 2c20 626c  endpoints %s, bl
-0000cf80: 6f63 6b20 2564 2c20 7370 6563 7472 756d  ock %d, spectrum
-0000cf90: 2025 7320 2e2e 2e22 2c0d 0a20 2020 2020   %s ...",..     
-0000cfa0: 2020 2020 2020 206c 656e 2873 7065 6374         len(spect
-0000cfb0: 7275 6d29 2c20 656e 6470 6f69 6e74 732c  rum), endpoints,
-0000cfc0: 2062 6c6f 636b 5f6c 656e 5f62 7974 6573   block_len_bytes
-0000cfd0: 2c20 7370 6563 7472 756d 5b30 3a39 5d29  , spectrum[0:9])
-0000cfe0: 0d0a 0d0a 2020 2020 2020 2020 6966 206c  ....        if l
-0000cff0: 656e 2873 7065 6374 7275 6d29 2021 3d20  en(spectrum) != 
-0000d000: 7069 7865 6c73 3a0d 0a20 2020 2020 2020  pixels:..       
-0000d010: 2020 2020 206c 6f67 2e65 7272 6f72 2822       log.error("
-0000d020: 6765 745f 6c69 6e65 2072 6561 6420 7772  get_line read wr
-0000d030: 6f6e 6720 6e75 6d62 6572 206f 6620 7069  ong number of pi
-0000d040: 7865 6c73 2028 6578 7065 6374 6564 2025  xels (expected %
-0000d050: 642c 2072 6561 6420 2564 2922 2c20 7069  d, read %d)", pi
-0000d060: 7865 6c73 2c20 6c65 6e28 7370 6563 7472  xels, len(spectr
-0000d070: 756d 2929 0d0a 2020 2020 2020 2020 2020  um))..          
-0000d080: 2020 7265 7370 6f6e 7365 2e65 7272 6f72    response.error
-0000d090: 5f6d 7367 203d 2066 2267 6574 5f6c 696e  _msg = f"get_lin
-0000d0a0: 6520 7265 6164 2077 726f 6e67 206e 756d  e read wrong num
-0000d0b0: 6265 7220 6f66 2070 6978 656c 7320 2865  ber of pixels (e
-0000d0c0: 7870 6563 7465 6420 7b70 6978 656c 737d  xpected {pixels}
-0000d0d0: 2c20 7265 6164 207b 6c65 6e28 7370 6563  , read {len(spec
-0000d0e0: 7472 756d 297d 2922 0d0a 2020 2020 2020  trum)})"..      
-0000d0f0: 2020 2020 2020 7265 7370 6f6e 7365 2e65        response.e
-0000d100: 7272 6f72 5f6c 766c 203d 2045 7272 6f72  rror_lvl = Error
-0000d110: 4c65 7665 6c2e 6c6f 770d 0a20 2020 2020  Level.low..     
-0000d120: 2020 2020 2020 2072 6573 706f 6e73 652e         response.
-0000d130: 6b65 6570 5f61 6c69 7665 203d 2054 7275  keep_alive = Tru
-0000d140: 650d 0a20 2020 2020 2020 2020 2020 2072  e..            r
-0000d150: 6574 7572 6e20 7265 7370 6f6e 7365 0d0a  eturn response..
-0000d160: 2020 2020 2020 2020 2020 2020 2320 6966              # if
-0000d170: 206c 656e 2873 7065 6374 7275 6d29 203c   len(spectrum) <
-0000d180: 2070 6978 656c 733a 0d0a 2020 2020 2020   pixels:..      
-0000d190: 2020 2020 2020 2320 2020 2020 7370 6563        #     spec
-0000d1a0: 7472 756d 2e65 7874 656e 6428 5b30 5d20  trum.extend([0] 
-0000d1b0: 2a20 2870 6978 656c 7320 2d20 6c65 6e28  * (pixels - len(
-0000d1c0: 7370 6563 7472 756d 2929 290d 0a20 2020  spectrum)))..   
-0000d1d0: 2020 2020 2020 2020 2023 2065 6c73 653a           # else:
-0000d1e0: 0d0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-0000d1f0: 2020 2020 7370 6563 7472 756d 203d 2073      spectrum = s
-0000d200: 7065 6374 7275 6d5b 3a2d 7069 7865 6c73  pectrum[:-pixels
-0000d210: 5d0d 0a0d 0a20 2020 2020 2020 2023 2323  ]....        ###
-0000d220: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d230: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d240: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d250: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d260: 2323 2323 230d 0a20 2020 2020 2020 2023  #####..        #
-0000d270: 0d0a 2020 2020 2020 2020 2320 2020 2020  ..        #     
-0000d280: 2020 2020 2020 2020 2020 2020 2020 706f                po
-0000d290: 7374 2d70 726f 6365 7373 2074 6865 2073  st-process the s
-0000d2a0: 7065 6374 7275 6d0d 0a20 2020 2020 2020  pectrum..       
-0000d2b0: 2023 0d0a 2020 2020 2020 2020 2323 2323   #..        ####
-0000d2c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d2d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d2e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d2f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d300: 2323 2323 0d0a 0d0a 2020 2020 2020 2020  ####....        
-0000d310: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d320: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d330: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d340: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d350: 2323 2323 2323 2323 0d0a 2020 2020 2020  ########..      
-0000d360: 2020 2320 4170 706c 7920 496e 4761 4173    # Apply InGaAs
-0000d370: 2065 7665 6e2f 6f64 6420 6761 696e 2f6f   even/odd gain/o
-0000d380: 6666 7365 7420 696e 2073 6f66 7477 6172  ffset in softwar
-0000d390: 650d 0a20 2020 2020 2020 2023 2323 2323  e..        #####
-0000d3a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d3b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d3c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d3d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d3e0: 2323 230d 0a0d 0a20 2020 2020 2020 2023  ###....        #
-0000d3f0: 2028 6265 666f 7265 2078 2d61 7869 7320   (before x-axis 
-0000d400: 696e 7665 7273 696f 6e20 6265 6361 7573  inversion becaus
-0000d410: 6520 7468 6973 2069 7320 7768 6572 6520  e this is where 
-0000d420: 4650 4741 2077 696c 6c20 646f 2069 7429  FPGA will do it)
-0000d430: 0d0a 0d0a 2020 2020 2020 2020 2320 7468  ....        # th
-0000d440: 6973 2073 686f 756c 6420 6265 2064 6f6e  is should be don
-0000d450: 6520 696e 2074 6865 2046 5047 412c 2062  e in the FPGA, b
-0000d460: 7574 206f 6c64 6572 2046 5720 6469 646e  ut older FW didn
-0000d470: 2774 2068 6176 6520 7468 6174 0d0a 2020  't have that..  
-0000d480: 2020 2020 2020 2320 696d 706c 656d 656e        # implemen
-0000d490: 7465 642c 2073 6f20 6669 7820 696e 2053  ted, so fix in S
-0000d4a0: 5720 756e 6c65 7373 2045 4550 524f 4d20  W unless EEPROM 
-0000d4b0: 696e 6469 6361 7465 7320 2261 6c72 6561  indicates "alrea
-0000d4c0: 6479 2068 616e 646c 6564 220d 0a20 2020  dy handled"..   
-0000d4d0: 2020 2020 2069 6620 7365 6c66 2e73 6574       if self.set
-0000d4e0: 7469 6e67 732e 6973 5f69 6e67 6161 7328  tings.is_ingaas(
-0000d4f0: 2920 616e 6420 6e6f 7420 7365 6c66 2e73  ) and not self.s
-0000d500: 6574 7469 6e67 732e 6565 7072 6f6d 2e68  ettings.eeprom.h
-0000d510: 6172 6477 6172 655f 6576 656e 5f6f 6464  ardware_even_odd
-0000d520: 3a0d 0a20 2020 2020 2020 2020 2020 2073  :..            s
-0000d530: 656c 662e 5f63 6f72 7265 6374 5f69 6e67  elf._correct_ing
-0000d540: 6161 735f 6761 696e 5f61 6e64 5f6f 6666  aas_gain_and_off
-0000d550: 7365 7428 7370 6563 7472 756d 290d 0a0d  set(spectrum)...
-0000d560: 0a20 2020 2020 2020 2023 2323 2323 2323  .        #######
-0000d570: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d580: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ce40: 0a0a 2020 2020 2020 2020 2320 6d61 696e  ..        # main
+0000ce50: 2075 7365 2d63 6173 6520 666f 7220 4e4f   use-case for NO
+0000ce60: 5420 7365 6e64 696e 6720 6120 7472 6967  T sending a trig
+0000ce70: 6765 7220 776f 756c 6420 6265 2077 6865  ger would be whe
+0000ce80: 6e20 7265 6164 696e 670a 2020 2020 2020  n reading.      
+0000ce90: 2020 2320 7375 6273 6571 7565 6e74 206c    # subsequent l
+0000cea0: 696e 6573 206f 6620 6461 7461 2066 726f  ines of data fro
+0000ceb0: 6d20 6172 6561 2073 6361 6e20 2266 6173  m area scan "fas
+0000cec0: 7422 206d 6f64 650a 0a20 2020 2020 2020  t" mode..       
+0000ced0: 2061 6371 7569 7369 7469 6f6e 5f74 696d   acquisition_tim
+0000cee0: 6573 7461 6d70 203d 2064 6174 6574 696d  estamp = datetim
+0000cef0: 652e 6461 7465 7469 6d65 2e6e 6f77 2829  e.datetime.now()
+0000cf00: 0a20 2020 2020 2020 2069 6620 7472 6967  .        if trig
+0000cf10: 6765 7220 616e 6420 7365 6c66 2e73 6574  ger and self.set
+0000cf20: 7469 6e67 732e 7374 6174 652e 7472 6967  tings.state.trig
+0000cf30: 6765 725f 736f 7572 6365 203d 3d20 5370  ger_source == Sp
+0000cf40: 6563 7472 6f6d 6574 6572 5374 6174 652e  ectrometerState.
+0000cf50: 5452 4947 4745 525f 534f 5552 4345 5f49  TRIGGER_SOURCE_I
+0000cf60: 4e54 4552 4e41 4c3a 0a20 2020 2020 2020  NTERNAL:.       
+0000cf70: 2020 2020 2023 204f 6e6c 7920 7365 6e64       # Only send
+0000cf80: 2041 4351 5549 5245 2028 696e 7465 726e   ACQUIRE (intern
+0000cf90: 616c 2053 5720 7472 6967 6765 7229 2069  al SW trigger) i
+0000cfa0: 6620 6578 7465 726e 616c 2048 5720 7472  f external HW tr
+0000cfb0: 6967 6765 7220 6973 2064 6973 6162 6c65  igger is disable
+0000cfc0: 6420 2864 6566 6175 6c74 290a 2020 2020  d (default).    
+0000cfd0: 2020 2020 2020 2020 6c6f 672e 6465 6275          log.debu
+0000cfe0: 6728 2267 6574 5f6c 696e 653a 2072 6571  g("get_line: req
+0000cff0: 7565 7374 696e 6720 7370 6563 7472 756d  uesting spectrum
+0000d000: 2229 0a20 2020 2020 2020 2020 2020 2073  ").            s
+0000d010: 656c 662e 5f73 656e 645f 636f 6465 2830  elf._send_code(0
+0000d020: 7861 642c 206c 6162 656c 3d22 4143 5155  xad, label="ACQU
+0000d030: 4952 455f 5350 4543 5452 554d 2229 0a0a  IRE_SPECTRUM")..
+0000d040: 2020 2020 2020 2020 2323 2323 2323 2323          ########
+0000d050: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d060: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d070: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d080: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d090: 0a20 2020 2020 2020 2023 2070 7265 7061  .        # prepa
+0000d0a0: 7265 2074 6f20 7265 6164 2073 7065 6374  re to read spect
+0000d0b0: 7275 6d0a 2020 2020 2020 2020 2323 2323  rum.        ####
+0000d0c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d0d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d0e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d0f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d100: 2323 2323 0a0a 2020 2020 2020 2020 7069  ####..        pi
+0000d110: 7865 6c73 203d 2073 656c 662e 7365 7474  xels = self.sett
+0000d120: 696e 6773 2e70 6978 656c 7328 290a 0a20  ings.pixels().. 
+0000d130: 2020 2020 2020 2023 2077 6865 6e20 6368         # when ch
+0000d140: 616e 6769 6e67 2064 6574 6563 746f 7220  anging detector 
+0000d150: 524f 492c 2065 7861 6374 6c79 204f 4e45  ROI, exactly ONE
+0000d160: 2052 4541 4420 7368 6f75 6c64 2062 6520   READ should be 
+0000d170: 6174 2074 6865 2070 7265 7669 6f75 7320  at the previous 
+0000d180: 6c65 6e67 7468 0a20 2020 2020 2020 2023  length.        #
+0000d190: 2069 6620 7365 6c66 2e70 7265 765f 7069   if self.prev_pi
+0000d1a0: 7865 6c73 2069 7320 6e6f 7420 4e6f 6e65  xels is not None
+0000d1b0: 3a0a 2020 2020 2020 2020 2320 2020 2020  :.        #     
+0000d1c0: 6c6f 672e 6465 6275 6728 6622 6765 745f  log.debug(f"get_
+0000d1d0: 6c69 6e65 3a20 7573 696e 6720 6f6e 652d  line: using one-
+0000d1e0: 7469 6d65 2070 7265 765f 7069 7865 6c73  time prev_pixels
+0000d1f0: 2076 616c 7565 206f 6620 7b73 656c 662e   value of {self.
+0000d200: 7072 6576 5f70 6978 656c 737d 2072 6174  prev_pixels} rat
+0000d210: 6865 7220 7468 616e 207b 7069 7865 6c73  her than {pixels
+0000d220: 7d22 290a 2020 2020 2020 2020 2320 2020  }").        #   
+0000d230: 2020 7069 7865 6c73 203d 2073 656c 662e    pixels = self.
+0000d240: 7072 6576 5f70 6978 656c 730a 2020 2020  prev_pixels.    
+0000d250: 2020 2020 2320 2020 2020 7365 6c66 2e70      #     self.p
+0000d260: 7265 765f 7069 7865 6c73 203d 204e 6f6e  rev_pixels = Non
+0000d270: 650a 0a20 2020 2020 2020 2023 2061 6c6c  e..        # all
+0000d280: 206d 6f64 656c 7320 7265 7475 726e 2073   models return s
+0000d290: 7065 6374 7261 2061 7320 5b75 696e 7431  pectra as [uint1
+0000d2a0: 365d 0a20 2020 2020 2020 2065 6e64 706f  6].        endpo
+0000d2b0: 696e 7473 203d 205b 3078 3832 5d0a 2020  ints = [0x82].  
+0000d2c0: 2020 2020 2020 626c 6f63 6b5f 6c65 6e5f        block_len_
+0000d2d0: 6279 7465 7320 3d20 7069 7865 6c73 202a  bytes = pixels *
+0000d2e0: 2032 0a20 2020 2020 2020 2069 6620 7069   2.        if pi
+0000d2f0: 7865 6c73 203d 3d20 3230 3438 2061 6e64  xels == 2048 and
+0000d300: 206e 6f74 2073 656c 662e 7365 7474 696e   not self.settin
+0000d310: 6773 2e69 735f 6172 6d28 293a 0a20 2020  gs.is_arm():.   
+0000d320: 2020 2020 2020 2020 2065 6e64 706f 696e           endpoin
+0000d330: 7473 203d 205b 3078 3832 2c20 3078 3836  ts = [0x82, 0x86
+0000d340: 5d0a 2020 2020 2020 2020 2020 2020 626c  ].            bl
+0000d350: 6f63 6b5f 6c65 6e5f 6279 7465 7320 3d20  ock_len_bytes = 
+0000d360: 3230 3438 2023 2031 3032 3420 7069 7865  2048 # 1024 pixe
+0000d370: 6c73 2061 7069 6563 6520 6672 6f6d 2074  ls apiece from t
+0000d380: 776f 2065 6e64 706f 696e 7473 0a0a 2020  wo endpoints..  
+0000d390: 2020 2020 2020 6966 2073 656c 662e 7365        if self.se
+0000d3a0: 7474 696e 6773 2e69 735f 6d69 6372 6f28  ttings.is_micro(
+0000d3b0: 293a 0a20 2020 2020 2020 2020 2020 2023  ):.            #
+0000d3c0: 2077 6520 6861 7665 206e 6f20 6964 6561   we have no idea
+0000d3d0: 2069 6620 5365 7269 6573 2d58 5320 6861   if Series-XS ha
+0000d3e0: 7320 746f 2022 7761 6b65 2075 7022 2074  s to "wake up" t
+0000d3f0: 6865 2073 656e 736f 722c 2073 6f20 7761  he sensor, so wa
+0000d400: 6974 0a20 2020 2020 2020 2020 2020 2023  it.            #
+0000d410: 206c 6f6e 6720 656e 6f75 6768 2066 6f72   long enough for
+0000d420: 2032 306d 7320 2b20 3820 7468 726f 7761   20ms + 8 throwa
+0000d430: 7761 7920 6672 616d 6573 2069 6620 6e65  way frames if ne
+0000d440: 6564 2062 6520 2849 4d58 3338 3520 6461  ed be (IMX385 da
+0000d450: 7461 7368 6565 7420 7036 3929 0a20 2020  tasheet p69).   
+0000d460: 2020 2020 2020 2020 2074 696d 656f 7574           timeout
+0000d470: 5f6d 7320 3d20 7365 6c66 2e73 6574 7469  _ms = self.setti
+0000d480: 6e67 732e 7374 6174 652e 696e 7465 6772  ngs.state.integr
+0000d490: 6174 696f 6e5f 7469 6d65 5f6d 7320 2a20  ation_time_ms * 
+0000d4a0: 3820 2b20 3530 3020 2a20 7365 6c66 2e73  8 + 500 * self.s
+0000d4b0: 6574 7469 6e67 732e 6e75 6d5f 636f 6e6e  ettings.num_conn
+0000d4c0: 6563 7465 645f 6465 7669 6365 7320 2b20  ected_devices + 
+0000d4d0: 3230 0a20 2020 2020 2020 2065 6c73 653a  20.        else:
+0000d4e0: 0a20 2020 2020 2020 2020 2020 2074 696d  .            tim
+0000d4f0: 656f 7574 5f6d 7320 3d20 7365 6c66 2e73  eout_ms = self.s
+0000d500: 6574 7469 6e67 732e 7374 6174 652e 696e  ettings.state.in
+0000d510: 7465 6772 6174 696f 6e5f 7469 6d65 5f6d  tegration_time_m
+0000d520: 7320 2a20 3220 2b20 3130 3030 202a 2073  s * 2 + 1000 * s
+0000d530: 656c 662e 7365 7474 696e 6773 2e6e 756d  elf.settings.num
+0000d540: 5f63 6f6e 6e65 6374 6564 5f64 6576 6963  _connected_devic
+0000d550: 6573 0a0a 2020 2020 2020 2020 7365 6c66  es..        self
+0000d560: 2e5f 7761 6974 5f66 6f72 5f75 7362 5f61  ._wait_for_usb_a
+0000d570: 7661 696c 6162 6c65 2829 0a0a 2020 2020  vailable()..    
+0000d580: 2020 2020 2323 2323 2323 2323 2323 2323      ############
 0000d590: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0000d5a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d5b0: 230d 0a20 2020 2020 2020 2023 2041 7265  #..        # Are
-0000d5c0: 6120 5363 616e 2028 7261 7265 290d 0a20  a Scan (rare).. 
-0000d5d0: 2020 2020 2020 2023 2323 2323 2323 2323         #########
-0000d5e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d5f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d600: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d610: 2323 2323 2323 2323 2323 2323 2323 230d  ###############.
-0000d620: 0a0d 0a20 2020 2020 2020 2023 2028 6265  ...        # (be
-0000d630: 666f 7265 2078 2d61 7869 7320 696e 7665  fore x-axis inve
-0000d640: 7273 696f 6e20 6265 6361 7573 6520 6c69  rsion because li
-0000d650: 6e65 2069 6e64 6578 2061 7420 4650 4741  ne index at FPGA
-0000d660: 2070 6978 656c 2030 290d 0a0d 0a20 2020   pixel 0)....   
-0000d670: 2020 2020 2023 2049 6620 7765 2772 6520       # If we're 
-0000d680: 696e 2061 7265 6120 7363 616e 206d 6f64  in area scan mod
-0000d690: 652c 2075 7365 2066 6972 7374 2070 6978  e, use first pix
-0000d6a0: 656c 2061 7320 726f 7720 696e 6465 7820  el as row index 
-0000d6b0: 286c 6561 7665 2070 6978 656c 200d 0a20  (leave pixel .. 
-0000d6c0: 2020 2020 2020 2023 2069 6e20 7370 6563         # in spec
-0000d6d0: 7472 756d 292e 2020 446f 2074 6869 7320  trum).  Do this 
-0000d6e0: 6265 666f 7265 2061 6e79 2068 6f72 697a  before any horiz
-0000d6f0: 6f6e 7461 6c20 6176 6572 6167 696e 6720  ontal averaging 
-0000d700: 7768 6963 6820 6d69 6768 7420 0d0a 2020  which might ..  
-0000d710: 2020 2020 2020 2320 636f 7272 7570 7420        # corrupt 
-0000d720: 6669 7273 7420 7069 7865 6c29 2e20 204e  first pixel).  N
-0000d730: 6f74 6520 7468 6174 2049 6e47 6141 7320  ote that InGaAs 
-0000d740: 646f 6e27 7420 7375 7070 6f72 7420 4465  don't support De
-0000d750: 7465 6374 6f72 5265 6769 6f6e 732e 0d0a  tectorRegions...
-0000d760: 2020 2020 2020 2020 6172 6561 5f73 6361          area_sca
-0000d770: 6e5f 726f 775f 636f 756e 7420 3d20 2d31  n_row_count = -1
-0000d780: 0d0a 2020 2020 2020 2020 6966 2073 656c  ..        if sel
-0000d790: 662e 7365 7474 696e 6773 2e73 7461 7465  f.settings.state
-0000d7a0: 2e61 7265 615f 7363 616e 5f65 6e61 626c  .area_scan_enabl
-0000d7b0: 6564 3a0d 0a20 2020 2020 2020 2020 2020  ed:..           
-0000d7c0: 2061 7265 615f 7363 616e 5f72 6f77 5f63   area_scan_row_c
-0000d7d0: 6f75 6e74 203d 2073 7065 6374 7275 6d5b  ount = spectrum[
-0000d7e0: 305d 0d0a 0d0a 2020 2020 2020 2020 2020  0]....          
-0000d7f0: 2020 2320 666f 7220 6920 696e 2072 616e    # for i in ran
-0000d800: 6765 2834 293a 0d0a 2020 2020 2020 2020  ge(4):..        
-0000d810: 2020 2020 2320 2020 2020 7370 6563 7472      #     spectr
-0000d820: 756d 5b69 5d20 3d20 7370 6563 7472 756d  um[i] = spectrum
-0000d830: 5b34 5d20 2320 4b4c 5544 4745 3a20 4e52  [4] # KLUDGE: NR
-0000d840: 442d 6475 616c 0d0a 0d0a 2020 2020 2020  D-dual....      
-0000d850: 2020 2020 2020 2320 4c65 6176 6520 7468        # Leave th
-0000d860: 6520 726f 7720 636f 756e 7465 7220 696e  e row counter in
-0000d870: 2070 6c61 6365 2069 6620 7765 2772 6520   place if we're 
-0000d880: 696e 2022 4661 7374 2220 4172 6561 2053  in "Fast" Area S
-0000d890: 6361 6e20 6d6f 6465 2c0d 0a20 2020 2020  can mode,..     
-0000d8a0: 2020 2020 2020 2023 2073 696e 6365 2064         # since d
-0000d8b0: 6f77 6e73 7472 6561 6d20 736f 6674 7761  ownstream softwa
-0000d8c0: 7265 2063 616e 2075 7365 2069 7420 746f  re can use it to
-0000d8d0: 2061 7373 656d 626c 6520 7468 6520 6669   assemble the fi
-0000d8e0: 6e61 6c20 696d 6167 652e 0d0a 2020 2020  nal image...    
-0000d8f0: 2020 2020 2020 2020 2320 2822 536c 6f77          # ("Slow
-0000d900: 2220 4172 6561 2053 6361 6e20 6d6f 6465  " Area Scan mode
-0000d910: 2073 656e 7420 7468 6973 2076 616c 7565   sent this value
-0000d920: 2062 6163 6b20 6173 2061 2073 6570 6172   back as a separ
-0000d930: 6174 6520 6669 656c 6420 696e 0d0a 2020  ate field in..  
-0000d940: 2020 2020 2020 2020 2020 2320 7468 6520            # the 
-0000d950: 5265 6164 696e 672c 2062 7574 2074 6869  Reading, but thi
-0000d960: 7320 6973 6e27 7420 706f 7373 6962 6c65  s isn't possible
-0000d970: 2069 6e20 4661 7374 206d 6f64 652e 2020   in Fast mode.  
-0000d980: 4a75 7374 2064 656c 6574 650d 0a20 2020  Just delete..   
-0000d990: 2020 2020 2020 2020 2023 2053 6c6f 7720           # Slow 
-0000d9a0: 6d6f 6465 2077 6865 6e20 4661 7374 2069  mode when Fast i
-0000d9b0: 7320 7769 6465 6c79 2064 6570 6c6f 7965  s widely deploye
-0000d9c0: 642e 290d 0a20 2020 2020 2020 2020 2020  d.)..           
-0000d9d0: 2023 0d0a 2020 2020 2020 2020 2020 2020   #..            
-0000d9e0: 6966 206e 6f74 2073 656c 662e 7365 7474  if not self.sett
-0000d9f0: 696e 6773 2e73 7461 7465 2e61 7265 615f  ings.state.area_
-0000da00: 7363 616e 5f66 6173 743a 0d0a 2020 2020  scan_fast:..    
-0000da10: 2020 2020 2020 2020 2020 2020 7370 6563              spec
-0000da20: 7472 756d 5b30 5d20 3d20 7370 6563 7472  trum[0] = spectr
-0000da30: 756d 5b31 5d0d 0a0d 0a20 2020 2020 2020  um[1]....       
-0000da40: 2023 2323 2323 2323 2323 2323 2323 2323   ###############
-0000da50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000da60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000da70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000da80: 2323 2323 2323 2323 230d 0a20 2020 2020  #########..     
-0000da90: 2020 2023 2053 7461 7274 2d6f 662d 5370     # Start-of-Sp
-0000daa0: 6563 7472 756d 204d 6172 6b65 7220 2872  ectrum Marker (r
-0000dab0: 6172 6529 0d0a 2020 2020 2020 2020 2323  are)..        ##
-0000dac0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000dad0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000dae0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000daf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000db00: 2323 2323 2323 0d0a 0d0a 2020 2020 2020  ######....      
-0000db10: 2020 2320 2862 6566 6f72 6520 782d 6178    # (before x-ax
-0000db20: 6973 2069 6e76 6572 7369 6f6e 2062 6563  is inversion bec
-0000db30: 6175 7365 206d 6172 6b65 7220 6174 2046  ause marker at F
-0000db40: 5047 4120 7069 7865 6c20 3029 0d0a 0d0a  PGA pixel 0)....
-0000db50: 2020 2020 2020 2020 2320 4368 6563 6b20          # Check 
-0000db60: 616e 6420 7472 6163 6b20 7468 6520 2273  and track the "s
-0000db70: 7461 7274 206f 6620 7370 6563 7472 756d  tart of spectrum
-0000db80: 2220 6d61 726b 6572 2e20 2054 6869 7320  " marker.  This 
-0000db90: 6973 2076 6572 7920 7261 7265 2061 6e64  is very rare and
-0000dba0: 0d0a 2020 2020 2020 2020 2320 6f6e 6c79  ..        # only
-0000dbb0: 2066 6f72 2065 7870 6572 696d 656e 7461   for experimenta
-0000dbc0: 6c20 756e 6974 732e 2020 4375 7272 656e  l units.  Curren
-0000dbd0: 746c 7920 5761 7361 7463 6820 646f 6573  tly Wasatch does
-0000dbe0: 206e 6f74 2068 6176 6520 616e 790d 0a20   not have any.. 
-0000dbf0: 2020 2020 2020 2023 2022 7374 616e 6461         # "standa
-0000dc00: 7264 2220 7370 6563 7472 756d 2066 7261  rd" spectrum fra
-0000dc10: 6d69 6e67 2064 6174 612c 2061 6c74 686f  ming data, altho
-0000dc20: 7567 6820 7375 6368 2077 6f75 6c64 2062  ugh such would b
-0000dc30: 6520 7573 6566 756c 2e20 5468 6973 0d0a  e useful. This..
-0000dc40: 2020 2020 2020 2020 2320 6973 206f 6e6c          # is onl
-0000dc50: 7920 656e 6162 6c65 6420 696e 2046 5047  y enabled in FPG
-0000dc60: 4173 2077 6865 6e20 7472 7969 6e67 2074  As when trying t
-0000dc70: 6f20 6465 6275 6720 7261 7265 2074 696d  o debug rare tim
-0000dc80: 696e 6720 6973 7375 6573 2e20 5468 650d  ing issues. The.
-0000dc90: 0a20 2020 2020 2020 2023 2022 4d61 726b  .        # "Mark
-0000dca0: 6572 2220 6973 2073 696d 706c 7920 6120  er" is simply a 
-0000dcb0: 7069 7865 6c20 7769 7468 2074 6865 2076  pixel with the v
-0000dcc0: 616c 7565 2030 7866 6666 662e 2020 4f6e  alue 0xffff.  On
-0000dcd0: 2046 5047 4120 4657 2077 6865 7265 2074   FPGA FW where t
-0000dce0: 6865 0d0a 2020 2020 2020 2020 2320 6d61  he..        # ma
-0000dcf0: 726b 6572 2069 7320 656e 6162 6c65 642c  rker is enabled,
-0000dd00: 2073 7065 6374 7261 6c20 6461 7461 2069   spectral data i
-0000dd10: 7320 636c 616d 7065 6420 746f 2030 7866  s clamped to 0xf
-0000dd20: 6666 652c 206d 6561 6e69 6e67 2073 7563  ffe, meaning suc
-0000dd30: 680d 0a20 2020 2020 2020 2023 206d 6172  h..        # mar
-0000dd40: 6b65 7273 2063 616e 204f 4e4c 5920 6170  kers can ONLY ap
-0000dd50: 7065 6172 2061 7320 7468 6520 6669 7273  pear as the firs
-0000dd60: 7420 7069 7865 6c20 696e 2061 2073 7065  t pixel in a spe
-0000dd70: 6374 7275 6d2e 0d0a 2020 2020 2020 2020  ctrum...        
-0000dd80: 230d 0a20 2020 2020 2020 2023 2057 6f75  #..        # Wou
-0000dd90: 6c64 206e 6565 6420 7570 6461 7465 6420  ld need updated 
-0000dda0: 746f 2077 6f72 6b20 7769 7468 2044 6574  to work with Det
-0000ddb0: 6563 746f 7252 6567 696f 6e73 2e0d 0a20  ectorRegions... 
-0000ddc0: 2020 2020 2020 2069 6620 7365 6c66 2e73         if self.s
-0000ddd0: 6574 7469 6e67 732e 6861 735f 6d61 726b  ettings.has_mark
-0000dde0: 6572 2829 2061 6e64 206e 6f74 2073 656c  er() and not sel
-0000ddf0: 662e 7365 7474 696e 6773 2e73 7461 7465  f.settings.state
-0000de00: 2e61 7265 615f 7363 616e 5f65 6e61 626c  .area_scan_enabl
-0000de10: 6564 3a0d 0a20 2020 2020 2020 2020 2020  ed:..           
-0000de20: 206d 6172 6b65 7220 3d20 3078 6666 6666   marker = 0xffff
-0000de30: 0d0a 2020 2020 2020 2020 2020 2020 6966  ..            if
-0000de40: 2073 7065 6374 7275 6d5b 305d 203d 3d20   spectrum[0] == 
-0000de50: 6d61 726b 6572 3a0d 0a20 2020 2020 2020  marker:..       
-0000de60: 2020 2020 2020 2020 2023 206d 6172 6b65           # marke
-0000de70: 7220 666f 756e 6420 7768 6572 6520 6578  r found where ex
-0000de80: 7065 6374 6564 2c20 736f 2061 6c6c 2069  pected, so all i
-0000de90: 7320 676f 6f64 2028 6f76 6572 7772 6974  s good (overwrit
-0000dea0: 6520 666f 7220 610d 0a20 2020 2020 2020  e for a..       
-0000deb0: 2020 2020 2020 2020 2023 2063 6c65 616e           # clean
-0000dec0: 2067 7261 7068 290d 0a20 2020 2020 2020   graph)..       
-0000ded0: 2020 2020 2020 2020 2073 7065 6374 7275           spectru
-0000dee0: 6d5b 305d 203d 2073 7065 6374 7275 6d5b  m[0] = spectrum[
-0000def0: 315d 0d0a 2020 2020 2020 2020 2020 2020  1]..            
-0000df00: 656c 7365 3a0d 0a20 2020 2020 2020 2020  else:..         
-0000df10: 2020 2020 2020 2023 2077 6520 4449 444e         # we DIDN
-0000df20: 2754 2066 696e 6420 7468 6520 6d61 726b  'T find the mark
-0000df30: 6572 2077 6865 7265 2069 7420 7761 7320  er where it was 
-0000df40: 6578 7065 6374 6564 2c20 736f 2066 6c61  expected, so fla
-0000df50: 6720 616e 640d 0a20 2020 2020 2020 2020  g and..         
-0000df60: 2020 2020 2020 2023 2067 6f20 6875 6e74         # go hunt
-0000df70: 696e 670d 0a20 2020 2020 2020 2020 2020  ing..           
-0000df80: 2020 2020 206c 6f67 2e65 7272 6f72 2822       log.error("
-0000df90: 6765 745f 6c69 6e65 3a20 6d69 7373 696e  get_line: missin
-0000dfa0: 6720 6d61 726b 6572 2229 0d0a 2020 2020  g marker")..    
-0000dfb0: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-0000dfc0: 6920 696e 2072 616e 6765 2870 6978 656c  i in range(pixel
-0000dfd0: 7329 3a0d 0a20 2020 2020 2020 2020 2020  s):..           
-0000dfe0: 2020 2020 2020 2020 2069 6620 7370 6563           if spec
-0000dff0: 7472 756d 5b69 5d20 3d3d 206d 6172 6b65  trum[i] == marke
-0000e000: 723a 0d0a 2020 2020 2020 2020 2020 2020  r:..            
-0000e010: 2020 2020 2020 2020 2020 2020 6c6f 672e              log.
-0000e020: 6572 726f 7228 2267 6574 5f6c 696e 653a  error("get_line:
-0000e030: 206d 6172 6b65 7220 666f 756e 6420 6174   marker found at
-0000e040: 2070 6978 656c 2025 6422 2c20 6929 0d0a   pixel %d", i)..
-0000e050: 0d0a 2020 2020 2020 2020 2320 636f 6e73  ..        # cons
-0000e060: 6964 6572 2073 6b69 7070 696e 6720 6d75  ider skipping mu
-0000e070: 6368 206f 6620 7468 6520 666f 6c6c 6f77  ch of the follow
-0000e080: 696e 6720 6966 2069 6e20 6172 6561 2073  ing if in area s
-0000e090: 6361 6e20 6d6f 6465 0d0a 0d0a 2020 2020  can mode....    
-0000e0a0: 2020 2020 2323 2323 2323 2323 2323 2323      ############
-0000e0b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e0c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e0d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e0e0: 2323 2323 2323 2323 2323 2323 0d0a 2020  ############..  
-0000e0f0: 2020 2020 2020 2320 5374 6f6d 7020 6172        # Stomp ar
-0000e100: 7261 7920 656e 6473 0d0a 2020 2020 2020  ray ends..      
-0000e110: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
-0000e120: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e130: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e140: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e150: 2323 2323 2323 2323 2323 0d0a 0d0a 2020  ##########....  
-0000e160: 2020 2020 2020 2320 2862 6566 6f72 6520        # (before 
-0000e170: 782d 6178 6973 2069 6e76 6572 7369 6f6e  x-axis inversion
-0000e180: 2062 6563 6175 7365 206f 7074 6963 616c   because optical
-0000e190: 6c79 206d 6173 6b65 6420 7069 7865 6c73  ly masked pixels
-0000e1a0: 2061 7265 2070 6879 7369 6361 6c29 0d0a   are physical)..
-0000e1b0: 0d0a 2020 2020 2020 2020 2320 736f 6d65  ..        # some
-0000e1c0: 2064 6574 6563 746f 7273 2068 6176 6520   detectors have 
-0000e1d0: 2267 6172 6261 6765 2220 7069 7865 6c73  "garbage" pixels
-0000e1e0: 2061 7420 7468 6520 6672 6f6e 7420 6f72   at the front or
-0000e1f0: 2065 6e64 206f 6620 6576 6572 790d 0a20   end of every.. 
-0000e200: 2020 2020 2020 2023 2073 7065 6374 7275         # spectru
-0000e210: 6d20 2873 796e 6320 6279 7465 7320 616e  m (sync bytes an
-0000e220: 6420 7768 6174 2d6e 6f74 290d 0a20 2020  d what-not)..   
-0000e230: 2020 2020 2069 6620 7365 6c66 2e73 6574       if self.set
-0000e240: 7469 6e67 732e 6973 5f6d 6963 726f 2829  tings.is_micro()
-0000e250: 2061 6e64 2073 656c 662e 7365 7474 696e   and self.settin
-0000e260: 6773 2e73 7461 7465 2e64 6574 6563 746f  gs.state.detecto
-0000e270: 725f 7265 6769 6f6e 7320 6973 204e 6f6e  r_regions is Non
-0000e280: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-0000e290: 6966 2073 656c 662e 7365 7474 696e 6773  if self.settings
-0000e2a0: 2e69 735f 696d 7833 3932 2829 3a0d 0a20  .is_imx392():.. 
-0000e2b0: 2020 2020 2020 2020 2020 2020 2020 2075                 u
-0000e2c0: 7469 6c73 2e73 746f 6d70 5f66 6972 7374  tils.stomp_first
-0000e2d0: 2873 7065 6374 7275 6d2c 2033 290d 0a20  (spectrum, 3).. 
-0000e2e0: 2020 2020 2020 2020 2020 2020 2020 2075                 u
-0000e2f0: 7469 6c73 2e73 746f 6d70 5f6c 6173 7420  tils.stomp_last 
-0000e300: 2873 7065 6374 7275 6d2c 2031 3729 0d0a  (spectrum, 17)..
-0000e310: 2020 2020 2020 2020 2020 2020 656c 7365              else
-0000e320: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-0000e330: 2020 2023 2070 7265 7375 6d61 626c 7920     # presumably 
-0000e340: 494d 5833 3835 0d0a 2020 2020 2020 2020  IMX385..        
-0000e350: 2020 2020 2020 2020 7574 696c 732e 7374          utils.st
-0000e360: 6f6d 705f 6669 7273 7428 7370 6563 7472  omp_first(spectr
-0000e370: 756d 2c20 3329 0d0a 2020 2020 2020 2020  um, 3)..        
-0000e380: 2020 2020 2020 2020 7574 696c 732e 7374          utils.st
-0000e390: 6f6d 705f 6c61 7374 2028 7370 6563 7472  omp_last (spectr
-0000e3a0: 756d 2c20 3129 0d0a 0d0a 2020 2020 2020  um, 1)....      
-0000e3b0: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
+0000d5b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d5c0: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
+0000d5d0: 2020 2020 2023 2072 6561 6420 7468 6520       # read the 
+0000d5e0: 6461 7461 2066 726f 6d20 6275 6c6b 2065  data from bulk e
+0000d5f0: 6e64 706f 696e 7428 7329 0a20 2020 2020  ndpoint(s).     
+0000d600: 2020 2023 2323 2323 2323 2323 2323 2323     #############
+0000d610: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d620: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d630: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d640: 2323 2323 2323 2323 2323 230a 0a20 2020  ###########..   
+0000d650: 2020 2020 2073 7065 6374 7275 6d20 3d20       spectrum = 
+0000d660: 5b5d 0a20 2020 2020 2020 2065 7272 6f72  [].        error
+0000d670: 7320 3d20 300a 2020 2020 2020 2020 666f  s = 0.        fo
+0000d680: 7220 656e 6470 6f69 6e74 2069 6e20 656e  r endpoint in en
+0000d690: 6470 6f69 6e74 733a 0a20 2020 2020 2020  dpoints:.       
+0000d6a0: 2020 2020 2064 6174 6120 3d20 4e6f 6e65       data = None
+0000d6b0: 0a20 2020 2020 2020 2020 2020 2077 6869  .            whi
+0000d6c0: 6c65 2064 6174 6120 6973 204e 6f6e 653a  le data is None:
+0000d6d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d6e0: 2074 7279 3a0a 2020 2020 2020 2020 2020   try:.          
+0000d6f0: 2020 2020 2020 2020 2020 6c6f 672e 6465            log.de
+0000d700: 6275 6728 2277 6169 7469 6e67 2066 6f72  bug("waiting for
+0000d710: 2025 6420 6279 7465 7320 2874 696d 656f   %d bytes (timeo
+0000d720: 7574 2025 646d 7329 222c 2062 6c6f 636b  ut %dms)", block
+0000d730: 5f6c 656e 5f62 7974 6573 2c20 7469 6d65  _len_bytes, time
+0000d740: 6f75 745f 6d73 290a 2020 2020 2020 2020  out_ms).        
+0000d750: 2020 2020 2020 2020 2020 2020 6461 7461              data
+0000d760: 203d 2073 656c 662e 6465 7669 6365 5f74   = self.device_t
+0000d770: 7970 652e 7265 6164 2873 656c 662e 6465  ype.read(self.de
+0000d780: 7669 6365 2c20 656e 6470 6f69 6e74 2c20  vice, endpoint, 
+0000d790: 626c 6f63 6b5f 6c65 6e5f 6279 7465 732c  block_len_bytes,
+0000d7a0: 2074 696d 656f 7574 3d74 696d 656f 7574   timeout=timeout
+0000d7b0: 5f6d 7329 0a20 2020 2020 2020 2020 2020  _ms).           
+0000d7c0: 2020 2020 2020 2020 206c 6f67 2e64 6562           log.deb
+0000d7d0: 7567 2822 7265 6164 2025 6420 6279 7465  ug("read %d byte
+0000d7e0: 7322 2c20 6c65 6e28 6461 7461 2929 0a20  s", len(data)). 
+0000d7f0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0000d800: 7863 6570 7420 4578 6365 7074 696f 6e20  xcept Exception 
+0000d810: 6173 2065 7863 3a0a 2020 2020 2020 2020  as exc:.        
+0000d820: 2020 2020 2020 2020 2020 2020 6966 2073              if s
+0000d830: 656c 662e 6465 7669 6365 5f74 7970 6520  elf.device_type 
+0000d840: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
+0000d850: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d860: 206c 6f67 2e65 7272 6f72 2866 224e 6f20   log.error(f"No 
+0000d870: 6465 7669 6365 5f74 7970 6522 290a 2020  device_type").  
+0000d880: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d890: 2020 2020 2020 7265 7370 6f6e 7365 2e65        response.e
+0000d8a0: 7272 6f72 5f6d 7367 203d 2066 2245 6e63  rror_msg = f"Enc
+0000d8b0: 6f75 6e74 6572 6564 2065 7272 6f72 206f  ountered error o
+0000d8c0: 6e20 7265 6164 220a 2020 2020 2020 2020  n read".        
+0000d8d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d8e0: 7265 7370 6f6e 7365 2e65 7272 6f72 5f6c  response.error_l
+0000d8f0: 766c 203d 2045 7272 6f72 4c65 7665 6c2e  vl = ErrorLevel.
+0000d900: 6869 6768 0a20 2020 2020 2020 2020 2020  high.           
+0000d910: 2020 2020 2020 2020 2020 2020 2072 6573               res
+0000d920: 706f 6e73 652e 706f 6973 6f6e 5f70 696c  ponse.poison_pil
+0000d930: 6c20 3d20 5472 7565 2023 2075 6e72 6563  l = True # unrec
+0000d940: 6f76 6572 6162 6c65 0a20 2020 2020 2020  overable.       
+0000d950: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d960: 2072 6574 7572 6e20 7265 7370 6f6e 7365   return response
+0000d970: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d980: 2020 2020 2065 6c69 6620 7365 6c66 2e73       elif self.s
+0000d990: 6574 7469 6e67 732e 7374 6174 652e 7472  ettings.state.tr
+0000d9a0: 6967 6765 725f 736f 7572 6365 203d 3d20  igger_source == 
+0000d9b0: 5370 6563 7472 6f6d 6574 6572 5374 6174  SpectrometerStat
+0000d9c0: 652e 5452 4947 4745 525f 534f 5552 4345  e.TRIGGER_SOURCE
+0000d9d0: 5f45 5854 4552 4e41 4c3a 0a20 2020 2020  _EXTERNAL:.     
+0000d9e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d9f0: 2020 2023 2077 6520 646f 6e27 7420 6b6e     # we don't kn
+0000da00: 6f77 2068 6f77 206c 6f6e 6720 7765 276c  ow how long we'l
+0000da10: 6c20 6861 7665 2074 6f20 7761 6974 2066  l have to wait f
+0000da20: 6f72 2074 6865 2074 7269 6767 6572 2c20  or the trigger, 
+0000da30: 736f 0a20 2020 2020 2020 2020 2020 2020  so.             
+0000da40: 2020 2020 2020 2020 2020 2023 206a 7573             # jus
+0000da50: 7420 6c6f 6f70 2061 6e64 2068 6f70 650a  t loop and hope.
+0000da60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000da70: 2020 2020 2020 2020 2320 6c6f 672e 6465          # log.de
+0000da80: 6275 6728 2273 7469 6c6c 2077 6169 7469  bug("still waiti
+0000da90: 6e67 2066 6f72 2065 7874 6572 6e61 6c20  ng for external 
+0000daa0: 7472 6967 6765 7222 290a 2020 2020 2020  trigger").      
+0000dab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dac0: 2020 7061 7373 0a20 2020 2020 2020 2020    pass.         
+0000dad0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+0000dae0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000daf0: 2020 2020 2020 2020 2065 7272 6f72 7320           errors 
+0000db00: 2b3d 2031 0a20 2020 2020 2020 2020 2020  += 1.           
+0000db10: 2020 2020 2020 2020 2020 2020 206c 6f67               log
+0000db20: 2e65 7272 6f72 2866 2245 6e63 6f75 6e74  .error(f"Encount
+0000db30: 6572 6564 2065 7272 6f72 206f 6e20 7265  ered error on re
+0000db40: 6164 206f 6620 7b65 7863 7d22 290a 2020  ad of {exc}").  
+0000db50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000db60: 2020 2020 2020 6966 2065 7272 6f72 7320        if errors 
+0000db70: 3c20 333a 0a20 2020 2020 2020 2020 2020  < 3:.           
+0000db80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000db90: 206c 6f67 2e65 7272 6f72 2866 2269 676e   log.error(f"ign
+0000dba0: 6f72 696e 6720 6572 726f 7220 6e75 6d62  oring error numb
+0000dbb0: 6572 207b 6572 726f 7273 7d22 290a 2020  er {errors}").  
+0000dbc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dbd0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0000dbe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dbf0: 2020 2020 2020 2020 7265 7370 6f6e 7365          response
+0000dc00: 2e65 7272 6f72 5f6d 7367 203d 2022 456e  .error_msg = "En
+0000dc10: 636f 756e 7465 7265 6420 6572 726f 7220  countered error 
+0000dc20: 6f6e 2072 6561 6422 0a20 2020 2020 2020  on read".       
+0000dc30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dc40: 2020 2020 2072 6573 706f 6e73 652e 6572       response.er
+0000dc50: 726f 725f 6c76 6c20 3d20 4572 726f 724c  ror_lvl = ErrorL
+0000dc60: 6576 656c 2e68 6967 680a 2020 2020 2020  evel.high.      
+0000dc70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dc80: 2020 2020 2020 7265 7475 726e 2072 6573        return res
+0000dc90: 706f 6e73 650a 0a20 2020 2020 2020 2020  ponse..         
+0000dca0: 2020 2023 2054 6869 7320 6973 2061 2063     # This is a c
+0000dcb0: 6f6e 766f 6c75 7465 6420 7761 7920 746f  onvoluted way to
+0000dcc0: 2069 7465 7261 7465 2061 6372 6f73 7320   iterate across 
+0000dcd0: 7468 6520 7265 6365 6976 6564 2062 7974  the received byt
+0000dce0: 6573 2069 6e20 2764 6174 6127 2061 730a  es in 'data' as.
+0000dcf0: 2020 2020 2020 2020 2020 2020 2320 7477              # tw
+0000dd00: 6f20 696e 7465 726c 6561 7665 6420 6172  o interleaved ar
+0000dd10: 7261 7973 2c20 626f 7468 206f 6e6c 7920  rays, both only 
+0000dd20: 7072 6f63 6573 7369 6e67 2061 6c74 6572  processing alter
+0000dd30: 6e61 7469 6e67 2062 7974 6573 2c20 6275  nating bytes, bu
+0000dd40: 7420 6f6e 6520 2869 290a 2020 2020 2020  t one (i).      
+0000dd50: 2020 2020 2020 2320 7374 6172 7469 6e67        # starting
+0000dd60: 2061 7420 7a65 726f 2028 6576 656e 2062   at zero (even b
+0000dd70: 7974 6573 2920 616e 6420 7468 6520 6f74  ytes) and the ot
+0000dd80: 6865 7220 286a 2920 7374 6172 7469 6e67  her (j) starting
+0000dd90: 2061 7420 3120 286f 6464 2062 7974 6573   at 1 (odd bytes
+0000dda0: 292e 0a20 2020 2020 2020 2020 2020 2073  )..            s
+0000ddb0: 7562 7370 6563 7472 756d 203d 205b 696e  ubspectrum = [in
+0000ddc0: 7428 6920 7c20 286a 203c 3c20 3829 2920  t(i | (j << 8)) 
+0000ddd0: 666f 7220 692c 206a 2069 6e20 7a69 7028  for i, j in zip(
+0000dde0: 6461 7461 5b3a 3a32 5d2c 2064 6174 615b  data[::2], data[
+0000ddf0: 313a 3a32 5d29 5d20 2320 4c53 422d 4d53  1::2])] # LSB-MS
+0000de00: 420a 0a20 2020 2020 2020 2020 2020 2073  B..            s
+0000de10: 7065 6374 7275 6d2e 6578 7465 6e64 2873  pectrum.extend(s
+0000de20: 7562 7370 6563 7472 756d 290a 0a20 2020  ubspectrum)..   
+0000de30: 2020 2020 2020 2020 2023 2065 6d70 6972           # empir
+0000de40: 6963 616c 6c79 2064 6574 6572 6d69 6e65  ically determine
+0000de50: 6420 6e65 6564 2066 6f72 2035 6d73 2064  d need for 5ms d
+0000de60: 656c 6179 2077 6865 6e20 7377 6974 6368  elay when switch
+0000de70: 696e 6720 656e 6470 6f69 6e74 730a 2020  ing endpoints.  
+0000de80: 2020 2020 2020 2020 2020 2320 6f6e 2032            # on 2
+0000de90: 3034 3870 7820 6465 7465 6374 6f72 7320  048px detectors 
+0000dea0: 6475 7269 6e67 2061 7265 6120 7363 616e  during area scan
+0000deb0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0000dec0: 7365 6c66 2e73 6574 7469 6e67 732e 7374  self.settings.st
+0000ded0: 6174 652e 6172 6561 5f73 6361 6e5f 656e  ate.area_scan_en
+0000dee0: 6162 6c65 6420 616e 6420 7069 7865 6c73  abled and pixels
+0000def0: 203d 3d20 3230 3438 3a20 2320 616e 6420   == 2048: # and 
+0000df00: 656e 6470 6f69 6e74 203d 3d20 3078 3832  endpoint == 0x82
+0000df10: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000df20: 2020 6c6f 672e 6465 6275 6728 2273 6c65    log.debug("sle
+0000df30: 6570 696e 6720 356d 7320 6265 7477 6565  eping 5ms betwee
+0000df40: 6e20 656e 6470 6f69 6e74 7322 290a 2020  n endpoints").  
+0000df50: 2020 2020 2020 2020 2020 2020 2020 736c                sl
+0000df60: 6565 7028 302e 3030 3529 0a0a 2020 2020  eep(0.005)..    
+0000df70: 2020 2020 2320 7265 6365 6976 6564 2061      # received a
+0000df80: 2072 6573 706f 6e73 652c 2073 6f20 6465   response, so de
+0000df90: 6372 656d 656e 7420 7468 726f 7761 7761  crement throwawa
+0000dfa0: 7973 0a20 2020 2020 2020 2073 656c 662e  ys.        self.
+0000dfb0: 7265 6d61 696e 696e 675f 7468 726f 7761  remaining_throwa
+0000dfc0: 7761 7973 203d 206d 6178 2830 2c20 7365  ways = max(0, se
+0000dfd0: 6c66 2e72 656d 6169 6e69 6e67 5f74 6872  lf.remaining_thr
+0000dfe0: 6f77 6177 6179 7320 2d20 3129 0a0a 2020  owaways - 1)..  
+0000dff0: 2020 2020 2020 2323 2323 2323 2323 2323        ##########
+0000e000: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e010: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e020: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e030: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
+0000e040: 2020 2020 2020 2023 2065 7272 6f72 2d63         # error-c
+0000e050: 6865 636b 2074 6865 2072 6563 6569 7665  heck the receive
+0000e060: 6420 7370 6563 7472 756d 0a20 2020 2020  d spectrum.     
+0000e070: 2020 2023 2323 2323 2323 2323 2323 2323     #############
+0000e080: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e090: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e0a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e0b0: 2323 2323 2323 2323 2323 230a 0a20 2020  ###########..   
+0000e0c0: 2020 2020 206c 6f67 2e64 6562 7567 2822       log.debug("
+0000e0d0: 6765 745f 6c69 6e65 3a20 636f 6d70 6c65  get_line: comple
+0000e0e0: 7465 6420 696e 2025 2e32 6620 7365 6320  ted in %.2f sec 
+0000e0f0: 2876 7320 696e 7465 6772 6174 696f 6e20  (vs integration 
+0000e100: 7469 6d65 2025 6420 6d73 2922 2c0a 2020  time %d ms)",.  
+0000e110: 2020 2020 2020 2020 2020 2864 6174 6574            (datet
+0000e120: 696d 652e 6461 7465 7469 6d65 2e6e 6f77  ime.datetime.now
+0000e130: 2829 202d 2061 6371 7569 7369 7469 6f6e  () - acquisition
+0000e140: 5f74 696d 6573 7461 6d70 292e 746f 7461  _timestamp).tota
+0000e150: 6c5f 7365 636f 6e64 7328 292c 0a20 2020  l_seconds(),.   
+0000e160: 2020 2020 2020 2020 2073 656c 662e 7365           self.se
+0000e170: 7474 696e 6773 2e73 7461 7465 2e69 6e74  ttings.state.int
+0000e180: 6567 7261 7469 6f6e 5f74 696d 655f 6d73  egration_time_ms
+0000e190: 290a 0a20 2020 2020 2020 206c 6f67 2e64  )..        log.d
+0000e1a0: 6562 7567 2822 6765 745f 6c69 6e65 3a20  ebug("get_line: 
+0000e1b0: 7069 7865 6c73 2025 642c 2065 6e64 706f  pixels %d, endpo
+0000e1c0: 696e 7473 2025 732c 2062 6c6f 636b 2025  ints %s, block %
+0000e1d0: 642c 2073 7065 6374 7275 6d20 2573 202e  d, spectrum %s .
+0000e1e0: 2e2e 222c 0a20 2020 2020 2020 2020 2020  ..",.           
+0000e1f0: 206c 656e 2873 7065 6374 7275 6d29 2c20   len(spectrum), 
+0000e200: 656e 6470 6f69 6e74 732c 2062 6c6f 636b  endpoints, block
+0000e210: 5f6c 656e 5f62 7974 6573 2c20 7370 6563  _len_bytes, spec
+0000e220: 7472 756d 5b30 3a39 5d29 0a0a 2020 2020  trum[0:9])..    
+0000e230: 2020 2020 6966 206c 656e 2873 7065 6374      if len(spect
+0000e240: 7275 6d29 2021 3d20 7069 7865 6c73 3a0a  rum) != pixels:.
+0000e250: 2020 2020 2020 2020 2020 2020 6c6f 672e              log.
+0000e260: 6572 726f 7228 2267 6574 5f6c 696e 6520  error("get_line 
+0000e270: 7265 6164 2077 726f 6e67 206e 756d 6265  read wrong numbe
+0000e280: 7220 6f66 2070 6978 656c 7320 2865 7870  r of pixels (exp
+0000e290: 6563 7465 6420 2564 2c20 7265 6164 2025  ected %d, read %
+0000e2a0: 6429 222c 2070 6978 656c 732c 206c 656e  d)", pixels, len
+0000e2b0: 2873 7065 6374 7275 6d29 290a 2020 2020  (spectrum)).    
+0000e2c0: 2020 2020 2020 2020 7265 7370 6f6e 7365          response
+0000e2d0: 2e65 7272 6f72 5f6d 7367 203d 2066 2267  .error_msg = f"g
+0000e2e0: 6574 5f6c 696e 6520 7265 6164 2077 726f  et_line read wro
+0000e2f0: 6e67 206e 756d 6265 7220 6f66 2070 6978  ng number of pix
+0000e300: 656c 7320 2865 7870 6563 7465 6420 7b70  els (expected {p
+0000e310: 6978 656c 737d 2c20 7265 6164 207b 6c65  ixels}, read {le
+0000e320: 6e28 7370 6563 7472 756d 297d 2922 0a20  n(spectrum)})". 
+0000e330: 2020 2020 2020 2020 2020 2072 6573 706f             respo
+0000e340: 6e73 652e 6572 726f 725f 6c76 6c20 3d20  nse.error_lvl = 
+0000e350: 4572 726f 724c 6576 656c 2e6c 6f77 0a20  ErrorLevel.low. 
+0000e360: 2020 2020 2020 2020 2020 2072 6573 706f             respo
+0000e370: 6e73 652e 6b65 6570 5f61 6c69 7665 203d  nse.keep_alive =
+0000e380: 2054 7275 650a 2020 2020 2020 2020 2020   True.          
+0000e390: 2020 7265 7475 726e 2072 6573 706f 6e73    return respons
+0000e3a0: 650a 0a20 2020 2020 2020 2023 2323 2323  e..        #####
+0000e3b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0000e3c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0000e3d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0000e3e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e3f0: 2323 2323 2323 2323 2323 0d0a 2020 2020  ##########..    
-0000e400: 2020 2020 2320 496e 7665 7274 2058 2d41      # Invert X-A
-0000e410: 7869 730d 0a20 2020 2020 2020 2023 2323  xis..        ###
-0000e420: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e430: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e440: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e3f0: 2323 230a 2020 2020 2020 2020 230a 2020  ###.        #.  
+0000e400: 2020 2020 2020 2320 2020 2020 2020 2020        #         
+0000e410: 2020 2020 2020 2020 2020 706f 7374 2d70            post-p
+0000e420: 726f 6365 7373 2074 6865 2073 7065 6374  rocess the spect
+0000e430: 7275 6d0a 2020 2020 2020 2020 230a 2020  rum.        #.  
+0000e440: 2020 2020 2020 2323 2323 2323 2323 2323        ##########
 0000e450: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e460: 2323 2323 230d 0a0d 0a20 2020 2020 2020  #####....       
-0000e470: 2023 2046 6f72 2062 656e 6368 6573 2077   # For benches w
-0000e480: 6865 7265 2074 6865 2064 6574 6563 746f  here the detecto
-0000e490: 7220 6973 2065 7373 656e 7469 616c 6c79  r is essentially
-0000e4a0: 2072 6f74 6174 6564 2031 3830 2d64 6567   rotated 180-deg
-0000e4b0: 2066 726f 6d20 6f75 720d 0a20 2020 2020   from our..     
-0000e4c0: 2020 2023 2074 7970 6963 616c 206f 7269     # typical ori
-0000e4d0: 656e 7461 7469 6f6e 2077 6974 6820 7265  entation with re
-0000e4e0: 6761 7264 2074 6f20 7468 6520 6772 6174  gard to the grat
-0000e4f0: 696e 6720 2865 2e67 2e20 496e 4761 4173  ing (e.g. InGaAs
-0000e500: 204f 454d 0d0a 2020 2020 2020 2020 2320   OEM..        # 
-0000e510: 6265 6e63 6865 732c 2077 6865 7265 2072  benches, where r
-0000e520: 6564 2077 6176 656c 656e 6774 6873 2061  ed wavelengths a
-0000e530: 7265 2064 6966 6672 6163 7465 6420 746f  re diffracted to
-0000e540: 7761 7264 2070 6978 656c 2030 2c20 616e  ward pixel 0, an
-0000e550: 6420 626c 7565 0d0a 2020 2020 2020 2020  d blue..        
-0000e560: 2320 7761 7665 6c65 6e67 7468 7320 746f  # wavelengths to
-0000e570: 7761 7264 2070 6978 656c 2035 3131 292e  ward pixel 511).
-0000e580: 0d0a 2020 2020 2020 2020 230d 0a20 2020  ..        #..   
-0000e590: 2020 2020 2023 204e 6f74 6520 7468 6973       # Note this
-0000e5a0: 2073 696d 706c 7920 7065 7266 6f72 6d73   simply performs
-0000e5b0: 2061 2068 6f72 697a 6f6e 7461 6c20 464c   a horizontal FL
-0000e5c0: 4950 2028 6d69 7272 6f72 2920 6f66 2074  IP (mirror) of t
-0000e5d0: 6865 2076 6572 7469 6361 6c6c 792d 0d0a  he vertically-..
-0000e5e0: 2020 2020 2020 2020 2320 6269 6e6e 6564          # binned
-0000e5f0: 2031 2d44 2073 7065 6374 7261 2c20 616e   1-D spectra, an
-0000e600: 6420 6973 204e 4f54 2073 7566 6669 6369  d is NOT suffici
-0000e610: 656e 7420 746f 2070 6572 666f 726d 2061  ent to perform a
-0000e620: 2067 656e 7569 6e65 2031 3830 2d0d 0a20   genuine 180-.. 
-0000e630: 2020 2020 2020 2023 2064 6567 7265 6520         # degree 
-0000e640: 726f 7461 7469 6f6e 206f 6620 322d 4420  rotation of 2-D 
-0000e650: 696d 6167 696e 6720 6d6f 6465 3b20 6966  imaging mode; if
-0000e660: 2022 6175 7468 656e 7469 6322 2061 7265   "authentic" are
-0000e670: 6120 7363 616e 2069 730d 0a20 2020 2020  a scan is..     
-0000e680: 2020 2023 2064 6573 6972 6564 2c20 7468     # desired, th
-0000e690: 6520 6361 6c6c 6572 2077 6f75 6c64 206c  e caller would l
-0000e6a0: 696b 6577 6973 6520 6e65 6564 2074 6f20  ikewise need to 
-0000e6b0: 7265 7665 7273 6520 7468 6520 6469 7370  reverse the disp
-0000e6c0: 6c61 7920 6f72 6465 7220 6f66 0d0a 2020  lay order of..  
-0000e6d0: 2020 2020 2020 2320 7468 6520 726f 7773        # the rows
-0000e6e0: 2e0d 0a20 2020 2020 2020 2023 0d0a 2020  ...        #..  
-0000e6f0: 2020 2020 2020 2320 2020 2020 2020 2020        #         
-0000e700: 2020 4974 2069 7320 5649 5441 4c4c 5920    It is VITALLY 
-0000e710: 494d 504f 5254 414e 5420 7468 6174 2061  IMPORTANT that a
-0000e720: 6c6c 2064 7269 7665 7273 2061 6772 6565  ll drivers agree
-0000e730: 0d0a 2020 2020 2020 2020 2320 2020 2020  ..        #     
-0000e740: 2020 2020 2020 206f 6e20 7768 656e 2074         on when t
-0000e750: 6f20 7065 7266 6f72 6d20 582d 4178 6973  o perform X-Axis
-0000e760: 2069 6e76 6572 7369 6f6e 2069 6e20 7468   inversion in th
-0000e770: 650d 0a20 2020 2020 2020 2023 2020 2020  e..        #    
-0000e780: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e790: 2020 2020 4f72 6465 7220 6f66 204f 7065      Order of Ope
-0000e7a0: 7261 7469 6f6e 732e 0d0a 2020 2020 2020  rations...      
-0000e7b0: 2020 230d 0a20 2020 2020 2020 2069 6620    #..        if 
-0000e7c0: 7365 6c66 2e73 6574 7469 6e67 732e 6565  self.settings.ee
-0000e7d0: 7072 6f6d 2e69 6e76 6572 745f 785f 6178  prom.invert_x_ax
-0000e7e0: 6973 2061 6e64 206e 6f74 2073 656c 662e  is and not self.
-0000e7f0: 7365 7474 696e 6773 2e73 7461 7465 2e61  settings.state.a
-0000e800: 7265 615f 7363 616e 5f65 6e61 626c 6564  rea_scan_enabled
-0000e810: 3a0d 0a20 2020 2020 2020 2020 2020 2073  :..            s
-0000e820: 7065 6374 7275 6d2e 7265 7665 7273 6528  pectrum.reverse(
-0000e830: 290d 0a0d 0a20 2020 2020 2020 2023 2323  )....        ###
-0000e840: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e850: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e860: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e870: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e880: 2323 2323 230d 0a20 2020 2020 2020 2023  #####..        #
-0000e890: 2042 6164 2050 6978 656c 2043 6f72 7265   Bad Pixel Corre
-0000e8a0: 6374 696f 6e0d 0a20 2020 2020 2020 2023  ction..        #
-0000e8b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e8c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e8d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e8e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e8f0: 2323 2323 2323 230d 0a0d 0a20 2020 2020  #######....     
-0000e900: 2020 2069 6620 7365 6c66 2e73 6574 7469     if self.setti
-0000e910: 6e67 732e 7374 6174 652e 6261 645f 7069  ngs.state.bad_pi
-0000e920: 7865 6c5f 6d6f 6465 203d 3d20 5370 6563  xel_mode == Spec
-0000e930: 7472 6f6d 6574 6572 5374 6174 652e 4241  trometerState.BA
-0000e940: 445f 5049 5845 4c5f 4d4f 4445 5f41 5645  D_PIXEL_MODE_AVE
-0000e950: 5241 4745 3a0d 0a20 2020 2020 2020 2020  RAGE:..         
-0000e960: 2020 2073 656c 662e 5f63 6f72 7265 6374     self._correct
-0000e970: 5f62 6164 5f70 6978 656c 7328 7370 6563  _bad_pixels(spec
-0000e980: 7472 756d 290d 0a0d 0a20 2020 2020 2020  trum)....       
-0000e990: 2023 2323 2323 2323 2323 2323 2323 2323   ###############
-0000e9a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e9b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e9c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e9d0: 2323 2323 2323 2323 230d 0a20 2020 2020  #########..     
-0000e9e0: 2020 2023 2053 7761 7020 416c 7465 726e     # Swap Altern
-0000e9f0: 6174 696e 6720 5069 7865 6c73 2028 7665  ating Pixels (ve
-0000ea00: 7279 2072 6172 6529 0d0a 2020 2020 2020  ry rare)..      
-0000ea10: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
-0000ea20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ea30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ea40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ea50: 2323 2323 2323 2323 2323 0d0a 0d0a 2020  ##########....  
-0000ea60: 2020 2020 2020 2320 6120 7072 6f74 6f74        # a protot
-0000ea70: 7970 6520 6d6f 6465 6c20 6f75 7470 7574  ype model output
-0000ea80: 2073 7065 6374 7261 2077 6974 6820 616c   spectra with al
-0000ea90: 7465 726e 6174 696e 6720 7069 7865 6c73  ternating pixels
-0000eaa0: 2073 7761 7070 6564 2c20 616e 640d 0a20   swapped, and.. 
-0000eab0: 2020 2020 2020 2023 2074 6869 7320 7761         # this wa
-0000eac0: 7320 7175 6963 6b65 7220 7468 616e 2063  s quicker than c
-0000ead0: 6861 6e67 696e 6720 696e 2066 6972 6d77  hanging in firmw
-0000eae0: 6172 650d 0a0d 0a20 2020 2020 2020 2069  are....        i
-0000eaf0: 6620 7365 6c66 2e73 6574 7469 6e67 732e  f self.settings.
-0000eb00: 7374 6174 652e 7377 6170 5f61 6c74 6572  state.swap_alter
-0000eb10: 6e61 7469 6e67 5f70 6978 656c 7320 616e  nating_pixels an
-0000eb20: 6420 7365 6c66 2e73 6574 7469 6e67 732e  d self.settings.
-0000eb30: 7374 6174 652e 6465 7465 6374 6f72 5f72  state.detector_r
-0000eb40: 6567 696f 6e73 2069 7320 4e6f 6e65 3a0d  egions is None:.
-0000eb50: 0a20 2020 2020 2020 2020 2020 206c 6f67  .            log
-0000eb60: 2e64 6562 7567 2822 7377 6170 7069 6e67  .debug("swapping
-0000eb70: 2061 6c74 6572 6e61 7469 6e67 2070 6978   alternating pix
-0000eb80: 656c 733a 2073 7065 6374 7275 6d20 3d20  els: spectrum = 
-0000eb90: 2573 222c 2073 7065 6374 7275 6d5b 3a31  %s", spectrum[:1
-0000eba0: 305d 290d 0a20 2020 2020 2020 2020 2020  0])..           
-0000ebb0: 2063 6f72 7265 6374 6564 203d 205b 5d0d   corrected = [].
-0000ebc0: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
-0000ebd0: 2061 2c20 6220 696e 207a 6970 2873 7065   a, b in zip(spe
-0000ebe0: 6374 7275 6d5b 303a 3a32 5d2c 2073 7065  ctrum[0::2], spe
-0000ebf0: 6374 7275 6d5b 313a 3a32 5d29 3a0d 0a20  ctrum[1::2]):.. 
-0000ec00: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-0000ec10: 6f72 7265 6374 6564 2e65 7874 656e 6428  orrected.extend(
-0000ec20: 5b62 2c20 615d 290d 0a20 2020 2020 2020  [b, a])..       
-0000ec30: 2020 2020 2073 7065 6374 7275 6d20 3d20       spectrum = 
-0000ec40: 636f 7272 6563 7465 640d 0a20 2020 2020  corrected..     
-0000ec50: 2020 2020 2020 206c 6f67 2e64 6562 7567         log.debug
-0000ec60: 2822 7377 6170 7065 6420 616c 7465 726e  ("swapped altern
-0000ec70: 6174 696e 6720 7069 7865 6c73 3a20 7370  ating pixels: sp
-0000ec80: 6563 7472 756d 203d 2025 7322 2c20 7370  ectrum = %s", sp
-0000ec90: 6563 7472 756d 5b3a 3130 5d29 0d0a 0d0a  ectrum[:10])....
-0000eca0: 2020 2020 2020 2020 2323 2323 2323 2323          ########
-0000ecb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ecc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ecd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ece0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ecf0: 0d0a 2020 2020 2020 2020 2320 3278 3220  ..        # 2x2 
-0000ed00: 6269 6e6e 696e 670d 0a20 2020 2020 2020  binning..       
-0000ed10: 2023 2323 2323 2323 2323 2323 2323 2323   ###############
-0000ed20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ed30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ed40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ed50: 2323 2323 2323 2323 230d 0a0d 0a20 2020  #########....   
-0000ed60: 2020 2020 2023 2061 7070 6c79 2073 6f2d       # apply so-
-0000ed70: 6361 6c6c 6564 2022 3278 3220 7069 7865  called "2x2 pixe
-0000ed80: 6c20 6269 6e6e 696e 6722 200d 0a20 2020  l binning" ..   
-0000ed90: 2020 2020 2073 7065 6374 7275 6d20 3d20       spectrum = 
-0000eda0: 7365 6c66 2e5f 6170 706c 795f 3278 325f  self._apply_2x2_
-0000edb0: 6269 6e6e 696e 6728 7370 6563 7472 756d  binning(spectrum
-0000edc0: 290d 0a0d 0a20 2020 2020 2020 2023 2323  )....        ###
-0000edd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ede0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000edf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ee00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ee10: 2323 2323 230d 0a20 2020 2020 2020 2023  #####..        #
-0000ee20: 2047 7261 7068 2041 6c74 6572 6e61 7469   Graph Alternati
-0000ee30: 6e67 2050 6978 656c 730d 0a20 2020 2020  ng Pixels..     
-0000ee40: 2020 2023 2323 2323 2323 2323 2323 2323     #############
-0000ee50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ee60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ee70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ee80: 2323 2323 2323 2323 2323 230d 0a0d 0a20  ###########.... 
-0000ee90: 2020 2020 2020 2023 2057 6865 6e20 696e         # When in
-0000eea0: 7465 6772 6174 696e 6720 6e65 7720 7365  tegrating new se
-0000eeb0: 6e73 6f72 732c 206f 7220 7465 7374 696e  nsors, or testin
-0000eec0: 6720 2269 6e74 6572 6c65 6176 6564 2220  g "interleaved" 
-0000eed0: 6465 7465 6374 6f72 7320 6c69 6b65 0d0a  detectors like..
-0000eee0: 2020 2020 2020 2020 2320 7468 6520 496e          # the In
-0000eef0: 4761 4173 2c20 736f 6d65 7469 6d65 7320  GaAs, sometimes 
-0000ef00: 7765 2077 616e 7420 746f 206f 6e6c 7920  we want to only 
-0000ef10: 6c6f 6f6b 2061 7420 2265 7665 7279 206f  look at "every o
-0000ef20: 7468 6572 2220 7069 7865 6c20 746f 0d0a  ther" pixel to..
-0000ef30: 2020 2020 2020 2020 2320 666c 6174 7465          # flatte
-0000ef40: 6e2d 6f75 7420 6972 7265 6775 6c61 7269  n-out irregulari
-0000ef50: 7469 6573 2069 6e20 4261 7965 7220 6669  ties in Bayer fi
-0000ef60: 6c74 6572 7320 6f72 2070 686f 746f 6469  lters or photodi
-0000ef70: 6f64 6520 6172 7261 7973 2e0d 0a20 2020  ode arrays...   
-0000ef80: 2020 2020 2023 2048 6f77 6576 6572 2c20       # However, 
-0000ef90: 7765 2064 6f6e 2774 2077 616e 7420 746f  we don't want to
-0000efa0: 2064 6973 7275 7074 2074 6865 2065 7870   disrupt the exp
-0000efb0: 6563 7465 6420 7069 7865 6c2d 636f 756e  ected pixel-coun
-0000efc0: 742c 2073 6f20 6a75 7374 0d0a 2020 2020  t, so just..    
-0000efd0: 2020 2020 2320 6176 6572 6167 652d 6f76      # average-ov
-0000efe0: 6572 2074 6865 2073 6b69 7070 6564 2070  er the skipped p
-0000eff0: 6978 656c 732e 0d0a 2020 2020 2020 2020  ixels...        
-0000f000: 230d 0a20 2020 2020 2020 2023 204e 6f74  #..        # Not
-0000f010: 2069 6d70 6f72 7461 6e74 2065 6e6f 7567   important enoug
-0000f020: 6820 746f 2075 7064 6174 6520 666f 7220  h to update for 
-0000f030: 4465 7465 6374 6f72 5265 6769 6f6e 730d  DetectorRegions.
-0000f040: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-0000f050: 2e73 6574 7469 6e67 732e 7374 6174 652e  .settings.state.
-0000f060: 6772 6170 685f 616c 7465 726e 6174 696e  graph_alternatin
-0000f070: 675f 7069 7865 6c73 3a0d 0a20 2020 2020  g_pixels:..     
-0000f080: 2020 2020 2020 206c 6f67 2e64 6562 7567         log.debug
-0000f090: 2822 6170 706c 7969 6e67 2067 7261 7068  ("applying graph
-0000f0a0: 5f61 6c74 6572 6e61 7469 6e67 5f70 6978  _alternating_pix
-0000f0b0: 656c 7322 290d 0a20 2020 2020 2020 2020  els")..         
-0000f0c0: 2020 2073 6d6f 6f74 6865 6420 3d20 5b5d     smoothed = []
-0000f0d0: 0d0a 2020 2020 2020 2020 2020 2020 666f  ..            fo
-0000f0e0: 7220 6920 696e 2072 616e 6765 286c 656e  r i in range(len
-0000f0f0: 2873 7065 6374 7275 6d29 293a 0d0a 2020  (spectrum)):..  
-0000f100: 2020 2020 2020 2020 2020 2020 2020 6966                if
-0000f110: 2069 2025 2032 203d 3d20 303a 0d0a 2020   i % 2 == 0:..  
+0000e460: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e470: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e480: 2323 2323 2323 2323 2323 2323 2323 0a0a  ##############..
+0000e490: 2020 2020 2020 2020 2323 2323 2323 2323          ########
+0000e4a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e4b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e4c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e4d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e4e0: 0a20 2020 2020 2020 2023 2041 7070 6c79  .        # Apply
+0000e4f0: 2049 6e47 6141 7320 6576 656e 2f6f 6464   InGaAs even/odd
+0000e500: 2067 6169 6e2f 6f66 6673 6574 2069 6e20   gain/offset in 
+0000e510: 736f 6674 7761 7265 0a20 2020 2020 2020  software.       
+0000e520: 2023 2323 2323 2323 2323 2323 2323 2323   ###############
+0000e530: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e540: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e550: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e560: 2323 2323 2323 2323 230a 0a20 2020 2020  #########..     
+0000e570: 2020 2023 2028 6265 666f 7265 2078 2d61     # (before x-a
+0000e580: 7869 7320 696e 7665 7273 696f 6e20 6265  xis inversion be
+0000e590: 6361 7573 6520 7468 6973 2069 7320 7768  cause this is wh
+0000e5a0: 6572 6520 4650 4741 2077 696c 6c20 646f  ere FPGA will do
+0000e5b0: 2069 7429 0a0a 2020 2020 2020 2020 2320   it)..        # 
+0000e5c0: 7468 6973 2073 686f 756c 6420 6265 2064  this should be d
+0000e5d0: 6f6e 6520 696e 2074 6865 2046 5047 412c  one in the FPGA,
+0000e5e0: 2062 7574 206f 6c64 6572 2046 5720 6469   but older FW di
+0000e5f0: 646e 2774 2068 6176 6520 7468 6174 0a20  dn't have that. 
+0000e600: 2020 2020 2020 2023 2069 6d70 6c65 6d65         # impleme
+0000e610: 6e74 6564 2c20 736f 2066 6978 2069 6e20  nted, so fix in 
+0000e620: 5357 2075 6e6c 6573 7320 4545 5052 4f4d  SW unless EEPROM
+0000e630: 2069 6e64 6963 6174 6573 2022 616c 7265   indicates "alre
+0000e640: 6164 7920 6861 6e64 6c65 6422 0a20 2020  ady handled".   
+0000e650: 2020 2020 2069 6620 7365 6c66 2e73 6574       if self.set
+0000e660: 7469 6e67 732e 6973 5f69 6e67 6161 7328  tings.is_ingaas(
+0000e670: 2920 616e 6420 6e6f 7420 7365 6c66 2e73  ) and not self.s
+0000e680: 6574 7469 6e67 732e 6565 7072 6f6d 2e68  ettings.eeprom.h
+0000e690: 6172 6477 6172 655f 6576 656e 5f6f 6464  ardware_even_odd
+0000e6a0: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
+0000e6b0: 6c66 2e5f 636f 7272 6563 745f 696e 6761  lf._correct_inga
+0000e6c0: 6173 5f67 6169 6e5f 616e 645f 6f66 6673  as_gain_and_offs
+0000e6d0: 6574 2873 7065 6374 7275 6d29 0a0a 2020  et(spectrum)..  
+0000e6e0: 2020 2020 2020 2323 2323 2323 2323 2323        ##########
+0000e6f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e700: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e710: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e720: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
+0000e730: 2020 2020 2020 2023 2041 7265 6120 5363         # Area Sc
+0000e740: 616e 2028 7261 7265 290a 2020 2020 2020  an (rare).      
+0000e750: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
+0000e760: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e770: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e780: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e790: 2323 2323 2323 2323 2323 0a0a 2020 2020  ##########..    
+0000e7a0: 2020 2020 2320 2862 6566 6f72 6520 782d      # (before x-
+0000e7b0: 6178 6973 2069 6e76 6572 7369 6f6e 2062  axis inversion b
+0000e7c0: 6563 6175 7365 206c 696e 6520 696e 6465  ecause line inde
+0000e7d0: 7820 6174 2046 5047 4120 7069 7865 6c20  x at FPGA pixel 
+0000e7e0: 3029 0a0a 2020 2020 2020 2020 2320 4966  0)..        # If
+0000e7f0: 2077 6527 7265 2069 6e20 6172 6561 2073   we're in area s
+0000e800: 6361 6e20 6d6f 6465 2c20 7573 6520 6669  can mode, use fi
+0000e810: 7273 7420 7069 7865 6c20 6173 2072 6f77  rst pixel as row
+0000e820: 2069 6e64 6578 2028 6c65 6176 6520 7069   index (leave pi
+0000e830: 7865 6c20 0a20 2020 2020 2020 2023 2069  xel .        # i
+0000e840: 6e20 7370 6563 7472 756d 292e 2020 446f  n spectrum).  Do
+0000e850: 2074 6869 7320 6265 666f 7265 2061 6e79   this before any
+0000e860: 2068 6f72 697a 6f6e 7461 6c20 6176 6572   horizontal aver
+0000e870: 6167 696e 6720 7768 6963 6820 6d69 6768  aging which migh
+0000e880: 7420 0a20 2020 2020 2020 2023 2063 6f72  t .        # cor
+0000e890: 7275 7074 2066 6972 7374 2070 6978 656c  rupt first pixel
+0000e8a0: 292e 2020 4e6f 7465 2074 6861 7420 496e  ).  Note that In
+0000e8b0: 4761 4173 2064 6f6e 2774 2073 7570 706f  GaAs don't suppo
+0000e8c0: 7274 2044 6574 6563 746f 7252 6567 696f  rt DetectorRegio
+0000e8d0: 6e73 2e0a 2020 2020 2020 2020 6172 6561  ns..        area
+0000e8e0: 5f73 6361 6e5f 726f 775f 636f 756e 7420  _scan_row_count 
+0000e8f0: 3d20 2d31 0a20 2020 2020 2020 2069 6620  = -1.        if 
+0000e900: 7365 6c66 2e73 6574 7469 6e67 732e 7374  self.settings.st
+0000e910: 6174 652e 6172 6561 5f73 6361 6e5f 656e  ate.area_scan_en
+0000e920: 6162 6c65 643a 0a20 2020 2020 2020 2020  abled:.         
+0000e930: 2020 2061 7265 615f 7363 616e 5f72 6f77     area_scan_row
+0000e940: 5f63 6f75 6e74 203d 2073 7065 6374 7275  _count = spectru
+0000e950: 6d5b 305d 0a0a 2020 2020 2020 2020 2020  m[0]..          
+0000e960: 2020 2320 666f 7220 6920 696e 2072 616e    # for i in ran
+0000e970: 6765 2834 293a 0a20 2020 2020 2020 2020  ge(4):.         
+0000e980: 2020 2023 2020 2020 2073 7065 6374 7275     #     spectru
+0000e990: 6d5b 695d 203d 2073 7065 6374 7275 6d5b  m[i] = spectrum[
+0000e9a0: 345d 2023 204b 4c55 4447 453a 204e 5244  4] # KLUDGE: NRD
+0000e9b0: 2d64 7561 6c0a 0a20 2020 2020 2020 2020  -dual..         
+0000e9c0: 2020 2023 204c 6561 7665 2074 6865 2072     # Leave the r
+0000e9d0: 6f77 2063 6f75 6e74 6572 2069 6e20 706c  ow counter in pl
+0000e9e0: 6163 6520 6966 2077 6527 7265 2069 6e20  ace if we're in 
+0000e9f0: 2246 6173 7422 2041 7265 6120 5363 616e  "Fast" Area Scan
+0000ea00: 206d 6f64 652c 0a20 2020 2020 2020 2020   mode,.         
+0000ea10: 2020 2023 2073 696e 6365 2064 6f77 6e73     # since downs
+0000ea20: 7472 6561 6d20 736f 6674 7761 7265 2063  tream software c
+0000ea30: 616e 2075 7365 2069 7420 746f 2061 7373  an use it to ass
+0000ea40: 656d 626c 6520 7468 6520 6669 6e61 6c20  emble the final 
+0000ea50: 696d 6167 652e 0a20 2020 2020 2020 2020  image..         
+0000ea60: 2020 2023 2028 2253 6c6f 7722 2041 7265     # ("Slow" Are
+0000ea70: 6120 5363 616e 206d 6f64 6520 7365 6e74  a Scan mode sent
+0000ea80: 2074 6869 7320 7661 6c75 6520 6261 636b   this value back
+0000ea90: 2061 7320 6120 7365 7061 7261 7465 2066   as a separate f
+0000eaa0: 6965 6c64 2069 6e0a 2020 2020 2020 2020  ield in.        
+0000eab0: 2020 2020 2320 7468 6520 5265 6164 696e      # the Readin
+0000eac0: 672c 2062 7574 2074 6869 7320 6973 6e27  g, but this isn'
+0000ead0: 7420 706f 7373 6962 6c65 2069 6e20 4661  t possible in Fa
+0000eae0: 7374 206d 6f64 652e 2020 4a75 7374 2064  st mode.  Just d
+0000eaf0: 656c 6574 650a 2020 2020 2020 2020 2020  elete.          
+0000eb00: 2020 2320 536c 6f77 206d 6f64 6520 7768    # Slow mode wh
+0000eb10: 656e 2046 6173 7420 6973 2077 6964 656c  en Fast is widel
+0000eb20: 7920 6465 706c 6f79 6564 2e29 0a20 2020  y deployed.).   
+0000eb30: 2020 2020 2020 2020 2023 0a20 2020 2020           #.     
+0000eb40: 2020 2020 2020 2069 6620 6e6f 7420 7365         if not se
+0000eb50: 6c66 2e73 6574 7469 6e67 732e 7374 6174  lf.settings.stat
+0000eb60: 652e 6172 6561 5f73 6361 6e5f 6661 7374  e.area_scan_fast
+0000eb70: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000eb80: 2020 7370 6563 7472 756d 5b30 5d20 3d20    spectrum[0] = 
+0000eb90: 7370 6563 7472 756d 5b31 5d0a 0a20 2020  spectrum[1]..   
+0000eba0: 2020 2020 2023 2323 2323 2323 2323 2323       ###########
+0000ebb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ebc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ebd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ebe0: 2323 2323 2323 2323 2323 2323 230a 2020  #############.  
+0000ebf0: 2020 2020 2020 2320 5374 6172 742d 6f66        # Start-of
+0000ec00: 2d53 7065 6374 7275 6d20 4d61 726b 6572  -Spectrum Marker
+0000ec10: 2028 7261 7265 290a 2020 2020 2020 2020   (rare).        
+0000ec20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ec30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ec40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ec50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ec60: 2323 2323 2323 2323 0a0a 2020 2020 2020  ########..      
+0000ec70: 2020 2320 2862 6566 6f72 6520 782d 6178    # (before x-ax
+0000ec80: 6973 2069 6e76 6572 7369 6f6e 2062 6563  is inversion bec
+0000ec90: 6175 7365 206d 6172 6b65 7220 6174 2046  ause marker at F
+0000eca0: 5047 4120 7069 7865 6c20 3029 0a0a 2020  PGA pixel 0)..  
+0000ecb0: 2020 2020 2020 2320 4368 6563 6b20 616e        # Check an
+0000ecc0: 6420 7472 6163 6b20 7468 6520 2273 7461  d track the "sta
+0000ecd0: 7274 206f 6620 7370 6563 7472 756d 2220  rt of spectrum" 
+0000ece0: 6d61 726b 6572 2e20 2054 6869 7320 6973  marker.  This is
+0000ecf0: 2076 6572 7920 7261 7265 2061 6e64 0a20   very rare and. 
+0000ed00: 2020 2020 2020 2023 206f 6e6c 7920 666f         # only fo
+0000ed10: 7220 6578 7065 7269 6d65 6e74 616c 2075  r experimental u
+0000ed20: 6e69 7473 2e20 2043 7572 7265 6e74 6c79  nits.  Currently
+0000ed30: 2057 6173 6174 6368 2064 6f65 7320 6e6f   Wasatch does no
+0000ed40: 7420 6861 7665 2061 6e79 0a20 2020 2020  t have any.     
+0000ed50: 2020 2023 2022 7374 616e 6461 7264 2220     # "standard" 
+0000ed60: 7370 6563 7472 756d 2066 7261 6d69 6e67  spectrum framing
+0000ed70: 2064 6174 612c 2061 6c74 686f 7567 6820   data, although 
+0000ed80: 7375 6368 2077 6f75 6c64 2062 6520 7573  such would be us
+0000ed90: 6566 756c 2e20 5468 6973 0a20 2020 2020  eful. This.     
+0000eda0: 2020 2023 2069 7320 6f6e 6c79 2065 6e61     # is only ena
+0000edb0: 626c 6564 2069 6e20 4650 4741 7320 7768  bled in FPGAs wh
+0000edc0: 656e 2074 7279 696e 6720 746f 2064 6562  en trying to deb
+0000edd0: 7567 2072 6172 6520 7469 6d69 6e67 2069  ug rare timing i
+0000ede0: 7373 7565 732e 2054 6865 0a20 2020 2020  ssues. The.     
+0000edf0: 2020 2023 2022 4d61 726b 6572 2220 6973     # "Marker" is
+0000ee00: 2073 696d 706c 7920 6120 7069 7865 6c20   simply a pixel 
+0000ee10: 7769 7468 2074 6865 2076 616c 7565 2030  with the value 0
+0000ee20: 7866 6666 662e 2020 4f6e 2046 5047 4120  xffff.  On FPGA 
+0000ee30: 4657 2077 6865 7265 2074 6865 0a20 2020  FW where the.   
+0000ee40: 2020 2020 2023 206d 6172 6b65 7220 6973       # marker is
+0000ee50: 2065 6e61 626c 6564 2c20 7370 6563 7472   enabled, spectr
+0000ee60: 616c 2064 6174 6120 6973 2063 6c61 6d70  al data is clamp
+0000ee70: 6564 2074 6f20 3078 6666 6665 2c20 6d65  ed to 0xfffe, me
+0000ee80: 616e 696e 6720 7375 6368 0a20 2020 2020  aning such.     
+0000ee90: 2020 2023 206d 6172 6b65 7273 2063 616e     # markers can
+0000eea0: 204f 4e4c 5920 6170 7065 6172 2061 7320   ONLY appear as 
+0000eeb0: 7468 6520 6669 7273 7420 7069 7865 6c20  the first pixel 
+0000eec0: 696e 2061 2073 7065 6374 7275 6d2e 0a20  in a spectrum.. 
+0000eed0: 2020 2020 2020 2023 0a20 2020 2020 2020         #.       
+0000eee0: 2023 2057 6f75 6c64 206e 6565 6420 7570   # Would need up
+0000eef0: 6461 7465 6420 746f 2077 6f72 6b20 7769  dated to work wi
+0000ef00: 7468 2044 6574 6563 746f 7252 6567 696f  th DetectorRegio
+0000ef10: 6e73 2e0a 2020 2020 2020 2020 6966 2073  ns..        if s
+0000ef20: 656c 662e 7365 7474 696e 6773 2e68 6173  elf.settings.has
+0000ef30: 5f6d 6172 6b65 7228 2920 616e 6420 6e6f  _marker() and no
+0000ef40: 7420 7365 6c66 2e73 6574 7469 6e67 732e  t self.settings.
+0000ef50: 7374 6174 652e 6172 6561 5f73 6361 6e5f  state.area_scan_
+0000ef60: 656e 6162 6c65 643a 0a20 2020 2020 2020  enabled:.       
+0000ef70: 2020 2020 206d 6172 6b65 7220 3d20 3078       marker = 0x
+0000ef80: 6666 6666 0a20 2020 2020 2020 2020 2020  ffff.           
+0000ef90: 2069 6620 7370 6563 7472 756d 5b30 5d20   if spectrum[0] 
+0000efa0: 3d3d 206d 6172 6b65 723a 0a20 2020 2020  == marker:.     
+0000efb0: 2020 2020 2020 2020 2020 2023 206d 6172             # mar
+0000efc0: 6b65 7220 666f 756e 6420 7768 6572 6520  ker found where 
+0000efd0: 6578 7065 6374 6564 2c20 736f 2061 6c6c  expected, so all
+0000efe0: 2069 7320 676f 6f64 2028 6f76 6572 7772   is good (overwr
+0000eff0: 6974 6520 666f 7220 610a 2020 2020 2020  ite for a.      
+0000f000: 2020 2020 2020 2020 2020 2320 636c 6561            # clea
+0000f010: 6e20 6772 6170 6829 0a20 2020 2020 2020  n graph).       
+0000f020: 2020 2020 2020 2020 2073 7065 6374 7275           spectru
+0000f030: 6d5b 305d 203d 2073 7065 6374 7275 6d5b  m[0] = spectrum[
+0000f040: 315d 0a20 2020 2020 2020 2020 2020 2065  1].            e
+0000f050: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0000f060: 2020 2020 2023 2077 6520 4449 444e 2754       # we DIDN'T
+0000f070: 2066 696e 6420 7468 6520 6d61 726b 6572   find the marker
+0000f080: 2077 6865 7265 2069 7420 7761 7320 6578   where it was ex
+0000f090: 7065 6374 6564 2c20 736f 2066 6c61 6720  pected, so flag 
+0000f0a0: 616e 640a 2020 2020 2020 2020 2020 2020  and.            
+0000f0b0: 2020 2020 2320 676f 2068 756e 7469 6e67      # go hunting
+0000f0c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000f0d0: 206c 6f67 2e65 7272 6f72 2822 6765 745f   log.error("get_
+0000f0e0: 6c69 6e65 3a20 6d69 7373 696e 6720 6d61  line: missing ma
+0000f0f0: 726b 6572 2229 0a20 2020 2020 2020 2020  rker").         
+0000f100: 2020 2020 2020 2066 6f72 2069 2069 6e20         for i in 
+0000f110: 7261 6e67 6528 7069 7865 6c73 293a 0a20  range(pixels):. 
 0000f120: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f130: 2020 736d 6f6f 7468 6564 2e61 7070 656e    smoothed.appen
-0000f140: 6428 7370 6563 7472 756d 5b69 5d29 0d0a  d(spectrum[i])..
+0000f130: 2020 2069 6620 7370 6563 7472 756d 5b69     if spectrum[i
+0000f140: 5d20 3d3d 206d 6172 6b65 723a 0a20 2020  ] == marker:.   
 0000f150: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f160: 656c 7365 3a0d 0a20 2020 2020 2020 2020  else:..         
-0000f170: 2020 2020 2020 2020 2020 2069 6620 6920             if i 
-0000f180: 2b20 3120 3c20 6c65 6e28 7370 6563 7472  + 1 < len(spectr
-0000f190: 756d 293a 0d0a 2020 2020 2020 2020 2020  um):..          
-0000f1a0: 2020 2020 2020 2020 2020 2020 2020 6176                av
-0000f1b0: 6572 6167 6564 203d 2028 7370 6563 7472  eraged = (spectr
-0000f1c0: 756d 5b69 2d31 5d20 2b20 7370 6563 7472  um[i-1] + spectr
-0000f1d0: 756d 5b69 2b31 5d29 202f 2032 2e30 0d0a  um[i+1]) / 2.0..
-0000f1e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f1f0: 2020 2020 656c 7365 3a0d 0a20 2020 2020      else:..     
-0000f200: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f210: 2020 2061 7665 7261 6765 6420 3d20 7370     averaged = sp
-0000f220: 6563 7472 756d 5b69 202d 2031 5d0d 0a20  ectrum[i - 1].. 
-0000f230: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f240: 2020 2073 6d6f 6f74 6865 642e 6170 7065     smoothed.appe
-0000f250: 6e64 2861 7665 7261 6765 6429 0d0a 2020  nd(averaged)..  
-0000f260: 2020 2020 2020 2020 2020 7370 6563 7472            spectr
-0000f270: 756d 203d 2073 6d6f 6f74 6865 640d 0a0d  um = smoothed...
-0000f280: 0a20 2020 2020 2020 2023 2053 6f6d 6577  .        # Somew
-0000f290: 6861 7420 6f64 646c 792c 2077 6527 7265  hat oddly, we're
-0000f2a0: 2063 7572 7265 6e74 6c79 2072 6574 7572   currently retur
-0000f2b0: 6e69 6e67 2061 2054 5550 4c45 206f 6620  ning a TUPLE of 
-0000f2c0: 7468 6520 7370 6563 7472 756d 2061 6e64  the spectrum and
-0000f2d0: 0d0a 2020 2020 2020 2020 2320 7468 6520  ..        # the 
-0000f2e0: 6172 6561 2073 6361 6e20 726f 7720 636f  area scan row co
-0000f2f0: 756e 742e 2020 5768 656e 2022 4661 7374  unt.  When "Fast
-0000f300: 2220 4172 6561 2053 6361 6e20 6973 206d  " Area Scan is m
-0000f310: 6f72 6520 636f 6d6d 6f6e 706c 6163 6520  ore commonplace 
-0000f320: 0d0a 2020 2020 2020 2020 2320 7765 276c  ..        # we'l
-0000f330: 6c20 6368 616e 6765 2074 6869 7320 6261  l change this ba
-0000f340: 636b 2074 6f20 6a75 7374 2072 6574 7572  ck to just retur
-0000f350: 6e69 6e67 2074 6865 2073 7065 6374 7275  ning the spectru
-0000f360: 6d20 6172 7261 7920 6469 7265 6374 6c79  m array directly
-0000f370: 2e0d 0a20 2020 2020 2020 2072 6573 706f  ...        respo
-0000f380: 6e73 652e 6461 7461 203d 2053 7065 6374  nse.data = Spect
-0000f390: 7275 6d41 6e64 526f 7728 7370 6563 7472  rumAndRow(spectr
-0000f3a0: 756d 2c20 6172 6561 5f73 6361 6e5f 726f  um, area_scan_ro
-0000f3b0: 775f 636f 756e 7429 200d 0a20 2020 2020  w_count) ..     
-0000f3c0: 2020 2072 6574 7572 6e20 7265 7370 6f6e     return respon
-0000f3d0: 7365 0d0a 0d0a 2020 2020 6465 6620 7365  se....    def se
-0000f3e0: 745f 696e 7465 6772 6174 696f 6e5f 7469  t_integration_ti
-0000f3f0: 6d65 5f6d 7328 7365 6c66 2c20 6d73 3a20  me_ms(self, ms: 
-0000f400: 666c 6f61 7429 3a20 2320 2d3e 2053 7065  float): # -> Spe
-0000f410: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
-0000f420: 6520 0d0a 2020 2020 2020 2020 2222 220d  e ..        """.
-0000f430: 0a20 2020 2020 2020 2053 656e 6420 7468  .        Send th
-0000f440: 6520 7570 6461 7465 6420 696e 7465 6772  e updated integr
-0000f450: 6174 696f 6e20 7469 6d65 2069 6e20 6120  ation time in a 
-0000f460: 636f 6e74 726f 6c20 6d65 7373 6167 6520  control message 
-0000f470: 746f 2074 6865 2064 6576 6963 650d 0a20  to the device.. 
-0000f480: 2020 2020 2020 2040 7761 726e 696e 6720         @warning 
-0000f490: 6469 7361 626c 6564 2045 4550 524f 4d20  disabled EEPROM 
-0000f4a0: 7261 6e67 652d 6368 6563 6b69 6e67 2062  range-checking b
-0000f4b0: 7920 6375 7374 6f6d 6572 0d0a 2020 2020  y customer..    
-0000f4c0: 2020 2020 2020 2020 2072 6571 7565 7374           request
-0000f4d0: 3b20 7261 6e67 6520 6c69 6d69 7473 2069  ; range limits i
-0000f4e0: 6e20 4545 5052 4f4d 2061 7265 2064 6566  n EEPROM are def
-0000f4f0: 696e 6564 2061 7320 3136 2d62 6974 0d0a  ined as 16-bit..
-0000f500: 2020 2020 2020 2020 2020 2020 2076 616c               val
-0000f510: 7565 732c 2077 6869 6c65 2069 6e74 6567  ues, while integ
-0000f520: 7261 7469 6f6e 2074 696d 6520 6973 2061  ration time is a
-0000f530: 6374 7561 6c6c 7920 6120 3234 2d62 6974  ctually a 24-bit
-0000f540: 2076 616c 7565 2c0d 0a20 2020 2020 2020   value,..       
-0000f550: 2020 2020 2020 7375 6368 2074 6861 7420        such that 
-0000f560: 7468 6520 4545 5052 4f4d 2069 7320 6172  the EEPROM is ar
-0000f570: 7469 6669 6369 616c 6c79 206c 696d 6974  tificially limit
-0000f580: 696e 6720 6f75 7220 7261 6e67 652e 0d0a  ing our range...
-0000f590: 2020 2020 2020 2020 2222 220d 0a20 2020          """..   
-0000f5a0: 2020 2020 206d 7320 3d20 6d61 7828 312c       ms = max(1,
-0000f5b0: 2069 6e74 2872 6f75 6e64 286d 7329 2929   int(round(ms)))
-0000f5c0: 0d0a 0d0a 2020 2020 2020 2020 6c73 7720  ....        lsw 
-0000f5d0: 3d20 206d 7320 2020 2020 2020 2026 2030  =  ms        & 0
-0000f5e0: 7866 6666 660d 0a20 2020 2020 2020 206d  xffff..        m
-0000f5f0: 7377 203d 2028 6d73 203e 3e20 3136 2920  sw = (ms >> 16) 
-0000f600: 2620 3078 3030 6666 0d0a 0d0a 2020 2020  & 0x00ff....    
-0000f610: 2020 2020 7265 7375 6c74 203d 2073 656c      result = sel
-0000f620: 662e 5f73 656e 645f 636f 6465 2830 7842  f._send_code(0xB
-0000f630: 322c 206c 7377 2c20 6d73 772c 206c 6162  2, lsw, msw, lab
-0000f640: 656c 3d22 5345 545f 494e 5445 4752 4154  el="SET_INTEGRAT
-0000f650: 494f 4e5f 5449 4d45 5f4d 5322 290d 0a20  ION_TIME_MS").. 
-0000f660: 2020 2020 2020 206c 6f67 2e64 6562 7567         log.debug
-0000f670: 2822 5345 545f 494e 5445 4752 4154 494f  ("SET_INTEGRATIO
-0000f680: 4e5f 5449 4d45 5f4d 533a 206e 6f77 2025  N_TIME_MS: now %
-0000f690: 6422 2c20 6d73 290d 0a20 2020 2020 2020  d", ms)..       
-0000f6a0: 2073 656c 662e 7365 7474 696e 6773 2e73   self.settings.s
-0000f6b0: 7461 7465 2e69 6e74 6567 7261 7469 6f6e  tate.integration
-0000f6c0: 5f74 696d 655f 6d73 203d 206d 730d 0a0d  _time_ms = ms...
-0000f6d0: 0a20 2020 2020 2020 2023 2063 6f6e 7363  .        # consc
-0000f6e0: 696f 7573 6c79 2062 7574 2063 6175 7469  iously but cauti
-0000f6f0: 6f75 736c 7920 6469 7361 626c 696e 6720  ously disabling 
-0000f700: 7468 6973 2066 756e 6374 696f 6e61 6c69  this functionali
-0000f710: 7479 0d0a 2020 2020 2020 2020 2320 6966  ty..        # if
-0000f720: 2073 656c 662e 7365 7474 696e 6773 2e69   self.settings.i
-0000f730: 735f 6d69 6372 6f28 293a 0d0a 2020 2020  s_micro():..    
-0000f740: 2020 2020 2320 2020 2020 7365 6c66 2e75      #     self.u
-0000f750: 7064 6174 655f 6c61 7365 725f 7761 7463  pdate_laser_watc
-0000f760: 6864 6f67 2829 3b0d 0a0d 0a20 2020 2020  hdog();....     
-0000f770: 2020 2072 6574 7572 6e20 7265 7375 6c74     return result
-0000f780: 0d0a 0d0a 2020 2020 2320 2323 2323 2323  ....    # ######
-0000f790: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000f7a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000f7b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000f7c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000f7d0: 2323 2323 0d0a 2020 2020 2320 5465 6d70  ####..    # Temp
-0000f7e0: 6572 6174 7572 650d 0a20 2020 2023 2023  erature..    # #
-0000f7f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000f800: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000f810: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000f820: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000f830: 2323 2323 2323 2323 230d 0a0d 0a20 2020  #########....   
-0000f840: 2064 6566 2073 656c 6563 745f 6164 6328   def select_adc(
-0000f850: 7365 6c66 2c20 6e3a 2069 6e74 293a 2023  self, n: int): #
-0000f860: 202d 3e20 5370 6563 7472 6f6d 6574 6572   -> Spectrometer
-0000f870: 5265 7370 6f6e 7365 200d 0a20 2020 2020  Response ..     
-0000f880: 2020 206c 6f67 2e64 6562 7567 2822 7365     log.debug("se
-0000f890: 6c65 6374 5f61 6463 202d 3e20 2564 222c  lect_adc -> %d",
-0000f8a0: 206e 290d 0a20 2020 2020 2020 2073 656c   n)..        sel
-0000f8b0: 662e 7365 7474 696e 6773 2e73 7461 7465  f.settings.state
-0000f8c0: 2e73 656c 6563 7465 645f 6164 6320 3d20  .selected_adc = 
-0000f8d0: 6e0d 0a20 2020 2020 2020 2072 6573 756c  n..        resul
-0000f8e0: 7420 3d20 7365 6c66 2e5f 7365 6e64 5f63  t = self._send_c
-0000f8f0: 6f64 6528 3078 6564 2c20 6e2c 206c 6162  ode(0xed, n, lab
-0000f900: 656c 3d22 5345 4c45 4354 5f41 4443 2229  el="SELECT_ADC")
-0000f910: 0d0a 2020 2020 2020 2020 7365 6c66 2e5f  ..        self._
-0000f920: 6765 745f 636f 6465 2830 7864 352c 2077  get_code(0xd5, w
-0000f930: 4c65 6e67 7468 3d32 2c20 6c61 6265 6c3d  Length=2, label=
-0000f940: 2247 4554 5f41 4443 2028 7468 726f 7761  "GET_ADC (throwa
-0000f950: 7761 7929 2229 2023 2073 7461 6269 6c69  way)") # stabili
-0000f960: 7a61 7469 6f6e 2072 6561 640d 0a20 2020  zation read..   
-0000f970: 2020 2020 2072 6574 7572 6e20 7265 7375       return resu
-0000f980: 6c74 0d0a 0d0a 2020 2020 6465 6620 6765  lt....    def ge
-0000f990: 745f 7365 636f 6e64 6172 795f 6164 635f  t_secondary_adc_
-0000f9a0: 6361 6c69 6272 6174 6564 2873 656c 662c  calibrated(self,
-0000f9b0: 2072 6177 3a20 666c 6f61 7420 3d20 4e6f   raw: float = No
-0000f9c0: 6e65 293a 2023 202d 3e20 5370 6563 7472  ne): # -> Spectr
-0000f9d0: 6f6d 6574 6572 5265 7370 6f6e 7365 200d  ometerResponse .
-0000f9e0: 0a20 2020 2020 2020 2069 6620 6e6f 7420  .        if not 
-0000f9f0: 7365 6c66 2e68 6173 5f6c 696e 6561 7269  self.has_lineari
-0000fa00: 7479 5f63 6f65 6666 7328 293a 0d0a 2020  ty_coeffs():..  
-0000fa10: 2020 2020 2020 2020 2020 6c6f 672e 6465            log.de
-0000fa20: 6275 6728 2273 6563 6f6e 6461 7279 5f61  bug("secondary_a
-0000fa30: 6463 5f63 616c 6962 7261 7465 643a 206e  dc_calibrated: n
-0000fa40: 6f20 6361 6c69 6272 6174 696f 6e22 290d  o calibration").
-0000fa50: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0000fa60: 7572 6e20 5370 6563 7472 6f6d 6574 6572  urn Spectrometer
-0000fa70: 5265 7370 6f6e 7365 2864 6174 613d 4e6f  Response(data=No
-0000fa80: 6e65 2c20 6572 726f 725f 6c76 6c3d 4572  ne, error_lvl=Er
-0000fa90: 726f 724c 6576 656c 2e6c 6f77 2c20 6572  rorLevel.low, er
-0000faa0: 726f 725f 6d73 673d 2273 6563 6f6e 6461  ror_msg="seconda
-0000fab0: 7279 5f61 6463 5f63 616c 6962 7261 7465  ry_adc_calibrate
-0000fac0: 643a 206e 6f20 6361 6c69 6272 6174 696f  d: no calibratio
-0000fad0: 6e22 290d 0a0d 0a20 2020 2020 2020 2069  n")....        i
-0000fae0: 6620 7261 7720 6973 204e 6f6e 653a 0d0a  f raw is None:..
-0000faf0: 2020 2020 2020 2020 2020 2020 7265 7370              resp
-0000fb00: 6f6e 7365 203d 2073 656c 662e 6765 745f  onse = self.get_
-0000fb10: 7365 636f 6e64 6172 795f 6164 635f 7261  secondary_adc_ra
-0000fb20: 7728 290d 0a20 2020 2020 2020 2069 6620  w()..        if 
-0000fb30: 7265 7370 6f6e 7365 2e64 6174 6120 6973  response.data is
-0000fb40: 204e 6f6e 653a 0d0a 2020 2020 2020 2020   None:..        
-0000fb50: 2020 2020 7265 7475 726e 2072 6573 706f      return respo
-0000fb60: 6e73 650d 0a0d 0a20 2020 2020 2020 2072  nse....        r
-0000fb70: 6177 203d 2066 6c6f 6174 2872 6573 706f  aw = float(respo
-0000fb80: 6e73 652e 6461 7461 290d 0a0d 0a20 2020  nse.data)....   
-0000fb90: 2020 2020 2023 2075 7365 2074 6865 2066       # use the f
-0000fba0: 6972 7374 2034 206c 696e 6561 7269 7479  irst 4 linearity
-0000fbb0: 2063 6f65 6666 6963 6965 6e74 7320 6173   coefficients as
-0000fbc0: 2061 2033 7264 2d6f 7264 6572 2070 6f6c   a 3rd-order pol
-0000fbd0: 796e 6f6d 6961 6c0d 0a20 2020 2020 2020  ynomial..       
-0000fbe0: 2063 616c 6962 7261 7465 6420 3d20 666c   calibrated = fl
-0000fbf0: 6f61 7428 7365 6c66 2e73 6574 7469 6e67  oat(self.setting
-0000fc00: 732e 6565 7072 6f6d 2e6c 696e 6561 7269  s.eeprom.lineari
-0000fc10: 7479 5f63 6f65 6666 735b 305d 2920 5c0d  ty_coeffs[0]) \.
-0000fc20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000fc30: 2020 2020 2b20 666c 6f61 7428 7365 6c66      + float(self
-0000fc40: 2e73 6574 7469 6e67 732e 6565 7072 6f6d  .settings.eeprom
-0000fc50: 2e6c 696e 6561 7269 7479 5f63 6f65 6666  .linearity_coeff
-0000fc60: 735b 315d 2920 2a20 7261 7720 5c0d 0a20  s[1]) * raw \.. 
-0000fc70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fc80: 2020 2b20 666c 6f61 7428 7365 6c66 2e73    + float(self.s
-0000fc90: 6574 7469 6e67 732e 6565 7072 6f6d 2e6c  ettings.eeprom.l
-0000fca0: 696e 6561 7269 7479 5f63 6f65 6666 735b  inearity_coeffs[
-0000fcb0: 325d 2920 2a20 7261 7720 2a20 7261 7720  2]) * raw * raw 
-0000fcc0: 5c0d 0a20 2020 2020 2020 2020 2020 2020  \..             
-0000fcd0: 2020 2020 2020 2b20 666c 6f61 7428 7365        + float(se
-0000fce0: 6c66 2e73 6574 7469 6e67 732e 6565 7072  lf.settings.eepr
-0000fcf0: 6f6d 2e6c 696e 6561 7269 7479 5f63 6f65  om.linearity_coe
-0000fd00: 6666 735b 335d 2920 2a20 7261 7720 2a20  ffs[3]) * raw * 
-0000fd10: 7261 7720 2a20 7261 770d 0a20 2020 2020  raw * raw..     
-0000fd20: 2020 206c 6f67 2e64 6562 7567 2822 7365     log.debug("se
-0000fd30: 636f 6e64 6172 795f 6164 635f 6361 6c69  condary_adc_cali
-0000fd40: 6272 6174 6564 3a20 2566 222c 2063 616c  brated: %f", cal
-0000fd50: 6962 7261 7465 6429 0d0a 2020 2020 2020  ibrated)..      
-0000fd60: 2020 7265 7370 6f6e 7365 2e64 6174 6120    response.data 
-0000fd70: 3d20 6361 6c69 6272 6174 6564 0d0a 2020  = calibrated..  
-0000fd80: 2020 2020 2020 7265 7475 726e 2072 6573        return res
-0000fd90: 706f 6e73 650d 0a0d 0a20 2020 2064 6566  ponse....    def
-0000fda0: 2067 6574 5f73 6563 6f6e 6461 7279 5f61   get_secondary_a
-0000fdb0: 6463 5f72 6177 2873 656c 6629 3a20 2320  dc_raw(self): # 
-0000fdc0: 2d3e 2053 7065 6374 726f 6d65 7465 7252  -> SpectrometerR
-0000fdd0: 6573 706f 6e73 6520 0d0a 2020 2020 2020  esponse ..      
-0000fde0: 2020 2320 666c 6970 2074 6f20 7365 636f    # flip to seco
-0000fdf0: 6e64 6172 7920 4144 4320 6966 206e 6565  ndary ADC if nee
-0000fe00: 6465 640d 0a20 2020 2020 2020 2069 6620  ded..        if 
-0000fe10: 7365 6c66 2e73 6574 7469 6e67 732e 7374  self.settings.st
-0000fe20: 6174 652e 7365 6c65 6374 6564 5f61 6463  ate.selected_adc
-0000fe30: 2069 7320 4e6f 6e65 206f 7220 7365 6c66   is None or self
-0000fe40: 2e73 6574 7469 6e67 732e 7374 6174 652e  .settings.state.
-0000fe50: 7365 6c65 6374 6564 5f61 6463 2021 3d20  selected_adc != 
-0000fe60: 313a 0d0a 2020 2020 2020 2020 2020 2020  1:..            
-0000fe70: 7365 6c66 2e73 656c 6563 745f 6164 6328  self.select_adc(
-0000fe80: 3129 0d0a 0d0a 2020 2020 2020 2020 7265  1)....        re
-0000fe90: 7375 6c74 203d 2073 656c 662e 5f67 6574  sult = self._get
-0000fea0: 5f63 6f64 6528 3078 6435 2c20 774c 656e  _code(0xd5, wLen
-0000feb0: 6774 683d 322c 206c 6162 656c 3d22 4745  gth=2, label="GE
-0000fec0: 545f 4144 4322 2c20 6c73 625f 6c65 6e3d  T_ADC", lsb_len=
-0000fed0: 3229 2026 2030 7866 6666 0d0a 2020 2020  2) & 0xfff..    
-0000fee0: 2020 2020 6c6f 672e 6465 6275 6728 2273      log.debug("s
-0000fef0: 6563 6f6e 6461 7279 5f61 6463 5f72 6177  econdary_adc_raw
-0000ff00: 3a20 3078 2530 3478 222c 2072 6573 756c  : 0x%04x", resul
-0000ff10: 7429 0d0a 2020 2020 2020 2020 7265 7475  t)..        retu
-0000ff20: 726e 2072 6573 756c 740d 0a0d 0a20 2020  rn result....   
-0000ff30: 2023 230d 0a20 2020 2023 204c 6173 6572   ##..    # Laser
-0000ff40: 2074 656d 7065 7261 7475 7265 2063 6f6e   temperature con
-0000ff50: 7665 7273 696f 6e20 646f 6573 6e27 7420  version doesn't 
-0000ff60: 7573 6520 4545 5052 4f4d 2063 6f65 6666  use EEPROM coeff
-0000ff70: 7320 6174 2061 6c6c 2e0d 0a20 2020 2023  s at all...    #
-0000ff80: 204d 6f73 7420 5761 7361 7463 6820 5261   Most Wasatch Ra
-0000ff90: 6d61 6e20 7379 7374 656d 7320 7573 6520  man systems use 
-0000ffa0: 616e 2049 5053 2057 6176 656c 656e 6774  an IPS Wavelengt
-0000ffb0: 682d 5374 6162 696c 697a 6564 2054 4f2d  h-Stabilized TO-
-0000ffc0: 3536 0d0a 2020 2020 2320 6c61 7365 722c  56..    # laser,
-0000ffd0: 2077 6869 6368 2069 6e74 6572 6e61 6c6c   which internall
-0000ffe0: 7920 7573 6573 2061 2042 6574 6174 6865  y uses a Betathe
-0000fff0: 726d 2031 304b 3343 4733 2074 6865 726d  rm 10K3CG3 therm
-00010000: 6973 746f 722e 0d0a 2020 2020 230d 0a20  istor...    #.. 
-00010010: 2020 2023 2040 7365 6520 6874 7470 733a     # @see https:
-00010020: 2f2f 7777 772e 6970 736c 6173 6572 732e  //www.ipslasers.
-00010030: 636f 6d2f 6461 7461 2d73 6865 6574 732f  com/data-sheets/
-00010040: 534d 2d54 4f2d 3536 2d44 6174 612d 5368  SM-TO-56-Data-Sh
-00010050: 6565 742d 4950 532e 7064 660d 0a20 2020  eet-IPS.pdf..   
-00010060: 2023 0d0a 2020 2020 2320 5468 6520 6f66   #..    # The of
-00010070: 6669 6369 616c 2063 6f6e 7665 7273 696f  ficial conversio
-00010080: 6e20 6672 6f6d 2074 6865 726d 6973 746f  n from thermisto
-00010090: 7220 7265 7369 7374 616e 6365 2028 696e  r resistance (in
-000100a0: 206f 686d 7329 2074 6f20 6465 6743 2069   ohms) to degC i
-000100b0: 733a 0d0a 2020 2020 230d 0a20 2020 2023  s:..    #..    #
-000100c0: 205c 7665 7262 6174 696d 0d0a 2020 2020   \verbatim..    
-000100d0: 2320 3120 2f20 2820 2020 4331 0d0a 2020  # 1 / (   C1..  
-000100e0: 2020 2320 2020 2020 2020 2b20 4332 202a    #       + C2 *
-000100f0: 206c 6e28 6f68 6d73 290d 0a20 2020 2023   ln(ohms)..    #
-00010100: 2020 2020 2020 202b 2043 3320 2a20 706f         + C3 * po
-00010110: 7728 6c6e 286f 686d 7329 2c20 3329 0d0a  w(ln(ohms), 3)..
-00010120: 2020 2020 2320 2020 2020 290d 0a20 2020      #     )..   
-00010130: 2023 202d 2032 3733 2e31 350d 0a20 2020   # - 273.15..   
-00010140: 2023 0d0a 2020 2020 2320 5768 6572 653a   #..    # Where:
-00010150: 2043 3120 3d20 302e 3030 3131 330d 0a20   C1 = 0.00113.. 
-00010160: 2020 2023 2020 2020 2020 2020 4332 203d     #        C2 =
-00010170: 2030 2e30 3030 3233 340d 0a20 2020 2023   0.000234..    #
-00010180: 2020 2020 2020 2020 4333 203d 2038 2e37          C3 = 8.7
-00010190: 3865 2d38 0d0a 2020 2020 2320 5c65 6e64  8e-8..    # \end
-000101a0: 7665 7262 6174 696d 0d0a 2020 2020 230d  verbatim..    #.
-000101b0: 0a20 2020 2023 2040 7061 7261 6d20 7261  .    # @param ra
-000101c0: 7720 2020 2074 6865 2076 616c 7565 2072  w    the value r
-000101d0: 6561 6420 6672 6f6d 2074 6865 2074 6865  ead from the the
-000101e0: 726d 6973 746f 7227 7320 3132 2d62 6974  rmistor's 12-bit
-000101f0: 2041 4443 2028 7368 6f75 6c64 2062 6520   ADC (should be 
-00010200: 0d0a 2020 2020 2320 2020 2020 2020 2020  ..    #         
-00010210: 2020 2020 2020 7569 6e74 3132 2c20 6275        uint12, bu
-00010220: 7420 6170 7061 7265 6e74 6c79 2063 616e  t apparently can
-00010230: 2062 6520 5370 6563 7472 6f6d 6574 6572   be Spectrometer
-00010240: 5265 7370 6f6e 7365 3f29 0d0a 2020 2020  Response?)..    
-00010250: 6465 6620 6765 745f 6c61 7365 725f 7465  def get_laser_te
-00010260: 6d70 6572 6174 7572 655f 6465 6743 2873  mperature_degC(s
-00010270: 656c 662c 2072 6177 3a20 696e 7420 3d20  elf, raw: int = 
-00010280: 4e6f 6e65 293a 2023 202d 3e20 5370 6563  None): # -> Spec
-00010290: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
-000102a0: 200d 0a20 2020 2020 2020 2069 6620 6e6f   ..        if no
-000102b0: 7420 6973 696e 7374 616e 6365 2872 6177  t isinstance(raw
-000102c0: 2c20 5370 6563 7472 6f6d 6574 6572 5265  , SpectrometerRe
-000102d0: 7370 6f6e 7365 293a 0d0a 2020 2020 2020  sponse):..      
-000102e0: 2020 2020 2020 7261 7720 3d20 5370 6563        raw = Spec
-000102f0: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
-00010300: 2864 6174 613d 7261 7729 0d0a 2020 2020  (data=raw)..    
-00010310: 2020 2020 6966 2072 6177 2069 7320 4e6f      if raw is No
-00010320: 6e65 3a0d 0a20 2020 2020 2020 2020 2020  ne:..           
-00010330: 2072 6177 203d 2073 656c 662e 6765 745f   raw = self.get_
-00010340: 6c61 7365 725f 7465 6d70 6572 6174 7572  laser_temperatur
-00010350: 655f 7261 7728 290d 0a0d 0a20 2020 2020  e_raw()....     
-00010360: 2020 2069 6620 7261 772e 6461 7461 2069     if raw.data i
-00010370: 7320 4e6f 6e65 3a0d 0a20 2020 2020 2020  s None:..       
-00010380: 2020 2020 206d 7367 3d22 6765 745f 6c61       msg="get_la
-00010390: 7365 725f 7465 6d70 6572 6174 7572 655f  ser_temperature_
-000103a0: 6465 6743 3a20 6572 726f 7220 7265 6164  degC: error read
-000103b0: 696e 6720 7261 7720 6c61 7365 7220 7465  ing raw laser te
-000103c0: 6d70 6572 6174 7572 6522 0d0a 2020 2020  mperature"..    
-000103d0: 2020 2020 2020 2020 6c6f 672e 6572 726f          log.erro
-000103e0: 7228 6d73 6729 0d0a 2020 2020 2020 2020  r(msg)..        
-000103f0: 2020 2020 7265 7475 726e 2053 7065 6374      return Spect
-00010400: 726f 6d65 7465 7252 6573 706f 6e73 6528  rometerResponse(
-00010410: 6572 726f 725f 6c76 6c3d 4572 726f 724c  error_lvl=ErrorL
-00010420: 6576 656c 2e6c 6f77 2c20 6572 726f 725f  evel.low, error_
-00010430: 6d73 673d 6d73 6729 0d0a 0d0a 2020 2020  msg=msg)....    
-00010440: 2020 2020 6966 2072 6177 2e64 6174 6120      if raw.data 
-00010450: 3e20 3078 6666 663a 0d0a 2020 2020 2020  > 0xfff:..      
-00010460: 2020 2020 2020 6d73 6720 3d20 2267 6574        msg = "get
-00010470: 5f6c 6173 6572 5f74 656d 7065 7261 7475  _laser_temperatu
-00010480: 7265 5f64 6567 433a 2072 6177 2076 616c  re_degC: raw val
-00010490: 7565 2030 7825 3034 7820 6578 6365 6564  ue 0x%04x exceed
-000104a0: 7320 3132 2062 6974 7322 2025 2072 6177  s 12 bits" % raw
-000104b0: 2e64 6174 610d 0a20 2020 2020 2020 2020  .data..         
-000104c0: 2020 206c 6f67 2e65 7272 6f72 286d 7367     log.error(msg
-000104d0: 290d 0a20 2020 2020 2020 2020 2020 2072  )..            r
-000104e0: 6574 7572 6e20 5370 6563 7472 6f6d 6574  eturn Spectromet
-000104f0: 6572 5265 7370 6f6e 7365 2864 6174 613d  erResponse(data=
-00010500: 4e6f 6e65 2c20 6572 726f 725f 6c76 6c3d  None, error_lvl=
-00010510: 4572 726f 724c 6576 656c 2e6c 6f77 2c20  ErrorLevel.low, 
-00010520: 6572 726f 725f 6d73 673d 6d73 6729 0d0a  error_msg=msg)..
-00010530: 0d0a 2020 2020 2020 2020 6966 2072 6177  ..        if raw
-00010540: 2e64 6174 6120 3d3d 2030 3a0d 0a20 2020  .data == 0:..   
-00010550: 2020 2020 2020 2020 206d 7367 203d 2022           msg = "
-00010560: 6765 745f 6c61 7365 725f 7465 6d70 6572  get_laser_temper
-00010570: 6174 7572 655f 6465 6743 3a20 6361 6e27  ature_degC: can'
-00010580: 7420 7461 6b65 206c 6f67 206f 6620 7261  t take log of ra
-00010590: 7720 4144 4320 7661 6c75 6520 3022 0d0a  w ADC value 0"..
-000105a0: 2020 2020 2020 2020 2020 2020 6c6f 672e              log.
-000105b0: 6572 726f 7228 6d73 6729 0d0a 2020 2020  error(msg)..    
-000105c0: 2020 2020 2020 2020 7265 7475 726e 2053          return S
-000105d0: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
-000105e0: 6e73 6528 6461 7461 3d4e 6f6e 6529 2023  nse(data=None) #
-000105f0: 206e 6f74 2070 726f 706f 6761 7469 6e67   not propogating
-00010600: 2065 7272 6f72 5f6d 7367 2066 6f72 206e   error_msg for n
-00010610: 6f77 0d0a 0d0a 2020 2020 2020 2020 6465  ow....        de
-00010620: 6743 203d 2030 0d0a 2020 2020 2020 2020  gC = 0..        
-00010630: 7472 793a 0d0a 2020 2020 2020 2020 2020  try:..          
-00010640: 2020 766f 6c74 6167 6520 2020 203d 2032    voltage    = 2
-00010650: 2e35 202a 2072 6177 2e64 6174 6120 2f20  .5 * raw.data / 
-00010660: 3430 3936 0d0a 2020 2020 2020 2020 2020  4096..          
-00010670: 2020 7265 7369 7374 616e 6365 203d 2032    resistance = 2
-00010680: 3134 3530 2e30 202a 2076 6f6c 7461 6765  1450.0 * voltage
-00010690: 202f 2028 322e 3520 2d20 766f 6c74 6167   / (2.5 - voltag
-000106a0: 6529 2023 204c 4220 636f 6e66 6972 6d65  e) # LB confirme
-000106b0: 640d 0a0d 0a20 2020 2020 2020 2020 2020  d....           
-000106c0: 2069 6620 7265 7369 7374 616e 6365 203c   if resistance <
-000106d0: 2030 3a0d 0a20 2020 2020 2020 2020 2020   0:..           
-000106e0: 2020 2020 206d 7367 3d22 6765 745f 6c61       msg="get_la
-000106f0: 7365 725f 7465 6d70 6572 6174 7572 655f  ser_temperature_
-00010700: 6465 6743 3a20 6361 6e27 7420 636f 6d70  degC: can't comp
-00010710: 7574 6520 6465 6743 3a20 7261 7720 3d20  ute degC: raw = 
-00010720: 3078 2530 3478 2c20 766f 6c74 6167 6520  0x%04x, voltage 
-00010730: 3d20 2566 2c20 7265 7369 7374 616e 6365  = %f, resistance
-00010740: 203d 2025 6622 2025 2028 0d0a 2020 2020   = %f" % (..    
-00010750: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010760: 7261 772e 6461 7461 2c20 766f 6c74 6167  raw.data, voltag
-00010770: 652c 2072 6573 6973 7461 6e63 6529 0d0a  e, resistance)..
-00010780: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010790: 6c6f 672e 6572 726f 7228 6d73 6729 0d0a  log.error(msg)..
-000107a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000107b0: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
-000107c0: 7465 7252 6573 706f 6e73 6528 6461 7461  terResponse(data
-000107d0: 3d4e 6f6e 652c 2065 7272 6f72 5f6c 6576  =None, error_lev
-000107e0: 656c 3d45 7272 6f72 4c65 7665 6c2e 6c6f  el=ErrorLevel.lo
-000107f0: 772c 2065 7272 6f72 5f6d 7367 3d6d 7367  w, error_msg=msg
-00010800: 290d 0a0d 0a20 2020 2020 2020 2020 2020  )....           
-00010810: 206c 6f67 5661 6c20 2020 2020 3d20 6d61   logVal     = ma
-00010820: 7468 2e6c 6f67 2872 6573 6973 7461 6e63  th.log(resistanc
-00010830: 6520 2f20 3130 3030 302e 3029 0d0a 2020  e / 10000.0)..  
-00010840: 2020 2020 2020 2020 2020 696e 7369 6465            inside
-00010850: 4d61 696e 203d 206c 6f67 5661 6c20 2b20  Main = logVal + 
-00010860: 3339 3737 2e30 202f 2028 3235 202b 2032  3977.0 / (25 + 2
-00010870: 3733 2e30 290d 0a20 2020 2020 2020 2020  73.0)..         
-00010880: 2020 2064 6567 4320 2020 2020 2020 3d20     degC       = 
-00010890: 3339 3737 2e30 202f 2069 6e73 6964 654d  3977.0 / insideM
-000108a0: 6169 6e20 2d20 3237 332e 300d 0a0d 0a20  ain - 273.0.... 
-000108b0: 2020 2020 2020 2020 2020 206c 6f67 2e64             log.d
-000108c0: 6562 7567 2822 4c61 7365 7220 7465 6d70  ebug("Laser temp
-000108d0: 6572 6174 7572 653a 2025 2e32 6620 6465  erature: %.2f de
-000108e0: 6720 4320 2830 7825 3034 7820 7261 7729  g C (0x%04x raw)
-000108f0: 2220 2520 2864 6567 432c 2072 6177 2e64  " % (degC, raw.d
-00010900: 6174 6129 290d 0a20 2020 2020 2020 2065  ata))..        e
-00010910: 7863 6570 743a 0d0a 2020 2020 2020 2020  xcept:..        
-00010920: 2020 2020 6d73 6720 3d20 2265 7863 6570      msg = "excep
-00010930: 7469 6f6e 2063 6f6d 7075 7469 6e67 206c  tion computing l
-00010940: 6173 6572 2074 656d 7065 7261 7475 7265  aser temperature
-00010950: 220d 0a20 2020 2020 2020 2020 2020 206c  "..            l
-00010960: 6f67 2e65 7272 6f72 286d 7367 2c20 6578  og.error(msg, ex
-00010970: 635f 696e 666f 3d31 290d 0a20 2020 2020  c_info=1)..     
-00010980: 2020 2020 2020 2072 6574 7572 6e20 5370         return Sp
-00010990: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-000109a0: 7365 2864 6174 613d 4e6f 6e65 2c20 6572  se(data=None, er
-000109b0: 726f 725f 6c65 7665 6c3d 4572 726f 724c  ror_level=ErrorL
-000109c0: 6576 656c 2e6c 6f77 2c20 6572 726f 725f  evel.low, error_
-000109d0: 6d73 673d 6d73 6729 0d0a 0d0a 2020 2020  msg=msg)....    
-000109e0: 2020 2020 7265 7475 726e 2053 7065 6374      return Spect
-000109f0: 726f 6d65 7465 7252 6573 706f 6e73 6528  rometerResponse(
-00010a00: 6461 7461 3d64 6567 4329 0d0a 0d0a 2020  data=degC)....  
-00010a10: 2020 2323 2040 6e6f 7465 2062 6967 2d65    ## @note big-e
-00010a20: 6e64 6961 6e2c 2072 6576 6572 7365 206f  ndian, reverse o
-00010a30: 6620 6765 745f 6c61 7365 725f 7465 6d70  f get_laser_temp
-00010a40: 6572 6174 7572 655f 7261 770d 0a20 2020  erature_raw..   
-00010a50: 2064 6566 2067 6574 5f64 6574 6563 746f   def get_detecto
-00010a60: 725f 7465 6d70 6572 6174 7572 655f 7261  r_temperature_ra
-00010a70: 7728 7365 6c66 293a 2023 202d 3e20 5370  w(self): # -> Sp
-00010a80: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-00010a90: 7365 200d 0a20 2020 2020 2020 2072 6574  se ..        ret
-00010aa0: 7572 6e20 7365 6c66 2e5f 6765 745f 636f  urn self._get_co
-00010ab0: 6465 2830 7864 372c 206c 6162 656c 3d22  de(0xd7, label="
-00010ac0: 4745 545f 4343 445f 5445 4d50 222c 206d  GET_CCD_TEMP", m
-00010ad0: 7362 5f6c 656e 3d32 290d 0a0d 0a20 2020  sb_len=2)....   
-00010ae0: 2064 6566 2067 6574 5f64 6574 6563 746f   def get_detecto
-00010af0: 725f 7465 6d70 6572 6174 7572 655f 6465  r_temperature_de
-00010b00: 6743 2873 656c 662c 2072 6177 3a20 666c  gC(self, raw: fl
-00010b10: 6f61 7420 3d20 4e6f 6e65 293a 2023 202d  oat = None): # -
-00010b20: 3e20 5370 6563 7472 6f6d 6574 6572 5265  > SpectrometerRe
-00010b30: 7370 6f6e 7365 200d 0a20 2020 2020 2020  sponse ..       
-00010b40: 2069 6620 7261 7720 6973 204e 6f6e 653a   if raw is None:
-00010b50: 0d0a 2020 2020 2020 2020 2020 2020 7261  ..            ra
-00010b60: 7720 3d20 7365 6c66 2e67 6574 5f64 6574  w = self.get_det
-00010b70: 6563 746f 725f 7465 6d70 6572 6174 7572  ector_temperatur
-00010b80: 655f 7261 7728 292e 6461 7461 0d0a 0d0a  e_raw().data....
-00010b90: 2020 2020 2020 2020 6966 2072 6177 2069          if raw i
-00010ba0: 7320 4e6f 6e65 3a0d 0a20 2020 2020 2020  s None:..       
-00010bb0: 2020 2020 2072 6574 7572 6e20 7261 770d       return raw.
-00010bc0: 0a0d 0a20 2020 2020 2020 2064 6567 4320  ...        degC 
-00010bd0: 3d20 7365 6c66 2e73 6574 7469 6e67 732e  = self.settings.
-00010be0: 6565 7072 6f6d 2e61 6463 5f74 6f5f 6465  eeprom.adc_to_de
-00010bf0: 6743 5f63 6f65 6666 735b 305d 2020 2020  gC_coeffs[0]    
-00010c00: 2020 2020 2020 2020 205c 0d0a 2020 2020           \..    
-00010c10: 2020 2020 2020 2020 202b 2073 656c 662e           + self.
-00010c20: 7365 7474 696e 6773 2e65 6570 726f 6d2e  settings.eeprom.
-00010c30: 6164 635f 746f 5f64 6567 435f 636f 6566  adc_to_degC_coef
-00010c40: 6673 5b31 5d20 2a20 7261 7720 2020 2020  fs[1] * raw     
-00010c50: 2020 5c0d 0a20 2020 2020 2020 2020 2020    \..           
-00010c60: 2020 2b20 7365 6c66 2e73 6574 7469 6e67    + self.setting
-00010c70: 732e 6565 7072 6f6d 2e61 6463 5f74 6f5f  s.eeprom.adc_to_
-00010c80: 6465 6743 5f63 6f65 6666 735b 325d 202a  degC_coeffs[2] *
-00010c90: 2072 6177 202a 2072 6177 0d0a 2020 2020   raw * raw..    
-00010ca0: 2020 2020 6c6f 672e 6465 6275 6728 2244      log.debug("D
-00010cb0: 6574 6563 746f 7220 7465 6d70 6572 6174  etector temperat
-00010cc0: 7572 653a 2025 2e32 6620 6465 6720 4320  ure: %.2f deg C 
-00010cd0: 2830 7825 3034 7820 7261 7729 2220 2520  (0x%04x raw)" % 
-00010ce0: 2864 6567 432c 2072 6177 2929 0d0a 2020  (degC, raw))..  
-00010cf0: 2020 2020 2020 7265 7475 726e 2053 7065        return Spe
-00010d00: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
-00010d10: 6528 6461 7461 3d64 6567 4329 0d0a 0d0a  e(data=degC)....
-00010d20: 2020 2020 6465 6620 7365 745f 6465 7465      def set_dete
-00010d30: 6374 6f72 5f74 6563 5f73 6574 706f 696e  ctor_tec_setpoin
-00010d40: 745f 6465 6743 2873 656c 662c 2064 6567  t_degC(self, deg
-00010d50: 433a 2066 6c6f 6174 293a 2023 202d 3e20  C: float): # -> 
-00010d60: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
-00010d70: 6f6e 7365 200d 0a20 2020 2020 2020 2022  onse ..        "
-00010d80: 2222 0d0a 2020 2020 2020 2020 4174 7465  ""..        Atte
-00010d90: 6d70 7420 746f 2073 6574 2074 6865 2043  mpt to set the C
-00010da0: 4344 2063 6f6f 6c65 7220 7365 7470 6f69  CD cooler setpoi
-00010db0: 6e74 2e20 5665 7269 6679 2074 6861 7420  nt. Verify that 
-00010dc0: 6974 2069 7320 7769 7468 696e 2061 6e0d  it is within an.
-00010dd0: 0a20 2020 2020 2020 2061 6363 6570 7461  .        accepta
-00010de0: 626c 6520 7261 6e67 652e 2049 6465 616c  ble range. Ideal
-00010df0: 6c79 2074 6869 7320 6973 2074 6f20 7072  ly this is to pr
-00010e00: 6576 656e 7420 636f 6e64 656e 7361 7469  event condensati
-00010e10: 6f6e 2061 6e64 206f 7468 6572 0d0a 2020  on and other..  
-00010e20: 2020 2020 2020 6973 7375 6573 2e20 5468        issues. Th
-00010e30: 6973 2076 616c 7565 2069 7320 6120 6465  is value is a de
-00010e40: 6661 756c 7420 616e 6420 6973 2068 7567  fault and is hug
-00010e50: 656c 7920 6465 7065 6e64 656e 7420 6f6e  ely dependent on
-00010e60: 2074 6865 0d0a 2020 2020 2020 2020 656e   the..        en
-00010e70: 7669 726f 6e6d 656e 7461 6c20 636f 6e64  vironmental cond
-00010e80: 6974 696f 6e73 2e0d 0a20 2020 2020 2020  itions...       
-00010e90: 2022 2222 0d0a 2020 2020 2020 2020 6966   """..        if
-00010ea0: 206e 6f74 2073 656c 662e 7365 7474 696e   not self.settin
-00010eb0: 6773 2e65 6570 726f 6d2e 6861 735f 636f  gs.eeprom.has_co
-00010ec0: 6f6c 696e 673a 0d0a 2020 2020 2020 2020  oling:..        
-00010ed0: 2020 2020 6c6f 672e 6572 726f 7228 2275      log.error("u
-00010ee0: 6e61 626c 6520 746f 2063 6f6e 7472 6f6c  nable to control
-00010ef0: 2054 4543 3a20 4545 5052 4f4d 2072 6570   TEC: EEPROM rep
-00010f00: 6f72 7473 206e 6f20 636f 6f6c 696e 6722  orts no cooling"
-00010f10: 290d 0a20 2020 2020 2020 2020 2020 2072  )..            r
-00010f20: 6574 7572 6e20 5370 6563 7472 6f6d 6574  eturn Spectromet
-00010f30: 6572 5265 7370 6f6e 7365 2864 6174 613d  erResponse(data=
-00010f40: 4661 6c73 652c 2065 7272 6f72 5f6c 766c  False, error_lvl
-00010f50: 3d45 7272 6f72 4c65 7665 6c2e 6c6f 772c  =ErrorLevel.low,
-00010f60: 2065 7272 6f72 5f6d 7367 3d22 756e 6162   error_msg="unab
-00010f70: 6c65 2074 6f20 636f 6e74 726f 6c20 5445  le to control TE
-00010f80: 433a 2045 4550 524f 4d20 7265 706f 7274  C: EEPROM report
-00010f90: 7320 6e6f 2063 6f6f 6c69 6e67 2229 0d0a  s no cooling")..
-00010fa0: 0d0a 2020 2020 2020 2020 6966 2064 6567  ..        if deg
-00010fb0: 4320 3c20 7365 6c66 2e73 6574 7469 6e67  C < self.setting
-00010fc0: 732e 6565 7072 6f6d 2e6d 696e 5f74 656d  s.eeprom.min_tem
-00010fd0: 705f 6465 6743 3a0d 0a20 2020 2020 2020  p_degC:..       
-00010fe0: 2020 2020 206c 6f67 2e63 7269 7469 6361       log.critica
-00010ff0: 6c28 2273 6574 5f64 6574 6563 746f 725f  l("set_detector_
-00011000: 7465 635f 7365 7470 6f69 6e74 5f64 6567  tec_setpoint_deg
-00011010: 433a 2073 6574 706f 696e 7420 2566 2062  C: setpoint %f b
-00011020: 656c 6f77 206d 696e 2025 6622 2c20 6465  elow min %f", de
-00011030: 6743 2c20 7365 6c66 2e73 6574 7469 6e67  gC, self.setting
-00011040: 732e 6565 7072 6f6d 2e6d 696e 5f74 656d  s.eeprom.min_tem
-00011050: 705f 6465 6743 290d 0a20 2020 2020 2020  p_degC)..       
-00011060: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
-00011070: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
-00011080: 2864 6174 613d 4661 6c73 652c 2065 7272  (data=False, err
-00011090: 6f72 5f6c 766c 3d45 7272 6f72 4c65 7665  or_lvl=ErrorLeve
-000110a0: 6c2e 6c6f 772c 2065 7272 6f72 5f6d 7367  l.low, error_msg
-000110b0: 3d22 7365 7470 6f69 6e74 2062 656c 6f77  ="setpoint below
-000110c0: 206d 696e 696d 756d 2229 0d0a 0d0a 2020   minimum")....  
-000110d0: 2020 2020 2020 6966 2064 6567 4320 3e20        if degC > 
-000110e0: 7365 6c66 2e73 6574 7469 6e67 732e 6565  self.settings.ee
-000110f0: 7072 6f6d 2e6d 6178 5f74 656d 705f 6465  prom.max_temp_de
-00011100: 6743 3a0d 0a20 2020 2020 2020 2020 2020  gC:..           
-00011110: 206c 6f67 2e63 7269 7469 6361 6c28 2273   log.critical("s
-00011120: 6574 5f64 6574 6563 746f 725f 7465 635f  et_detector_tec_
-00011130: 7365 7470 6f69 6e74 5f64 6567 433a 2073  setpoint_degC: s
-00011140: 6574 706f 696e 7420 2566 2065 7863 6565  etpoint %f excee
-00011150: 6473 206d 6178 2025 6622 2c20 6465 6743  ds max %f", degC
-00011160: 2c20 7365 6c66 2e73 6574 7469 6e67 732e  , self.settings.
-00011170: 6565 7072 6f6d 2e6d 6178 5f74 656d 705f  eeprom.max_temp_
-00011180: 6465 6743 290d 0a20 2020 2020 2020 2020  degC)..         
-00011190: 2020 2072 6574 7572 6e20 5370 6563 7472     return Spectr
-000111a0: 6f6d 6574 6572 5265 7370 6f6e 7365 2864  ometerResponse(d
-000111b0: 6174 613d 4661 6c73 652c 2065 7272 6f72  ata=False, error
-000111c0: 5f6c 766c 3d45 7272 6f72 4c65 7665 6c2e  _lvl=ErrorLevel.
-000111d0: 6c6f 772c 2065 7272 6f72 5f6d 7367 3d22  low, error_msg="
-000111e0: 7365 7470 6f69 6e74 2062 6579 6f6e 6420  setpoint beyond 
-000111f0: 6d61 7822 290d 0a0d 0a20 2020 2020 2020  max")....       
-00011200: 2072 6177 203d 2069 6e74 2872 6f75 6e64   raw = int(round
-00011210: 2873 656c 662e 7365 7474 696e 6773 2e65  (self.settings.e
-00011220: 6570 726f 6d2e 6465 6743 5f74 6f5f 6461  eprom.degC_to_da
-00011230: 635f 636f 6566 6673 5b30 5d0d 0a20 2020  c_coeffs[0]..   
-00011240: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011250: 2020 202b 2073 656c 662e 7365 7474 696e     + self.settin
-00011260: 6773 2e65 6570 726f 6d2e 6465 6743 5f74  gs.eeprom.degC_t
-00011270: 6f5f 6461 635f 636f 6566 6673 5b31 5d20  o_dac_coeffs[1] 
-00011280: 2a20 6465 6743 0d0a 2020 2020 2020 2020  * degC..        
-00011290: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
-000112a0: 7365 6c66 2e73 6574 7469 6e67 732e 6565  self.settings.ee
-000112b0: 7072 6f6d 2e64 6567 435f 746f 5f64 6163  prom.degC_to_dac
-000112c0: 5f63 6f65 6666 735b 325d 202a 2064 6567  _coeffs[2] * deg
-000112d0: 4320 2a20 6465 6743 2929 0d0a 0d0a 2020  C * degC))....  
-000112e0: 2020 2020 2020 2320 524f 554e 4420 2864        # ROUND (d
-000112f0: 6f6e 2774 206d 6173 6b29 2074 6f20 3132  on't mask) to 12
-00011300: 2d62 6974 2044 4143 0d0a 2020 2020 2020  -bit DAC..      
-00011310: 2020 7261 7720 3d20 6d61 7828 302c 206d    raw = max(0, m
-00011320: 696e 2872 6177 2c20 3078 6666 6629 290d  in(raw, 0xfff)).
-00011330: 0a0d 0a20 2020 2020 2020 206c 6f67 2e64  ...        log.d
-00011340: 6562 7567 2822 5365 7420 4343 4420 5445  ebug("Set CCD TE
-00011350: 4320 5365 7470 6f69 6e74 3a20 252e 3266  C Setpoint: %.2f
-00011360: 2064 6567 2043 2028 7261 7720 4144 4320   deg C (raw ADC 
-00011370: 3078 2530 3478 2922 2c20 6465 6743 2c20  0x%04x)", degC, 
-00011380: 7261 7729 0d0a 2020 2020 2020 2020 6f6b  raw)..        ok
-00011390: 203d 2073 656c 662e 5f73 656e 645f 636f   = self._send_co
-000113a0: 6465 2830 7864 382c 2072 6177 2c20 6c61  de(0xd8, raw, la
-000113b0: 6265 6c3d 2253 4554 5f44 4554 4543 544f  bel="SET_DETECTO
-000113c0: 525f 5445 435f 5345 5450 4f49 4e54 2229  R_TEC_SETPOINT")
-000113d0: 0d0a 2020 2020 2020 2020 7365 6c66 2e73  ..        self.s
-000113e0: 6574 7469 6e67 732e 7374 6174 652e 7465  ettings.state.te
-000113f0: 635f 7365 7470 6f69 6e74 5f64 6567 4320  c_setpoint_degC 
-00011400: 3d20 6465 6743 0d0a 2020 2020 2020 2020  = degC..        
-00011410: 7365 6c66 2e64 6574 6563 746f 725f 7465  self.detector_te
-00011420: 635f 7365 7470 6f69 6e74 5f68 6173 5f62  c_setpoint_has_b
-00011430: 6565 6e5f 7365 7420 3d20 5472 7565 0d0a  een_set = True..
-00011440: 2020 2020 2020 2020 7265 7475 726e 206f          return o
-00011450: 6b0d 0a0d 0a20 2020 2064 6566 2067 6574  k....    def get
-00011460: 5f64 6574 6563 746f 725f 7465 635f 7365  _detector_tec_se
-00011470: 7470 6f69 6e74 5f64 6567 4328 7365 6c66  tpoint_degC(self
-00011480: 293a 2023 202d 3e20 5370 6563 7472 6f6d  ): # -> Spectrom
-00011490: 6574 6572 5265 7370 6f6e 7365 200d 0a20  eterResponse .. 
-000114a0: 2020 2020 2020 2069 6620 7365 6c66 2e64         if self.d
-000114b0: 6574 6563 746f 725f 7465 635f 7365 7470  etector_tec_setp
-000114c0: 6f69 6e74 5f68 6173 5f62 6565 6e5f 7365  oint_has_been_se
-000114d0: 743a 0d0a 2020 2020 2020 2020 2020 2020  t:..            
-000114e0: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
-000114f0: 7465 7252 6573 706f 6e73 6528 7365 6c66  terResponse(self
-00011500: 2e73 6574 7469 6e67 732e 7374 6174 652e  .settings.state.
-00011510: 7465 635f 7365 7470 6f69 6e74 5f64 6567  tec_setpoint_deg
-00011520: 4329 0d0a 2020 2020 2020 2020 6c6f 672e  C)..        log.
-00011530: 6572 726f 7228 2244 6574 6563 746f 7220  error("Detector 
-00011540: 5445 4320 7365 7470 6f69 6e74 2068 6173  TEC setpoint has
-00011550: 206e 6f74 2079 6574 2062 6565 6e20 6170   not yet been ap
-00011560: 706c 6965 6422 290d 0a20 2020 2020 2020  plied")..       
-00011570: 2072 6574 7572 6e20 5370 6563 7472 6f6d   return Spectrom
-00011580: 6574 6572 5265 7370 6f6e 7365 2864 6174  eterResponse(dat
-00011590: 613d 302e 3029 0d0a 0d0a 2020 2020 6465  a=0.0)....    de
-000115a0: 6620 6765 745f 6465 7465 6374 6f72 5f74  f get_detector_t
-000115b0: 6563 5f73 6574 706f 696e 745f 7261 7728  ec_setpoint_raw(
-000115c0: 7365 6c66 293a 2023 202d 3e20 5370 6563  self): # -> Spec
-000115d0: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
-000115e0: 200d 0a20 2020 2020 2020 2072 6574 7572   ..        retur
-000115f0: 6e20 7365 6c66 2e67 6574 5f64 6163 2830  n self.get_dac(0
-00011600: 290d 0a0d 0a20 2020 2064 6566 2067 6574  )....    def get
-00011610: 5f64 6163 2873 656c 662c 2064 6163 496e  _dac(self, dacIn
-00011620: 6465 783a 2069 6e74 203d 2030 293a 2023  dex: int = 0): #
-00011630: 202d 3e20 5370 6563 7472 6f6d 6574 6572   -> Spectrometer
-00011640: 5265 7370 6f6e 7365 200d 0a20 2020 2020  Response ..     
-00011650: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
-00011660: 6765 745f 636f 6465 2830 7864 392c 2077  get_code(0xd9, w
-00011670: 496e 6465 783d 6461 6349 6e64 6578 2c20  Index=dacIndex, 
-00011680: 6c61 6265 6c3d 2247 4554 5f44 4143 222c  label="GET_DAC",
-00011690: 206c 7362 5f6c 656e 3d32 290d 0a0d 0a20   lsb_len=2).... 
-000116a0: 2020 2023 2320 4074 6f64 6f20 7265 6e61     ## @todo rena
-000116b0: 6d65 2073 6574 5f64 6574 6563 746f 725f  me set_detector_
-000116c0: 7465 635f 656e 6162 6c65 0d0a 2020 2020  tec_enable..    
-000116d0: 6465 6620 7365 745f 7465 635f 656e 6162  def set_tec_enab
-000116e0: 6c65 2873 656c 662c 2066 6c61 673a 2062  le(self, flag: b
-000116f0: 6f6f 6c29 3a20 2320 2d3e 2053 7065 6374  ool): # -> Spect
-00011700: 726f 6d65 7465 7252 6573 706f 6e73 6520  rometerResponse 
-00011710: 0d0a 2020 2020 2020 2020 6966 206e 6f74  ..        if not
-00011720: 2073 656c 662e 7365 7474 696e 6773 2e65   self.settings.e
-00011730: 6570 726f 6d2e 6861 735f 636f 6f6c 696e  eprom.has_coolin
-00011740: 673a 0d0a 2020 2020 2020 2020 2020 2020  g:..            
-00011750: 6c6f 672e 6465 6275 6728 2275 6e61 626c  log.debug("unabl
-00011760: 6520 746f 2063 6f6e 7472 6f6c 2054 4543  e to control TEC
-00011770: 3a20 4545 5052 4f4d 2072 6570 6f72 7473  : EEPROM reports
-00011780: 206e 6f20 636f 6f6c 696e 6722 290d 0a20   no cooling").. 
-00011790: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-000117a0: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
-000117b0: 7370 6f6e 7365 2864 6174 613d 4661 6c73  sponse(data=Fals
-000117c0: 652c 2065 7272 6f72 5f6d 7367 3d22 756e  e, error_msg="un
-000117d0: 6162 6c65 2074 6f20 636f 6e74 726f 6c20  able to control 
-000117e0: 5445 433a 2045 4550 524f 4d20 7265 706f  TEC: EEPROM repo
-000117f0: 7274 7320 6e6f 2063 6f6f 6c69 6e67 2229  rts no cooling")
-00011800: 0d0a 0d0a 2020 2020 2020 2020 6966 206e  ....        if n
-00011810: 6f74 2073 656c 662e 7365 7474 696e 6773  ot self.settings
-00011820: 2e65 6570 726f 6d2e 6861 735f 6465 7465  .eeprom.has_dete
-00011830: 6374 6f72 5f74 6563 5f63 616c 6962 7261  ctor_tec_calibra
-00011840: 7469 6f6e 2829 3a0d 0a20 2020 2020 2020  tion():..       
-00011850: 2020 2020 206c 6f67 2e64 6562 7567 2822       log.debug("
-00011860: 756e 6162 6c65 2074 6f20 636f 6e74 726f  unable to contro
-00011870: 6c20 5445 433a 2045 4550 524f 4d20 6d69  l TEC: EEPROM mi
-00011880: 7373 696e 6720 7661 6c69 6420 5445 4320  ssing valid TEC 
-00011890: 6361 6c69 6272 6174 696f 6e22 290d 0a20  calibration").. 
-000118a0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-000118b0: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
-000118c0: 7370 6f6e 7365 2864 6174 613d 4661 6c73  sponse(data=Fals
-000118d0: 652c 2065 7272 6f72 5f6d 7367 3d22 756e  e, error_msg="un
-000118e0: 6162 6c65 2074 6f20 636f 6e74 726f 6c20  able to control 
-000118f0: 5445 433a 2045 4550 524f 4d20 6d69 7373  TEC: EEPROM miss
-00011900: 696e 6720 7661 6c69 6420 5445 4320 6361  ing valid TEC ca
-00011910: 6c69 6272 6174 696f 6e22 290d 0a0d 0a20  libration").... 
-00011920: 2020 2020 2020 2076 616c 7565 203d 2031         value = 1
-00011930: 2069 6620 666c 6167 2065 6c73 6520 300d   if flag else 0.
-00011940: 0a0d 0a20 2020 2020 2020 2069 6620 6e6f  ...        if no
-00011950: 7420 7365 6c66 2e64 6574 6563 746f 725f  t self.detector_
-00011960: 7465 635f 7365 7470 6f69 6e74 5f68 6173  tec_setpoint_has
-00011970: 5f62 6565 6e5f 7365 743a 0d0a 0d0a 2020  _been_set:....  
-00011980: 2020 2020 2020 2020 2020 2320 4074 6f64            # @tod
-00011990: 6f20 7368 6f75 6c64 2074 6869 7320 6e6f  o should this no
-000119a0: 7420 6265 2065 6570 726f 6d2e 7374 6172  t be eeprom.star
-000119b0: 7475 705f 7465 6d70 5f64 6567 430d 0a20  tup_temp_degC.. 
-000119c0: 2020 2020 2020 2020 2020 206c 6f67 2e64             log.d
-000119d0: 6562 7567 2822 6465 6661 756c 7469 6e67  ebug("defaulting
-000119e0: 2054 4543 2073 6574 706f 696e 7420 746f   TEC setpoint to
-000119f0: 206d 696e 2025 7322 2c20 7365 6c66 2e73   min %s", self.s
-00011a00: 6574 7469 6e67 732e 6565 7072 6f6d 2e6d  ettings.eeprom.m
-00011a10: 696e 5f74 656d 705f 6465 6743 290d 0a20  in_temp_degC).. 
-00011a20: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00011a30: 7365 745f 6465 7465 6374 6f72 5f74 6563  set_detector_tec
-00011a40: 5f73 6574 706f 696e 745f 6465 6743 2873  _setpoint_degC(s
-00011a50: 656c 662e 7365 7474 696e 6773 2e65 6570  elf.settings.eep
-00011a60: 726f 6d2e 6d69 6e5f 7465 6d70 5f64 6567  rom.min_temp_deg
-00011a70: 4329 0d0a 0d0a 2020 2020 2020 2020 6c6f  C)....        lo
-00011a80: 672e 6465 6275 6728 2253 656e 6420 6465  g.debug("Send de
-00011a90: 7465 6374 6f72 2054 4543 2065 6e61 626c  tector TEC enabl
-00011aa0: 653a 2025 7322 2c20 7661 6c75 6529 0d0a  e: %s", value)..
-00011ab0: 2020 2020 2020 2020 6f6b 203d 2073 656c          ok = sel
-00011ac0: 662e 5f73 656e 645f 636f 6465 2830 7864  f._send_code(0xd
-00011ad0: 362c 2076 616c 7565 2c20 6c61 6265 6c3d  6, value, label=
-00011ae0: 2253 4554 5f44 4554 4543 544f 525f 5445  "SET_DETECTOR_TE
-00011af0: 435f 454e 4142 4c45 2229 0d0a 2020 2020  C_ENABLE")..    
-00011b00: 2020 2020 6966 206f 6b2e 6461 7461 3a0d      if ok.data:.
-00011b10: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00011b20: 662e 7365 7474 696e 6773 2e73 7461 7465  f.settings.state
-00011b30: 2e74 6563 5f65 6e61 626c 6564 203d 2066  .tec_enabled = f
-00011b40: 6c61 670d 0a20 2020 2020 2020 2072 6574  lag..        ret
-00011b50: 7572 6e20 6f6b 0d0a 0d0a 2020 2020 6465  urn ok....    de
-00011b60: 6620 7365 745f 7472 6967 6765 725f 736f  f set_trigger_so
-00011b70: 7572 6365 2873 656c 662c 2076 616c 7565  urce(self, value
-00011b80: 3a20 626f 6f6c 293a 2023 202d 3e20 5370  : bool): # -> Sp
-00011b90: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-00011ba0: 7365 200d 0a20 2020 2020 2020 2022 2222  se ..        """
-00011bb0: 0d0a 2020 2020 2020 2020 5365 7420 7468  ..        Set th
-00011bc0: 6520 736f 7572 6365 2066 6f72 2069 6e63  e source for inc
-00011bd0: 6f6d 696e 6720 6163 7175 6973 6974 696f  oming acquisitio
-00011be0: 6e20 7472 6967 6765 7273 2e0d 0a20 2020  n triggers...   
-00011bf0: 2020 2020 2040 7061 7261 6d20 7661 6c75       @param valu
-00011c00: 6520 6569 7468 6572 2030 2066 6f72 2022  e either 0 for "
-00011c10: 696e 7465 726e 616c 2220 6f72 2031 2066  internal" or 1 f
-00011c20: 6f72 2022 6578 7465 726e 616c 220d 0a20  or "external".. 
-00011c30: 2020 2020 2020 2057 6974 6820 696e 7465         With inte
-00011c40: 726e 616c 2074 7269 6767 6572 696e 6720  rnal triggering 
-00011c50: 2874 6865 2064 6566 6175 6c74 292c 2074  (the default), t
-00011c60: 6865 2073 7065 6374 726f 6d65 7465 7220  he spectrometer 
-00011c70: 6578 7065 6374 7320 7468 650d 0a20 2020  expects the..   
-00011c80: 2020 2020 2055 5342 2068 6f73 7420 746f       USB host to
-00011c90: 2065 7870 6c69 6369 746c 7920 7365 6e64   explicitly send
-00011ca0: 2061 2053 5441 5254 5f41 4351 5549 5349   a START_ACQUISI
-00011cb0: 5449 4f4e 2028 4143 5155 4952 4529 206f  TION (ACQUIRE) o
-00011cc0: 7063 6f64 6520 746f 0d0a 2020 2020 2020  pcode to..      
-00011cd0: 2020 6265 6769 6e20 6561 6368 2069 6e74    begin each int
-00011ce0: 6567 7261 7469 6f6e 2e20 2049 6e20 6578  egration.  In ex
-00011cf0: 7465 726e 616c 2074 7269 6767 6572 696e  ternal triggerin
-00011d00: 672c 2074 6865 2073 7065 6374 726f 6d65  g, the spectrome
-00011d10: 7465 720d 0a20 2020 2020 2020 2077 6169  ter..        wai
-00011d20: 7473 2066 6f72 2074 6865 2072 6973 696e  ts for the risin
-00011d30: 6720 6564 6765 206f 6e20 6120 7369 676e  g edge on a sign
-00011d40: 616c 2063 6f6e 6e65 6374 6564 2074 6f20  al connected to 
-00011d50: 6120 7069 6e20 6f6e 2074 6865 204f 454d  a pin on the OEM
-00011d60: 0d0a 2020 2020 2020 2020 6163 6365 7373  ..        access
-00011d70: 6f72 7920 636f 6e6e 6563 746f 722e 0d0a  ory connector...
-00011d80: 2020 2020 2020 2020 5465 6368 6e69 6361          Technica
-00011d90: 6c6c 7920 6f6e 2041 524d 2c20 7468 6520  lly on ARM, the 
-00011da0: 6d69 6372 6f63 6f6e 7472 6f6c 6c65 7220  microcontroller 
-00011db0: 6973 2063 6f6e 7469 6e75 6f75 736c 7920  is continuously 
-00011dc0: 6d6f 6e69 746f 7269 6e67 0d0a 2020 2020  monitoring..    
-00011dd0: 2020 2020 626f 7468 2074 6865 2065 7874      both the ext
-00011de0: 6572 6e61 6c20 7069 6e20 616e 6420 6c69  ernal pin and li
-00011df0: 7374 656e 696e 6720 666f 7220 696e 7465  stening for inte
-00011e00: 726e 616c 2073 6f66 7477 6172 6520 6f70  rnal software op
-00011e10: 636f 6465 732e 0d0a 2020 2020 2020 2020  codes...        
-00011e20: 4f6e 2074 6865 2046 5832 2079 6f75 206e  On the FX2 you n
-00011e30: 6565 6420 746f 2065 7870 6c69 6369 746c  eed to explicitl
-00011e40: 7920 706c 6163 6520 7468 6520 6d69 6372  y place the micr
-00011e50: 6f63 6f6e 7472 6f6c 6c65 7220 696e 746f  ocontroller into
-00011e60: 0d0a 2020 2020 2020 2020 6578 7465 726e  ..        extern
-00011e70: 616c 2074 7269 6767 6572 696e 6720 6d6f  al triggering mo
-00011e80: 6465 2074 6f20 6176 6169 6c20 7468 6520  de to avail the 
-00011e90: 6665 6174 7572 652e 0d0a 2020 2020 2020  feature...      
-00011ea0: 2020 2222 220d 0a20 2020 2020 2020 2073    """..        s
-00011eb0: 656c 662e 7365 7474 696e 6773 2e73 7461  elf.settings.sta
-00011ec0: 7465 2e74 7269 6767 6572 5f73 6f75 7263  te.trigger_sourc
-00011ed0: 6520 3d20 7661 6c75 650d 0a20 2020 2020  e = value..     
-00011ee0: 2020 206c 6f67 2e64 6562 7567 2822 7472     log.debug("tr
-00011ef0: 6967 6765 725f 736f 7572 6365 206e 6f77  igger_source now
-00011f00: 2025 7322 2c20 7661 6c75 6529 0d0a 0d0a   %s", value)....
-00011f10: 2020 2020 2020 2020 2320 446f 6e27 7420          # Don't 
-00011f20: 7365 6e64 2074 6865 206f 7063 6f64 6520  send the opcode 
-00011f30: 6f6e 2041 524d 2e20 5365 6520 6973 7375  on ARM. See issu
-00011f40: 6520 2332 206f 6e20 5761 7361 7463 6855  e #2 on WasatchU
-00011f50: 5342 2070 726f 6a65 6374 0d0a 2020 2020  SB project..    
-00011f60: 2020 2020 6966 2073 656c 662e 7365 7474      if self.sett
-00011f70: 696e 6773 2e69 735f 6172 6d28 293a 0d0a  ings.is_arm():..
-00011f80: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00011f90: 726e 2053 7065 6374 726f 6d65 7465 7252  rn SpectrometerR
-00011fa0: 6573 706f 6e73 6528 6461 7461 3d46 616c  esponse(data=Fal
-00011fb0: 7365 290d 0a0d 0a20 2020 2020 2020 206d  se)....        m
-00011fc0: 7362 203d 2030 0d0a 2020 2020 2020 2020  sb = 0..        
-00011fd0: 6c73 6220 3d20 7661 6c75 650d 0a20 2020  lsb = value..   
-00011fe0: 2020 2020 2062 7566 203d 205b 305d 202a       buf = [0] *
-00011ff0: 2038 0d0a 0d0a 2020 2020 2020 2020 2320   8....        # 
-00012000: 4d5a 3a20 7468 6973 2069 7320 7765 6972  MZ: this is weir
-00012010: 642e 2e2e 7765 2772 6520 7365 6e64 696e  d...we're sendin
-00012020: 6720 7468 6520 6275 6666 6572 206f 6e20  g the buffer on 
-00012030: 616e 2046 5832 2d6f 6e6c 7920 636f 6d6d  an FX2-only comm
-00012040: 616e 640d 0a20 2020 2020 2020 2072 6574  and..        ret
-00012050: 7572 6e20 7365 6c66 2e5f 7365 6e64 5f63  urn self._send_c
-00012060: 6f64 6528 3078 6432 2c20 6c73 622c 206d  ode(0xd2, lsb, m
-00012070: 7362 2c20 6275 662c 206c 6162 656c 3d22  sb, buf, label="
-00012080: 5345 545f 5452 4947 4745 525f 534f 5552  SET_TRIGGER_SOUR
-00012090: 4345 2229 0d0a 0d0a 2020 2020 2323 0d0a  CE")....    ##..
-000120a0: 2020 2020 2320 4346 5f53 454c 4543 5420      # CF_SELECT 
-000120b0: 6973 2063 6f6e 6669 6775 7265 6420 7573  is configured us
-000120c0: 696e 6720 6269 7420 3220 6f66 2074 6865  ing bit 2 of the
-000120d0: 2046 5047 4120 636f 6e66 6967 7572 6174   FPGA configurat
-000120e0: 696f 6e20 7265 6769 7374 6572 0d0a 2020  ion register..  
-000120f0: 2020 2320 3078 3132 2e20 2054 6869 7320    # 0x12.  This 
-00012100: 6269 7420 6361 6e20 6265 2073 6574 2075  bit can be set u
-00012110: 7369 6e67 2076 656e 646f 7220 636f 6d6d  sing vendor comm
-00012120: 616e 6473 2030 7865 6220 746f 2053 4554  ands 0xeb to SET
-00012130: 2061 6e64 2030 7865 630d 0a20 2020 2023   and 0xec..    #
-00012140: 2074 6f20 4745 542e 2020 4e6f 7465 2074   to GET.  Note t
-00012150: 6861 7420 7468 6520 7365 7420 636f 6d6d  hat the set comm
-00012160: 616e 6420 6973 2065 7870 6563 7469 6e67  and is expecting
-00012170: 2061 2035 2d62 7974 6520 756e 7369 676e   a 5-byte unsign
-00012180: 6564 0d0a 2020 2020 2320 7661 6c75 652c  ed..    # value,
-00012190: 2074 6865 2068 6967 6865 7374 2062 7974   the highest byt
-000121a0: 6520 6f66 2077 6869 6368 2077 6520 7061  e of which we pa
-000121b0: 7373 2061 7320 7061 7274 206f 6620 616e  ss as part of an
-000121c0: 2038 2d62 7974 6520 6275 6666 6572 2e0d   8-byte buffer..
-000121d0: 0a20 2020 2023 204e 6f74 2073 7572 6520  .    # Not sure 
-000121e0: 7768 792e 0d0a 2020 2020 6465 6620 7365  why...    def se
-000121f0: 745f 6869 6768 5f67 6169 6e5f 6d6f 6465  t_high_gain_mode
-00012200: 5f65 6e61 626c 6528 7365 6c66 2c20 666c  _enable(self, fl
-00012210: 6167 3a20 626f 6f6c 293a 2023 202d 3e20  ag: bool): # -> 
-00012220: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
-00012230: 6f6e 7365 200d 0a20 2020 2020 2020 206c  onse ..        l
-00012240: 6f67 2e64 6562 7567 2822 5365 7420 6869  og.debug("Set hi
-00012250: 6768 2067 6169 6e20 6d6f 6465 3a20 2573  gh gain mode: %s
-00012260: 222c 2066 6c61 6729 0d0a 2020 2020 2020  ", flag)..      
-00012270: 2020 6966 206e 6f74 2073 656c 662e 7365    if not self.se
-00012280: 7474 696e 6773 2e69 735f 696e 6761 6173  ttings.is_ingaas
-00012290: 2829 3a0d 0a20 2020 2020 2020 2020 2020  ():..           
-000122a0: 206c 6f67 2e64 6562 7567 2822 5345 545f   log.debug("SET_
-000122b0: 4849 4748 5f47 4149 4e5f 4d4f 4445 5f45  HIGH_GAIN_MODE_E
-000122c0: 4e41 424c 4520 6f6e 6c79 2073 7570 706f  NABLE only suppo
-000122d0: 7274 6564 206f 6e20 496e 4761 4173 2229  rted on InGaAs")
-000122e0: 0d0a 2020 2020 2020 2020 2020 2020 7265  ..            re
-000122f0: 7475 726e 2053 7065 6374 726f 6d65 7465  turn Spectromete
-00012300: 7252 6573 706f 6e73 6528 6461 7461 3d46  rResponse(data=F
-00012310: 616c 7365 2c65 7272 6f72 5f6d 7367 3d22  alse,error_msg="
-00012320: 4869 6768 2047 6169 6e20 6e6f 7420 7375  High Gain not su
-00012330: 7070 6f72 7420 6f6e 2074 6869 7320 7370  pport on this sp
-00012340: 6563 7472 6f6d 6574 6572 2229 0d0a 0d0a  ectrometer")....
-00012350: 2020 2020 2020 2020 7661 6c75 6520 3d20          value = 
-00012360: 3120 6966 2066 6c61 6720 656c 7365 2030  1 if flag else 0
-00012370: 0d0a 0d0a 2020 2020 2020 2020 2320 7468  ....        # th
-00012380: 6973 2069 7320 646f 6e65 2061 7574 6f6d  is is done autom
-00012390: 6174 6963 616c 6c79 206f 6e20 4152 4d2c  atically on ARM,
-000123a0: 2062 7574 2066 6f72 2074 6869 7320 6f70   but for this op
-000123b0: 636f 6465 2077 6520 646f 2069 7420 6f6e  code we do it on
-000123c0: 2046 5832 2061 7320 7765 6c6c 0d0a 2020   FX2 as well..  
-000123d0: 2020 2020 2020 6275 6620 3d20 5b30 5d20        buf = [0] 
-000123e0: 2a20 380d 0a0d 0a20 2020 2020 2020 2073  * 8....        s
-000123f0: 656c 662e 7365 7474 696e 6773 2e73 7461  elf.settings.sta
-00012400: 7465 2e68 6967 685f 6761 696e 5f6d 6f64  te.high_gain_mod
-00012410: 655f 656e 6162 6c65 6420 3d20 666c 6167  e_enabled = flag
-00012420: 0d0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-00012430: 2073 656c 662e 5f73 656e 645f 636f 6465   self._send_code
-00012440: 2830 7865 622c 2077 5661 6c75 653d 7661  (0xeb, wValue=va
-00012450: 6c75 652c 2077 496e 6465 783d 302c 2064  lue, wIndex=0, d
-00012460: 6174 615f 6f72 5f77 4c65 6e67 7468 3d62  ata_or_wLength=b
-00012470: 7566 2c20 6c61 6265 6c3d 2253 4554 5f48  uf, label="SET_H
-00012480: 4947 485f 4741 494e 5f4d 4f44 455f 454e  IGH_GAIN_MODE_EN
-00012490: 4142 4c45 2229 0d0a 0d0a 2020 2020 6465  ABLE")....    de
-000124a0: 6620 6765 745f 6869 6768 5f67 6169 6e5f  f get_high_gain_
-000124b0: 6d6f 6465 5f65 6e61 626c 6564 2873 656c  mode_enabled(sel
-000124c0: 6629 3a20 2320 2d3e 2053 7065 6374 726f  f): # -> Spectro
-000124d0: 6d65 7465 7252 6573 706f 6e73 6520 0d0a  meterResponse ..
-000124e0: 2020 2020 2020 2020 6966 206e 6f74 2073          if not s
-000124f0: 656c 662e 7365 7474 696e 6773 2e69 735f  elf.settings.is_
-00012500: 696e 6761 6173 2829 3a0d 0a20 2020 2020  ingaas():..     
-00012510: 2020 2020 2020 206c 6f67 2e64 6562 7567         log.debug
-00012520: 2822 4745 545f 4849 4748 5f47 4149 4e5f  ("GET_HIGH_GAIN_
-00012530: 4d4f 4445 5f45 4e41 424c 4520 6f6e 6c79  MODE_ENABLE only
-00012540: 2073 7570 706f 7274 6564 206f 6e20 496e   supported on In
-00012550: 4761 4173 2229 0d0a 2020 2020 2020 2020  GaAs")..        
-00012560: 2020 2020 7265 7475 726e 2053 7065 6374      return Spect
-00012570: 726f 6d65 7465 7252 6573 706f 6e73 6528  rometerResponse(
-00012580: 7365 6c66 2e73 6574 7469 6e67 732e 6565  self.settings.ee
-00012590: 7072 6f6d 2e68 6967 685f 6761 696e 5f6d  prom.high_gain_m
-000125a0: 6f64 655f 656e 6162 6c65 6429 0d0a 0d0a  ode_enabled)....
-000125b0: 2020 2020 2020 2020 7365 6c66 2e73 6574          self.set
-000125c0: 7469 6e67 732e 7374 6174 652e 6869 6768  tings.state.high
-000125d0: 5f67 6169 6e5f 6d6f 6465 5f65 6e61 626c  _gain_mode_enabl
-000125e0: 6564 203d 2030 2021 3d20 7365 6c66 2e5f  ed = 0 != self._
-000125f0: 6765 745f 636f 6465 2830 7865 632c 206c  get_code(0xec, l
-00012600: 7362 5f6c 656e 3d31 2c20 6c61 6265 6c3d  sb_len=1, label=
-00012610: 2247 4554 5f48 4947 485f 4741 494e 5f4d  "GET_HIGH_GAIN_M
-00012620: 4f44 455f 454e 4142 4c45 4422 290d 0a20  ODE_ENABLED").. 
-00012630: 2020 2020 2020 2072 6574 7572 6e20 5370         return Sp
-00012640: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-00012650: 7365 2873 656c 662e 7365 7474 696e 6773  se(self.settings
-00012660: 2e73 7461 7465 2e68 6967 685f 6761 696e  .state.high_gain
-00012670: 5f6d 6f64 655f 656e 6162 6c65 6429 0d0a  _mode_enabled)..
-00012680: 0d0a 2020 2020 2323 2323 2323 2323 2323  ..    ##########
-00012690: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000126a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000126b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000126c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000126d0: 2323 0d0a 2020 2020 2320 4c61 7365 7220  ##..    # Laser 
-000126e0: 636f 6d6d 616e 6473 0d0a 2020 2020 2323  commands..    ##
-000126f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00012700: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00012710: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00012720: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00012730: 2323 2323 2323 2323 2323 0d0a 0d0a 2020  ##########....  
-00012740: 2020 6465 6620 6765 745f 6f70 745f 6c61    def get_opt_la
-00012750: 7365 725f 636f 6e74 726f 6c28 7365 6c66  ser_control(self
-00012760: 293a 2023 202d 3e20 5370 6563 7472 6f6d  ): # -> Spectrom
-00012770: 6574 6572 5265 7370 6f6e 7365 200d 0a20  eterResponse .. 
-00012780: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00012790: 6c66 2e67 6574 5f75 7070 6572 5f63 6f64  lf.get_upper_cod
-000127a0: 6528 3078 3039 2c20 6c61 6265 6c3d 2247  e(0x09, label="G
-000127b0: 4554 5f4f 5054 5f4c 4153 4552 5f43 4f4e  ET_OPT_LASER_CON
-000127c0: 5452 4f4c 222c 206d 7362 5f6c 656e 3d31  TROL", msb_len=1
-000127d0: 290d 0a0d 0a20 2020 2064 6566 2067 6574  )....    def get
-000127e0: 5f6f 7074 5f68 6173 5f6c 6173 6572 2873  _opt_has_laser(s
-000127f0: 656c 6629 3a20 2320 2d3e 2053 7065 6374  elf): # -> Spect
-00012800: 726f 6d65 7465 7252 6573 706f 6e73 6520  rometerResponse 
-00012810: 0d0a 2020 2020 2020 2020 6176 6169 6c61  ..        availa
-00012820: 626c 6520 3d20 2830 2021 3d20 7365 6c66  ble = (0 != self
-00012830: 2e67 6574 5f75 7070 6572 5f63 6f64 6528  .get_upper_code(
-00012840: 3078 3038 2c20 6c61 6265 6c3d 2247 4554  0x08, label="GET
-00012850: 5f4f 5054 5f48 4153 5f4c 4153 4552 222c  _OPT_HAS_LASER",
-00012860: 206d 7362 5f6c 656e 3d31 292e 6461 7461   msb_len=1).data
-00012870: 290d 0a20 2020 2020 2020 2069 6620 6176  )..        if av
-00012880: 6169 6c61 626c 6520 213d 2073 656c 662e  ailable != self.
-00012890: 7365 7474 696e 6773 2e65 6570 726f 6d2e  settings.eeprom.
-000128a0: 6861 735f 6c61 7365 723a 0d0a 2020 2020  has_laser:..    
-000128b0: 2020 2020 2020 2020 6c6f 672e 6572 726f          log.erro
-000128c0: 7228 224f 5054 5f48 4153 5f4c 4153 4552  r("OPT_HAS_LASER
-000128d0: 206f 7063 6f64 6520 7265 7375 6c74 2025   opcode result %
-000128e0: 7320 213d 2045 4550 524f 4d20 6861 735f  s != EEPROM has_
-000128f0: 6c61 7365 7220 2573 2028 7573 696e 6720  laser %s (using 
-00012900: 6f70 636f 6465 2922 2c0d 0a20 2020 2020  opcode)",..     
-00012910: 2020 2020 2020 2020 2020 2076 616c 7565             value
-00012920: 2c20 7365 6c66 2e73 6574 7469 6e67 732e  , self.settings.
-00012930: 6565 7072 6f6d 2e68 6173 5f6c 6173 6572  eeprom.has_laser
-00012940: 290d 0a20 2020 2020 2020 2072 6574 7572  )..        retur
-00012950: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
-00012960: 7370 6f6e 7365 2864 6174 613d 6176 6169  sponse(data=avai
-00012970: 6c61 626c 6529 0d0a 0d0a 2020 2020 2323  lable)....    ##
-00012980: 2040 6e6f 7465 206c 6974 746c 652d 656e   @note little-en
-00012990: 6469 616e 2c20 7265 7665 7273 6520 6f66  dian, reverse of
-000129a0: 2067 6574 5f64 6574 6563 746f 725f 7465   get_detector_te
-000129b0: 6d70 6572 6174 7572 655f 7261 770d 0a20  mperature_raw.. 
-000129c0: 2020 2064 6566 2067 6574 5f6c 6173 6572     def get_laser
-000129d0: 5f74 656d 7065 7261 7475 7265 5f72 6177  _temperature_raw
-000129e0: 2873 656c 6629 3a20 2320 2d3e 2053 7065  (self): # -> Spe
-000129f0: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
-00012a00: 6520 0d0a 2020 2020 2020 2020 2320 666c  e ..        # fl
-00012a10: 6970 2074 6f20 7072 696d 6172 7920 4144  ip to primary AD
-00012a20: 4320 6966 206e 6565 6465 640d 0a20 2020  C if needed..   
-00012a30: 2020 2020 2069 6620 7365 6c66 2e73 6574       if self.set
-00012a40: 7469 6e67 732e 7374 6174 652e 7365 6c65  tings.state.sele
-00012a50: 6374 6564 5f61 6463 2069 7320 4e6f 6e65  cted_adc is None
-00012a60: 206f 7220 7365 6c66 2e73 6574 7469 6e67   or self.setting
-00012a70: 732e 7374 6174 652e 7365 6c65 6374 6564  s.state.selected
-00012a80: 5f61 6463 2021 3d20 303a 0d0a 2020 2020  _adc != 0:..    
-00012a90: 2020 2020 2020 2020 7365 6c66 2e73 656c          self.sel
-00012aa0: 6563 745f 6164 6328 3029 0d0a 0d0a 2020  ect_adc(0)....  
-00012ab0: 2020 2020 2020 7265 7375 6c74 203d 2073        result = s
-00012ac0: 656c 662e 5f67 6574 5f63 6f64 6528 3078  elf._get_code(0x
-00012ad0: 6435 2c20 774c 656e 6774 683d 322c 206c  d5, wLength=2, l
-00012ae0: 6162 656c 3d22 4745 545f 4144 4322 2c20  abel="GET_ADC", 
-00012af0: 6c73 625f 6c65 6e3d 3229 0d0a 2020 2020  lsb_len=2)..    
-00012b00: 2020 2020 6966 206e 6f74 2072 6573 756c      if not resul
-00012b10: 742e 6461 7461 3a0d 0a20 2020 2020 2020  t.data:..       
-00012b20: 2020 2020 206c 6f67 2e64 6562 7567 2822       log.debug("
-00012b30: 556e 6162 6c65 2074 6f20 7265 6164 206c  Unable to read l
-00012b40: 6173 6572 2074 656d 7065 7261 7475 7265  aser temperature
-00012b50: 2229 0d0a 2020 2020 2020 2020 2020 2020  ")..            
-00012b60: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
-00012b70: 7465 7252 6573 706f 6e73 6528 3029 0d0a  terResponse(0)..
-00012b80: 2020 2020 2020 2020 7265 7375 6c74 2e64          result.d
-00012b90: 6174 6120 3d20 7265 7375 6c74 2e64 6174  ata = result.dat
-00012ba0: 6120 2620 3078 6666 660d 0a20 2020 2020  a & 0xfff..     
-00012bb0: 2020 2072 6574 7572 6e20 7265 7375 6c74     return result
-00012bc0: 0d0a 0d0a 2020 2020 6465 6620 7365 745f  ....    def set_
-00012bd0: 7365 6c65 6374 6564 5f6c 6173 6572 2873  selected_laser(s
-00012be0: 656c 662c 2076 616c 7565 3a20 696e 7429  elf, value: int)
-00012bf0: 3a20 2320 2d3e 2053 7065 6374 726f 6d65  : # -> Spectrome
-00012c00: 7465 7252 6573 706f 6e73 6520 0d0a 2020  terResponse ..  
-00012c10: 2020 2020 2020 2222 220d 0a20 2020 2020        """..     
-00012c20: 2020 204f 6e20 7370 6563 7472 6f6d 6574     On spectromet
-00012c30: 6572 7320 7375 7070 6f72 7469 6e67 2074  ers supporting t
-00012c40: 776f 206c 6173 6572 732c 2073 656c 6563  wo lasers, selec
-00012c50: 7420 7468 6520 7072 696d 6172 7920 2830  t the primary (0
-00012c60: 2920 6f72 0d0a 2020 2020 2020 2020 7365  ) or..        se
-00012c70: 636f 6e64 6172 7920 2831 292e 2020 4c61  condary (1).  La
-00012c80: 7365 7220 456e 6162 6c65 2c20 6c61 7365  ser Enable, lase
-00012c90: 7220 706f 7765 7220 6574 6320 7368 6f75  r power etc shou
-00012ca0: 6c64 2061 6c6c 2074 6865 6e0d 0a20 2020  ld all then..   
-00012cb0: 2020 2020 2061 6666 6563 7420 7468 6520       affect the 
-00012cc0: 6375 7272 656e 746c 792d 7365 6c65 6374  currently-select
-00012cd0: 6564 206c 6173 6572 2e0d 0a20 2020 2020  ed laser...     
-00012ce0: 2020 2040 7761 726e 696e 6720 636f 6e66     @warning conf
-00012cf0: 6c69 6374 7320 7769 7468 2047 4554 5f52  licts with GET_R
-00012d00: 414d 414e 5f4d 4f44 455f 454e 4142 4c45  AMAN_MODE_ENABLE
-00012d10: 0d0a 2020 2020 2020 2020 2222 220d 0a20  ..        """.. 
-00012d20: 2020 2020 2020 206e 203d 2031 2069 6620         n = 1 if 
-00012d30: 7661 6c75 6520 656c 7365 2030 0d0a 0d0a  value else 0....
-00012d40: 2020 2020 2020 2020 6966 206e 6f74 2073          if not s
-00012d50: 656c 662e 7365 7474 696e 6773 2e65 6570  elf.settings.eep
-00012d60: 726f 6d2e 6861 735f 6c61 7365 723a 0d0a  rom.has_laser:..
-00012d70: 2020 2020 2020 2020 2020 2020 6c6f 672e              log.
-00012d80: 6572 726f 7228 2275 6e61 626c 6520 746f  error("unable to
-00012d90: 2063 6f6e 7472 6f6c 206c 6173 6572 3a20   control laser: 
-00012da0: 4545 5052 4f4d 2072 6570 6f72 7473 206e  EEPROM reports n
-00012db0: 6f20 6c61 7365 7220 696e 7374 616c 6c65  o laser installe
-00012dc0: 6422 290d 0a20 2020 2020 2020 2020 2020  d")..           
-00012dd0: 2072 6574 7572 6e20 5370 6563 7472 6f6d   return Spectrom
-00012de0: 6574 6572 5265 7370 6f6e 7365 2864 6174  eterResponse(dat
-00012df0: 613d 4661 6c73 652c 6572 726f 725f 6d73  a=False,error_ms
-00012e00: 673d 224e 6f20 6c61 7365 7220 696e 7374  g="No laser inst
-00012e10: 616c 6c65 7222 290d 0a0d 0a20 2020 2020  aller")....     
-00012e20: 2020 206c 6f67 2e64 6562 7567 2822 7365     log.debug("se
-00012e30: 6c65 6374 696e 6720 6c61 7365 7220 2564  lecting laser %d
-00012e40: 222c 206e 290d 0a20 2020 2020 2020 2073  ", n)..        s
-00012e50: 656c 662e 7365 7474 696e 6773 2e73 7461  elf.settings.sta
-00012e60: 7465 2e73 656c 6563 7465 645f 6c61 7365  te.selected_lase
-00012e70: 7220 3d20 6e0d 0a0d 0a20 2020 2020 2020  r = n....       
-00012e80: 2072 6574 7572 6e20 7365 6c66 2e5f 7365   return self._se
-00012e90: 6e64 5f63 6f64 6528 6252 6571 7565 7374  nd_code(bRequest
-00012ea0: 2020 2020 2020 2020 3d20 3078 6666 2c0d          = 0xff,.
-00012eb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00012ec0: 2020 2020 2020 2020 2020 2020 2020 2077                 w
-00012ed0: 5661 6c75 6520 2020 2020 2020 2020 203d  Value          =
-00012ee0: 2030 7831 352c 0d0a 2020 2020 2020 2020   0x15,..        
-00012ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012f00: 2020 2020 2020 7749 6e64 6578 2020 2020        wIndex    
-00012f10: 2020 2020 2020 3d20 6e2c 0d0a 2020 2020        = n,..    
-00012f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012f30: 2020 2020 2020 2020 2020 6461 7461 5f6f            data_o
-00012f40: 725f 774c 656e 6774 6820 3d20 5b30 5d20  r_wLength = [0] 
-00012f50: 2a20 382c 0d0a 2020 2020 2020 2020 2020  * 8,..          
-00012f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012f70: 2020 2020 6c61 6265 6c20 2020 2020 2020      label       
-00012f80: 2020 2020 3d20 2253 4554 5f53 454c 4543      = "SET_SELEC
-00012f90: 5445 445f 4c41 5345 5222 290d 0a0d 0a20  TED_LASER").... 
-00012fa0: 2020 2064 6566 2067 6574 5f73 656c 6563     def get_selec
-00012fb0: 7465 645f 6c61 7365 7228 7365 6c66 293a  ted_laser(self):
-00012fc0: 2023 202d 3e20 5370 6563 7472 6f6d 6574   # -> Spectromet
-00012fd0: 6572 5265 7370 6f6e 7365 200d 0a20 2020  erResponse ..   
-00012fe0: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
-00012ff0: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
-00013000: 2864 6174 613d 7365 6c66 2e73 6574 7469  (data=self.setti
-00013010: 6e67 732e 7374 6174 652e 7365 6c65 6374  ngs.state.select
-00013020: 6564 5f6c 6173 6572 290d 0a0d 0a20 2020  ed_laser)....   
-00013030: 2064 6566 2067 6574 5f6c 6173 6572 5f65   def get_laser_e
-00013040: 6e61 626c 6564 2873 656c 6629 3a20 2320  nabled(self): # 
-00013050: 2d3e 2053 7065 6374 726f 6d65 7465 7252  -> SpectrometerR
-00013060: 6573 706f 6e73 6520 0d0a 2020 2020 2020  esponse ..      
-00013070: 2020 666c 6167 203d 2030 2021 3d20 7365    flag = 0 != se
-00013080: 6c66 2e5f 6765 745f 636f 6465 2830 7865  lf._get_code(0xe
-00013090: 322c 206c 6162 656c 3d22 4745 545f 4c41  2, label="GET_LA
-000130a0: 5345 525f 454e 4142 4c45 4422 2c20 6d73  SER_ENABLED", ms
-000130b0: 625f 6c65 6e3d 3129 2e64 6174 610d 0a20  b_len=1).data.. 
-000130c0: 2020 2020 2020 206c 6f67 2e64 6562 7567         log.debug
-000130d0: 2822 6765 745f 6c61 7365 725f 656e 6162  ("get_laser_enab
-000130e0: 6c65 643a 2025 7322 2c20 666c 6167 290d  led: %s", flag).
-000130f0: 0a20 2020 2020 2020 2073 656c 662e 7365  .        self.se
-00013100: 7474 696e 6773 2e73 7461 7465 2e6c 6173  ttings.state.las
-00013110: 6572 5f65 6e61 626c 6564 203d 2066 6c61  er_enabled = fla
-00013120: 670d 0a20 2020 2020 2020 2072 6574 7572  g..        retur
-00013130: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
-00013140: 7370 6f6e 7365 2864 6174 613d 666c 6167  sponse(data=flag
-00013150: 290d 0a0d 0a20 2020 2064 6566 2073 6574  )....    def set
-00013160: 5f6c 6173 6572 5f65 6e61 626c 6528 7365  _laser_enable(se
-00013170: 6c66 2c20 666c 6167 3a20 626f 6f6c 293a  lf, flag: bool):
-00013180: 2023 202d 3e20 5370 6563 7472 6f6d 6574   # -> Spectromet
-00013190: 6572 5265 7370 6f6e 7365 200d 0a20 2020  erResponse ..   
-000131a0: 2020 2020 2022 2222 0d0a 2020 2020 2020       """..      
-000131b0: 2020 5475 726e 2074 6865 206c 6173 6572    Turn the laser
-000131c0: 206f 6e20 6f72 206f 6666 2e0d 0a20 2020   on or off...   
-000131d0: 2020 2020 2049 6620 6c61 7365 7220 706f       If laser po
-000131e0: 7765 7220 6861 736e 2774 2079 6574 2062  wer hasn't yet b
-000131f0: 6565 6e20 6578 7465 726e 616c 6c79 2063  een externally c
-00013200: 6f6e 6669 6775 7265 642c 2061 7070 6c69  onfigured, appli
-00013210: 6573 2074 6865 2064 6566 6175 6c74 0d0a  es the default..
-00013220: 2020 2020 2020 2020 6f66 2066 756c 6c2d          of full-
-00013230: 706f 7765 722e 2020 5468 6520 6e65 7720  power.  The new 
-00013240: 7374 6174 6520 7769 6c6c 2062 6520 6170  state will be ap
-00013250: 706c 6965 6420 696d 6d65 6469 6174 656c  plied immediatel
-00013260: 792e 0d0a 2020 2020 2020 2020 4070 6172  y...        @par
-00013270: 616d 2066 6c61 6720 2849 6e70 7574 2920  am flag (Input) 
-00013280: 626f 6f6c 2028 5472 7565 2074 7572 6e73  bool (True turns
-00013290: 206c 6173 6572 206f 6e2c 2046 616c 7365   laser on, False
-000132a0: 2074 7572 6e73 206c 6173 6572 206f 6666   turns laser off
-000132b0: 290d 0a20 2020 2020 2020 2040 7265 7475  )..        @retu
-000132c0: 726e 7320 7768 6574 6865 7220 7468 6520  rns whether the 
-000132d0: 6e65 7720 7374 6174 6520 7761 7320 6170  new state was ap
-000132e0: 706c 6965 640d 0a20 2020 2020 2020 2022  plied..        "
-000132f0: 2222 0d0a 2020 2020 2020 2020 6966 206e  ""..        if n
-00013300: 6f74 2073 656c 662e 7365 7474 696e 6773  ot self.settings
-00013310: 2e65 6570 726f 6d2e 6861 735f 6c61 7365  .eeprom.has_lase
-00013320: 723a 0d0a 2020 2020 2020 2020 2020 2020  r:..            
-00013330: 6c6f 672e 6572 726f 7228 2275 6e61 626c  log.error("unabl
-00013340: 6520 746f 2063 6f6e 7472 6f6c 206c 6173  e to control las
-00013350: 6572 3a20 4545 5052 4f4d 2072 6570 6f72  er: EEPROM repor
-00013360: 7473 206e 6f20 6c61 7365 7220 696e 7374  ts no laser inst
-00013370: 616c 6c65 6422 290d 0a20 2020 2020 2020  alled")..       
-00013380: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
-00013390: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
-000133a0: 2864 6174 613d 4661 6c73 652c 2065 7272  (data=False, err
-000133b0: 6f72 5f6d 7367 3d22 6e6f 206c 6173 6572  or_msg="no laser
-000133c0: 2069 6e73 7461 6c6c 6564 2229 0d0a 0d0a   installed")....
-000133d0: 2020 2020 2020 2020 2320 4152 4d20 7365          # ARM se
-000133e0: 656d 7320 746f 2072 6571 7569 7265 2074  ems to require t
-000133f0: 6861 7420 6c61 7365 7220 706f 7765 7220  hat laser power 
-00013400: 6265 2073 6574 2062 6566 6f72 6520 7468  be set before th
-00013410: 6520 6c61 7365 7220 6973 2065 6e61 626c  e laser is enabl
-00013420: 6564 0d0a 2020 2020 2020 2020 6966 2073  ed..        if s
-00013430: 656c 662e 6e65 7874 5f61 7070 6c69 6564  elf.next_applied
-00013440: 5f6c 6173 6572 5f70 6f77 6572 2069 7320  _laser_power is 
-00013450: 4e6f 6e65 3a0d 0a20 2020 2020 2020 2020  None:..         
-00013460: 2020 2073 656c 662e 7365 745f 6c61 7365     self.set_lase
-00013470: 725f 706f 7765 725f 7065 7263 2831 3030  r_power_perc(100
-00013480: 2e30 290d 0a0d 0a20 2020 2020 2020 2073  .0)....        s
-00013490: 656c 662e 7365 7474 696e 6773 2e73 7461  elf.settings.sta
-000134a0: 7465 2e6c 6173 6572 5f65 6e61 626c 6564  te.laser_enabled
-000134b0: 203d 2066 6c61 670d 0a20 2020 2020 2020   = flag..       
-000134c0: 2073 656c 662e 5f73 6574 5f6c 6173 6572   self._set_laser
-000134d0: 5f65 6e61 626c 655f 696d 6d65 6469 6174  _enable_immediat
-000134e0: 6528 666c 6167 290d 0a20 2020 2020 2020  e(flag)..       
-000134f0: 2072 6574 7572 6e20 5370 6563 7472 6f6d   return Spectrom
-00013500: 6574 6572 5265 7370 6f6e 7365 2864 6174  eterResponse(dat
-00013510: 613d 5472 7565 290d 0a0d 0a20 2020 2064  a=True)....    d
-00013520: 6566 2073 6574 5f6c 6173 6572 5f70 6f77  ef set_laser_pow
-00013530: 6572 5f72 616d 7069 6e67 5f65 6e61 626c  er_ramping_enabl
-00013540: 6528 7365 6c66 2c20 666c 6167 3a20 626f  e(self, flag: bo
-00013550: 6f6c 293a 2023 202d 3e20 5370 6563 7472  ol): # -> Spectr
-00013560: 6f6d 6574 6572 5265 7370 6f6e 7365 200d  ometerResponse .
-00013570: 0a20 2020 2020 2020 206c 6f67 2e65 7272  .        log.err
-00013580: 6f72 2822 6c61 7365 7220 706f 7765 7220  or("laser power 
-00013590: 7261 6d70 696e 6720 6861 7320 6265 656e  ramping has been
-000135a0: 2064 6570 7265 6361 7465 6422 290d 0a20   deprecated").. 
-000135b0: 2020 2020 2020 2072 6574 7572 6e20 5370         return Sp
-000135c0: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-000135d0: 7365 2864 6174 613d 4661 6c73 6529 0d0a  se(data=False)..
-000135e0: 0d0a 2020 2020 6465 6620 6765 745f 6c61  ..    def get_la
-000135f0: 7365 725f 706f 7765 725f 7261 6d70 696e  ser_power_rampin
-00013600: 675f 656e 6162 6c65 6428 7365 6c66 293a  g_enabled(self):
-00013610: 2023 202d 3e20 626f 6f6c 200d 0a20 2020   # -> bool ..   
-00013620: 2020 2020 2072 6574 7572 6e20 4661 6c73       return Fals
-00013630: 650d 0a0d 0a20 2020 2064 6566 205f 7365  e....    def _se
-00013640: 745f 6c61 7365 725f 656e 6162 6c65 5f69  t_laser_enable_i
-00013650: 6d6d 6564 6961 7465 2873 656c 662c 2066  mmediate(self, f
-00013660: 6c61 673a 2062 6f6f 6c29 3a20 2320 2d3e  lag: bool): # ->
-00013670: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
-00013680: 706f 6e73 6520 0d0a 2020 2020 2020 2020  ponse ..        
-00013690: 2222 220d 0a20 2020 2020 2020 2054 6865  """..        The
-000136a0: 2075 7365 7220 6861 7320 7265 7175 6573   user has reques
-000136b0: 7465 6420 746f 2075 7064 6174 6520 7468  ted to update th
-000136c0: 6520 6c61 7365 7220 6669 7269 6e67 2073  e laser firing s
-000136d0: 7461 7465 2028 6f6e 206f 7220 6f66 6629  tate (on or off)
-000136e0: 2c0d 0a20 2020 2020 2020 2073 6f20 6170  ,..        so ap
-000136f0: 706c 7920 7468 6520 6e65 7720 6c61 7365  ply the new lase
-00013700: 7220 7374 6174 6520 746f 2074 6865 2073  r state to the s
-00013710: 7065 6374 726f 6d65 7465 7220 696d 6d65  pectrometer imme
-00013720: 6469 6174 656c 792e 0d0a 0d0a 2020 2020  diately.....    
-00013730: 2020 2020 4265 6361 7573 6520 7468 6520      Because the 
-00013740: 6162 696c 6974 7920 746f 2069 6d6d 6564  ability to immed
-00013750: 6961 7465 6c79 2064 6973 6162 6c65 2061  iately disable a
-00013760: 206c 6173 6572 2069 7320 6120 7361 6665   laser is a safe
-00013770: 7479 2d72 656c 6174 6564 0d0a 2020 2020  ty-related..    
-00013780: 2020 2020 6665 6174 7572 6520 286e 6f74      feature (not
-00013790: 696e 6720 7468 6174 2074 7275 6c79 2073  ing that truly s
-000137a0: 6166 6574 792d 6372 6974 6963 616c 2063  afety-critical c
-000137b0: 6170 6162 696c 6974 6965 7320 7368 6f75  apabilities shou
-000137c0: 6c64 2062 650d 0a20 2020 2020 2020 2069  ld be..        i
-000137d0: 6d70 6c65 6d65 6e74 6564 2069 6e20 6861  mplemented in ha
-000137e0: 7264 7761 7265 2c20 616e 6420 6765 6e65  rdware, and gene
-000137f0: 7261 6c6c 7920 6361 6e27 7420 6265 2072  rally can't be r
-00013800: 6f62 7573 746c 7920 6163 6869 6576 6564  obustly achieved
-00013810: 2074 6872 6f75 6768 0d0a 2020 2020 2020   through..      
-00013820: 2020 5079 7468 6f6e 2073 6372 6970 7473    Python scripts
-00013830: 292c 2074 6869 7320 6675 6e63 7469 6f6e  ), this function
-00013840: 2074 616b 6573 2074 6865 2075 6e75 7375   takes the unusu
-00013850: 616c 2073 7465 7020 6f66 206c 6f6f 7069  al step of loopi
-00013860: 6e67 206f 7665 720d 0a20 2020 2020 2020  ng over..       
-00013870: 206d 756c 7469 706c 6520 6174 7465 6d70   multiple attemp
-00013880: 7473 2074 6f20 7365 7420 7468 6520 6c61  ts to set the la
-00013890: 7365 7220 7374 6174 6520 756e 7469 6c20  ser state until 
-000138a0: 6569 7468 6572 2074 6865 2063 6f6d 6d61  either the comma
-000138b0: 6e64 2073 7563 6365 6564 732c 0d0a 2020  nd succeeds,..  
-000138c0: 2020 2020 2020 6f72 2033 2063 6f6e 7365        or 3 conse
-000138d0: 6375 7469 7665 2066 6169 6c75 7265 7320  cutive failures 
-000138e0: 6861 7665 206f 6363 7572 6564 2e0d 0a0d  have occured....
-000138f0: 0a20 2020 2020 2020 2054 6869 7320 6265  .        This be
-00013900: 6861 7669 6f72 2077 6173 2061 6464 6564  havior was added
-00013910: 2061 6674 6572 2061 2064 6576 656c 6f70   after a develop
-00013920: 6d65 6e74 616c 2c20 756e 7265 6c65 6173  mental, unreleas
-00013930: 6564 2070 726f 746f 7479 7065 2077 6173  ed prototype was
-00013940: 0d0a 2020 2020 2020 2020 666f 756e 6420  ..        found 
-00013950: 746f 206f 6363 6173 696f 6e61 6c6c 7920  to occasionally 
-00013960: 6472 6f70 2055 5342 2070 6163 6b65 7473  drop USB packets
-00013970: 2c20 616e 6420 7761 7320 7468 6572 6566  , and was theref
-00013980: 6f72 6520 7375 7363 6570 7469 626c 6520  ore susceptible 
-00013990: 746f 0d0a 2020 2020 2020 2020 696e 6164  to..        inad
-000139a0: 7665 7274 656e 746c 7920 6661 696c 696e  vertently failin
-000139b0: 6720 746f 2064 6973 6162 6c65 2074 6865  g to disable the
-000139c0: 206c 6173 6572 2075 706f 6e20 636f 6d6d   laser upon comm
-000139d0: 616e 642e 0d0a 0d0a 2020 2020 2020 2020  and.....        
-000139e0: 4070 7269 7661 7465 2028 6173 2063 616c  @private (as cal
-000139f0: 6c65 7273 2061 7265 2072 6563 6f6d 6d65  lers are recomme
-00013a00: 6e64 6564 2074 6f20 7573 6520 7365 745f  nded to use set_
-00013a10: 6c61 7365 725f 656e 6162 6c65 290d 0a20  laser_enable).. 
-00013a20: 2020 2020 2020 2040 7061 7261 6d20 666c         @param fl
-00013a30: 6167 2028 496e 7075 7429 2077 6865 7468  ag (Input) wheth
-00013a40: 6572 2074 6865 206c 6173 6572 2073 686f  er the laser sho
-00013a50: 756c 6420 6265 206f 6e20 2874 7275 6529  uld be on (true)
-00013a60: 206f 7220 6f66 6620 2866 616c 7365 290d   or off (false).
-00013a70: 0a20 2020 2020 2020 2040 7265 7475 726e  .        @return
-00013a80: 7320 7472 7565 2069 6620 6e65 7720 7374  s true if new st
-00013a90: 6174 6520 7761 7320 7375 6363 6573 7366  ate was successf
-00013aa0: 756c 6c79 2061 7070 6c69 6564 0d0a 2020  ully applied..  
-00013ab0: 2020 2020 2020 2222 220d 0a20 2020 2020        """..     
-00013ac0: 2020 206c 6f67 2e64 6562 7567 2822 5365     log.debug("Se
-00013ad0: 6e64 206c 6173 6572 2065 6e61 626c 653a  nd laser enable:
-00013ae0: 2025 7322 2c20 666c 6167 290d 0a20 2020   %s", flag)..   
-00013af0: 2020 2020 2069 6620 666c 6167 3a0d 0a20       if flag:.. 
-00013b00: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00013b10: 6c61 7374 5f61 7070 6c69 6564 5f6c 6173  last_applied_las
-00013b20: 6572 5f70 6f77 6572 203d 2030 2e30 0d0a  er_power = 0.0..
-00013b30: 2020 2020 2020 2020 656c 7365 3a0d 0a20          else:.. 
-00013b40: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00013b50: 6c61 7374 5f61 7070 6c69 6564 5f6c 6173  last_applied_las
-00013b60: 6572 5f70 6f77 6572 203d 2073 656c 662e  er_power = self.
-00013b70: 6e65 7874 5f61 7070 6c69 6564 5f6c 6173  next_applied_las
-00013b80: 6572 5f70 6f77 6572 0d0a 0d0a 2020 2020  er_power....    
-00013b90: 2020 2020 7365 6c66 2e73 6574 5f73 7472      self.set_str
-00013ba0: 6f62 655f 656e 6162 6c65 2866 6c61 6729  obe_enable(flag)
-00013bb0: 0d0a 0d0a 2020 2020 2020 2020 6966 2073  ....        if s
-00013bc0: 656c 662e 7365 7474 696e 6773 2e69 735f  elf.settings.is_
-00013bd0: 7873 2829 3a0d 0a20 2020 2020 2020 2020  xs():..         
-00013be0: 2020 2023 2053 6572 6965 732d 5853 2067     # Series-XS g
-00013bf0: 6574 4c61 7365 7245 6e61 626c 6520 646f  etLaserEnable do
-00013c00: 6573 6e27 7420 7072 6f76 6964 6520 696d  esn't provide im
-00013c10: 6d65 6469 6174 6520 636f 6e66 6972 6d61  mediate confirma
-00013c20: 7469 6f6e 200d 0a20 2020 2020 2020 2020  tion ..         
-00013c30: 2020 2023 2062 6563 6175 7365 2069 7427     # because it'
-00013c40: 7320 636f 6d69 6e67 6c65 6420 7769 7468  s comingled with
-00013c50: 206c 6173 6572 5761 7463 6864 6f67 5365   laserWatchdogSe
-00013c60: 6320 616e 6420 7072 6f62 6162 6c79 200d  c and probably .
-00013c70: 0a20 2020 2020 2020 2020 2020 2023 206c  .            # l
-00013c80: 6173 6572 4465 6c61 7953 6563 0d0a 2020  aserDelaySec..  
-00013c90: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00013ca0: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
-00013cb0: 706f 6e73 6528 6461 7461 3d54 7275 6529  ponse(data=True)
-00013cc0: 0d0a 0d0a 2020 2020 2020 2020 2320 7472  ....        # tr
-00013cd0: 7920 746f 2076 6572 6966 7920 6c61 7365  y to verify lase
-00013ce0: 7245 6e61 626c 6520 776f 726b 6564 0d0a  rEnable worked..
-00013cf0: 2020 2020 2020 2020 7472 6965 7320 3d20          tries = 
-00013d00: 300d 0a20 2020 2020 2020 2077 6869 6c65  0..        while
-00013d10: 2054 7275 653a 0d0a 2020 2020 2020 2020   True:..        
-00013d20: 2020 2020 7265 7320 3d20 7365 6c66 2e67      res = self.g
-00013d30: 6574 5f6c 6173 6572 5f65 6e61 626c 6564  et_laser_enabled
-00013d40: 2829 0d0a 2020 2020 2020 2020 2020 2020  ()..            
-00013d50: 6966 2066 6c61 6720 3d3d 2072 6573 2e64  if flag == res.d
-00013d60: 6174 613a 0d0a 2020 2020 2020 2020 2020  ata:..          
-00013d70: 2020 2020 2020 7265 7475 726e 2053 7065        return Spe
-00013d80: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
-00013d90: 6528 6461 7461 3d54 7275 6529 0d0a 2020  e(data=True)..  
-00013da0: 2020 2020 2020 2020 2020 7472 6965 7320            tries 
-00013db0: 2b3d 2031 0d0a 2020 2020 2020 2020 2020  += 1..          
-00013dc0: 2020 6966 2074 7269 6573 203e 2033 3a0d    if tries > 3:.
-00013dd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00013de0: 206c 6f67 2e63 7269 7469 6361 6c28 226c   log.critical("l
-00013df0: 6173 6572 5f65 6e61 626c 6520 2573 2063  aser_enable %s c
-00013e00: 6f6d 6d61 6e64 2066 6169 6c65 642c 2067  ommand failed, g
-00013e10: 6976 696e 6720 7570 222c 2066 6c61 6729  iving up", flag)
-00013e20: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00013e30: 2020 7365 6c66 2e71 7565 7565 5f6d 6573    self.queue_mes
-00013e40: 7361 6765 2822 6d61 7271 7565 655f 6572  sage("marquee_er
-00013e50: 726f 7222 2c20 226c 6173 6572 2073 6574  ror", "laser set
-00013e60: 7469 6e67 2066 6169 6c65 6422 290d 0a20  ting failed").. 
-00013e70: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00013e80: 6574 7572 6e20 5370 6563 7472 6f6d 6574  eturn Spectromet
-00013e90: 6572 5265 7370 6f6e 7365 2864 6174 613d  erResponse(data=
-00013ea0: 4661 6c73 652c 6572 726f 725f 6d73 673d  False,error_msg=
-00013eb0: 226c 6173 6572 2073 6574 7469 6e67 2066  "laser setting f
-00013ec0: 6169 6c65 6422 2c65 7272 6f72 5f6c 766c  ailed",error_lvl
-00013ed0: 3d45 7272 6f72 4c65 7665 6c2e 6d65 6469  =ErrorLevel.medi
-00013ee0: 756d 290d 0a20 2020 2020 2020 2020 2020  um)..           
-00013ef0: 2065 6c73 653a 0d0a 2020 2020 2020 2020   else:..        
-00013f00: 2020 2020 2020 2020 6c6f 672e 6572 726f          log.erro
-00013f10: 7228 226c 6173 6572 5f65 6e61 626c 6520  r("laser_enable 
-00013f20: 2573 2063 6f6d 6d61 6e64 2066 6169 6c65  %s command faile
-00013f30: 642c 2072 652d 7472 7969 6e67 222c 2066  d, re-trying", f
-00013f40: 6c61 6729 0d0a 2020 2020 2020 2020 2020  lag)..          
-00013f50: 2020 2020 2020 7365 6c66 2e73 6574 5f73        self.set_s
-00013f60: 7472 6f62 655f 656e 6162 6c65 2866 6c61  trobe_enable(fla
-00013f70: 6729 0d0a 0d0a 2020 2020 6465 6620 7365  g)....    def se
-00013f80: 745f 6c61 7365 725f 706f 7765 725f 6d57  t_laser_power_mW
-00013f90: 2873 656c 662c 206d 575f 696e 3a20 696e  (self, mW_in: in
-00013fa0: 7429 3a20 2320 2d3e 2053 7065 6374 726f  t): # -> Spectro
-00013fb0: 6d65 7465 7252 6573 706f 6e73 6520 0d0a  meterResponse ..
-00013fc0: 2020 2020 2020 2020 6966 206d 575f 696e          if mW_in
-00013fd0: 2069 7320 4e6f 6e65 206f 7220 6e6f 7420   is None or not 
-00013fe0: 7365 6c66 2e73 6574 7469 6e67 732e 6565  self.settings.ee
-00013ff0: 7072 6f6d 2e68 6173 5f6c 6173 6572 5f70  prom.has_laser_p
-00014000: 6f77 6572 5f63 616c 6962 7261 7469 6f6e  ower_calibration
-00014010: 2829 3a0d 0a20 2020 2020 2020 2020 2020  ():..           
-00014020: 206c 6f67 2e65 7272 6f72 2822 4545 5052   log.error("EEPR
-00014030: 4f4d 2064 6f65 736e 2774 2068 6176 6520  OM doesn't have 
-00014040: 6c61 7365 7220 706f 7765 7220 6361 6c69  laser power cali
-00014050: 6272 6174 696f 6e22 290d 0a20 2020 2020  bration")..     
-00014060: 2020 2020 2020 2073 656c 662e 7365 7474         self.sett
-00014070: 696e 6773 2e73 7461 7465 2e6c 6173 6572  ings.state.laser
-00014080: 5f70 6f77 6572 5f6d 5720 3d20 300d 0a20  _power_mW = 0.. 
-00014090: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-000140a0: 7365 7474 696e 6773 2e73 7461 7465 2e6c  settings.state.l
-000140b0: 6173 6572 5f70 6f77 6572 5f70 6572 6320  aser_power_perc 
-000140c0: 3d20 300d 0a20 2020 2020 2020 2020 2020  = 0..           
-000140d0: 2073 656c 662e 7365 7474 696e 6773 2e73   self.settings.s
-000140e0: 7461 7465 2e75 7365 5f6d 5720 3d20 4661  tate.use_mW = Fa
-000140f0: 6c73 650d 0a20 2020 2020 2020 2020 2020  lse..           
-00014100: 2072 6574 7572 6e20 5370 6563 7472 6f6d   return Spectrom
-00014110: 6574 6572 5265 7370 6f6e 7365 2864 6174  eterResponse(dat
-00014120: 613d 4661 6c73 652c 6572 726f 725f 6d73  a=False,error_ms
-00014130: 673d 226e 6f20 6c61 7365 7220 706f 7765  g="no laser powe
-00014140: 7220 6361 6c69 6272 6174 696f 6e22 290d  r calibration").
-00014150: 0a0d 0a20 2020 2020 2020 206d 5720 3d20  ...        mW = 
-00014160: 6d69 6e28 7365 6c66 2e73 6574 7469 6e67  min(self.setting
-00014170: 732e 6565 7072 6f6d 2e6d 6178 5f6c 6173  s.eeprom.max_las
-00014180: 6572 5f70 6f77 6572 5f6d 572c 206d 6178  er_power_mW, max
-00014190: 2873 656c 662e 7365 7474 696e 6773 2e65  (self.settings.e
-000141a0: 6570 726f 6d2e 6d69 6e5f 6c61 7365 725f  eprom.min_laser_
-000141b0: 706f 7765 725f 6d57 2c20 6d57 5f69 6e29  power_mW, mW_in)
-000141c0: 290d 0a0d 0a20 2020 2020 2020 2070 6572  )....        per
-000141d0: 6320 3d20 7365 6c66 2e73 6574 7469 6e67  c = self.setting
-000141e0: 732e 6565 7072 6f6d 2e6c 6173 6572 5f70  s.eeprom.laser_p
-000141f0: 6f77 6572 5f6d 575f 746f 5f70 6572 6365  ower_mW_to_perce
-00014200: 6e74 286d 5729 0d0a 2020 2020 2020 2020  nt(mW)..        
-00014210: 6c6f 672e 6465 6275 6728 2273 6574 5f6c  log.debug("set_l
-00014220: 6173 6572 5f70 6f77 6572 5f6d 573a 2072  aser_power_mW: r
-00014230: 616e 6765 2028 252e 3266 2c20 252e 3266  ange (%.2f, %.2f
-00014240: 292c 2072 6571 7565 7374 6564 2025 2e32  ), requested %.2
-00014250: 662c 2061 7070 726f 7665 6420 252e 3266  f, approved %.2f
-00014260: 2c20 7065 7263 656e 7420 3d20 252e 3266  , percent = %.2f
-00014270: 222c 0d0a 2020 2020 2020 2020 2020 2020  ",..            
-00014280: 7365 6c66 2e73 6574 7469 6e67 732e 6565  self.settings.ee
-00014290: 7072 6f6d 2e6d 696e 5f6c 6173 6572 5f70  prom.min_laser_p
-000142a0: 6f77 6572 5f6d 572c 0d0a 2020 2020 2020  ower_mW,..      
-000142b0: 2020 2020 2020 7365 6c66 2e73 6574 7469        self.setti
-000142c0: 6e67 732e 6565 7072 6f6d 2e6d 6178 5f6c  ngs.eeprom.max_l
-000142d0: 6173 6572 5f70 6f77 6572 5f6d 572c 0d0a  aser_power_mW,..
-000142e0: 2020 2020 2020 2020 2020 2020 6d57 5f69              mW_i
-000142f0: 6e2c 0d0a 2020 2020 2020 2020 2020 2020  n,..            
-00014300: 6d57 2c0d 0a20 2020 2020 2020 2020 2020  mW,..           
-00014310: 2070 6572 6329 0d0a 2020 2020 2020 2020   perc)..        
-00014320: 7365 6c66 2e73 6574 7469 6e67 732e 7374  self.settings.st
-00014330: 6174 652e 6c61 7365 725f 706f 7765 725f  ate.laser_power_
-00014340: 6d57 203d 206d 570d 0a20 2020 2020 2020  mW = mW..       
-00014350: 2072 6574 7572 6e20 7365 6c66 2e73 6574   return self.set
-00014360: 5f6c 6173 6572 5f70 6f77 6572 5f70 6572  _laser_power_per
-00014370: 6328 7065 7263 2c20 7365 745f 696e 5f70  c(perc, set_in_p
-00014380: 6572 633d 4661 6c73 6529 0d0a 0d0a 2020  erc=False)....  
-00014390: 2020 2323 0d0a 2020 2020 2320 4062 7269    ##..    # @bri
-000143a0: 6566 2053 6574 7320 7768 6574 6865 7220  ef Sets whether 
-000143b0: 7468 6520 5057 4d20 7075 6c73 6520 7065  the PWM pulse pe
-000143c0: 7269 6f64 2069 7320 3130 3030 c2b5 7320  riod is 1000..s 
-000143d0: 2868 6967 682d 7265 736f 6c75 7469 6f6e  (high-resolution
-000143e0: 2c20 6465 6661 756c 7429 0d0a 2020 2020  , default)..    
-000143f0: 2320 6f72 2031 3030 c2b5 7320 286c 6f77  # or 100..s (low
-00014400: 2d72 6573 6f6c 7574 696f 6e2c 206c 6567  -resolution, leg
-00014410: 6163 7929 2e0d 0a20 2020 2023 0d0a 2020  acy)...    #..  
-00014420: 2020 2320 4070 6172 616d 2066 6c61 6720    # @param flag 
-00014430: 2849 6e70 7574 2920 5472 7565 2066 6f72  (Input) True for
-00014440: 2031 3030 30c2 b573 2050 574d 2070 6572   1000..s PWM per
-00014450: 696f 6420 2868 6967 682d 7265 736f 6c75  iod (high-resolu
-00014460: 7469 6f6e 2c20 6465 6661 756c 7429 2c20  tion, default), 
-00014470: 0d0a 2020 2020 2320 2020 2020 2020 2046  ..    #        F
-00014480: 616c 7365 2066 6f72 2031 3030 c2b5 7320  alse for 100..s 
-00014490: 286c 6f77 2d72 6573 6f6c 7574 696f 6e29  (low-resolution)
-000144a0: 0d0a 2020 2020 2320 0d0a 2020 2020 2320  ..    # ..    # 
-000144b0: 4c61 7365 7220 706f 7765 7220 6973 2063  Laser power is c
-000144c0: 6f6e 7472 6f6c 6c65 6420 7669 6120 5057  ontrolled via PW
-000144d0: 4d20 2850 756c 7365 2057 6964 7468 204d  M (Pulse Width M
-000144e0: 6f64 756c 6174 696f 6e29 2c20 6573 7365  odulation), esse
-000144f0: 6e74 6961 6c6c 7920 0d0a 2020 2020 2320  ntially ..    # 
-00014500: 6120 7371 7561 7265 2077 6176 6520 7768  a square wave wh
-00014510: 6f73 6520 2264 7574 7920 6379 636c 6522  ose "duty cycle"
-00014520: 2028 6869 6768 2076 7320 6c6f 7729 2c20   (high vs low), 
-00014530: 6578 7072 6573 7365 6420 6173 2061 2070  expressed as a p
-00014540: 6572 6365 6e74 6167 652c 0d0a 2020 2020  ercentage,..    
-00014550: 2320 7265 7072 6573 656e 7473 2074 6865  # represents the
-00014560: 2061 6d6f 756e 7420 6f66 2074 696d 6520   amount of time 
-00014570: 7468 6520 6c61 7365 7220 6973 2061 6374  the laser is act
-00014580: 7561 6c6c 7920 6669 7269 6e67 2e20 4966  ually firing. If
-00014590: 2074 6865 2064 7574 790d 0a20 2020 2023   the duty..    #
-000145a0: 2063 7963 6c65 2069 7320 3333 252c 2074   cycle is 33%, t
-000145b0: 6865 206c 6173 6572 2077 696c 6c20 6265  he laser will be
-000145c0: 2066 6972 696e 6720 312f 3320 6f66 2074   firing 1/3 of t
-000145d0: 6865 2074 696d 652c 2072 6570 7265 7365  he time, represe
-000145e0: 6e74 696e 670d 0a20 2020 2023 2061 7070  nting..    # app
-000145f0: 726f 7869 6d61 7465 6c79 206f 6e65 2d74  roximately one-t
-00014600: 6869 7264 206f 6620 2266 756c 6c20 706f  hird of "full po
-00014610: 7765 7222 2e20 200d 0a20 2020 2023 200d  wer".  ..    # .
-00014620: 0a20 2020 2023 2028 4974 2773 206e 6f74  .    # (It's not
-00014630: 2022 6578 6163 746c 7922 206f 6e65 2d74   "exactly" one-t
-00014640: 6869 7264 2062 6563 6175 7365 2074 6865  hird because the
-00014650: 206c 6173 6572 206e 6565 6473 2061 206d   laser needs a m
-00014660: 6f6d 656e 7420 746f 200d 0a20 2020 2023  oment to ..    #
-00014670: 2073 7461 626c 697a 6520 7768 656e 2065   stablize when e
-00014680: 6e65 7267 697a 6564 2c20 616e 6420 7468  nergized, and th
-00014690: 6174 2022 7374 6172 742d 7570 2220 696e  at "start-up" in
-000146a0: 7374 6162 696c 6974 7920 6973 2069 6e63  stability is inc
-000146b0: 7265 6173 6564 200d 0a20 2020 2023 2077  reased ..    # w
-000146c0: 6865 6e20 796f 7527 7265 2063 6f6e 7374  hen you're const
-000146d0: 616e 746c 7920 7075 6c73 696e 6720 7468  antly pulsing th
-000146e0: 6520 6c61 7365 7220 6f6e 2d61 6e64 2d6f  e laser on-and-o
-000146f0: 6666 2e29 0d0a 2020 2020 2320 0d0a 2020  ff.)..    # ..  
-00014700: 2020 2320 5468 6973 2066 756e 6374 696f    # This functio
-00014710: 6e20 6973 2075 7365 6420 746f 2064 6574  n is used to det
-00014720: 6572 6d69 6e65 2074 6865 204c 454e 4754  ermine the LENGT
-00014730: 4820 2870 6572 696f 6429 206f 6620 7468  H (period) of th
-00014740: 6174 2050 574d 0d0a 2020 2020 2320 7371  at PWM..    # sq
-00014750: 7561 7265 2077 6176 652e 2020 4265 6361  uare wave.  Beca
-00014760: 7573 6520 7468 6520 6c61 7365 7227 7320  use the laser's 
-00014770: 5057 4d20 7061 7261 6d65 7465 7273 2061  PWM parameters a
-00014780: 7265 2061 6c6c 2073 7065 6369 6669 6564  re all specified
-00014790: 2069 6e0d 0a20 2020 2023 206d 6963 726f   in..    # micro
-000147a0: 7365 636f 6e64 7320 28c2 b573 292c 2061  seconds (..s), a
-000147b0: 206c 6f6e 6765 7220 7065 7269 6f64 2061   longer period a
-000147c0: 6c6c 6f77 7320 6772 6561 7465 7220 7072  llows greater pr
-000147d0: 6563 6973 696f 6e20 2872 6573 6f6c 7574  ecision (resolut
-000147e0: 696f 6e29 0d0a 2020 2020 2320 696e 2073  ion)..    # in s
-000147f0: 7065 6369 6679 696e 6720 7468 6520 6475  pecifying the du
-00014800: 7479 2063 7963 6c65 2e0d 0a20 2020 2023  ty cycle...    #
-00014810: 200d 0a20 2020 2023 2048 6973 746f 7269   ..    # Histori
-00014820: 6361 6c6c 792c 2057 6173 6174 6368 2073  cally, Wasatch s
-00014830: 7065 6374 726f 6d65 7465 7273 2075 7365  pectrometers use
-00014840: 6420 6120 5057 4d20 7065 7269 6f64 206f  d a PWM period o
-00014850: 6620 3130 30c2 b573 2c20 6d65 616e 696e  f 100..s, meanin
-00014860: 670d 0a20 2020 2023 2074 6865 2070 756c  g..    # the pul
-00014870: 7365 2077 6964 7468 2028 7469 6d65 2065  se width (time e
-00014880: 6163 6820 7761 7665 2077 6173 2068 6967  ach wave was hig
-00014890: 6829 2063 6f75 6c64 206f 6e6c 7920 6265  h) could only be
-000148a0: 2073 6574 2066 726f 6d20 312d 3939 c2b5   set from 1-99..
-000148b0: 732c 0d0a 2020 2020 2320 6769 7669 6e67  s,..    # giving
-000148c0: 2061 6e20 6573 7365 6e74 6961 6c20 6c61   an essential la
-000148d0: 7365 7220 706f 7765 7220 7265 736f 6c75  ser power resolu
-000148e0: 7469 6f6e 206f 6620 3125 2e20 2054 6861  tion of 1%.  Tha
-000148f0: 7420 6265 6861 7669 6f72 2063 616e 0d0a  t behavior can..
-00014900: 2020 2020 2320 6265 2072 6573 746f 7265      # be restore
-00014910: 6420 6279 2073 6574 7469 6e67 2074 6869  d by setting thi
-00014920: 7320 7661 6c75 6520 4661 6c73 652e 0d0a  s value False...
-00014930: 2020 2020 2320 0d0a 2020 2020 2320 4d6f      # ..    # Mo
-00014940: 7265 2072 6563 656e 746c 792c 2077 6527  re recently, we'
-00014950: 7665 2069 6e63 7265 6173 6564 2074 6865  ve increased the
-00014960: 2064 6566 6175 6c74 2050 574d 2070 756c   default PWM pul
-00014970: 7365 2070 6572 696f 6420 746f 2031 3030  se period to 100
-00014980: 30c2 b573 200d 0a20 2020 2023 2028 316d  0..s ..    # (1m
-00014990: 7329 2e20 5369 6e63 6520 7468 6520 7075  s). Since the pu
-000149a0: 6c73 6520 7769 6474 6820 6973 2073 7469  lse width is sti
-000149b0: 6c6c 2073 6574 2069 6e20 c2b5 732c 2074  ll set in ..s, t
-000149c0: 6861 7420 616c 6c6f 7773 2061 6e0d 0a20  hat allows an.. 
-000149d0: 2020 2023 2065 6666 6563 7469 7665 206c     # effective l
-000149e0: 6173 6572 2070 6f77 6572 2072 6573 6f6c  aser power resol
-000149f0: 7574 696f 6e20 6f66 2030 2e31 252e 2020  ution of 0.1%.  
-00014a00: 5468 6973 2069 7320 7468 6520 6e65 7720  This is the new 
-00014a10: 6465 6661 756c 742c 0d0a 2020 2020 2320  default,..    # 
-00014a20: 616e 6420 6361 6e20 6265 2065 7870 6c69  and can be expli
-00014a30: 6369 746c 7920 7265 7175 6573 7465 6420  citly requested 
-00014a40: 6279 2073 6574 7469 6e67 2074 6869 7320  by setting this 
-00014a50: 7661 6c75 6520 746f 2054 7275 652e 0d0a  value to True...
-00014a60: 2020 2020 230d 0a20 2020 2023 2040 7761      #..    # @wa
-00014a70: 726e 696e 6720 4e6f 7465 2074 6861 7420  rning Note that 
-00014a80: 7468 6973 2066 756e 6374 696f 6e20 6973  this function is
-00014a90: 2070 726f 7669 6465 6420 666f 7220 6361   provided for ca
-00014aa0: 7365 7320 7768 6572 6520 7468 6520 6c61  ses where the la
-00014ab0: 7365 7220 706f 7765 7220 0d0a 2020 2020  ser power ..    
-00014ac0: 2320 6973 2073 6574 2061 7320 6120 7065  # is set as a pe
-00014ad0: 7263 656e 7461 6765 2e20 2057 6865 6e20  rcentage.  When 
-00014ae0: 7365 7474 696e 6720 6c61 7365 7220 706f  setting laser po
-00014af0: 7765 7220 7468 726f 7567 6820 6d69 6c6c  wer through mill
-00014b00: 6957 6174 7473 2c20 7573 696e 670d 0a20  iWatts, using.. 
-00014b10: 2020 2023 2074 6865 206f 6e62 6f61 7264     # the onboard
-00014b20: 206c 6173 6572 2070 6f77 6572 2063 616c   laser power cal
-00014b30: 6962 7261 7469 6f6e 2c20 6974 2069 7320  ibration, it is 
-00014b40: 696d 706f 7274 616e 7420 746f 2075 7365  important to use
-00014b50: 2074 6865 2073 616d 650d 0a20 2020 2023   the same..    #
-00014b60: 2072 6573 6f6c 7574 696f 6e20 6173 2077   resolution as w
-00014b70: 6173 2069 6e20 6566 6665 6374 2077 6865  as in effect whe
-00014b80: 6e20 7468 6520 6361 6c69 6272 6174 696f  n the calibratio
-00014b90: 6e20 7761 7320 6765 6e65 7261 7465 642e  n was generated.
-00014ba0: 2020 416c 6c20 5761 7361 7463 680d 0a20    All Wasatch.. 
-00014bb0: 2020 2023 206c 6173 6572 2070 6f77 6572     # laser power
-00014bc0: 2063 616c 6962 7261 7469 6f6e 7320 6172   calibrations ar
-00014bd0: 6520 6765 6e65 7261 7465 6420 696e 2022  e generated in "
-00014be0: 6869 6768 2d72 6573 6f6c 7574 696f 6e2c  high-resolution,
-00014bf0: 2220 736f 2074 6869 7320 0d0a 2020 2020  " so this ..    
-00014c00: 2320 6675 6e63 7469 6f6e 2053 484f 554c  # function SHOUL
-00014c10: 4420 4e4f 5420 6265 2073 6574 2022 4661  D NOT be set "Fa
-00014c20: 6c73 6522 2028 6c6f 772d 7265 7329 2069  lse" (low-res) i
-00014c30: 6620 7365 7474 696e 6720 6c61 7365 7220  f setting laser 
-00014c40: 706f 7765 7220 696e 206d 572e 0d0a 2020  power in mW...  
-00014c50: 2020 6465 6620 7365 745f 6c61 7365 725f    def set_laser_
-00014c60: 706f 7765 725f 6869 6768 5f72 6573 6f6c  power_high_resol
-00014c70: 7574 696f 6e28 7365 6c66 2c20 666c 6167  ution(self, flag
-00014c80: 3a20 626f 6f6c 293a 2023 202d 3e20 5370  : bool): # -> Sp
-00014c90: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-00014ca0: 7365 200d 0a20 2020 2020 2020 2073 656c  se ..        sel
-00014cb0: 662e 7365 7474 696e 6773 2e73 7461 7465  f.settings.state
-00014cc0: 2e6c 6173 6572 5f70 6f77 6572 5f68 6967  .laser_power_hig
-00014cd0: 685f 7265 736f 6c75 7469 6f6e 203d 2054  h_resolution = T
-00014ce0: 7275 6520 6966 2066 6c61 6720 656c 7365  rue if flag else
-00014cf0: 2046 616c 7365 0d0a 2020 2020 2020 2020   False..        
-00014d00: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
-00014d10: 7465 7252 6573 706f 6e73 6528 290d 0a0d  terResponse()...
-00014d20: 0a20 2020 2064 6566 2073 6574 5f6c 6173  .    def set_las
-00014d30: 6572 5f70 6f77 6572 5f72 6571 7569 7265  er_power_require
-00014d40: 5f6d 6f64 756c 6174 696f 6e28 7365 6c66  _modulation(self
-00014d50: 2c20 666c 6167 3a20 626f 6f6c 293a 2023  , flag: bool): #
-00014d60: 202d 3e20 5370 6563 7472 6f6d 6574 6572   -> Spectrometer
-00014d70: 5265 7370 6f6e 7365 200d 0a20 2020 2020  Response ..     
-00014d80: 2020 2073 656c 662e 7365 7474 696e 6773     self.settings
-00014d90: 2e73 7461 7465 2e6c 6173 6572 5f70 6f77  .state.laser_pow
-00014da0: 6572 5f72 6571 7569 7265 5f6d 6f64 756c  er_require_modul
-00014db0: 6174 696f 6e20 3d20 5472 7565 2069 6620  ation = True if 
-00014dc0: 666c 6167 2065 6c73 6520 4661 6c73 650d  flag else False.
-00014dd0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00014de0: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
-00014df0: 6f6e 7365 2829 0d0a 0d0a 2020 2020 2323  onse()....    ##
-00014e00: 0d0a 2020 2020 2320 4074 6f64 6f20 7375  ..    # @todo su
-00014e10: 7070 6f72 7420 666c 6f61 7469 6e67 2d70  pport floating-p
-00014e20: 6f69 6e74 2076 616c 7565 2c20 6173 2077  oint value, as w
-00014e30: 6520 6861 7665 2061 2031 322d 6269 7420  e have a 12-bit 
-00014e40: 4144 4320 616e 6420 6361 6e20 7072 6f76  ADC and can prov
-00014e50: 6964 650d 0a20 2020 2023 2061 2062 6974  ide..    # a bit
-00014e60: 206d 6f72 6520 7072 6563 6973 696f 6e20   more precision 
-00014e70: 7468 616e 2031 3030 2064 6973 6372 6574  than 100 discret
-00014e80: 6520 7374 6570 7320 2867 6f61 6c20 746f  e steps (goal to
-00014e90: 2073 7570 706f 7274 2030 2e31 202d 202e   support 0.1 - .
-00014ea0: 3132 3525 2072 6573 6f6c 7574 696f 6e29  125% resolution)
-00014eb0: 0d0a 2020 2020 6465 6620 7365 745f 6c61  ..    def set_la
-00014ec0: 7365 725f 706f 7765 725f 7065 7263 2873  ser_power_perc(s
-00014ed0: 656c 662c 2076 616c 7565 5f69 6e3a 2066  elf, value_in: f
-00014ee0: 6c6f 6174 2c20 7365 745f 696e 5f70 6572  loat, set_in_per
-00014ef0: 633a 2062 6f6f 6c20 3d20 5472 7565 293a  c: bool = True):
-00014f00: 2023 202d 3e20 5370 6563 7472 6f6d 6574   # -> Spectromet
-00014f10: 6572 5265 7370 6f6e 7365 200d 0a20 2020  erResponse ..   
-00014f20: 2020 2020 2069 6620 6e6f 7420 7365 6c66       if not self
-00014f30: 2e73 6574 7469 6e67 732e 6565 7072 6f6d  .settings.eeprom
-00014f40: 2e68 6173 5f6c 6173 6572 3a0d 0a20 2020  .has_laser:..   
-00014f50: 2020 2020 2020 2020 206c 6f67 2e65 7272           log.err
-00014f60: 6f72 2822 756e 6162 6c65 2074 6f20 636f  or("unable to co
-00014f70: 6e74 726f 6c20 6c61 7365 723a 2045 4550  ntrol laser: EEP
-00014f80: 524f 4d20 7265 706f 7274 7320 6e6f 206c  ROM reports no l
-00014f90: 6173 6572 2069 6e73 7461 6c6c 6564 2229  aser installed")
-00014fa0: 0d0a 2020 2020 2020 2020 2020 2020 7265  ..            re
-00014fb0: 7475 726e 2053 7065 6374 726f 6d65 7465  turn Spectromete
-00014fc0: 7252 6573 706f 6e73 6528 6461 7461 3d46  rResponse(data=F
-00014fd0: 616c 7365 2c65 7272 6f72 5f6d 7367 3d22  alse,error_msg="
-00014fe0: 6e6f 206c 6173 6572 2069 6e73 7461 6c6c  no laser install
-00014ff0: 6564 2229 0d0a 0d0a 2020 2020 2020 2020  ed")....        
-00015000: 7661 6c75 6520 3d20 666c 6f61 7428 6d61  value = float(ma
-00015010: 7828 302c 206d 696e 2831 3030 2c20 7661  x(0, min(100, va
-00015020: 6c75 655f 696e 2929 290d 0a20 2020 2020  lue_in)))..     
-00015030: 2020 2073 656c 662e 7365 7474 696e 6773     self.settings
-00015040: 2e73 7461 7465 2e6c 6173 6572 5f70 6f77  .state.laser_pow
-00015050: 6572 5f70 6572 6320 3d20 7661 6c75 650d  er_perc = value.
-00015060: 0a20 2020 2020 2020 206c 6f67 2e64 6562  .        log.deb
-00015070: 7567 2822 7365 745f 6c61 7365 725f 706f  ug("set_laser_po
-00015080: 7765 725f 7065 7263 3a20 7261 6e67 6520  wer_perc: range 
-00015090: 2830 2c20 3130 3029 2c20 7265 7175 6573  (0, 100), reques
-000150a0: 7465 6420 252e 3266 2c20 6170 706c 7969  ted %.2f, applyi
-000150b0: 6e67 2025 2e32 6622 2c20 7661 6c75 655f  ng %.2f", value_
-000150c0: 696e 2c20 7661 6c75 6529 0d0a 0d0a 2020  in, value)....  
-000150d0: 2020 2020 2020 6966 2073 6574 5f69 6e5f        if set_in_
-000150e0: 7065 7263 3a0d 0a20 2020 2020 2020 2020  perc:..         
-000150f0: 2020 2023 2061 7070 6172 656e 746c 7920     # apparently 
-00015100: 7468 6520 6c61 7365 7220 706f 7765 7220  the laser power 
-00015110: 7761 7320 6578 706c 6963 6974 6c79 2063  was explicitly c
-00015120: 6f6d 6d61 6e64 6564 2061 7320 6120 7065  ommanded as a pe
-00015130: 7263 656e 7461 6765 0d0a 2020 2020 2020  rcentage..      
-00015140: 2020 2020 2020 2320 6f66 2066 756c 6c2c        # of full,
-00015150: 2061 6e64 206e 6f74 2022 636f 6d70 7574   and not "comput
-00015160: 6564 2066 726f 6d20 6d57 2220 7573 696e  ed from mW" usin
-00015170: 6720 6120 6361 6c69 6272 6174 696f 6e2c  g a calibration,
-00015180: 2073 6f20 636c 6561 720d 0a20 2020 2020   so clear..     
-00015190: 2020 2020 2020 2023 2074 6865 206d 5720         # the mW 
-000151a0: 7365 7470 6f69 6e74 0d0a 2020 2020 2020  setpoint..      
-000151b0: 2020 2020 2020 7365 6c66 2e73 6574 7469        self.setti
-000151c0: 6e67 732e 7374 6174 652e 6c61 7365 725f  ngs.state.laser_
-000151d0: 706f 7765 725f 6d57 203d 2030 0d0a 0d0a  power_mW = 0....
-000151e0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-000151f0: 656c 662e 7365 745f 6c61 7365 725f 706f  elf.set_laser_po
-00015200: 7765 725f 7065 7263 5f69 6d6d 6564 6961  wer_perc_immedia
-00015210: 7465 2876 616c 7565 290d 0a0d 0a20 2020  te(value)....   
-00015220: 2023 230d 0a20 2020 2023 2053 6574 7320   ##..    # Sets 
-00015230: 6c61 7365 7220 706f 7765 7220 286d 6f64  laser power (mod
-00015240: 756c 6174 6564 2070 756c 7365 2077 6964  ulated pulse wid
-00015250: 7468 2920 7768 6963 6820 7769 6c6c 2062  th) which will b
-00015260: 6520 7573 6564 206e 6578 7420 7469 6d65  e used next time
-00015270: 2074 6865 0d0a 2020 2020 2320 6c61 7365   the..    # lase
-00015280: 7220 6973 2074 7572 6e65 6420 6f6e 2028  r is turned on (
-00015290: 6f72 2063 6861 6e67 6564 2069 6d6d 6564  or changed immed
-000152a0: 6961 7465 6c79 2c20 6966 2074 6865 206c  iately, if the l
-000152b0: 6173 6572 2069 7320 616c 7265 6164 7920  aser is already 
-000152c0: 656e 6162 6c65 6429 2e0d 0a20 2020 2023  enabled)...    #
-000152d0: 204c 6173 6572 2070 6f77 6572 2069 7320   Laser power is 
-000152e0: 6465 7465 726d 696e 6564 2062 7920 6120  determined by a 
-000152f0: 636f 6d62 696e 6174 696f 6e20 6f66 2074  combination of t
-00015300: 6865 2070 756c 7365 2077 6964 7468 2c0d  he pulse width,.
-00015310: 0a20 2020 2023 2070 6572 696f 6420 616e  .    # period an
-00015320: 6420 6d6f 6475 6c61 7469 6f6e 2062 6569  d modulation bei
-00015330: 6e67 2065 6e61 626c 6564 2e20 5468 6572  ng enabled. Ther
-00015340: 6520 6172 6520 6d61 6e79 2063 6f6d 6269  e are many combi
-00015350: 6e61 7469 6f6e 7320 6f66 0d0a 2020 2020  nations of..    
-00015360: 2320 7468 6573 6520 7661 6c75 6573 2074  # these values t
-00015370: 6861 7420 7769 6c6c 2070 726f 6475 6365  hat will produce
-00015380: 2061 2067 6976 656e 2070 6572 6365 6e74   a given percent
-00015390: 6167 6520 6f66 2074 6865 2074 6f74 616c  age of the total
-000153a0: 206c 6173 6572 0d0a 2020 2020 2320 706f   laser..    # po
-000153b0: 7765 7220 7468 726f 7567 6820 7075 6c73  wer through puls
-000153c0: 6520 7769 6474 6820 6d6f 6475 6c61 7469  e width modulati
-000153d0: 6f6e 2e20 5468 6572 6520 6973 206e 6f20  on. There is no 
-000153e0: 2767 6574 206c 6173 6572 2070 6f77 6572  'get laser power
-000153f0: 270d 0a20 2020 2023 2063 6f6e 7472 6f6c  '..    # control
-00015400: 206d 6573 7361 6765 206f 6e20 7468 6520   message on the 
-00015410: 6465 7669 6365 2e0d 0a20 2020 2023 0d0a  device...    #..
-00015420: 2020 2020 2320 536f 6d65 206f 6620 7468      # Some of th
-00015430: 6520 676f 616c 7320 6f66 2045 6e6c 6967  e goals of Enlig
-00015440: 6874 656e 2061 7265 2066 6f72 2069 7420  hten are for it 
-00015450: 746f 2062 6520 7374 6162 6c65 2c20 616e  to be stable, an
-00015460: 6420 6120 7265 6173 6f6e 0d0a 2020 2020  d a reason..    
-00015470: 2320 7765 2068 6176 6520 7361 6c65 732e  # we have sales.
-00015480: 2044 7572 696e 6720 7370 6563 7472 6f6d   During spectrom
-00015490: 6574 6572 2062 7569 6c64 732c 2069 7420  eter builds, it 
-000154a0: 7761 7320 6469 7363 6f76 6572 6564 2074  was discovered t
-000154b0: 6861 740d 0a20 2020 2023 2074 6865 206c  hat..    # the l
-000154c0: 6173 6572 2070 6f77 6572 2073 6574 7469  aser power setti
-000154d0: 6e67 7320 7765 7265 206e 6f74 2069 6d70  ngs were not imp
-000154e0: 6c65 6d65 6e74 6564 2e20 4475 7269 6e67  lemented. During
-000154f0: 2074 6865 0d0a 2020 2020 2320 696d 706c   the..    # impl
-00015500: 656d 656e 7461 7469 6f6e 2070 726f 6365  ementation proce
-00015510: 7373 2c20 6974 2077 6173 2064 6973 636f  ss, it was disco
-00015520: 7665 7265 6420 7468 6174 2074 6865 206c  vered that the l
-00015530: 6173 6572 206d 6f64 756c 6174 696f 6e2c  aser modulation,
-00015540: 0d0a 2020 2020 2320 7075 6c73 6520 7065  ..    # pulse pe
-00015550: 7269 6f64 2061 6e64 2070 756c 7365 2077  riod and pulse w
-00015560: 6964 7468 2063 6f6d 6d61 6e64 7320 646f  idth commands do
-00015570: 206e 6f74 2063 6f6e 666f 726d 2074 6f0d   not conform to.
-00015580: 0a20 2020 2023 2073 7065 6369 6669 6361  .    # specifica
-00015590: 7469 6f6e 2e20 5768 6572 6520 796f 7520  tion. Where you 
-000155a0: 6361 6e20 7365 7420 696e 7465 6772 6174  can set integrat
-000155b0: 696f 6e20 7469 6d65 2031 3030 206d 7320  ion time 100 ms 
-000155c0: 7769 7468 2074 6865 0d0a 2020 2020 2320  with the..    # 
-000155d0: 636f 6d6d 616e 643a 0d0a 2020 2020 230d  command:..    #.
-000155e0: 0a20 2020 2023 2064 6576 6963 652e 6374  .    # device.ct
-000155f0: 726c 5f74 7261 6e73 6665 7228 626d 5265  rl_transfer(bmRe
-00015600: 7175 6573 7454 7970 653d 6465 7669 6365  questType=device
-00015610: 5f74 6f5f 686f 7374 2c0d 0a20 2020 2023  _to_host,..    #
-00015620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015630: 2020 2020 2020 6252 6571 7565 7374 3d30        bRequest=0
-00015640: 7844 422c 0d0a 2020 2020 2320 2020 2020  xDB,..    #     
-00015650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015660: 2077 5661 6c75 653d 3130 302c 0d0a 2020   wValue=100,..  
-00015670: 2020 2320 2020 2020 2020 2020 2020 2020    #             
-00015680: 2020 2020 2020 2020 2077 496e 6465 783d           wIndex=
-00015690: 302c 0d0a 2020 2020 2320 2020 2020 2020  0,..    #       
-000156a0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-000156b0: 6174 615f 6f72 5f77 4c65 6e67 7468 3d30  ata_or_wLength=0
-000156c0: 290d 0a20 2020 2023 0d0a 2020 2020 2320  )..    #..    # 
-000156d0: 5468 6520 6c61 7365 7220 7075 6c73 6520  The laser pulse 
-000156e0: 7065 7269 6f64 206d 7573 7420 6265 2073  period must be s
-000156f0: 6574 2077 6865 7265 2074 6865 2077 5661  et where the wVa
-00015700: 6c75 6520 616e 640d 0a20 2020 2023 2064  lue and..    # d
-00015710: 6174 615f 6f72 5f77 4c65 6e67 7468 2070  ata_or_wLength p
-00015720: 6172 616d 6574 6572 7320 6172 6520 6571  arameters are eq
-00015730: 7561 6c2e 2053 6f20 6966 2079 6f75 2077  ual. So if you w
-00015740: 616e 7465 6420 6120 7075 6c73 650d 0a20  anted a pulse.. 
-00015750: 2020 2023 2070 6572 696f 6420 6f66 2031     # period of 1
-00015760: 3030 2c20 796f 7520 6d75 7374 2073 7065  00, you must spe
-00015770: 6369 6679 2074 6865 2076 616c 7565 2069  cify the value i
-00015780: 6e20 626f 7468 2070 6c61 6365 733a 0d0a  n both places:..
-00015790: 2020 2020 230d 0a20 2020 2023 202e 2e2e      #..    # ...
-000157a0: 0d0a 2020 2020 2320 2020 2020 2020 2020  ..    #         
-000157b0: 2020 2020 2020 2020 2020 2020 2077 5661               wVa
-000157c0: 6c75 653d 3130 302c 0d0a 2020 2020 2320  lue=100,..    # 
-000157d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000157e0: 2020 2020 2064 6174 615f 6f72 5f77 4c65       data_or_wLe
-000157f0: 6e67 7468 3d31 3030 290d 0a20 2020 2023  ngth=100)..    #
-00015800: 202e 2e2e 0d0a 2020 2020 230d 0a20 2020   .....    #..   
-00015810: 2023 2054 6869 7320 696e 2074 7572 6e20   # This in turn 
-00015820: 696d 706c 6965 7320 7468 6174 2074 6865  implies that the
-00015830: 206c 6567 6163 7920 6669 726d 7761 7265   legacy firmware
-00015840: 2068 6173 2061 206c 6f6e 6720 6d61 736b   has a long mask
-00015850: 6564 0d0a 2020 2020 2320 6973 7375 6520  ed..    # issue 
-00015860: 7768 656e 2072 6561 6469 6e67 2074 6865  when reading the
-00015870: 2076 616c 7565 2074 6f20 7570 6461 7465   value to update
-00015880: 2066 726f 6d20 7468 6520 6461 7461 5f6f   from the data_o
-00015890: 725f 774c 656e 6774 680d 0a20 2020 2023  r_wLength..    #
-000158a0: 2070 6172 616d 6574 6572 2069 6e73 7465   parameter inste
-000158b0: 6164 206f 6620 7468 6520 7756 616c 7565  ad of the wValue
-000158c0: 2066 6965 6c64 2e20 5468 6973 2069 7320   field. This is 
-000158d0: 6f6e 6c79 2061 6363 7572 6174 6520 666f  only accurate fo
-000158e0: 7220 7468 650d 0a20 2020 2023 206c 6173  r the..    # las
-000158f0: 6572 206d 6f64 756c 6174 696f 6e20 7265  er modulation re
-00015900: 6c61 7465 6420 6675 6e63 7469 6f6e 732e  lated functions.
-00015910: 0d0a 2020 2020 230d 0a20 2020 2023 2054  ..    #..    # T
-00015920: 6869 7320 6973 2062 6163 6b65 6420 7570  his is backed up
-00015930: 2062 7920 7468 6520 4461 7368 2076 3320   by the Dash v3 
-00015940: 5374 726f 6b65 7243 6f6e 7472 6f6c 2044  StrokerControl D
-00015950: 4c4c 2069 6d70 6c65 6d65 6e74 6174 696f  LL implementatio
-00015960: 6e2e 0d0a 2020 2020 2320 4974 2077 6173  n...    # It was
-00015970: 2064 6973 636f 7665 7265 6420 7468 6174   discovered that
-00015980: 2074 6865 2053 7472 6f6b 6572 436f 6e74   the StrokerCont
-00015990: 726f 6c20 444c 4c20 7365 7473 2074 6865  rol DLL sets the
-000159a0: 2077 5661 6c75 6520 616e 640d 0a20 2020   wValue and..   
-000159b0: 2023 2064 6174 6120 6f72 2077 4c65 6e67   # data or wLeng
-000159c0: 7468 2070 6172 616d 6574 6572 7320 746f  th parameters to
-000159d0: 2074 6865 2073 616d 6520 7661 6c75 6520   the same value 
-000159e0: 6174 2065 7665 7279 2063 6f6e 7472 6f6c  at every control
-000159f0: 0d0a 2020 2020 2320 6d65 7373 6167 6520  ..    # message 
-00015a00: 7772 6974 652e 0d0a 2020 2020 230d 0a20  write...    #.. 
-00015a10: 2020 2023 2054 6865 2065 7863 6974 696e     # The excitin
-00015a20: 6720 7461 6b65 6177 6179 2068 6572 6520  g takeaway here 
-00015a30: 6973 2074 6861 7420 456e 6c69 6768 7465  is that Enlighte
-00015a40: 6e20 6973 2073 7461 626c 6520 656e 6f75  n is stable enou
-00015a50: 6768 2e0d 0a20 2020 2023 2054 7572 6e69  gh...    # Turni
-00015a60: 6e67 2074 6865 206c 6173 6572 206f 6e20  ng the laser on 
-00015a70: 7769 7468 2074 6865 2064 6174 6120 6f72  with the data or
-00015a80: 2077 4c65 6e67 7468 2070 6172 616d 6574   wLength paramet
-00015a90: 6572 206e 6f74 2073 6574 0d0a 2020 2020  er not set..    
-00015aa0: 2320 636f 7272 6563 746c 7920 7769 6c6c  # correctly will
-00015ab0: 2063 6175 7365 2061 2068 6172 6477 6172   cause a hardwar
-00015ac0: 6520 6661 696c 7572 6520 616e 6420 636f  e failure and co
-00015ad0: 6d70 6c65 7465 2064 6576 6963 6520 6c6f  mplete device lo
-00015ae0: 636b 7570 0d0a 2020 2020 2320 7265 7175  ckup..    # requ
-00015af0: 6972 696e 6720 6120 706f 7765 7220 6379  iring a power cy
-00015b00: 636c 652e 0d0a 2020 2020 230d 0a20 2020  cle...    #..   
-00015b10: 2023 2066 6964 3a0d 0a20 2020 2023 2020   # fid:..    #  
-00015b20: 2020 2043 5249 5449 4341 4c20 4861 7264     CRITICAL Hard
-00015b30: 7761 7265 2046 6169 6c75 7265 2046 4944  ware Failure FID
-00015b40: 2053 656e 6420 436f 6465 2050 726f 626c   Send Code Probl
-00015b50: 656d 2077 6974 680d 0a20 2020 2023 2020  em with..    #  
-00015b60: 2020 2020 2020 2020 2020 2020 6374 726c              ctrl
-00015b70: 2074 7261 6e73 6665 723a 205b 4572 726e   transfer: [Errn
-00015b80: 6f20 4e6f 6e65 5d20 3131 0d0a 2020 2020  o None] 11..    
-00015b90: 230d 0a20 2020 2023 2055 6e6c 696b 6520  #..    # Unlike 
-00015ba0: 4461 7368 2077 6869 6368 206d 6179 206c  Dash which may l
-00015bb0: 6f63 6b75 7020 616e 6420 7265 7175 6972  ockup and requir
-00015bc0: 6520 6b69 6c6c 696e 6720 7468 6520 6170  e killing the ap
-00015bd0: 706c 6963 6174 696f 6e2c 0d0a 2020 2020  plication,..    
-00015be0: 2320 456e 6c69 6768 7465 6e20 646f 6573  # Enlighten does
-00015bf0: 206e 6f74 206c 6f63 6b20 7570 2e20 5468   not lock up. Th
-00015c00: 6520 456e 6c69 6768 7465 6e20 636f 6465  e Enlighten code
-00015c10: 2062 6173 6520 6861 7320 6e6f 7720 6265   base has now be
-00015c20: 656e 0d0a 2020 2020 2320 7573 6564 2074  en..    # used t
-00015c30: 6f20 756e 6d61 736b 2061 6e20 6973 7375  o unmask an issu
-00015c40: 6520 7468 6174 2068 6173 2062 6565 6e20  e that has been 
-00015c50: 6c75 726b 696e 6720 7769 7468 206f 7572  lurking with our
-00015c60: 206c 6567 6163 790d 0a20 2020 2023 2066   legacy..    # f
-00015c70: 6972 6d77 6172 6520 666f 7220 636c 6f73  irmware for clos
-00015c80: 6520 746f 2036 2079 6561 7273 2e20 5765  e to 6 years. We
-00015c90: 2776 6520 6465 7465 6374 6564 2074 6869  've detected thi
-00015ca0: 7320 6f75 7420 6f66 0d0a 2020 2020 2320  s out of..    # 
-00015cb0: 7370 6563 6966 6963 6174 696f 6e20 6172  specification ar
-00015cc0: 6561 206f 6620 7468 6520 636f 6465 2062  ea of the code b
-00015cd0: 6566 6f72 6520 6974 2063 616e 2061 6476  efore it can adv
-00015ce0: 6572 7365 6c79 2069 6d70 6163 7420 610d  ersely impact a.
-00015cf0: 0a20 2020 2023 2063 7573 746f 6d65 722e  .    # customer.
-00015d00: 2022 2222 0d0a 2020 2020 230d 0a20 2020   """..    #..   
-00015d10: 2023 2041 7320 6c6f 6e67 2061 7320 6c61   # As long as la
-00015d20: 7365 7220 706f 7765 7220 6973 206d 6f64  ser power is mod
-00015d30: 756c 6174 6564 2075 7369 6e67 2061 2070  ulated using a p
-00015d40: 6572 696f 6420 6f66 2031 3030 7573 2c0d  eriod of 100us,.
-00015d50: 0a20 2020 2023 2077 6974 6820 6120 6e65  .    # with a ne
-00015d60: 6365 7373 6172 696c 792d 696e 7465 6772  cessarily-integr
-00015d70: 616c 2070 756c 7365 2077 6964 7468 206f  al pulse width o
-00015d80: 6620 312d 3939 7573 2c20 7468 656e 2069  f 1-99us, then i
-00015d90: 7427 730d 0a20 2020 2023 206e 6f74 2070  t's..    # not p
-00015da0: 6879 7369 6361 6c6c 7920 706f 7373 6962  hysically possib
-00015db0: 6c65 2074 6f20 7375 7070 6f72 7420 6672  le to support fr
-00015dc0: 6163 7469 6f6e 616c 2070 6f77 6572 206c  actional power l
-00015dd0: 6576 656c 732e 0d0a 2020 2020 230d 0a20  evels...    #.. 
-00015de0: 2020 2023 2040 746f 646f 2074 616c 6b20     # @todo talk 
-00015df0: 746f 204a 6173 6f6e 2061 626f 7574 2063  to Jason about c
-00015e00: 6861 6e67 696e 6720 6d6f 6475 6c61 7469  hanging modulati
-00015e10: 6f6e 2050 4552 494f 4420 746f 206c 6f6e  on PERIOD to lon
-00015e20: 6765 720d 0a20 2020 2023 2020 2020 2076  ger..    #     v
-00015e30: 616c 7565 2028 3230 3075 733f 2034 3030  alue (200us? 400
-00015e40: 3f20 3130 3030 3f29 2c20 4f52 2077 6865  ? 1000?), OR whe
-00015e50: 7468 6572 2070 756c 7365 2057 4944 5448  ther pulse WIDTH
-00015e60: 2063 616e 2062 650d 0a20 2020 2023 2020   can be..    #  
-00015e70: 2020 2069 6e20 736d 616c 6c65 7220 756e     in smaller un
-00015e80: 6974 2028 3530 306e 733f 2031 3030 6e73  it (500ns? 100ns
-00015e90: 3f29 0d0a 2020 2020 6465 6620 7365 745f  ?)..    def set_
-00015ea0: 6c61 7365 725f 706f 7765 725f 7065 7263  laser_power_perc
-00015eb0: 5f69 6d6d 6564 6961 7465 2873 656c 662c  _immediate(self,
-00015ec0: 2076 616c 7565 3a20 666c 6f61 7429 3a20   value: float): 
-00015ed0: 2320 2d3e 2053 7065 6374 726f 6d65 7465  # -> Spectromete
-00015ee0: 7252 6573 706f 6e73 6520 0d0a 0d0a 2020  rResponse ....  
-00015ef0: 2020 2020 2020 2320 6c61 7365 7220 6361        # laser ca
-00015f00: 6e20 666c 6963 6b65 7220 6966 2077 6527  n flicker if we'
-00015f10: 7265 206f 6e20 7468 6520 7772 6f6e 6720  re on the wrong 
-00015f20: 4144 433f 0d0a 0d0a 2020 2020 2020 2020  ADC?....        
-00015f30: 2320 646f 6e27 7420 7761 6e74 2061 6e79  # don't want any
-00015f40: 7468 696e 6720 7765 6972 6420 7768 656e  thing weird when
-00015f50: 2070 6173 7369 6e67 206f 7665 7220 5553   passing over US
-00015f60: 420d 0a20 2020 2020 2020 2076 616c 7565  B..        value
-00015f70: 203d 2066 6c6f 6174 286d 6178 2830 2c20   = float(max(0, 
-00015f80: 6d69 6e28 3130 302c 2076 616c 7565 2929  min(100, value))
-00015f90: 290d 0a0d 0a20 2020 2020 2020 2023 2049  )....        # I
-00015fa0: 6620 6675 6c6c 2070 6f77 6572 2028 616e  f full power (an
-00015fb0: 6420 616c 6c6f 7765 6429 2c20 6469 7361  d allowed), disa
-00015fc0: 626c 6520 6d6f 6475 6c61 7469 6f6e 2061  ble modulation a
-00015fd0: 6e64 2065 7869 740d 0a20 2020 2020 2020  nd exit..       
-00015fe0: 2069 6620 7661 6c75 6520 3e3d 2031 3030   if value >= 100
-00015ff0: 3a0d 0a20 2020 2020 2020 2020 2020 2069  :..            i
-00016000: 6620 7365 6c66 2e73 6574 7469 6e67 732e  f self.settings.
-00016010: 7374 6174 652e 6c61 7365 725f 706f 7765  state.laser_powe
-00016020: 725f 7265 7175 6972 655f 6d6f 6475 6c61  r_require_modula
-00016030: 7469 6f6e 3a0d 0a20 2020 2020 2020 2020  tion:..         
-00016040: 2020 2020 2020 206c 6f67 2e64 6562 7567         log.debug
-00016050: 2822 3130 3025 2070 6f77 6572 2072 6571  ("100% power req
-00016060: 7565 7374 6564 2c20 7965 7420 6c61 7365  uested, yet lase
-00016070: 7220 6d6f 6475 6c61 7469 6f6e 2072 6571  r modulation req
-00016080: 7569 7265 642c 2073 6f20 6e6f 7420 6469  uired, so not di
-00016090: 7361 626c 696e 6720 6d6f 6475 6c61 7469  sabling modulati
-000160a0: 6f6e 2229 0d0a 2020 2020 2020 2020 2020  on")..          
-000160b0: 2020 656c 7365 3a0d 0a20 2020 2020 2020    else:..       
-000160c0: 2020 2020 2020 2020 206c 6f67 2e64 6562           log.deb
-000160d0: 7567 2822 5475 726e 696e 6720 6f66 6620  ug("Turning off 
-000160e0: 6c61 7365 7220 6d6f 6475 6c61 7469 6f6e  laser modulation
-000160f0: 2028 6675 6c6c 2070 6f77 6572 2922 290d   (full power)").
-00016100: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00016110: 2073 656c 662e 6e65 7874 5f61 7070 6c69   self.next_appli
-00016120: 6564 5f6c 6173 6572 5f70 6f77 6572 203d  ed_laser_power =
-00016130: 2031 3030 2e30 0d0a 2020 2020 2020 2020   100.0..        
-00016140: 2020 2020 2020 2020 6c6f 672e 6465 6275          log.debu
-00016150: 6728 226e 6578 745f 6170 706c 6965 645f  g("next_applied_
-00016160: 6c61 7365 725f 706f 7765 7220 3d20 3130  laser_power = 10
-00016170: 302e 3022 290d 0a20 2020 2020 2020 2020  0.0")..         
-00016180: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00016190: 6c66 2e73 6574 5f6d 6f64 5f65 6e61 626c  lf.set_mod_enabl
-000161a0: 6528 4661 6c73 6529 0d0a 0d0a 2020 2020  e(False)....    
-000161b0: 2020 2020 7065 7269 6f64 5f75 7320 3d20      period_us = 
-000161c0: 3130 3030 2069 6620 7365 6c66 2e73 6574  1000 if self.set
-000161d0: 7469 6e67 732e 7374 6174 652e 6c61 7365  tings.state.lase
-000161e0: 725f 706f 7765 725f 6869 6768 5f72 6573  r_power_high_res
-000161f0: 6f6c 7574 696f 6e20 656c 7365 2031 3030  olution else 100
-00016200: 0d0a 2020 2020 2020 2020 7769 6474 685f  ..        width_
-00016210: 7573 203d 2069 6e74 2872 6f75 6e64 2831  us = int(round(1
-00016220: 2e30 202a 2076 616c 7565 202a 2070 6572  .0 * value * per
-00016230: 696f 645f 7573 202f 2031 3030 2e30 2c20  iod_us / 100.0, 
-00016240: 3029 2920 2320 6e6f 7465 2074 6861 7420  0)) # note that 
-00016250: 7661 6c75 6520 6973 2069 6e20 7261 6e67  value is in rang
-00016260: 6520 2830 2c20 3130 3029 206e 6f74 2028  e (0, 100) not (
-00016270: 302c 2031 290d 0a0d 0a20 2020 2020 2020  0, 1)....       
-00016280: 2023 2070 756c 7365 2077 6964 7468 2063   # pulse width c
-00016290: 616e 2774 2062 6520 6c6f 6e67 6572 2074  an't be longer t
-000162a0: 6861 6e20 7065 7269 6f64 2c20 6f72 2073  han period, or s
-000162b0: 686f 7274 6572 2074 6861 6e20 3175 730d  horter than 1us.
-000162c0: 0a20 2020 2020 2020 2077 6964 7468 5f75  .        width_u
-000162d0: 7320 3d20 6d61 7828 312c 206d 696e 2877  s = max(1, min(w
-000162e0: 6964 7468 5f75 732c 2070 6572 696f 645f  idth_us, period_
-000162f0: 7573 2929 0d0a 0d0a 2020 2020 2020 2020  us))....        
-00016300: 2320 4368 616e 6765 2074 6865 2070 756c  # Change the pul
-00016310: 7365 2070 6572 696f 642e 2020 4e6f 7465  se period.  Note
-00016320: 2074 6861 7420 7765 2772 6520 6e6f 7420   that we're not 
-00016330: 7061 7273 696e 6720 696e 746f 2034 302d  parsing into 40-
-00016340: 6269 740d 0a20 2020 2020 2020 2023 2062  bit..        # b
-00016350: 6563 6175 7365 2074 6869 7320 696d 706c  ecause this impl
-00016360: 656d 656e 7461 7469 6f6e 2069 7320 6861  ementation is ha
-00016370: 7264 2d63 6f64 6564 2074 6f20 6569 7468  rd-coded to eith
-00016380: 6572 2031 3030 206f 7220 3130 3030 7573  er 100 or 1000us
-00016390: 0d0a 2020 2020 2020 2020 2320 2862 6f74  ..        # (bot
-000163a0: 6820 6669 7474 696e 6720 7765 6c6c 2077  h fitting well w
-000163b0: 6974 6869 6e20 7569 6e74 3136 290d 0a20  ithin uint16).. 
-000163c0: 2020 2020 2020 2072 6573 756c 7420 3d20         result = 
-000163d0: 7365 6c66 2e73 6574 5f6d 6f64 5f70 6572  self.set_mod_per
-000163e0: 696f 645f 7573 2870 6572 696f 645f 7573  iod_us(period_us
-000163f0: 290d 0a20 2020 2020 2020 2023 2069 6620  )..        # if 
-00016400: 7265 7375 6c74 2e64 6174 6120 6973 204e  result.data is N
-00016410: 6f6e 653a 0d0a 2020 2020 2020 2020 2320  one:..        # 
-00016420: 2020 2020 6c6f 672e 6372 6974 6963 616c      log.critical
-00016430: 2822 4861 7264 7761 7265 2046 6169 6c75  ("Hardware Failu
-00016440: 7265 2074 6f20 7365 6e64 206c 6173 6572  re to send laser
-00016450: 206d 6f64 2e20 7075 6c73 6520 7065 7269   mod. pulse peri
-00016460: 6f64 2229 0d0a 2020 2020 2020 2020 2320  od")..        # 
-00016470: 2020 2020 7265 7475 726e 2053 7065 6374      return Spect
-00016480: 726f 6d65 7465 7252 6573 706f 6e73 6528  rometerResponse(
-00016490: 6461 7461 3d46 616c 7365 2c65 7272 6f72  data=False,error
-000164a0: 5f6d 7367 3d22 6661 696c 6564 2074 6f20  _msg="failed to 
-000164b0: 7365 6e64 206c 6173 6572 206d 6f64 2229  send laser mod")
-000164c0: 0d0a 0d0a 2020 2020 2020 2020 2320 5365  ....        # Se
-000164d0: 7420 7468 6520 7075 6c73 6520 7769 6474  t the pulse widt
-000164e0: 6820 746f 2074 6865 2030 2d31 3030 2070  h to the 0-100 p
-000164f0: 6572 6365 6e74 6167 6520 6f66 2070 6f77  ercentage of pow
-00016500: 6572 0d0a 2020 2020 2020 2020 7265 7375  er..        resu
-00016510: 6c74 203d 2073 656c 662e 7365 745f 6d6f  lt = self.set_mo
-00016520: 645f 7769 6474 685f 7573 2877 6964 7468  d_width_us(width
-00016530: 5f75 7329 0d0a 2020 2020 2020 2020 2320  _us)..        # 
-00016540: 6966 2072 6573 756c 742e 6461 7461 2069  if result.data i
-00016550: 7320 4e6f 6e65 3a0d 0a20 2020 2020 2020  s None:..       
-00016560: 2023 2020 2020 206c 6f67 2e63 7269 7469   #     log.criti
-00016570: 6361 6c28 2248 6172 6477 6172 6520 4661  cal("Hardware Fa
-00016580: 696c 7572 6520 746f 2073 656e 6420 7075  ilure to send pu
-00016590: 6c73 6520 7769 6474 6822 290d 0a20 2020  lse width")..   
-000165a0: 2020 2020 2023 2020 2020 2072 6574 7572       #     retur
-000165b0: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
-000165c0: 7370 6f6e 7365 2864 6174 613d 4661 6c73  sponse(data=Fals
-000165d0: 652c 6572 726f 725f 6d73 673d 2266 6169  e,error_msg="fai
-000165e0: 6c65 6420 746f 2073 656e 6420 7075 6c73  led to send puls
-000165f0: 6520 7769 6474 6822 290d 0a0d 0a20 2020  e width")....   
-00016600: 2020 2020 2023 2045 6e61 626c 6520 6d6f       # Enable mo
-00016610: 6475 6c61 7469 6f6e 0d0a 2020 2020 2020  dulation..      
-00016620: 2020 7265 7375 6c74 203d 2073 656c 662e    result = self.
-00016630: 7365 745f 6d6f 645f 656e 6162 6c65 2854  set_mod_enable(T
-00016640: 7275 6529 0d0a 2020 2020 2020 2020 2320  rue)..        # 
-00016650: 6966 2072 6573 756c 742e 6461 7461 2069  if result.data i
-00016660: 7320 4e6f 6e65 3a0d 0a20 2020 2020 2020  s None:..       
-00016670: 2023 2020 2020 206c 6f67 2e63 7269 7469   #     log.criti
-00016680: 6361 6c28 2248 6172 6477 6172 6520 4661  cal("Hardware Fa
-00016690: 696c 7572 6520 746f 2073 656e 6420 6c61  ilure to send la
-000166a0: 7365 7220 6d6f 6475 6c61 7469 6f6e 2229  ser modulation")
-000166b0: 0d0a 2020 2020 2020 2020 2320 2020 2020  ..        #     
-000166c0: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
-000166d0: 7465 7252 6573 706f 6e73 6528 6461 7461  terResponse(data
-000166e0: 3d46 616c 7365 2c65 7272 6f72 5f6d 7367  =False,error_msg
-000166f0: 3d22 6661 696c 6564 2074 6f20 7365 6e64  ="failed to send
-00016700: 206c 6173 6572 206d 6f64 756c 6174 696f   laser modulatio
-00016710: 6e22 290d 0a0d 0a20 2020 2020 2020 206c  n")....        l
-00016720: 6f67 2e64 6562 7567 2822 4c61 7365 7220  og.debug("Laser 
-00016730: 706f 7765 7220 7365 7420 746f 3a20 2564  power set to: %d
-00016740: 222c 2076 616c 7565 290d 0a0d 0a20 2020  ", value)....   
-00016750: 2020 2020 2073 656c 662e 6e65 7874 5f61       self.next_a
-00016760: 7070 6c69 6564 5f6c 6173 6572 5f70 6f77  pplied_laser_pow
-00016770: 6572 203d 2076 616c 7565 0d0a 2020 2020  er = value..    
-00016780: 2020 2020 6c6f 672e 6465 6275 6728 226e      log.debug("n
-00016790: 6578 745f 6170 706c 6965 645f 6c61 7365  ext_applied_lase
-000167a0: 725f 706f 7765 7220 3d20 2573 222c 2073  r_power = %s", s
-000167b0: 656c 662e 6e65 7874 5f61 7070 6c69 6564  elf.next_applied
-000167c0: 5f6c 6173 6572 5f70 6f77 6572 290d 0a0d  _laser_power)...
-000167d0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-000167e0: 7265 7375 6c74 0d0a 0d0a 2020 2020 2323  result....    ##
-000167f0: 0d0a 2020 2020 2320 406e 6f74 6520 6e65  ..    # @note ne
-00016800: 7665 7220 7573 6564 2c20 7072 6f76 6964  ver used, provid
-00016810: 6564 2066 6f72 204f 454d 0d0a 2020 2020  ed for OEM..    
-00016820: 6465 6620 6765 745f 6c61 7365 725f 7465  def get_laser_te
-00016830: 6d70 6572 6174 7572 655f 7365 7470 6f69  mperature_setpoi
-00016840: 6e74 5f72 6177 2873 656c 6629 3a20 2320  nt_raw(self): # 
-00016850: 2d3e 2053 7065 6374 726f 6d65 7465 7252  -> SpectrometerR
-00016860: 6573 706f 6e73 6520 0d0a 2020 2020 2020  esponse ..      
-00016870: 2020 6966 206e 6f74 2073 656c 662e 7365    if not self.se
-00016880: 7474 696e 6773 2e65 6570 726f 6d2e 6861  ttings.eeprom.ha
-00016890: 735f 6c61 7365 723a 0d0a 2020 2020 2020  s_laser:..      
-000168a0: 2020 2020 2020 6c6f 672e 6572 726f 7228        log.error(
-000168b0: 2275 6e61 626c 6520 746f 2063 6f6e 7472  "unable to contr
-000168c0: 6f6c 206c 6173 6572 3a20 4545 5052 4f4d  ol laser: EEPROM
-000168d0: 2072 6570 6f72 7473 206e 6f20 6c61 7365   reports no lase
-000168e0: 7220 696e 7374 616c 6c65 6422 290d 0a20  r installed").. 
-000168f0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00016900: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
-00016910: 7370 6f6e 7365 2864 6174 613d 4e6f 6e65  sponse(data=None
-00016920: 2c65 7272 6f72 5f6d 7367 3d22 6e6f 206c  ,error_msg="no l
-00016930: 6173 6572 2069 6e73 7461 6c6c 6564 2229  aser installed")
-00016940: 0d0a 0d0a 2020 2020 2020 2020 7265 7475  ....        retu
-00016950: 726e 2073 656c 662e 5f67 6574 5f63 6f64  rn self._get_cod
-00016960: 6528 3078 6538 2c20 6c61 6265 6c3d 2247  e(0xe8, label="G
-00016970: 4554 5f4c 4153 4552 5f54 4543 5f53 4554  ET_LASER_TEC_SET
-00016980: 504f 494e 5422 290d 0a0d 0a20 2020 2064  POINT")....    d
-00016990: 6566 2073 6574 5f6c 6173 6572 5f74 656d  ef set_laser_tem
-000169a0: 7065 7261 7475 7265 5f73 6574 706f 696e  perature_setpoin
-000169b0: 745f 7261 7728 7365 6c66 2c20 7661 6c75  t_raw(self, valu
-000169c0: 653a 2069 6e74 293a 2023 202d 3e20 5370  e: int): # -> Sp
-000169d0: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-000169e0: 7365 200d 0a20 2020 2020 2020 206c 6f67  se ..        log
-000169f0: 2e64 6562 7567 2866 2253 656e 6420 6c61  .debug(f"Send la
-00016a00: 7365 7220 7465 6d70 6572 6174 7572 6520  ser temperature 
-00016a10: 7365 7470 6f69 6e74 2072 6177 3a20 3078  setpoint raw: 0x
-00016a20: 7b76 616c 7565 3a30 3378 7d22 290d 0a20  {value:03x}").. 
-00016a30: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00016a40: 6c66 2e5f 7365 6e64 5f63 6f64 6528 3078  lf._send_code(0x
-00016a50: 6537 2c20 7661 6c75 652c 206c 6162 656c  e7, value, label
-00016a60: 3d22 5345 545f 4c41 5345 525f 5445 435f  ="SET_LASER_TEC_
-00016a70: 5345 5450 4f49 4e54 2229 0d0a 0d0a 2020  SETPOINT")....  
-00016a80: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
-00016a90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00016aa0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00016ab0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00016ac0: 2323 2323 2323 2323 2323 2323 2323 0d0a  ##############..
-00016ad0: 2020 2020 2320 6469 6769 7461 6c20 706f      # digital po
-00016ae0: 7420 6f6e 2032 3230 3235 3020 5265 7634  t on 220250 Rev4
-00016af0: 412b 0d0a 2020 2020 2323 2323 2323 2323  A+..    ########
-00016b00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00016b10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00016b20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00016b30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00016b40: 2323 2323 0d0a 0d0a 2020 2020 6465 6620  ####....    def 
-00016b50: 7365 745f 6c61 7365 725f 706f 7765 725f  set_laser_power_
-00016b60: 6174 7465 6e75 6174 6f72 2873 656c 662c  attenuator(self,
-00016b70: 2076 616c 7565 293a 0d0a 2020 2020 2020   value):..      
-00016b80: 2020 636d 6420 3d20 2253 4554 5f4c 4153    cmd = "SET_LAS
-00016b90: 4552 5f41 5454 454e 5541 544f 5222 0d0a  ER_ATTENUATOR"..
-00016ba0: 2020 2020 2020 2020 6966 206e 6f74 2073          if not s
-00016bb0: 656c 662e 7365 7474 696e 6773 2e69 735f  elf.settings.is_
-00016bc0: 7873 2829 3a0d 0a20 2020 2020 2020 2020  xs():..         
-00016bd0: 2020 206d 7367 203d 2066 227b 636d 647d     msg = f"{cmd}
-00016be0: 2069 7320 6f6e 6c79 2061 7661 696c 6162   is only availab
-00016bf0: 6c65 206f 6e20 5853 2d53 6572 6965 7320  le on XS-Series 
-00016c00: 7769 7468 2032 3230 3235 3020 5265 7634  with 220250 Rev4
-00016c10: 412b 220d 0a20 2020 2020 2020 2020 2020  A+"..           
-00016c20: 206c 6f67 2e64 6562 7567 286d 7367 290d   log.debug(msg).
-00016c30: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00016c40: 7572 6e20 5370 6563 7472 6f6d 6574 6572  urn Spectrometer
-00016c50: 5265 7370 6f6e 7365 2864 6174 613d 4e6f  Response(data=No
-00016c60: 6e65 2c20 6572 726f 725f 6d73 673d 6d73  ne, error_msg=ms
-00016c70: 6729 0d0a 0d0a 2020 2020 2020 2020 2320  g)....        # 
-00016c80: 6469 6769 7461 6c20 706f 7465 6e74 696f  digital potentio
-00016c90: 6d65 7465 7220 6973 2038 2d62 6974 0d0a  meter is 8-bit..
-00016ca0: 2020 2020 2020 2020 7661 6c75 6520 3d20          value = 
-00016cb0: 6d61 7828 302c 206d 696e 2830 7866 662c  max(0, min(0xff,
-00016cc0: 2069 6e74 2872 6f75 6e64 2876 616c 7565   int(round(value
-00016cd0: 2929 2929 0d0a 0d0a 2020 2020 2020 2020  ))))....        
-00016ce0: 7265 7475 726e 2073 656c 662e 5f73 656e  return self._sen
-00016cf0: 645f 636f 6465 2830 7838 322c 2076 616c  d_code(0x82, val
-00016d00: 7565 2c20 6c61 6265 6c3d 636d 6429 0d0a  ue, label=cmd)..
-00016d10: 0d0a 2020 2020 6465 6620 6765 745f 6c61  ..    def get_la
-00016d20: 7365 725f 706f 7765 725f 6174 7465 6e75  ser_power_attenu
-00016d30: 6174 6f72 2873 656c 6629 3a0d 0a20 2020  ator(self):..   
-00016d40: 2020 2020 2063 6d64 203d 2022 4745 545f       cmd = "GET_
-00016d50: 4c41 5345 525f 4154 5445 4e55 4154 4f52  LASER_ATTENUATOR
-00016d60: 220d 0a20 2020 2020 2020 2069 6620 6e6f  "..        if no
-00016d70: 7420 7365 6c66 2e73 6574 7469 6e67 732e  t self.settings.
-00016d80: 6973 5f78 7328 293a 0d0a 2020 2020 2020  is_xs():..      
-00016d90: 2020 2020 2020 6d73 6720 3d20 6622 7b63        msg = f"{c
-00016da0: 6d64 7d20 6973 206f 6e6c 7920 6176 6169  md} is only avai
-00016db0: 6c61 626c 6520 6f6e 2058 532d 5365 7269  lable on XS-Seri
-00016dc0: 6573 2077 6974 6820 3232 3032 3530 2052  es with 220250 R
-00016dd0: 6576 3441 2b22 0d0a 2020 2020 2020 2020  ev4A+"..        
-00016de0: 2020 2020 6c6f 672e 6465 6275 6728 6d73      log.debug(ms
-00016df0: 6729 0d0a 2020 2020 2020 2020 2020 2020  g)..            
-00016e00: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
-00016e10: 7465 7252 6573 706f 6e73 6528 6461 7461  terResponse(data
-00016e20: 3d4e 6f6e 652c 2065 7272 6f72 5f6d 7367  =None, error_msg
-00016e30: 3d6d 7367 290d 0a0d 0a20 2020 2020 2020  =msg)....       
-00016e40: 2072 6574 7572 6e20 7365 6c66 2e5f 6765   return self._ge
-00016e50: 745f 636f 6465 2830 7838 332c 206d 7362  t_code(0x83, msb
-00016e60: 5f6c 656e 3d31 2c20 6c61 6265 6c3d 636d  _len=1, label=cm
-00016e70: 6429 0d0a 0d0a 2020 2020 2323 2323 2323  d)....    ######
-00016e80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00016e90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00016ea0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00016eb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00016ec0: 2323 2323 2323 0d0a 2020 2020 2320 6c61  ######..    # la
-00016ed0: 7365 7220 696e 7465 726c 6f63 6b0d 0a20  ser interlock.. 
-00016ee0: 2020 2023 2323 2323 2323 2323 2323 2323     #############
-00016ef0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00016f00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00016f10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00016f20: 2323 2323 2323 2323 2323 2323 2323 230d  ###############.
-00016f30: 0a0d 0a20 2020 2064 6566 2067 6574 5f6c  ...    def get_l
-00016f40: 6173 6572 5f69 6e74 6572 6c6f 636b 2873  aser_interlock(s
-00016f50: 656c 6629 3a20 2320 2d3e 2053 7065 6374  elf): # -> Spect
-00016f60: 726f 6d65 7465 7252 6573 706f 6e73 6520  rometerResponse 
-00016f70: 0d0a 2020 2020 2020 2020 2222 2220 4c65  ..        """ Le
-00016f80: 6761 6379 2077 7261 7070 6572 206f 7665  gacy wrapper ove
-00016f90: 7220 6361 6e5f 6c61 7365 725f 6669 7265  r can_laser_fire
-00016fa0: 2e20 2222 220d 0a20 2020 2020 2020 2072  . """..        r
-00016fb0: 6574 7572 6e20 7365 6c66 2e63 616e 5f6c  eturn self.can_l
-00016fc0: 6173 6572 5f66 6972 6528 290d 0a0d 0a20  aser_fire().... 
-00016fd0: 2020 2064 6566 2063 616e 5f6c 6173 6572     def can_laser
-00016fe0: 5f66 6972 6528 7365 6c66 293a 2023 202d  _fire(self): # -
-00016ff0: 3e20 5370 6563 7472 6f6d 6574 6572 5265  > SpectrometerRe
-00017000: 7370 6f6e 7365 200d 0a20 2020 2020 2020  sponse ..       
-00017010: 2022 2222 0d0a 2020 2020 2020 2020 406e   """..        @n
-00017020: 6f74 6520 6f6e 6c79 2077 6f72 6b73 206f  ote only works o
-00017030: 6e20 4658 322d 6261 7365 6420 7370 6563  n FX2-based spec
-00017040: 7472 6f6d 6574 6572 7320 7769 7468 2046  trometers with F
-00017050: 5720 3e3d 2031 302e 302e 302e 3131 0d0a  W >= 10.0.0.11..
-00017060: 2020 2020 2020 2020 4072 6574 7572 6e73          @returns
-00017070: 2054 7275 6520 6966 2074 6865 7265 2069   True if there i
-00017080: 7320 6120 6c61 7365 7220 616e 6420 6569  s a laser and ei
-00017090: 7468 6572 2074 6865 2069 6e74 6572 6c6f  ther the interlo
-000170a0: 636b 2069 730d 0a20 2020 2020 2020 2020  ck is..         
-000170b0: 636c 6f73 6564 2028 696e 2066 6972 696e  closed (in firin
-000170c0: 6720 706f 7369 7469 6f6e 292c 206f 7220  g position), or 
-000170d0: 7468 6572 6520 6973 206e 6f20 7265 6164  there is no read
-000170e0: 6162 6c65 0d0a 2020 2020 2020 2020 2069  able..         i
-000170f0: 6e74 6572 6c6f 636b 0d0a 2020 2020 2020  nterlock..      
-00017100: 2020 2222 220d 0a20 2020 2020 2020 2069    """..        i
-00017110: 6620 6e6f 7420 7365 6c66 2e73 6574 7469  f not self.setti
-00017120: 6e67 732e 6565 7072 6f6d 2e68 6173 5f6c  ngs.eeprom.has_l
-00017130: 6173 6572 3a0d 0a20 2020 2020 2020 2020  aser:..         
-00017140: 2020 206c 6f67 2e65 7272 6f72 2822 4545     log.error("EE
-00017150: 5052 4f4d 2072 6570 6f72 7473 206e 6f20  PROM reports no 
-00017160: 6c61 7365 7220 696e 7374 616c 6c65 6422  laser installed"
-00017170: 290d 0a20 2020 2020 2020 2020 2020 2072  )..            r
-00017180: 6574 7572 6e20 5370 6563 7472 6f6d 6574  eturn Spectromet
-00017190: 6572 5265 7370 6f6e 7365 2864 6174 613d  erResponse(data=
-000171a0: 4661 6c73 652c 6572 726f 725f 6d73 673d  False,error_msg=
-000171b0: 226e 6f20 6c61 7365 7220 696e 7374 616c  "no laser instal
-000171c0: 6c65 6422 290d 0a0d 0a20 2020 2020 2020  led")....       
-000171d0: 2069 6620 6e6f 7420 7365 6c66 2e73 6574   if not self.set
-000171e0: 7469 6e67 732e 6565 7072 6f6d 2e68 6173  tings.eeprom.has
-000171f0: 5f69 6e74 6572 6c6f 636b 5f66 6565 6462  _interlock_feedb
-00017200: 6163 6b3a 0d0a 2020 2020 2020 2020 2020  ack:..          
-00017210: 2020 6c6f 672e 6465 6275 6728 2243 414e    log.debug("CAN
-00017220: 5f4c 4153 4552 5f46 4952 4520 7265 7175  _LASER_FIRE requ
-00017230: 6972 6573 2068 6173 5f69 6e74 6572 6c6f  ires has_interlo
-00017240: 636b 5f66 6565 6462 6163 6b20 2864 6566  ck_feedback (def
-00017250: 6175 6c74 696e 6720 5472 7565 2922 290d  aulting True)").
-00017260: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00017270: 7572 6e20 5370 6563 7472 6f6d 6574 6572  urn Spectrometer
-00017280: 5265 7370 6f6e 7365 2864 6174 613d 5472  Response(data=Tr
-00017290: 7565 290d 0a0d 0a20 2020 2020 2020 2072  ue)....        r
-000172a0: 6573 203d 2073 656c 662e 5f67 6574 5f63  es = self._get_c
-000172b0: 6f64 6528 3078 6566 2c20 6c61 6265 6c3d  ode(0xef, label=
-000172c0: 2243 414e 5f4c 4153 4552 5f46 4952 4522  "CAN_LASER_FIRE"
-000172d0: 2c20 6d73 625f 6c65 6e3d 3129 0d0a 2020  , msb_len=1)..  
-000172e0: 2020 2020 2020 7265 732e 6461 7461 203d        res.data =
-000172f0: 2030 2021 3d20 7265 732e 6461 7461 0d0a   0 != res.data..
-00017300: 2020 2020 2020 2020 7265 7475 726e 2072          return r
-00017310: 6573 0d0a 0d0a 2020 2020 6465 6620 6973  es....    def is
-00017320: 5f6c 6173 6572 5f66 6972 696e 6728 7365  _laser_firing(se
-00017330: 6c66 293a 2023 202d 3e20 5370 6563 7472  lf): # -> Spectr
-00017340: 6f6d 6574 6572 5265 7370 6f6e 7365 200d  ometerResponse .
-00017350: 0a20 2020 2020 2020 2022 2222 0d0a 2020  .        """..  
-00017360: 2020 2020 2020 4368 6563 6b20 6966 2074        Check if t
-00017370: 6865 206c 6173 6572 2061 6374 7561 6c6c  he laser actuall
-00017380: 7920 4953 2066 6972 696e 672c 2069 6e64  y IS firing, ind
-00017390: 6570 656e 6465 6e74 206f 6620 6c61 7365  ependent of lase
-000173a0: 725f 656e 6162 6c65 206f 7220 0d0a 2020  r_enable or ..  
-000173b0: 2020 2020 2020 6361 6e5f 6c61 7365 725f        can_laser_
-000173c0: 6669 7265 2e0d 0a0d 0a20 2020 2020 2020  fire.....       
-000173d0: 2040 7265 7475 726e 7320 5370 6563 7472   @returns Spectr
-000173e0: 6f6d 6574 6572 5265 7370 6f6e 7365 0d0a  ometerResponse..
-000173f0: 2020 2020 2020 2020 2222 220d 0a20 2020          """..   
-00017400: 2020 2020 2069 6620 6e6f 7420 7365 6c66       if not self
-00017410: 2e73 6574 7469 6e67 732e 6565 7072 6f6d  .settings.eeprom
-00017420: 2e68 6173 5f69 6e74 6572 6c6f 636b 5f66  .has_interlock_f
-00017430: 6565 6462 6163 6b3a 0d0a 2020 2020 2020  eedback:..      
-00017440: 2020 2020 2020 6c6f 672e 6465 6275 6728        log.debug(
-00017450: 2249 535f 4c41 5345 525f 4649 5249 4e47  "IS_LASER_FIRING
-00017460: 2072 6571 7569 7265 7320 6861 735f 696e   requires has_in
-00017470: 7465 726c 6f63 6b5f 6665 6564 6261 636b  terlock_feedback
-00017480: 2028 6465 6661 756c 7469 6e67 2074 6f20   (defaulting to 
-00017490: 6c61 7365 725f 656e 6162 6c65 6429 2229  laser_enabled)")
-000174a0: 0d0a 2020 2020 2020 2020 2020 2020 7265  ..            re
-000174b0: 7475 726e 2073 656c 662e 6765 745f 6c61  turn self.get_la
-000174c0: 7365 725f 656e 6162 6c65 6428 290d 0a0d  ser_enabled()...
-000174d0: 0a20 2020 2020 2020 2072 6573 203d 2073  .        res = s
-000174e0: 656c 662e 6765 745f 7570 7065 725f 636f  elf.get_upper_co
-000174f0: 6465 2830 7830 642c 206c 6162 656c 3d22  de(0x0d, label="
-00017500: 4953 5f4c 4153 4552 5f46 4952 494e 4722  IS_LASER_FIRING"
-00017510: 2c20 6d73 625f 6c65 6e3d 3129 0d0a 2020  , msb_len=1)..  
-00017520: 2020 2020 2020 7265 732e 6461 7461 203d        res.data =
-00017530: 2030 2021 3d20 7265 732e 6461 7461 0d0a   0 != res.data..
-00017540: 2020 2020 2020 2020 7265 7475 726e 2072          return r
-00017550: 6573 0d0a 0d0a 2020 2020 2323 2323 2323  es....    ######
-00017560: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00017570: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00017580: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00017590: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000175a0: 2323 2323 2323 0d0a 2020 2020 2320 2865  ######..    # (e
-000175b0: 6e64 206f 6620 6c61 7365 7220 636f 6d6d  nd of laser comm
-000175c0: 616e 6473 290d 0a20 2020 2023 2323 2323  ands)..    #####
-000175d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000175e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000175f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00017600: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00017610: 2323 2323 2323 230d 0a0d 0a20 2020 2064  #######....    d
-00017620: 6566 2072 6573 6574 5f66 7067 6128 7365  ef reset_fpga(se
-00017630: 6c66 293a 2023 202d 3e20 5370 6563 7472  lf): # -> Spectr
-00017640: 6f6d 6574 6572 5265 7370 6f6e 7365 200d  ometerResponse .
-00017650: 0a20 2020 2020 2020 206c 6f67 2e64 6562  .        log.deb
-00017660: 7567 2822 6669 643a 2072 6573 6574 7469  ug("fid: resetti
-00017670: 6e67 2046 5047 4122 290d 0a20 2020 2020  ng FPGA")..     
-00017680: 2020 2072 6573 756c 7420 3d20 7365 6c66     result = self
-00017690: 2e5f 7365 6e64 5f63 6f64 6528 3078 6235  ._send_code(0xb5
-000176a0: 2c20 6c61 6265 6c3d 2252 4553 4554 5f46  , label="RESET_F
-000176b0: 5047 4122 290d 0a20 2020 2020 2020 206c  PGA")..        l
-000176c0: 6f67 2e64 6562 7567 2822 6669 643a 2073  og.debug("fid: s
-000176d0: 6c65 6570 696e 6720 3373 6563 2229 0d0a  leeping 3sec")..
-000176e0: 2020 2020 2020 2020 736c 6565 7028 3329          sleep(3)
-000176f0: 0d0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-00017700: 2072 6573 756c 740d 0a0d 0a20 2020 2023   result....    #
-00017710: 230d 0a20 2020 2023 2052 6561 6420 7468  #..    # Read th
-00017720: 6520 7472 6967 6765 7220 736f 7572 6365  e trigger source
-00017730: 2073 6574 7469 6e67 2066 726f 6d20 7468   setting from th
-00017740: 6520 6465 7669 6365 2e0d 0a20 2020 2023  e device...    #
-00017750: 0d0a 2020 2020 2320 2d20 3020 3d20 696e  ..    # - 0 = in
-00017760: 7465 726e 616c 0d0a 2020 2020 2320 2d20  ternal..    # - 
-00017770: 3120 3d20 6578 7465 726e 616c 0d0a 2020  1 = external..  
-00017780: 2020 230d 0a20 2020 2023 2055 7365 2063    #..    # Use c
-00017790: 6175 7469 6f6e 2077 6865 6e20 696e 7465  aution when inte
-000177a0: 7270 7265 7469 6e67 2074 6865 206c 6172  rpreting the lar
-000177b0: 6765 7220 6265 6861 7669 6f72 206f 660d  ger behavior of.
-000177c0: 0a20 2020 2023 2074 6865 2064 6576 6963  .    # the devic
-000177d0: 6520 6173 2041 524d 2061 6e64 2046 5832  e as ARM and FX2
-000177e0: 2069 6d70 6c65 6d65 6e74 6174 696f 6e73   implementations
-000177f0: 2064 6966 6665 7220 6173 206f 6620 3230   differ as of 20
-00017800: 3137 2d30 382d 3032 0d0a 2020 2020 230d  17-08-02..    #.
-00017810: 0a20 2020 2023 2040 6e6f 7465 206e 6576  .    # @note nev
-00017820: 6572 2063 616c 6c65 6420 6279 2045 4e4c  er called by ENL
-00017830: 4947 4854 454e 202d 2070 726f 7669 6465  IGHTEN - provide
-00017840: 6420 666f 7220 4f45 4d73 0d0a 2020 2020  d for OEMs..    
-00017850: 6465 6620 6765 745f 7472 6967 6765 725f  def get_trigger_
-00017860: 736f 7572 6365 2873 656c 6629 3a20 2320  source(self): # 
-00017870: 2d3e 2053 7065 6374 726f 6d65 7465 7252  -> SpectrometerR
-00017880: 6573 706f 6e73 6520 0d0a 2020 2020 2020  esponse ..      
-00017890: 2020 7661 6c75 6520 3d20 7365 6c66 2e5f    value = self._
-000178a0: 6765 745f 636f 6465 2830 7864 332c 206c  get_code(0xd3, l
-000178b0: 6162 656c 3d22 4745 545f 5452 4947 4745  abel="GET_TRIGGE
-000178c0: 525f 534f 5552 4345 222c 206d 7362 5f6c  R_SOURCE", msb_l
-000178d0: 656e 3d31 290d 0a20 2020 2020 2020 2073  en=1)..        s
-000178e0: 656c 662e 7365 7474 696e 6773 2e73 7461  elf.settings.sta
-000178f0: 7465 2e74 7269 6767 6572 5f73 6f75 7263  te.trigger_sourc
-00017900: 6520 3d20 7661 6c75 652e 6461 7461 0d0a  e = value.data..
-00017910: 2020 2020 2020 2020 7265 7475 726e 2076          return v
-00017920: 616c 7565 0d0a 0d0a 2020 2020 2323 0d0a  alue....    ##..
-00017930: 2020 2020 2320 406e 6f74 6520 6e6f 7420      # @note not 
-00017940: 6361 6c6c 6564 2062 7920 454e 4c49 4748  called by ENLIGH
-00017950: 5445 4e0d 0a20 2020 2023 2040 7761 726e  TEN..    # @warn
-00017960: 696e 6720 636f 6e66 6c69 6374 7320 7769  ing conflicts wi
-00017970: 7468 2047 4554 5f53 454c 4543 5445 445f  th GET_SELECTED_
-00017980: 4c41 5345 520d 0a20 2020 2064 6566 2067  LASER..    def g
-00017990: 6574 5f72 616d 616e 5f6d 6f64 655f 656e  et_raman_mode_en
-000179a0: 6162 6c65 645f 4e4f 545f 5553 4544 2873  abled_NOT_USED(s
-000179b0: 656c 6629 3a20 2320 2d3e 2053 7065 6374  elf): # -> Spect
-000179c0: 726f 6d65 7465 7252 6573 706f 6e73 6520  rometerResponse 
-000179d0: 0d0a 2020 2020 2020 2020 7265 7320 3d20  ..        res = 
-000179e0: 7365 6c66 2e67 6574 5f75 7070 6572 5f63  self.get_upper_c
-000179f0: 6f64 6528 3078 3135 2c20 6c61 6265 6c3d  ode(0x15, label=
-00017a00: 2247 4554 5f52 414d 414e 5f4d 4f44 455f  "GET_RAMAN_MODE_
-00017a10: 454e 4142 4c45 4422 2c20 6d73 625f 6c65  ENABLED", msb_le
-00017a20: 6e3d 3129 0d0a 2020 2020 2020 2020 7265  n=1)..        re
-00017a30: 732e 6461 7461 203d 2030 2021 3d20 7265  s.data = 0 != re
-00017a40: 732e 6461 7461 0d0a 2020 2020 2020 2020  s.data..        
-00017a50: 7265 7475 726e 2072 6573 0d0a 0d0a 2020  return res....  
-00017a60: 2020 2323 0d0a 2020 2020 2320 456e 6162    ##..    # Enab
-00017a70: 6c65 2022 5261 6d61 6e20 6d6f 6465 2220  le "Raman mode" 
-00017a80: 2861 7574 6f6d 6174 6963 206c 6173 6572  (automatic laser
-00017a90: 2920 696e 2074 6865 2073 7065 6374 726f  ) in the spectro
-00017aa0: 6d65 7465 7220 6669 726d 7761 7265 2e0d  meter firmware..
-00017ab0: 0a20 2020 2064 6566 2073 6574 5f72 616d  .    def set_ram
-00017ac0: 616e 5f6d 6f64 655f 656e 6162 6c65 5f4e  an_mode_enable_N
-00017ad0: 4f54 5f55 5345 4428 7365 6c66 2c20 666c  OT_USED(self, fl
-00017ae0: 6167 3a20 626f 6f6c 293a 2023 202d 3e20  ag: bool): # -> 
-00017af0: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
-00017b00: 6f6e 7365 200d 0a20 2020 2020 2020 2069  onse ..        i
-00017b10: 6620 6e6f 7420 7365 6c66 2e73 6574 7469  f not self.setti
-00017b20: 6e67 732e 6973 5f6d 6963 726f 2829 3a0d  ngs.is_micro():.
-00017b30: 0a20 2020 2020 2020 2020 2020 206c 6f67  .            log
-00017b40: 2e64 6562 7567 2822 5261 6d61 6e20 6d6f  .debug("Raman mo
-00017b50: 6465 206f 6e6c 7920 7375 7070 6f72 7465  de only supporte
-00017b60: 6420 6f6e 2053 6572 6965 732d 5853 2229  d on Series-XS")
-00017b70: 0d0a 2020 2020 2020 2020 2020 2020 7265  ..            re
-00017b80: 7475 726e 2053 7065 6374 726f 6d65 7465  turn Spectromete
-00017b90: 7252 6573 706f 6e73 6528 6461 7461 3d46  rResponse(data=F
-00017ba0: 616c 7365 2c65 7272 6f72 5f6d 7367 3d22  alse,error_msg="
-00017bb0: 7261 6d61 6e20 6d6f 6465 206e 6f74 2073  raman mode not s
-00017bc0: 7570 706f 7274 6564 2229 0d0a 0d0a 2020  upported")....  
-00017bd0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-00017be0: 662e 5f73 656e 645f 636f 6465 2862 5265  f._send_code(bRe
-00017bf0: 7175 6573 7420 2020 2020 2020 203d 2030  quest        = 0
-00017c00: 7866 662c 0d0a 2020 2020 2020 2020 2020  xff,..          
-00017c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017c20: 2020 2020 7756 616c 7565 2020 2020 2020      wValue      
-00017c30: 2020 2020 3d20 3078 3136 2c0d 0a20 2020      = 0x16,..   
+0000f160: 2020 2020 206c 6f67 2e65 7272 6f72 2822       log.error("
+0000f170: 6765 745f 6c69 6e65 3a20 6d61 726b 6572  get_line: marker
+0000f180: 2066 6f75 6e64 2061 7420 7069 7865 6c20   found at pixel 
+0000f190: 2564 222c 2069 290a 0a20 2020 2020 2020  %d", i)..       
+0000f1a0: 2023 2063 6f6e 7369 6465 7220 736b 6970   # consider skip
+0000f1b0: 7069 6e67 206d 7563 6820 6f66 2074 6865  ping much of the
+0000f1c0: 2066 6f6c 6c6f 7769 6e67 2069 6620 696e   following if in
+0000f1d0: 2061 7265 6120 7363 616e 206d 6f64 650a   area scan mode.
+0000f1e0: 0a20 2020 2020 2020 2023 2323 2323 2323  .        #######
+0000f1f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f200: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f210: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f220: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f230: 230a 2020 2020 2020 2020 2320 5374 6f6d  #.        # Stom
+0000f240: 7020 6172 7261 7920 656e 6473 0a20 2020  p array ends.   
+0000f250: 2020 2020 2023 2323 2323 2323 2323 2323       ###########
+0000f260: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f270: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f280: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f290: 2323 2323 2323 2323 2323 2323 230a 0a20  #############.. 
+0000f2a0: 2020 2020 2020 2023 2028 6265 666f 7265         # (before
+0000f2b0: 2078 2d61 7869 7320 696e 7665 7273 696f   x-axis inversio
+0000f2c0: 6e20 6265 6361 7573 6520 6f70 7469 6361  n because optica
+0000f2d0: 6c6c 7920 6d61 736b 6564 2070 6978 656c  lly masked pixel
+0000f2e0: 7320 6172 6520 7068 7973 6963 616c 290a  s are physical).
+0000f2f0: 0a20 2020 2020 2020 2023 2073 6f6d 6520  .        # some 
+0000f300: 6465 7465 6374 6f72 7320 6861 7665 2022  detectors have "
+0000f310: 6761 7262 6167 6522 2070 6978 656c 7320  garbage" pixels 
+0000f320: 6174 2074 6865 2066 726f 6e74 206f 7220  at the front or 
+0000f330: 656e 6420 6f66 2065 7665 7279 0a20 2020  end of every.   
+0000f340: 2020 2020 2023 2073 7065 6374 7275 6d20       # spectrum 
+0000f350: 2873 796e 6320 6279 7465 7320 616e 6420  (sync bytes and 
+0000f360: 7768 6174 2d6e 6f74 290a 2020 2020 2020  what-not).      
+0000f370: 2020 6966 2073 656c 662e 7365 7474 696e    if self.settin
+0000f380: 6773 2e69 735f 6d69 6372 6f28 2920 616e  gs.is_micro() an
+0000f390: 6420 7365 6c66 2e73 6574 7469 6e67 732e  d self.settings.
+0000f3a0: 7374 6174 652e 6465 7465 6374 6f72 5f72  state.detector_r
+0000f3b0: 6567 696f 6e73 2069 7320 4e6f 6e65 3a0a  egions is None:.
+0000f3c0: 2020 2020 2020 2020 2020 2020 6966 2073              if s
+0000f3d0: 656c 662e 7365 7474 696e 6773 2e69 735f  elf.settings.is_
+0000f3e0: 696d 7833 3932 2829 3a0a 2020 2020 2020  imx392():.      
+0000f3f0: 2020 2020 2020 2020 2020 7574 696c 732e            utils.
+0000f400: 7374 6f6d 705f 6669 7273 7428 7370 6563  stomp_first(spec
+0000f410: 7472 756d 2c20 3329 0a20 2020 2020 2020  trum, 3).       
+0000f420: 2020 2020 2020 2020 2075 7469 6c73 2e73           utils.s
+0000f430: 746f 6d70 5f6c 6173 7420 2873 7065 6374  tomp_last (spect
+0000f440: 7275 6d2c 2031 3729 0a20 2020 2020 2020  rum, 17).       
+0000f450: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+0000f460: 2020 2020 2020 2020 2020 2023 2070 7265             # pre
+0000f470: 7375 6d61 626c 7920 494d 5833 3835 0a20  sumably IMX385. 
+0000f480: 2020 2020 2020 2020 2020 2020 2020 2075                 u
+0000f490: 7469 6c73 2e73 746f 6d70 5f66 6972 7374  tils.stomp_first
+0000f4a0: 2873 7065 6374 7275 6d2c 2033 290a 2020  (spectrum, 3).  
+0000f4b0: 2020 2020 2020 2020 2020 2020 2020 7574                ut
+0000f4c0: 696c 732e 7374 6f6d 705f 6c61 7374 2028  ils.stomp_last (
+0000f4d0: 7370 6563 7472 756d 2c20 3129 0a0a 2020  spectrum, 1)..  
+0000f4e0: 2020 2020 2020 2323 2323 2323 2323 2323        ##########
+0000f4f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f500: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f510: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f520: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
+0000f530: 2020 2020 2020 2023 2045 6c65 6374 7269         # Electri
+0000f540: 6361 6c20 4461 726b 2043 6f72 7265 6374  cal Dark Correct
+0000f550: 696f 6e20 2845 4443 2c20 6578 7065 7269  ion (EDC, experi
+0000f560: 6d65 6e74 616c 290a 2020 2020 2020 2020  mental).        
+0000f570: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f580: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f590: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f5a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f5b0: 2323 2323 2323 2323 0a0a 2020 2020 2020  ########..      
+0000f5c0: 2020 7370 6563 7472 756d 203d 2073 656c    spectrum = sel
+0000f5d0: 662e 6170 706c 795f 6564 6328 7370 6563  f.apply_edc(spec
+0000f5e0: 7472 756d 290a 0a20 2020 2020 2020 2023  trum)..        #
+0000f5f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f600: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f610: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f620: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f630: 2323 2323 2323 230a 2020 2020 2020 2020  #######.        
+0000f640: 2320 496e 7665 7274 2058 2d41 7869 730a  # Invert X-Axis.
+0000f650: 2020 2020 2020 2020 2323 2323 2323 2323          ########
+0000f660: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f670: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f680: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f690: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f6a0: 0a0a 2020 2020 2020 2020 2320 466f 7220  ..        # For 
+0000f6b0: 6265 6e63 6865 7320 7768 6572 6520 7468  benches where th
+0000f6c0: 6520 6465 7465 6374 6f72 2069 7320 6573  e detector is es
+0000f6d0: 7365 6e74 6961 6c6c 7920 726f 7461 7465  sentially rotate
+0000f6e0: 6420 3138 302d 6465 6720 6672 6f6d 206f  d 180-deg from o
+0000f6f0: 7572 0a20 2020 2020 2020 2023 2074 7970  ur.        # typ
+0000f700: 6963 616c 206f 7269 656e 7461 7469 6f6e  ical orientation
+0000f710: 2077 6974 6820 7265 6761 7264 2074 6f20   with regard to 
+0000f720: 7468 6520 6772 6174 696e 6720 2865 2e67  the grating (e.g
+0000f730: 2e20 496e 4761 4173 204f 454d 0a20 2020  . InGaAs OEM.   
+0000f740: 2020 2020 2023 2062 656e 6368 6573 2c20       # benches, 
+0000f750: 7768 6572 6520 7265 6420 7761 7665 6c65  where red wavele
+0000f760: 6e67 7468 7320 6172 6520 6469 6666 7261  ngths are diffra
+0000f770: 6374 6564 2074 6f77 6172 6420 7069 7865  cted toward pixe
+0000f780: 6c20 302c 2061 6e64 2062 6c75 650a 2020  l 0, and blue.  
+0000f790: 2020 2020 2020 2320 7761 7665 6c65 6e67        # waveleng
+0000f7a0: 7468 7320 746f 7761 7264 2070 6978 656c  ths toward pixel
+0000f7b0: 2035 3131 292e 0a20 2020 2020 2020 2023   511)..        #
+0000f7c0: 0a20 2020 2020 2020 2023 204e 6f74 6520  .        # Note 
+0000f7d0: 7468 6973 2073 696d 706c 7920 7065 7266  this simply perf
+0000f7e0: 6f72 6d73 2061 2068 6f72 697a 6f6e 7461  orms a horizonta
+0000f7f0: 6c20 464c 4950 2028 6d69 7272 6f72 2920  l FLIP (mirror) 
+0000f800: 6f66 2074 6865 2076 6572 7469 6361 6c6c  of the verticall
+0000f810: 792d 0a20 2020 2020 2020 2023 2062 696e  y-.        # bin
+0000f820: 6e65 6420 312d 4420 7370 6563 7472 612c  ned 1-D spectra,
+0000f830: 2061 6e64 2069 7320 4e4f 5420 7375 6666   and is NOT suff
+0000f840: 6963 6965 6e74 2074 6f20 7065 7266 6f72  icient to perfor
+0000f850: 6d20 6120 6765 6e75 696e 6520 3138 302d  m a genuine 180-
+0000f860: 0a20 2020 2020 2020 2023 2064 6567 7265  .        # degre
+0000f870: 6520 726f 7461 7469 6f6e 206f 6620 322d  e rotation of 2-
+0000f880: 4420 696d 6167 696e 6720 6d6f 6465 3b20  D imaging mode; 
+0000f890: 6966 2022 6175 7468 656e 7469 6322 2061  if "authentic" a
+0000f8a0: 7265 6120 7363 616e 2069 730a 2020 2020  rea scan is.    
+0000f8b0: 2020 2020 2320 6465 7369 7265 642c 2074      # desired, t
+0000f8c0: 6865 2063 616c 6c65 7220 776f 756c 6420  he caller would 
+0000f8d0: 6c69 6b65 7769 7365 206e 6565 6420 746f  likewise need to
+0000f8e0: 2072 6576 6572 7365 2074 6865 2064 6973   reverse the dis
+0000f8f0: 706c 6179 206f 7264 6572 206f 660a 2020  play order of.  
+0000f900: 2020 2020 2020 2320 7468 6520 726f 7773        # the rows
+0000f910: 2e0a 2020 2020 2020 2020 230a 2020 2020  ..        #.    
+0000f920: 2020 2020 2320 2020 2020 2020 2020 2020      #           
+0000f930: 4974 2069 7320 5649 5441 4c4c 5920 494d  It is VITALLY IM
+0000f940: 504f 5254 414e 5420 7468 6174 2061 6c6c  PORTANT that all
+0000f950: 2064 7269 7665 7273 2061 6772 6565 0a20   drivers agree. 
+0000f960: 2020 2020 2020 2023 2020 2020 2020 2020         #        
+0000f970: 2020 2020 6f6e 2077 6865 6e20 746f 2070      on when to p
+0000f980: 6572 666f 726d 2058 2d41 7869 7320 696e  erform X-Axis in
+0000f990: 7665 7273 696f 6e20 696e 2074 6865 0a20  version in the. 
+0000f9a0: 2020 2020 2020 2023 2020 2020 2020 2020         #        
+0000f9b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f9c0: 4f72 6465 7220 6f66 204f 7065 7261 7469  Order of Operati
+0000f9d0: 6f6e 732e 0a20 2020 2020 2020 2023 0a20  ons..        #. 
+0000f9e0: 2020 2020 2020 2069 6620 7365 6c66 2e73         if self.s
+0000f9f0: 6574 7469 6e67 732e 6565 7072 6f6d 2e69  ettings.eeprom.i
+0000fa00: 6e76 6572 745f 785f 6178 6973 2061 6e64  nvert_x_axis and
+0000fa10: 206e 6f74 2073 656c 662e 7365 7474 696e   not self.settin
+0000fa20: 6773 2e73 7461 7465 2e61 7265 615f 7363  gs.state.area_sc
+0000fa30: 616e 5f65 6e61 626c 6564 3a0a 2020 2020  an_enabled:.    
+0000fa40: 2020 2020 2020 2020 7370 6563 7472 756d          spectrum
+0000fa50: 2e72 6576 6572 7365 2829 0a0a 2020 2020  .reverse()..    
+0000fa60: 2020 2020 2323 2323 2323 2323 2323 2323      ############
+0000fa70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fa80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fa90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000faa0: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
+0000fab0: 2020 2020 2023 2069 676e 6f72 6520 6973       # ignore is
+0000fac0: 6f6c 6174 6564 2022 666c 6174 2220 7370  olated "flat" sp
+0000fad0: 6563 7472 6120 6f6e 2053 6947 0a20 2020  ectra on SiG.   
+0000fae0: 2020 2020 2023 2323 2323 2323 2323 2323       ###########
+0000faf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fb00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fb10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fb20: 2323 2323 2323 2323 2323 2323 230a 0a20  #############.. 
+0000fb30: 2020 2020 2020 2069 6620 7365 6c66 2e73         if self.s
+0000fb40: 6574 7469 6e67 732e 6973 5f6d 6963 726f  ettings.is_micro
+0000fb50: 2829 2061 6e64 2075 7469 6c73 2e61 6c6c  () and utils.all
+0000fb60: 5f73 616d 6528 7370 6563 7472 756d 293a  _same(spectrum):
+0000fb70: 0a20 2020 2020 2020 2020 2020 2072 6573  .            res
+0000fb80: 706f 6e73 652e 6572 726f 725f 6d73 6720  ponse.error_msg 
+0000fb90: 3d20 2273 6b69 7070 696e 6720 666c 6174  = "skipping flat
+0000fba0: 2073 7065 6374 7275 6d22 0a20 2020 2020   spectrum".     
+0000fbb0: 2020 2020 2020 2072 6573 706f 6e73 652e         response.
+0000fbc0: 6572 726f 725f 6c76 6c20 3d20 4572 726f  error_lvl = Erro
+0000fbd0: 724c 6576 656c 2e6c 6f77 0a20 2020 2020  rLevel.low.     
+0000fbe0: 2020 2020 2020 2072 6573 706f 6e73 652e         response.
+0000fbf0: 6b65 6570 5f61 6c69 7665 203d 2054 7275  keep_alive = Tru
+0000fc00: 650a 2020 2020 2020 2020 2020 2020 6c6f  e.            lo
+0000fc10: 672e 6465 6275 6728 7265 7370 6f6e 7365  g.debug(response
+0000fc20: 2e65 7272 6f72 5f6d 7367 290a 2020 2020  .error_msg).    
+0000fc30: 2020 2020 2020 2020 7365 6c66 2e71 7565          self.que
+0000fc40: 7565 5f6d 6573 7361 6765 2822 6d61 7271  ue_message("marq
+0000fc50: 7565 655f 696e 666f 222c 2022 7365 6e73  uee_info", "sens
+0000fc60: 6f72 2069 7320 7374 6162 696c 697a 696e  or is stabilizin
+0000fc70: 6722 290a 2020 2020 2020 2020 2020 2020  g").            
+0000fc80: 7265 7475 726e 2072 6573 706f 6e73 650a  return response.
+0000fc90: 0a20 2020 2020 2020 2023 2323 2323 2323  .        #######
+0000fca0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fcb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fcc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fcd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fce0: 230a 2020 2020 2020 2020 2320 4261 6420  #.        # Bad 
+0000fcf0: 5069 7865 6c20 436f 7272 6563 7469 6f6e  Pixel Correction
+0000fd00: 0a20 2020 2020 2020 2023 2323 2323 2323  .        #######
+0000fd10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fd20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fd30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fd40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fd50: 230a 0a20 2020 2020 2020 2069 6620 7365  #..        if se
+0000fd60: 6c66 2e73 6574 7469 6e67 732e 7374 6174  lf.settings.stat
+0000fd70: 652e 6261 645f 7069 7865 6c5f 6d6f 6465  e.bad_pixel_mode
+0000fd80: 203d 3d20 5370 6563 7472 6f6d 6574 6572   == Spectrometer
+0000fd90: 5374 6174 652e 4241 445f 5049 5845 4c5f  State.BAD_PIXEL_
+0000fda0: 4d4f 4445 5f41 5645 5241 4745 3a0a 2020  MODE_AVERAGE:.  
+0000fdb0: 2020 2020 2020 2020 2020 7365 6c66 2e5f            self._
+0000fdc0: 636f 7272 6563 745f 6261 645f 7069 7865  correct_bad_pixe
+0000fdd0: 6c73 2873 7065 6374 7275 6d29 0a0a 2020  ls(spectrum)..  
+0000fde0: 2020 2020 2020 2323 2323 2323 2323 2323        ##########
+0000fdf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fe00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fe10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fe20: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
+0000fe30: 2020 2020 2020 2023 2053 7761 7020 416c         # Swap Al
+0000fe40: 7465 726e 6174 696e 6720 5069 7865 6c73  ternating Pixels
+0000fe50: 2028 7665 7279 2072 6172 6529 0a20 2020   (very rare).   
+0000fe60: 2020 2020 2023 2323 2323 2323 2323 2323       ###########
+0000fe70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fe80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fe90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fea0: 2323 2323 2323 2323 2323 2323 230a 0a20  #############.. 
+0000feb0: 2020 2020 2020 2023 2061 2070 726f 746f         # a proto
+0000fec0: 7479 7065 206d 6f64 656c 206f 7574 7075  type model outpu
+0000fed0: 7420 7370 6563 7472 6120 7769 7468 2061  t spectra with a
+0000fee0: 6c74 6572 6e61 7469 6e67 2070 6978 656c  lternating pixel
+0000fef0: 7320 7377 6170 7065 642c 2061 6e64 0a20  s swapped, and. 
+0000ff00: 2020 2020 2020 2023 2074 6869 7320 7761         # this wa
+0000ff10: 7320 7175 6963 6b65 7220 7468 616e 2063  s quicker than c
+0000ff20: 6861 6e67 696e 6720 696e 2066 6972 6d77  hanging in firmw
+0000ff30: 6172 650a 0a20 2020 2020 2020 2069 6620  are..        if 
+0000ff40: 7365 6c66 2e73 6574 7469 6e67 732e 7374  self.settings.st
+0000ff50: 6174 652e 7377 6170 5f61 6c74 6572 6e61  ate.swap_alterna
+0000ff60: 7469 6e67 5f70 6978 656c 7320 616e 6420  ting_pixels and 
+0000ff70: 7365 6c66 2e73 6574 7469 6e67 732e 7374  self.settings.st
+0000ff80: 6174 652e 6465 7465 6374 6f72 5f72 6567  ate.detector_reg
+0000ff90: 696f 6e73 2069 7320 4e6f 6e65 3a0a 2020  ions is None:.  
+0000ffa0: 2020 2020 2020 2020 2020 6c6f 672e 6465            log.de
+0000ffb0: 6275 6728 2273 7761 7070 696e 6720 616c  bug("swapping al
+0000ffc0: 7465 726e 6174 696e 6720 7069 7865 6c73  ternating pixels
+0000ffd0: 3a20 7370 6563 7472 756d 203d 2025 7322  : spectrum = %s"
+0000ffe0: 2c20 7370 6563 7472 756d 5b3a 3130 5d29  , spectrum[:10])
+0000fff0: 0a20 2020 2020 2020 2020 2020 2063 6f72  .            cor
+00010000: 7265 6374 6564 203d 205b 5d0a 2020 2020  rected = [].    
+00010010: 2020 2020 2020 2020 666f 7220 612c 2062          for a, b
+00010020: 2069 6e20 7a69 7028 7370 6563 7472 756d   in zip(spectrum
+00010030: 5b30 3a3a 325d 2c20 7370 6563 7472 756d  [0::2], spectrum
+00010040: 5b31 3a3a 325d 293a 0a20 2020 2020 2020  [1::2]):.       
+00010050: 2020 2020 2020 2020 2063 6f72 7265 6374           correct
+00010060: 6564 2e65 7874 656e 6428 5b62 2c20 615d  ed.extend([b, a]
+00010070: 290a 2020 2020 2020 2020 2020 2020 7370  ).            sp
+00010080: 6563 7472 756d 203d 2063 6f72 7265 6374  ectrum = correct
+00010090: 6564 0a20 2020 2020 2020 2020 2020 206c  ed.            l
+000100a0: 6f67 2e64 6562 7567 2822 7377 6170 7065  og.debug("swappe
+000100b0: 6420 616c 7465 726e 6174 696e 6720 7069  d alternating pi
+000100c0: 7865 6c73 3a20 7370 6563 7472 756d 203d  xels: spectrum =
+000100d0: 2025 7322 2c20 7370 6563 7472 756d 5b3a   %s", spectrum[:
+000100e0: 3130 5d29 0a0a 2020 2020 2020 2020 2323  10])..        ##
+000100f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010100: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010110: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010120: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010130: 2323 2323 2323 0a20 2020 2020 2020 2023  ######.        #
+00010140: 2032 7832 2062 696e 6e69 6e67 0a20 2020   2x2 binning.   
+00010150: 2020 2020 2023 2323 2323 2323 2323 2323       ###########
+00010160: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010170: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010180: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010190: 2323 2323 2323 2323 2323 2323 230a 0a20  #############.. 
+000101a0: 2020 2020 2020 2023 2061 7070 6c79 2073         # apply s
+000101b0: 6f2d 6361 6c6c 6564 2022 3278 3220 7069  o-called "2x2 pi
+000101c0: 7865 6c20 6269 6e6e 696e 6722 200a 2020  xel binning" .  
+000101d0: 2020 2020 2020 7370 6563 7472 756d 203d        spectrum =
+000101e0: 2073 656c 662e 5f61 7070 6c79 5f32 7832   self._apply_2x2
+000101f0: 5f62 696e 6e69 6e67 2873 7065 6374 7275  _binning(spectru
+00010200: 6d29 0a0a 2020 2020 2020 2020 2323 2323  m)..        ####
+00010210: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010220: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010230: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010240: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010250: 2323 2323 0a20 2020 2020 2020 2023 2047  ####.        # G
+00010260: 7261 7068 2041 6c74 6572 6e61 7469 6e67  raph Alternating
+00010270: 2050 6978 656c 730a 2020 2020 2020 2020   Pixels.        
+00010280: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010290: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000102a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000102b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000102c0: 2323 2323 2323 2323 0a0a 2020 2020 2020  ########..      
+000102d0: 2020 2320 5768 656e 2069 6e74 6567 7261    # When integra
+000102e0: 7469 6e67 206e 6577 2073 656e 736f 7273  ting new sensors
+000102f0: 2c20 6f72 2074 6573 7469 6e67 2022 696e  , or testing "in
+00010300: 7465 726c 6561 7665 6422 2064 6574 6563  terleaved" detec
+00010310: 746f 7273 206c 696b 650a 2020 2020 2020  tors like.      
+00010320: 2020 2320 7468 6520 496e 4761 4173 2c20    # the InGaAs, 
+00010330: 736f 6d65 7469 6d65 7320 7765 2077 616e  sometimes we wan
+00010340: 7420 746f 206f 6e6c 7920 6c6f 6f6b 2061  t to only look a
+00010350: 7420 2265 7665 7279 206f 7468 6572 2220  t "every other" 
+00010360: 7069 7865 6c20 746f 0a20 2020 2020 2020  pixel to.       
+00010370: 2023 2066 6c61 7474 656e 2d6f 7574 2069   # flatten-out i
+00010380: 7272 6567 756c 6172 6974 6965 7320 696e  rregularities in
+00010390: 2042 6179 6572 2066 696c 7465 7273 206f   Bayer filters o
+000103a0: 7220 7068 6f74 6f64 696f 6465 2061 7272  r photodiode arr
+000103b0: 6179 732e 0a20 2020 2020 2020 2023 2048  ays..        # H
+000103c0: 6f77 6576 6572 2c20 7765 2064 6f6e 2774  owever, we don't
+000103d0: 2077 616e 7420 746f 2064 6973 7275 7074   want to disrupt
+000103e0: 2074 6865 2065 7870 6563 7465 6420 7069   the expected pi
+000103f0: 7865 6c2d 636f 756e 742c 2073 6f20 6a75  xel-count, so ju
+00010400: 7374 0a20 2020 2020 2020 2023 2061 7665  st.        # ave
+00010410: 7261 6765 2d6f 7665 7220 7468 6520 736b  rage-over the sk
+00010420: 6970 7065 6420 7069 7865 6c73 2e0a 2020  ipped pixels..  
+00010430: 2020 2020 2020 230a 2020 2020 2020 2020        #.        
+00010440: 2320 4e6f 7420 696d 706f 7274 616e 7420  # Not important 
+00010450: 656e 6f75 6768 2074 6f20 7570 6461 7465  enough to update
+00010460: 2066 6f72 2044 6574 6563 746f 7252 6567   for DetectorReg
+00010470: 696f 6e73 0a20 2020 2020 2020 2069 6620  ions.        if 
+00010480: 7365 6c66 2e73 6574 7469 6e67 732e 7374  self.settings.st
+00010490: 6174 652e 6772 6170 685f 616c 7465 726e  ate.graph_altern
+000104a0: 6174 696e 675f 7069 7865 6c73 3a0a 2020  ating_pixels:.  
+000104b0: 2020 2020 2020 2020 2020 6c6f 672e 6465            log.de
+000104c0: 6275 6728 2261 7070 6c79 696e 6720 6772  bug("applying gr
+000104d0: 6170 685f 616c 7465 726e 6174 696e 675f  aph_alternating_
+000104e0: 7069 7865 6c73 2229 0a20 2020 2020 2020  pixels").       
+000104f0: 2020 2020 2073 6d6f 6f74 6865 6420 3d20       smoothed = 
+00010500: 5b5d 0a20 2020 2020 2020 2020 2020 2066  [].            f
+00010510: 6f72 2069 2069 6e20 7261 6e67 6528 6c65  or i in range(le
+00010520: 6e28 7370 6563 7472 756d 2929 3a0a 2020  n(spectrum)):.  
+00010530: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00010540: 2069 2025 2032 203d 3d20 303a 0a20 2020   i % 2 == 0:.   
+00010550: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010560: 2073 6d6f 6f74 6865 642e 6170 7065 6e64   smoothed.append
+00010570: 2873 7065 6374 7275 6d5b 695d 290a 2020  (spectrum[i]).  
+00010580: 2020 2020 2020 2020 2020 2020 2020 656c                el
+00010590: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+000105a0: 2020 2020 2020 2020 6966 2069 202b 2031          if i + 1
+000105b0: 203c 206c 656e 2873 7065 6374 7275 6d29   < len(spectrum)
+000105c0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000105d0: 2020 2020 2020 2020 2020 6176 6572 6167            averag
+000105e0: 6564 203d 2028 7370 6563 7472 756d 5b69  ed = (spectrum[i
+000105f0: 2d31 5d20 2b20 7370 6563 7472 756d 5b69  -1] + spectrum[i
+00010600: 2b31 5d29 202f 2032 2e30 0a20 2020 2020  +1]) / 2.0.     
+00010610: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+00010620: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00010630: 2020 2020 2020 2020 2020 2020 2061 7665               ave
+00010640: 7261 6765 6420 3d20 7370 6563 7472 756d  raged = spectrum
+00010650: 5b69 202d 2031 5d0a 2020 2020 2020 2020  [i - 1].        
+00010660: 2020 2020 2020 2020 2020 2020 736d 6f6f              smoo
+00010670: 7468 6564 2e61 7070 656e 6428 6176 6572  thed.append(aver
+00010680: 6167 6564 290a 2020 2020 2020 2020 2020  aged).          
+00010690: 2020 7370 6563 7472 756d 203d 2073 6d6f    spectrum = smo
+000106a0: 6f74 6865 640a 0a20 2020 2020 2020 2023  othed..        #
+000106b0: 2053 6f6d 6577 6861 7420 6f64 646c 792c   Somewhat oddly,
+000106c0: 2077 6527 7265 2063 7572 7265 6e74 6c79   we're currently
+000106d0: 2072 6574 7572 6e69 6e67 2061 2054 5550   returning a TUP
+000106e0: 4c45 206f 6620 7468 6520 7370 6563 7472  LE of the spectr
+000106f0: 756d 2061 6e64 0a20 2020 2020 2020 2023  um and.        #
+00010700: 2074 6865 2061 7265 6120 7363 616e 2072   the area scan r
+00010710: 6f77 2063 6f75 6e74 2e20 2057 6865 6e20  ow count.  When 
+00010720: 2246 6173 7422 2041 7265 6120 5363 616e  "Fast" Area Scan
+00010730: 2069 7320 6d6f 7265 2063 6f6d 6d6f 6e70   is more commonp
+00010740: 6c61 6365 200a 2020 2020 2020 2020 2320  lace .        # 
+00010750: 7765 276c 6c20 6368 616e 6765 2074 6869  we'll change thi
+00010760: 7320 6261 636b 2074 6f20 6a75 7374 2072  s back to just r
+00010770: 6574 7572 6e69 6e67 2074 6865 2073 7065  eturning the spe
+00010780: 6374 7275 6d20 6172 7261 7920 6469 7265  ctrum array dire
+00010790: 6374 6c79 2e0a 2020 2020 2020 2020 7265  ctly..        re
+000107a0: 7370 6f6e 7365 2e64 6174 6120 3d20 5370  sponse.data = Sp
+000107b0: 6563 7472 756d 416e 6452 6f77 2873 7065  ectrumAndRow(spe
+000107c0: 6374 7275 6d2c 2061 7265 615f 7363 616e  ctrum, area_scan
+000107d0: 5f72 6f77 5f63 6f75 6e74 2920 0a20 2020  _row_count) .   
+000107e0: 2020 2020 2072 6574 7572 6e20 7265 7370       return resp
+000107f0: 6f6e 7365 0a0a 2020 2020 6465 6620 6164  onse..    def ad
+00010800: 645f 7468 726f 7761 7761 7928 7365 6c66  d_throwaway(self
+00010810: 2c20 666c 6167 293a 0a20 2020 2020 2020  , flag):.       
+00010820: 2069 6620 666c 6167 2061 6e64 2073 656c   if flag and sel
+00010830: 662e 7365 7474 696e 6773 2e69 735f 7873  f.settings.is_xs
+00010840: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
+00010850: 6c6f 672e 6465 6275 6728 2271 7565 7569  log.debug("queui
+00010860: 6e67 2074 6872 6f77 6177 6179 7322 290a  ng throwaways").
+00010870: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00010880: 2e72 656d 6169 6e69 6e67 5f74 6872 6f77  .remaining_throw
+00010890: 6177 6179 7320 2b3d 2032 0a0a 2020 2020  aways += 2..    
+000108a0: 6465 6620 7365 745f 696e 7465 6772 6174  def set_integrat
+000108b0: 696f 6e5f 7469 6d65 5f6d 7328 7365 6c66  ion_time_ms(self
+000108c0: 2c20 6d73 3a20 666c 6f61 7429 3a0a 2020  , ms: float):.  
+000108d0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+000108e0: 2020 5365 6e64 2074 6865 2075 7064 6174    Send the updat
+000108f0: 6564 2069 6e74 6567 7261 7469 6f6e 2074  ed integration t
+00010900: 696d 6520 696e 2061 2063 6f6e 7472 6f6c  ime in a control
+00010910: 206d 6573 7361 6765 2074 6f20 7468 6520   message to the 
+00010920: 6465 7669 6365 0a20 2020 2020 2020 2040  device.        @
+00010930: 7761 726e 696e 6720 6469 7361 626c 6564  warning disabled
+00010940: 2045 4550 524f 4d20 7261 6e67 652d 6368   EEPROM range-ch
+00010950: 6563 6b69 6e67 2062 7920 6375 7374 6f6d  ecking by custom
+00010960: 6572 0a20 2020 2020 2020 2020 2020 2020  er.             
+00010970: 7265 7175 6573 743b 2072 616e 6765 206c  request; range l
+00010980: 696d 6974 7320 696e 2045 4550 524f 4d20  imits in EEPROM 
+00010990: 6172 6520 6465 6669 6e65 6420 6173 2031  are defined as 1
+000109a0: 362d 6269 740a 2020 2020 2020 2020 2020  6-bit.          
+000109b0: 2020 2076 616c 7565 732c 2077 6869 6c65     values, while
+000109c0: 2069 6e74 6567 7261 7469 6f6e 2074 696d   integration tim
+000109d0: 6520 6973 2061 6374 7561 6c6c 7920 6120  e is actually a 
+000109e0: 3234 2d62 6974 2076 616c 7565 2c0a 2020  24-bit value,.  
+000109f0: 2020 2020 2020 2020 2020 2073 7563 6820             such 
+00010a00: 7468 6174 2074 6865 2045 4550 524f 4d20  that the EEPROM 
+00010a10: 6973 2061 7274 6966 6963 6961 6c6c 7920  is artificially 
+00010a20: 6c69 6d69 7469 6e67 206f 7572 2072 616e  limiting our ran
+00010a30: 6765 2e0a 0a20 2020 2020 2020 2040 746f  ge...        @to
+00010a40: 646f 2053 6947 206e 6565 6473 2074 6f20  do SiG needs to 
+00010a50: 7761 6974 2032 306d 7320 2b20 3820 6672  wait 20ms + 8 fr
+00010a60: 616d 6573 2066 6f72 2073 7461 6269 6c69  ames for stabili
+00010a70: 7a61 7469 6f6e 2e0a 2020 2020 2020 2020  zation..        
+00010a80: 2222 220a 2020 2020 2020 2020 6966 206e  """.        if n
+00010a90: 6f74 2073 656c 662e 6973 5f73 656e 736f  ot self.is_senso
+00010aa0: 725f 7374 6162 6c65 2829 3a0a 2020 2020  r_stable():.    
+00010ab0: 2020 2020 2020 2020 6c6f 672e 6572 726f          log.erro
+00010ac0: 7228 2264 6563 6c69 6e69 6e67 2074 6f20  r("declining to 
+00010ad0: 6368 616e 6765 2073 656e 736f 7220 7365  change sensor se
+00010ae0: 7474 696e 6773 2077 6869 6c65 2073 7461  ttings while sta
+00010af0: 6269 6c69 7a69 6e67 2229 0a20 2020 2020  bilizing").     
+00010b00: 2020 2020 2020 2072 6574 7572 6e0a 0a20         return.. 
+00010b10: 2020 2020 2020 206d 7320 3d20 6d61 7828         ms = max(
+00010b20: 312c 2069 6e74 2872 6f75 6e64 286d 7329  1, int(round(ms)
+00010b30: 2929 0a0a 2020 2020 2020 2020 6c73 7720  ))..        lsw 
+00010b40: 3d20 206d 7320 2020 2020 2020 2026 2030  =  ms        & 0
+00010b50: 7866 6666 660a 2020 2020 2020 2020 6d73  xffff.        ms
+00010b60: 7720 3d20 286d 7320 3e3e 2031 3629 2026  w = (ms >> 16) &
+00010b70: 2030 7830 3066 660a 0a20 2020 2020 2020   0x00ff..       
+00010b80: 2072 6573 756c 7420 3d20 7365 6c66 2e5f   result = self._
+00010b90: 7365 6e64 5f63 6f64 6528 3078 4232 2c20  send_code(0xB2, 
+00010ba0: 6c73 772c 206d 7377 2c20 6c61 6265 6c3d  lsw, msw, label=
+00010bb0: 2253 4554 5f49 4e54 4547 5241 5449 4f4e  "SET_INTEGRATION
+00010bc0: 5f54 494d 455f 4d53 2229 0a20 2020 2020  _TIME_MS").     
+00010bd0: 2020 206c 6f67 2e64 6562 7567 2822 5345     log.debug("SE
+00010be0: 545f 494e 5445 4752 4154 494f 4e5f 5449  T_INTEGRATION_TI
+00010bf0: 4d45 5f4d 533a 206e 6f77 2025 6422 2c20  ME_MS: now %d", 
+00010c00: 6d73 290a 0a20 2020 2020 2020 2073 656c  ms)..        sel
+00010c10: 662e 6164 645f 7468 726f 7761 7761 7928  f.add_throwaway(
+00010c20: 6d73 2021 3d20 7365 6c66 2e73 6574 7469  ms != self.setti
+00010c30: 6e67 732e 7374 6174 652e 696e 7465 6772  ngs.state.integr
+00010c40: 6174 696f 6e5f 7469 6d65 5f6d 7329 0a20  ation_time_ms). 
+00010c50: 2020 2020 2020 2073 656c 662e 7365 7474         self.sett
+00010c60: 696e 6773 2e73 7461 7465 2e69 6e74 6567  ings.state.integ
+00010c70: 7261 7469 6f6e 5f74 696d 655f 6d73 203d  ration_time_ms =
+00010c80: 206d 730a 0a20 2020 2020 2020 2069 6620   ms..        if 
+00010c90: 7365 6c66 2e73 6574 7469 6e67 732e 6973  self.settings.is
+00010ca0: 5f78 7328 293a 0a20 2020 2020 2020 2020  _xs():.         
+00010cb0: 2020 2073 656c 662e 7175 6575 655f 6d65     self.queue_me
+00010cc0: 7373 6167 6528 226d 6172 7175 6565 5f69  ssage("marquee_i
+00010cd0: 6e66 6f22 2c20 2273 656e 736f 7220 6973  nfo", "sensor is
+00010ce0: 2073 7461 6269 6c69 7a69 6e67 2229 0a0a   stabilizing")..
+00010cf0: 2020 2020 2020 2020 7265 7475 726e 2072          return r
+00010d00: 6573 756c 740a 0a20 2020 2064 6566 2069  esult..    def i
+00010d10: 735f 7365 6e73 6f72 5f73 7461 626c 6528  s_sensor_stable(
+00010d20: 7365 6c66 293a 0a20 2020 2020 2020 2069  self):.        i
+00010d30: 6620 6e6f 7420 2873 656c 662e 7365 7474  f not (self.sett
+00010d40: 696e 6773 2e69 735f 696d 7828 2920 616e  ings.is_imx() an
+00010d50: 6420 7365 6c66 2e73 6574 7469 6e67 732e  d self.settings.
+00010d60: 7375 7070 6f72 7473 5f66 6561 7475 7265  supports_feature
+00010d70: 2822 696d 785f 7374 6162 696c 697a 6174  ("imx_stabilizat
+00010d80: 696f 6e22 2929 3a0a 2020 2020 2020 2020  ion")):.        
+00010d90: 2020 2020 7265 7475 726e 2054 7275 650a      return True.
+00010da0: 0a20 2020 2020 2020 2073 656c 662e 6765  .        self.ge
+00010db0: 745f 706f 6c6c 5f73 7461 7475 7328 290a  t_poll_status().
+00010dc0: 2020 2020 2020 2020 7374 6162 6c65 203d          stable =
+00010dd0: 2050 6f6c 6c53 7461 7475 732e 4944 4c45   PollStatus.IDLE
+00010de0: 203d 3d20 7365 6c66 2e73 6574 7469 6e67   == self.setting
+00010df0: 732e 7374 6174 652e 706f 6c6c 5f73 7461  s.state.poll_sta
+00010e00: 7475 730a 2020 2020 2020 2020 6c6f 672e  tus.        log.
+00010e10: 6465 6275 6728 6622 6973 5f73 656e 736f  debug(f"is_senso
+00010e20: 725f 7374 6162 6c65 3a20 7365 6e73 6f72  r_stable: sensor
+00010e30: 207b 2749 5327 2069 6620 7374 6162 6c65   {'IS' if stable
+00010e40: 2065 6c73 6520 2749 5320 4e4f 5427 7d20   else 'IS NOT'} 
+00010e50: 7374 6162 6c65 2028 706f 6c6c 5f73 7461  stable (poll_sta
+00010e60: 7475 7320 3078 7b73 656c 662e 7365 7474  tus 0x{self.sett
+00010e70: 696e 6773 2e73 7461 7465 2e70 6f6c 6c5f  ings.state.poll_
+00010e80: 7374 6174 7573 3a30 3278 7d29 2229 0a20  status:02x})"). 
+00010e90: 2020 2020 2020 2072 6574 7572 6e20 7374         return st
+00010ea0: 6162 6c65 0a0a 2020 2020 6465 6620 6765  able..    def ge
+00010eb0: 745f 706f 6c6c 5f73 7461 7475 7328 7365  t_poll_status(se
+00010ec0: 6c66 293a 0a20 2020 2020 2020 2073 7461  lf):.        sta
+00010ed0: 7475 7320 3d20 506f 6c6c 5374 6174 7573  tus = PollStatus
+00010ee0: 2e49 444c 4520 2320 2e55 4e44 4546 494e  .IDLE # .UNDEFIN
+00010ef0: 4544 2028 6b6c 7564 6765 290a 2020 2020  ED (kludge).    
+00010f00: 2020 2020 7265 7375 6c74 203d 2053 7065      result = Spe
+00010f10: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
+00010f20: 6528 6461 7461 3d73 7461 7475 7329 0a0a  e(data=status)..
+00010f30: 2020 2020 2020 2020 6966 2046 616c 7365          if False
+00010f40: 2061 6e64 2073 656c 662e 7365 7474 696e   and self.settin
+00010f50: 6773 2e69 735f 696d 7828 2920 616e 6420  gs.is_imx() and 
+00010f60: 7365 6c66 2e73 6574 7469 6e67 732e 7375  self.settings.su
+00010f70: 7070 6f72 7473 5f66 6561 7475 7265 2822  pports_feature("
+00010f80: 696d 785f 7374 6162 696c 697a 6174 696f  imx_stabilizatio
+00010f90: 6e22 293a 0a20 2020 2020 2020 2020 2020  n"):.           
+00010fa0: 2072 6573 756c 7420 3d20 7365 6c66 2e5f   result = self._
+00010fb0: 6765 745f 636f 6465 2830 7864 342c 206c  get_code(0xd4, l
+00010fc0: 7362 5f6c 656e 3d31 2c20 6c61 6265 6c3d  sb_len=1, label=
+00010fd0: 2247 4554 5f50 4f4c 4c5f 5354 4154 5553  "GET_POLL_STATUS
+00010fe0: 2229 0a20 2020 2020 2020 2020 2020 2069  ").            i
+00010ff0: 6620 7265 7375 6c74 2069 7320 6e6f 7420  f result is not 
+00011000: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+00011010: 2020 2020 2020 7374 6174 7573 203d 2072        status = r
+00011020: 6573 756c 742e 6461 7461 0a20 2020 2020  esult.data.     
+00011030: 2020 2073 656c 662e 7365 7474 696e 6773     self.settings
+00011040: 2e73 7461 7465 2e70 6f6c 6c5f 7374 6174  .state.poll_stat
+00011050: 7573 203d 2073 7461 7475 730a 2020 2020  us = status.    
+00011060: 2020 2020 6c6f 672e 6465 6275 6728 6622      log.debug(f"
+00011070: 6765 745f 706f 6c6c 5f73 7461 7475 733a  get_poll_status:
+00011080: 2073 7461 7475 7320 3078 7b73 7461 7475   status 0x{statu
+00011090: 733a 3032 787d 2229 0a20 2020 2020 2020  s:02x}").       
+000110a0: 2072 6574 7572 6e20 7265 7375 6c74 0a0a   return result..
+000110b0: 2020 2020 2320 2323 2323 2323 2323 2323      # ##########
+000110c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000110d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000110e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000110f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011100: 0a20 2020 2023 2041 4443 7320 2f20 4441  .    # ADCs / DA
+00011110: 4373 0a20 2020 2023 2023 2323 2323 2323  Cs.    # #######
+00011120: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011130: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011140: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011150: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011160: 2323 230a 0a20 2020 2023 2054 6869 7320  ###..    # This 
+00011170: 6973 2061 206c 6974 746c 6520 636f 6e66  is a little conf
+00011180: 7573 696e 672c 2073 6f3a 0a20 2020 2023  using, so:.    #
+00011190: 0a20 2020 2023 2054 6865 2022 7072 696d  .    # The "prim
+000111a0: 6172 7922 2041 4443 2028 4144 4320 3029  ary" ADC (ADC 0)
+000111b0: 2069 7320 6173 7375 6d65 6420 746f 2072   is assumed to r
+000111c0: 6574 7572 6e20 6c61 7365 7220 7465 6d70  eturn laser temp
+000111d0: 6572 6174 7572 652e 0a20 2020 2023 0a20  erature..    #. 
+000111e0: 2020 2023 2054 6865 2022 7365 636f 6e64     # The "second
+000111f0: 6172 7922 2041 4443 2028 4144 4320 3129  ary" ADC (ADC 1)
+00011200: 206d 6179 2062 6520 7769 7265 6420 746f   may be wired to
+00011210: 2076 6172 696f 7573 206f 7468 6572 2074   various other t
+00011220: 6869 6e67 7320 666f 720a 2020 2020 2320  hings for.    # 
+00011230: 6c65 6761 6379 206f 7220 4f45 4d20 7379  legacy or OEM sy
+00011240: 7374 656d 732e 2046 6f72 2069 6e73 7461  stems. For insta
+00011250: 6e63 652c 2069 7420 6861 7320 6265 656e  nce, it has been
+00011260: 2075 7365 6420 7769 7468 2061 6e20 696e   used with an in
+00011270: 7465 6772 6174 6564 0a20 2020 2023 2070  tegrated.    # p
+00011280: 686f 746f 6469 6f64 6520 666f 7220 7265  hotodiode for re
+00011290: 616c 2d74 696d 6520 6d65 6173 7572 656d  al-time measurem
+000112a0: 656e 7420 6f66 206c 6173 6572 206f 7574  ent of laser out
+000112b0: 7075 7420 706f 7765 7220 2877 6974 6820  put power (with 
+000112c0: 6f72 0a20 2020 2023 2077 6974 686f 7574  or.    # without
+000112d0: 2061 2063 616c 6962 7261 7469 6f6e 2074   a calibration t
+000112e0: 6f20 636f 6e76 6572 7420 7468 6520 7068  o convert the ph
+000112f0: 6f74 6f64 696f 6465 2072 6573 756c 7420  otodiode result 
+00011300: 746f 206d 572c 2068 656e 6365 0a20 2020  to mW, hence.   
+00011310: 2023 2067 6574 5f73 6563 6f6e 6461 7279   # get_secondary
+00011320: 5f61 6463 5f63 616c 6962 7261 7465 6429  _adc_calibrated)
+00011330: 2e0a 2020 2020 230a 2020 2020 2320 4d6f  ..    #.    # Mo
+00011340: 7374 2075 7365 7273 2077 696c 6c20 6e65  st users will ne
+00011350: 7665 7220 6e65 6564 2074 6f20 6578 706c  ver need to expl
+00011360: 6963 6974 6c79 2063 616c 6c20 7365 6c65  icitly call sele
+00011370: 6374 5f61 6463 2c20 616e 6420 6361 6e20  ct_adc, and can 
+00011380: 7369 6d70 6c79 0a20 2020 2023 2063 616c  simply.    # cal
+00011390: 6c20 6765 745f 6c61 7365 725f 7465 6d70  l get_laser_temp
+000113a0: 6572 6174 7572 655f 7261 7720 616e 642f  erature_raw and/
+000113b0: 6f72 2067 6574 5f6c 6173 6572 5f74 656d  or get_laser_tem
+000113c0: 7065 7261 7475 7265 5f64 6567 432e 0a0a  perature_degC...
+000113d0: 2020 2020 6465 6620 6765 745f 6461 6328      def get_dac(
+000113e0: 7365 6c66 2c20 6461 6349 6e64 6578 3a20  self, dacIndex: 
+000113f0: 696e 7420 3d20 3029 3a0a 2020 2020 2020  int = 0):.      
+00011400: 2020 7265 7475 726e 2073 656c 662e 5f67    return self._g
+00011410: 6574 5f63 6f64 6528 3078 6439 2c20 7749  et_code(0xd9, wI
+00011420: 6e64 6578 3d64 6163 496e 6465 782c 206c  ndex=dacIndex, l
+00011430: 6162 656c 3d22 4745 545f 4441 4322 2c20  abel="GET_DAC", 
+00011440: 6c73 625f 6c65 6e3d 3229 0a0a 2020 2020  lsb_len=2)..    
+00011450: 6465 6620 7365 6c65 6374 5f61 6463 2873  def select_adc(s
+00011460: 656c 662c 206e 3a20 696e 7429 3a0a 2020  elf, n: int):.  
+00011470: 2020 2020 2020 6c6f 672e 6465 6275 6728        log.debug(
+00011480: 2273 656c 6563 745f 6164 6320 2d3e 2025  "select_adc -> %
+00011490: 6422 2c20 6e29 0a20 2020 2020 2020 2073  d", n).        s
+000114a0: 656c 662e 7365 7474 696e 6773 2e73 7461  elf.settings.sta
+000114b0: 7465 2e73 656c 6563 7465 645f 6164 6320  te.selected_adc 
+000114c0: 3d20 6e0a 2020 2020 2020 2020 7265 7375  = n.        resu
+000114d0: 6c74 203d 2073 656c 662e 5f73 656e 645f  lt = self._send_
+000114e0: 636f 6465 2830 7865 642c 206e 2c20 6c61  code(0xed, n, la
+000114f0: 6265 6c3d 2253 454c 4543 545f 4144 4322  bel="SELECT_ADC"
+00011500: 290a 2020 2020 2020 2020 7365 6c66 2e5f  ).        self._
+00011510: 6765 745f 636f 6465 2830 7864 352c 2077  get_code(0xd5, w
+00011520: 4c65 6e67 7468 3d32 2c20 6c61 6265 6c3d  Length=2, label=
+00011530: 2247 4554 5f41 4443 2028 7468 726f 7761  "GET_ADC (throwa
+00011540: 7761 7929 2229 2023 2073 7461 6269 6c69  way)") # stabili
+00011550: 7a61 7469 6f6e 2072 6561 640a 2020 2020  zation read.    
+00011560: 2020 2020 7265 7475 726e 2072 6573 756c      return resul
+00011570: 740a 0a20 2020 2064 6566 2067 6574 5f73  t..    def get_s
+00011580: 6563 6f6e 6461 7279 5f61 6463 5f63 616c  econdary_adc_cal
+00011590: 6962 7261 7465 6428 7365 6c66 2c20 7261  ibrated(self, ra
+000115a0: 773a 2066 6c6f 6174 203d 204e 6f6e 6529  w: float = None)
+000115b0: 3a0a 2020 2020 2020 2020 6966 206e 6f74  :.        if not
+000115c0: 2073 656c 662e 6861 735f 6c69 6e65 6172   self.has_linear
+000115d0: 6974 795f 636f 6566 6673 2829 3a0a 2020  ity_coeffs():.  
+000115e0: 2020 2020 2020 2020 2020 6c6f 672e 6465            log.de
+000115f0: 6275 6728 2273 6563 6f6e 6461 7279 5f61  bug("secondary_a
+00011600: 6463 5f63 616c 6962 7261 7465 643a 206e  dc_calibrated: n
+00011610: 6f20 6361 6c69 6272 6174 696f 6e22 290a  o calibration").
+00011620: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00011630: 726e 2053 7065 6374 726f 6d65 7465 7252  rn SpectrometerR
+00011640: 6573 706f 6e73 6528 6461 7461 3d4e 6f6e  esponse(data=Non
+00011650: 652c 2065 7272 6f72 5f6c 766c 3d45 7272  e, error_lvl=Err
+00011660: 6f72 4c65 7665 6c2e 6c6f 772c 2065 7272  orLevel.low, err
+00011670: 6f72 5f6d 7367 3d22 7365 636f 6e64 6172  or_msg="secondar
+00011680: 795f 6164 635f 6361 6c69 6272 6174 6564  y_adc_calibrated
+00011690: 3a20 6e6f 2063 616c 6962 7261 7469 6f6e  : no calibration
+000116a0: 2229 0a0a 2020 2020 2020 2020 6966 2072  ")..        if r
+000116b0: 6177 2069 7320 4e6f 6e65 3a0a 2020 2020  aw is None:.    
+000116c0: 2020 2020 2020 2020 7265 7370 6f6e 7365          response
+000116d0: 203d 2073 656c 662e 6765 745f 7365 636f   = self.get_seco
+000116e0: 6e64 6172 795f 6164 635f 7261 7728 290a  ndary_adc_raw().
+000116f0: 2020 2020 2020 2020 6966 2072 6573 706f          if respo
+00011700: 6e73 652e 6461 7461 2069 7320 4e6f 6e65  nse.data is None
+00011710: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00011720: 7475 726e 2072 6573 706f 6e73 650a 0a20  turn response.. 
+00011730: 2020 2020 2020 2072 6177 203d 2066 6c6f         raw = flo
+00011740: 6174 2872 6573 706f 6e73 652e 6461 7461  at(response.data
+00011750: 290a 0a20 2020 2020 2020 2023 2075 7365  )..        # use
+00011760: 2074 6865 2066 6972 7374 2034 206c 696e   the first 4 lin
+00011770: 6561 7269 7479 2063 6f65 6666 6963 6965  earity coefficie
+00011780: 6e74 7320 6173 2061 2033 7264 2d6f 7264  nts as a 3rd-ord
+00011790: 6572 2070 6f6c 796e 6f6d 6961 6c0a 2020  er polynomial.  
+000117a0: 2020 2020 2020 6361 6c69 6272 6174 6564        calibrated
+000117b0: 203d 2066 6c6f 6174 2873 656c 662e 7365   = float(self.se
+000117c0: 7474 696e 6773 2e65 6570 726f 6d2e 6c69  ttings.eeprom.li
+000117d0: 6e65 6172 6974 795f 636f 6566 6673 5b30  nearity_coeffs[0
+000117e0: 5d29 205c 0a20 2020 2020 2020 2020 2020  ]) \.           
+000117f0: 2020 2020 2020 2020 2b20 666c 6f61 7428          + float(
+00011800: 7365 6c66 2e73 6574 7469 6e67 732e 6565  self.settings.ee
+00011810: 7072 6f6d 2e6c 696e 6561 7269 7479 5f63  prom.linearity_c
+00011820: 6f65 6666 735b 315d 2920 2a20 7261 7720  oeffs[1]) * raw 
+00011830: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
+00011840: 2020 2020 202b 2066 6c6f 6174 2873 656c       + float(sel
+00011850: 662e 7365 7474 696e 6773 2e65 6570 726f  f.settings.eepro
+00011860: 6d2e 6c69 6e65 6172 6974 795f 636f 6566  m.linearity_coef
+00011870: 6673 5b32 5d29 202a 2072 6177 202a 2072  fs[2]) * raw * r
+00011880: 6177 205c 0a20 2020 2020 2020 2020 2020  aw \.           
+00011890: 2020 2020 2020 2020 2b20 666c 6f61 7428          + float(
+000118a0: 7365 6c66 2e73 6574 7469 6e67 732e 6565  self.settings.ee
+000118b0: 7072 6f6d 2e6c 696e 6561 7269 7479 5f63  prom.linearity_c
+000118c0: 6f65 6666 735b 335d 2920 2a20 7261 7720  oeffs[3]) * raw 
+000118d0: 2a20 7261 7720 2a20 7261 770a 2020 2020  * raw * raw.    
+000118e0: 2020 2020 6c6f 672e 6465 6275 6728 2273      log.debug("s
+000118f0: 6563 6f6e 6461 7279 5f61 6463 5f63 616c  econdary_adc_cal
+00011900: 6962 7261 7465 643a 2025 6622 2c20 6361  ibrated: %f", ca
+00011910: 6c69 6272 6174 6564 290a 2020 2020 2020  librated).      
+00011920: 2020 7265 7370 6f6e 7365 2e64 6174 6120    response.data 
+00011930: 3d20 6361 6c69 6272 6174 6564 0a20 2020  = calibrated.   
+00011940: 2020 2020 2072 6574 7572 6e20 7265 7370       return resp
+00011950: 6f6e 7365 0a0a 2020 2020 6465 6620 6765  onse..    def ge
+00011960: 745f 7365 636f 6e64 6172 795f 6164 635f  t_secondary_adc_
+00011970: 7261 7728 7365 6c66 293a 0a20 2020 2020  raw(self):.     
+00011980: 2020 2023 2066 6c69 7020 746f 2073 6563     # flip to sec
+00011990: 6f6e 6461 7279 2041 4443 2069 6620 6e65  ondary ADC if ne
+000119a0: 6564 6564 0a20 2020 2020 2020 2069 6620  eded.        if 
+000119b0: 7365 6c66 2e73 6574 7469 6e67 732e 7374  self.settings.st
+000119c0: 6174 652e 7365 6c65 6374 6564 5f61 6463  ate.selected_adc
+000119d0: 2069 7320 4e6f 6e65 206f 7220 7365 6c66   is None or self
+000119e0: 2e73 6574 7469 6e67 732e 7374 6174 652e  .settings.state.
+000119f0: 7365 6c65 6374 6564 5f61 6463 2021 3d20  selected_adc != 
+00011a00: 313a 0a20 2020 2020 2020 2020 2020 2073  1:.            s
+00011a10: 656c 662e 7365 6c65 6374 5f61 6463 2831  elf.select_adc(1
+00011a20: 290a 0a20 2020 2020 2020 2072 6573 756c  )..        resul
+00011a30: 7420 3d20 7365 6c66 2e5f 6765 745f 636f  t = self._get_co
+00011a40: 6465 2830 7864 352c 2077 4c65 6e67 7468  de(0xd5, wLength
+00011a50: 3d32 2c20 6c61 6265 6c3d 2247 4554 5f41  =2, label="GET_A
+00011a60: 4443 222c 206c 7362 5f6c 656e 3d32 290a  DC", lsb_len=2).
+00011a70: 2020 2020 2020 2020 6c6f 672e 6465 6275          log.debu
+00011a80: 6728 2273 6563 6f6e 6461 7279 5f61 6463  g("secondary_adc
+00011a90: 5f72 6177 3a20 3078 2530 3478 222c 2072  _raw: 0x%04x", r
+00011aa0: 6573 756c 7429 0a20 2020 2020 2020 2072  esult).        r
+00011ab0: 6574 7572 6e20 7265 7375 6c74 0a0a 2020  eturn result..  
+00011ac0: 2020 2320 2323 2323 2323 2323 2323 2323    # ############
+00011ad0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011ae0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011af0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011b00: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
+00011b10: 2020 2023 204c 6173 6572 2054 656d 7065     # Laser Tempe
+00011b20: 7261 7475 7265 0a20 2020 2023 2023 2323  rature.    # ###
+00011b30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011b40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011b50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011b60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011b70: 2323 2323 2323 230a 0a20 2020 2064 6566  #######..    def
+00011b80: 2073 6574 5f6c 6173 6572 5f74 6563 5f6d   set_laser_tec_m
+00011b90: 6f64 6528 7365 6c66 2c20 6d6f 6465 293a  ode(self, mode):
+00011ba0: 0a20 2020 2020 2020 2069 6620 6e6f 7420  .        if not 
+00011bb0: 7365 6c66 2e73 6574 7469 6e67 732e 6973  self.settings.is
+00011bc0: 5f78 7328 293a 0a20 2020 2020 2020 2020  _xs():.         
+00011bd0: 2020 206d 7367 203d 2022 4c61 7365 7220     msg = "Laser 
+00011be0: 5445 4320 6d6f 6465 206f 6e6c 7920 6170  TEC mode only ap
+00011bf0: 706c 6963 6162 6c65 206f 6e20 5853 220a  plicable on XS".
+00011c00: 2020 2020 2020 2020 2020 2020 6c6f 672e              log.
+00011c10: 6572 726f 7228 6d73 6729 0a20 2020 2020  error(msg).     
+00011c20: 2020 2020 2020 2072 6574 7572 6e20 5370         return Sp
+00011c30: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
+00011c40: 7365 2864 6174 613d 4e6f 6e65 2c20 6572  se(data=None, er
+00011c50: 726f 725f 6c76 6c3d 4572 726f 724c 6576  ror_lvl=ErrorLev
+00011c60: 656c 2e6c 6f77 2c20 6572 726f 725f 6d73  el.low, error_ms
+00011c70: 673d 6d73 6729 0a0a 2020 2020 2020 2020  g=msg)..        
+00011c80: 6966 2069 7369 6e73 7461 6e63 6528 6d6f  if isinstance(mo
+00011c90: 6465 2c20 7374 7229 3a0a 2020 2020 2020  de, str):.      
+00011ca0: 2020 2020 2020 6d6f 6465 203d 206d 6f64        mode = mod
+00011cb0: 652e 7570 7065 7228 290a 2020 2020 2020  e.upper().      
+00011cc0: 2020 2020 2020 6966 206d 6f64 6520 3d3d        if mode ==
+00011cd0: 2022 4f46 4622 3a20 0a20 2020 2020 2020   "OFF": .       
+00011ce0: 2020 2020 2020 2020 206d 6f64 6520 3d20           mode = 
+00011cf0: 300a 2020 2020 2020 2020 2020 2020 656c  0.            el
+00011d00: 6966 206d 6f64 6520 3d3d 2022 4f4e 223a  if mode == "ON":
+00011d10: 2020 0a20 2020 2020 2020 2020 2020 2020    .             
+00011d20: 2020 206d 6f64 6520 3d20 310a 2020 2020     mode = 1.    
+00011d30: 2020 2020 2020 2020 656c 6966 206d 6f64          elif mod
+00011d40: 6520 3d3d 2022 4155 544f 223a 200a 2020  e == "AUTO": .  
+00011d50: 2020 2020 2020 2020 2020 2020 2020 6d6f                mo
+00011d60: 6465 203d 2032 0a20 2020 2020 2020 2020  de = 2.         
+00011d70: 2020 2065 6c69 6620 6d6f 6465 203d 3d20     elif mode == 
+00011d80: 2241 5554 4f5f 4f4e 223a 200a 2020 2020  "AUTO_ON": .    
+00011d90: 2020 2020 2020 2020 2020 2020 6d6f 6465              mode
+00011da0: 203d 2033 0a20 2020 2020 2020 2020 2020   = 3.           
+00011db0: 2065 6c73 653a 200a 2020 2020 2020 2020   else: .        
+00011dc0: 2020 2020 2020 2020 6d6f 6465 203d 2030          mode = 0
+00011dd0: 0a0a 2020 2020 2020 2020 6d6f 6465 203d  ..        mode =
+00011de0: 206d 696e 2833 2c20 6d61 7828 302c 2069   min(3, max(0, i
+00011df0: 6e74 286d 6f64 6529 2929 0a20 2020 2020  nt(mode))).     
+00011e00: 2020 2073 656c 662e 7365 7474 696e 6773     self.settings
+00011e10: 2e73 7461 7465 2e6c 6173 6572 5f74 6563  .state.laser_tec
+00011e20: 5f6d 6f64 6520 3d20 6d6f 6465 0a20 2020  _mode = mode.   
+00011e30: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+00011e40: 2e5f 7365 6e64 5f63 6f64 6528 3078 3834  ._send_code(0x84
+00011e50: 2c20 6d6f 6465 2c20 6c61 6265 6c3d 2253  , mode, label="S
+00011e60: 4554 5f4c 4153 4552 5f54 4543 5f4d 4f44  ET_LASER_TEC_MOD
+00011e70: 4522 290a 0a20 2020 2064 6566 2067 6574  E")..    def get
+00011e80: 5f6c 6173 6572 5f74 6563 5f6d 6f64 6528  _laser_tec_mode(
+00011e90: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
+00011ea0: 2222 200a 2020 2020 2020 2020 5468 6520  "" .        The 
+00011eb0: 6375 7272 656e 7420 6f70 636f 6465 2028  current opcode (
+00011ec0: 3078 3835 2920 7365 656d 7320 746f 2062  0x85) seems to b
+00011ed0: 6520 6163 7475 616c 6c79 2072 6574 7572  e actually retur
+00011ee0: 6e69 6e67 200a 2020 2020 2020 2020 4745  ning .        GE
+00011ef0: 545f 4c41 5345 525f 5445 435f 454e 4142  T_LASER_TEC_ENAB
+00011f00: 4c45 442c 206e 6f74 2047 4554 5f4c 4153  LED, not GET_LAS
+00011f10: 4552 5f54 4543 5f4d 4f44 452e 200a 2020  ER_TEC_MODE. .  
+00011f20: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00011f30: 2020 6966 206e 6f74 2073 656c 662e 7365    if not self.se
+00011f40: 7474 696e 6773 2e69 735f 7873 2829 3a0a  ttings.is_xs():.
+00011f50: 2020 2020 2020 2020 2020 2020 6d73 6720              msg 
+00011f60: 3d20 224c 6173 6572 2054 4543 206d 6f64  = "Laser TEC mod
+00011f70: 6520 6f6e 6c79 2061 7070 6c69 6361 626c  e only applicabl
+00011f80: 6520 6f6e 2058 5322 0a20 2020 2020 2020  e on XS".       
+00011f90: 2020 2020 206c 6f67 2e65 7272 6f72 286d       log.error(m
+00011fa0: 7367 290a 2020 2020 2020 2020 2020 2020  sg).            
+00011fb0: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
+00011fc0: 7465 7252 6573 706f 6e73 6528 6461 7461  terResponse(data
+00011fd0: 3d4e 6f6e 652c 2065 7272 6f72 5f6c 766c  =None, error_lvl
+00011fe0: 3d45 7272 6f72 4c65 7665 6c2e 6c6f 772c  =ErrorLevel.low,
+00011ff0: 2065 7272 6f72 5f6d 7367 3d6d 7367 290a   error_msg=msg).
+00012000: 0a20 2020 2020 2020 2072 6573 756c 7420  .        result 
+00012010: 3d20 7365 6c66 2e5f 6765 745f 636f 6465  = self._get_code
+00012020: 2830 7838 352c 2077 4c65 6e67 7468 3d31  (0x85, wLength=1
+00012030: 2c20 6c61 6265 6c3d 2247 4554 5f4c 4153  , label="GET_LAS
+00012040: 4552 5f54 4543 5f4d 4f44 4522 2c20 6c73  ER_TEC_MODE", ls
+00012050: 625f 6c65 6e3d 3129 0a20 2020 2020 2020  b_len=1).       
+00012060: 2069 6620 7265 7375 6c74 2069 7320 4e6f   if result is No
+00012070: 6e65 206f 7220 7265 7375 6c74 2e64 6174  ne or result.dat
+00012080: 6120 3c20 3020 6f72 2072 6573 756c 742e  a < 0 or result.
+00012090: 6461 7461 203e 2033 3a0a 2020 2020 2020  data > 3:.      
+000120a0: 2020 2020 2020 6d73 6720 3d20 6622 6765        msg = f"ge
+000120b0: 745f 6c61 7365 725f 7465 635f 6d6f 6465  t_laser_tec_mode
+000120c0: 3a20 696e 7661 6c69 6420 6d6f 6465 207b  : invalid mode {
+000120d0: 7265 7375 6c74 7d22 0a20 2020 2020 2020  result}".       
+000120e0: 2020 2020 206c 6f67 2e65 7272 6f72 286d       log.error(m
+000120f0: 7367 290a 2020 2020 2020 2020 2020 2020  sg).            
+00012100: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
+00012110: 7465 7252 6573 706f 6e73 6528 6461 7461  terResponse(data
+00012120: 3d4e 6f6e 652c 2065 7272 6f72 5f6c 766c  =None, error_lvl
+00012130: 3d45 7272 6f72 4c65 7665 6c2e 6c6f 772c  =ErrorLevel.low,
+00012140: 2065 7272 6f72 5f6d 7367 3d6d 7367 290a   error_msg=msg).
+00012150: 0a20 2020 2020 2020 2023 206d 6f64 6520  .        # mode 
+00012160: 3d20 7265 7375 6c74 2e64 6174 610a 2020  = result.data.  
+00012170: 2020 2020 2020 2320 6e61 6d65 7320 3d20        # names = 
+00012180: 5b20 274f 4646 272c 2027 4f4e 272c 2027  [ 'OFF', 'ON', '
+00012190: 4155 544f 272c 2027 4155 544f 5f4f 4e27  AUTO', 'AUTO_ON'
+000121a0: 205d 0a20 2020 2020 2020 2023 206c 6f67   ].        # log
+000121b0: 2e64 6562 7567 2866 2267 6574 5f6c 6173  .debug(f"get_las
+000121c0: 6572 5f74 6563 5f6d 6f64 653a 206d 6f64  er_tec_mode: mod
+000121d0: 6520 7b6e 616d 6573 5b6d 6f64 655d 7d22  e {names[mode]}"
+000121e0: 290a 2020 2020 2020 2020 2320 7365 6c66  ).        # self
+000121f0: 2e73 6574 7469 6e67 732e 7374 6174 652e  .settings.state.
+00012200: 6c61 7365 725f 7465 635f 6d6f 6465 203d  laser_tec_mode =
+00012210: 206d 6f64 6520 0a0a 2020 2020 2020 2020   mode ..        
+00012220: 656e 6162 6c65 6420 3d20 3020 213d 2072  enabled = 0 != r
+00012230: 6573 756c 742e 6461 7461 0a20 2020 2020  esult.data.     
+00012240: 2020 206c 6f67 2e64 6562 7567 2866 2267     log.debug(f"g
+00012250: 6574 5f6c 6173 6572 5f74 6563 5f6d 6f64  et_laser_tec_mod
+00012260: 653a 2065 6e61 626c 6564 207b 656e 6162  e: enabled {enab
+00012270: 6c65 647d 2229 0a20 2020 2020 2020 2073  led}").        s
+00012280: 656c 662e 7365 7474 696e 6773 2e73 7461  elf.settings.sta
+00012290: 7465 2e6c 6173 6572 5f74 6563 5f65 6e61  te.laser_tec_ena
+000122a0: 626c 6564 203d 2065 6e61 626c 6564 0a0a  bled = enabled..
+000122b0: 2020 2020 2020 2020 7265 7475 726e 2072          return r
+000122c0: 6573 756c 740a 0a20 2020 2023 230a 2020  esult..    ##.  
+000122d0: 2020 2320 4c61 7365 7220 7465 6d70 6572    # Laser temper
+000122e0: 6174 7572 6520 636f 6e76 6572 7369 6f6e  ature conversion
+000122f0: 2064 6f65 736e 2774 2075 7365 2045 4550   doesn't use EEP
+00012300: 524f 4d20 636f 6566 6673 2061 7420 616c  ROM coeffs at al
+00012310: 6c2e 0a20 2020 2023 0a20 2020 2023 2057  l..    #.    # W
+00012320: 6173 6174 6368 2053 4d4c 2070 726f 6475  asatch SML produ
+00012330: 6374 7320 7573 6520 616e 2049 5053 2057  cts use an IPS W
+00012340: 6176 656c 656e 6774 682d 5374 6162 696c  avelength-Stabil
+00012350: 697a 6564 2054 4f2d 3536 0a20 2020 2023  ized TO-56.    #
+00012360: 206c 6173 6572 2c20 7768 6963 6820 696e   laser, which in
+00012370: 7465 726e 616c 6c79 2075 7365 7320 6120  ternally uses a 
+00012380: 4265 7461 7468 6572 6d20 3130 4b33 4347  Betatherm 10K3CG
+00012390: 3320 7468 6572 6d69 7374 6f72 2e0a 2020  3 thermistor..  
+000123a0: 2020 230a 2020 2020 2320 4073 6565 2068    #.    # @see h
+000123b0: 7474 7073 3a2f 2f77 7777 2e69 7073 6c61  ttps://www.ipsla
+000123c0: 7365 7273 2e63 6f6d 2f64 6174 612d 7368  sers.com/data-sh
+000123d0: 6565 7473 2f53 4d2d 544f 2d35 362d 4461  eets/SM-TO-56-Da
+000123e0: 7461 2d53 6865 6574 2d49 5053 2e70 6466  ta-Sheet-IPS.pdf
+000123f0: 0a20 2020 2023 0a20 2020 2023 2054 6865  .    #.    # The
+00012400: 206f 6666 6963 6961 6c20 636f 6e76 6572   official conver
+00012410: 7369 6f6e 2066 726f 6d20 7468 6572 6d69  sion from thermi
+00012420: 7374 6f72 2072 6573 6973 7461 6e63 6520  stor resistance 
+00012430: 2869 6e20 6f68 6d73 2920 746f 2064 6567  (in ohms) to deg
+00012440: 4320 6973 3a0a 2020 2020 230a 2020 2020  C is:.    #.    
+00012450: 2320 5c76 6572 6261 7469 6d0a 2020 2020  # \verbatim.    
+00012460: 2320 3120 2f20 2820 2020 4331 0a20 2020  # 1 / (   C1.   
+00012470: 2023 2020 2020 2020 202b 2043 3220 2a20   #       + C2 * 
+00012480: 6c6e 286f 686d 7329 0a20 2020 2023 2020  ln(ohms).    #  
+00012490: 2020 2020 202b 2043 3320 2a20 706f 7728       + C3 * pow(
+000124a0: 6c6e 286f 686d 7329 2c20 3329 0a20 2020  ln(ohms), 3).   
+000124b0: 2023 2020 2020 2029 0a20 2020 2023 202d   #     ).    # -
+000124c0: 2032 3733 2e31 350a 2020 2020 230a 2020   273.15.    #.  
+000124d0: 2020 2320 5768 6572 653a 2043 3120 3d20    # Where: C1 = 
+000124e0: 302e 3030 3131 330a 2020 2020 2320 2020  0.00113.    #   
+000124f0: 2020 2020 2043 3220 3d20 302e 3030 3032       C2 = 0.0002
+00012500: 3334 0a20 2020 2023 2020 2020 2020 2020  34.    #        
+00012510: 4333 203d 2038 2e37 3865 2d38 0a20 2020  C3 = 8.78e-8.   
+00012520: 2023 205c 656e 6476 6572 6261 7469 6d0a   # \endverbatim.
+00012530: 2020 2020 230a 2020 2020 2320 5468 6174      #.    # That
+00012540: 2073 6169 642c 206f 6e20 5853 2074 6865   said, on XS the
+00012550: 2049 5053 2074 6865 726d 6973 746f 7220   IPS thermistor 
+00012560: 7468 656e 2067 6f65 7320 7468 726f 7567  then goes throug
+00012570: 6820 6120 4d41 5831 3937 3845 544d 2d54  h a MAX1978ETM-T
+00012580: 0a20 2020 2023 2054 4543 2049 4320 7768  .    # TEC IC wh
+00012590: 6963 6820 6275 6666 6572 7320 7468 6520  ich buffers the 
+000125a0: 7468 6572 6d69 7374 6f72 2076 6f6c 7461  thermistor volta
+000125b0: 6765 2e20 5468 6973 2072 6571 7569 7265  ge. This require
+000125c0: 7320 7468 6520 6164 6469 7469 6f6e 616c  s the additional
+000125d0: 0a20 2020 2023 2065 6d70 6972 6963 616c  .    # empirical
+000125e0: 6c79 2d64 6574 6572 6d69 6e65 6420 7374  ly-determined st
+000125f0: 6174 6963 2063 6f6e 7665 7273 696f 6e20  atic conversion 
+00012600: 6361 7074 7572 6564 2062 656c 6f77 2e0a  captured below..
+00012610: 2020 2020 230a 2020 2020 2320 5265 6772      #.    # Regr
+00012620: 6574 7461 626c 792c 2074 6865 206c 6173  ettably, the las
+00012630: 6572 2074 6865 726d 6973 746f 7220 766f  er thermistor vo
+00012640: 6c74 6167 6520 6f6e 2058 2073 6572 6965  ltage on X serie
+00012650: 7320 7370 6563 7472 6f6d 6574 6572 730a  s spectrometers.
+00012660: 2020 2020 2320 6f76 6572 666c 6f77 7320      # overflows 
+00012670: 7468 6520 4144 4320 7261 6e67 652c 2073  the ADC range, s
+00012680: 6f20 7765 2064 6f6e 2774 2063 7572 7265  o we don't curre
+00012690: 6e74 6c79 2068 6176 6520 7661 6c69 6420  ntly have valid 
+000126a0: 6c61 7365 7220 0a20 2020 2023 2074 656d  laser .    # tem
+000126b0: 7065 7261 7475 7265 2072 6561 642d 6f75  perature read-ou
+000126c0: 7420 6f6e 2058 2e20 0a20 2020 2023 0a20  t on X. .    #. 
+000126d0: 2020 2023 2041 6c73 6f2c 206f 6e20 4d4d     # Also, on MM
+000126e0: 4c20 756e 6974 7320 7573 696e 6720 7468  L units using th
+000126f0: 6520 4f6e 6461 7820 4f45 4d20 4d6f 6475  e Ondax OEM Modu
+00012700: 6c65 2c20 7468 6520 6361 626c 6520 746f  le, the cable to
+00012710: 2074 6865 2032 3230 3036 3020 0a20 2020   the 220060 .   
+00012720: 2023 2064 6f65 7320 6e6f 7420 7365 656d   # does not seem
+00012730: 2074 6f20 7061 7373 2d74 6872 6f75 6768   to pass-through
+00012740: 2074 6865 2074 6865 726d 6973 746f 7220   the thermistor 
+00012750: 7069 6e2c 2073 6f20 7765 2064 6f6e 2774  pin, so we don't
+00012760: 2068 6176 650a 2020 2020 2320 6c61 7365   have.    # lase
+00012770: 7220 7465 6d70 6572 6174 7572 6520 7265  r temperature re
+00012780: 6164 2d6f 7574 206f 6e20 7468 6f73 652c  ad-out on those,
+00012790: 2065 6974 6865 722e 2028 4e6f 7220 7068   either. (Nor ph
+000127a0: 6f74 6f64 696f 6465 2e2e 2e29 0a20 2020  otodiode...).   
+000127b0: 2023 0a20 2020 2023 2040 7061 7261 6d20   #.    # @param 
+000127c0: 7261 7720 2020 2074 6865 2076 616c 7565  raw    the value
+000127d0: 2072 6561 6420 6672 6f6d 2074 6865 2074   read from the t
+000127e0: 6865 726d 6973 746f 7227 7320 3132 2d62  hermistor's 12-b
+000127f0: 6974 2041 4443 2028 6361 6e20 6265 0a20  it ADC (can be. 
+00012800: 2020 2023 2020 2020 2020 2020 2020 2020     #            
+00012810: 2020 2075 696e 7431 3220 6f72 2053 7065     uint12 or Spe
+00012820: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
+00012830: 6529 0a20 2020 2064 6566 2067 6574 5f6c  e).    def get_l
+00012840: 6173 6572 5f74 656d 7065 7261 7475 7265  aser_temperature
+00012850: 5f64 6567 4328 7365 6c66 2c20 7261 773d  _degC(self, raw=
+00012860: 4e6f 6e65 293a 0a20 2020 2020 2020 2069  None):.        i
+00012870: 6620 6973 696e 7374 616e 6365 2872 6177  f isinstance(raw
+00012880: 2c20 5370 6563 7472 6f6d 6574 6572 5265  , SpectrometerRe
+00012890: 7370 6f6e 7365 293a 0a20 2020 2020 2020  sponse):.       
+000128a0: 2020 2020 2072 6177 203d 2072 6177 2e64       raw = raw.d
+000128b0: 6174 610a 2020 2020 2020 2020 6966 2072  ata.        if r
+000128c0: 6177 2069 7320 4e6f 6e65 3a0a 2020 2020  aw is None:.    
+000128d0: 2020 2020 2020 2020 7261 7720 3d20 7365          raw = se
+000128e0: 6c66 2e67 6574 5f6c 6173 6572 5f74 656d  lf.get_laser_tem
+000128f0: 7065 7261 7475 7265 5f72 6177 2829 0a0a  perature_raw()..
+00012900: 2020 2020 2020 2020 6966 2072 6177 2069          if raw i
+00012910: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
+00012920: 2020 2020 6d73 673d 2267 6574 5f6c 6173      msg="get_las
+00012930: 6572 5f74 656d 7065 7261 7475 7265 5f64  er_temperature_d
+00012940: 6567 433a 2065 7272 6f72 2072 6561 6469  egC: error readi
+00012950: 6e67 2072 6177 206c 6173 6572 2074 656d  ng raw laser tem
+00012960: 7065 7261 7475 7265 220a 2020 2020 2020  perature".      
+00012970: 2020 2020 2020 6c6f 672e 6572 726f 7228        log.error(
+00012980: 6d73 6729 0a20 2020 2020 2020 2020 2020  msg).           
+00012990: 2072 6574 7572 6e20 5370 6563 7472 6f6d   return Spectrom
+000129a0: 6574 6572 5265 7370 6f6e 7365 2865 7272  eterResponse(err
+000129b0: 6f72 5f6c 766c 3d45 7272 6f72 4c65 7665  or_lvl=ErrorLeve
+000129c0: 6c2e 6c6f 772c 2065 7272 6f72 5f6d 7367  l.low, error_msg
+000129d0: 3d6d 7367 290a 0a20 2020 2020 2020 2069  =msg)..        i
+000129e0: 6620 7261 7720 3e20 3078 6666 663a 0a20  f raw > 0xfff:. 
+000129f0: 2020 2020 2020 2020 2020 206d 7367 203d             msg =
+00012a00: 2066 2267 6574 5f6c 6173 6572 5f74 656d   f"get_laser_tem
+00012a10: 7065 7261 7475 7265 5f64 6567 433a 2072  perature_degC: r
+00012a20: 6177 2076 616c 7565 2030 787b 7261 773a  aw value 0x{raw:
+00012a30: 787d 2065 7863 6565 6473 2031 3220 6269  x} exceeds 12 bi
+00012a40: 7473 220a 2020 2020 2020 2020 2020 2020  ts".            
+00012a50: 6c6f 672e 6572 726f 7228 6d73 6729 0a20  log.error(msg). 
+00012a60: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00012a70: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
+00012a80: 7370 6f6e 7365 2864 6174 613d 4e6f 6e65  sponse(data=None
+00012a90: 2c20 6572 726f 725f 6c76 6c3d 4572 726f  , error_lvl=Erro
+00012aa0: 724c 6576 656c 2e6c 6f77 2c20 6572 726f  rLevel.low, erro
+00012ab0: 725f 6d73 673d 6d73 6729 0a0a 2020 2020  r_msg=msg)..    
+00012ac0: 2020 2020 6966 2072 6177 203d 3d20 303a      if raw == 0:
+00012ad0: 0a20 2020 2020 2020 2020 2020 206d 7367  .            msg
+00012ae0: 203d 2022 6765 745f 6c61 7365 725f 7465   = "get_laser_te
+00012af0: 6d70 6572 6174 7572 655f 6465 6743 3a20  mperature_degC: 
+00012b00: 6361 6e27 7420 7461 6b65 206c 6f67 206f  can't take log o
+00012b10: 6620 7261 7720 4144 4320 7661 6c75 6520  f raw ADC value 
+00012b20: 3022 0a20 2020 2020 2020 2020 2020 2023  0".            #
+00012b30: 206c 6f67 2e64 6562 7567 286d 7367 290a   log.debug(msg).
+00012b40: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00012b50: 726e 2053 7065 6374 726f 6d65 7465 7252  rn SpectrometerR
+00012b60: 6573 706f 6e73 6528 6461 7461 3d4e 6f6e  esponse(data=Non
+00012b70: 6529 2023 206e 6f74 2070 726f 706f 6761  e) # not propoga
+00012b80: 7469 6e67 2065 7272 6f72 5f6d 7367 2066  ting error_msg f
+00012b90: 6f72 206e 6f77 0a0a 2020 2020 2020 2020  or now..        
+00012ba0: 6465 6743 203d 2030 0a20 2020 2020 2020  degC = 0.       
+00012bb0: 2074 7279 3a0a 2020 2020 2020 2020 2020   try:.          
+00012bc0: 2020 6966 2073 656c 662e 7365 7474 696e    if self.settin
+00012bd0: 6773 2e69 735f 7873 2829 3a0a 2020 2020  gs.is_xs():.    
+00012be0: 2020 2020 2020 2020 2020 2020 2320 636f              # co
+00012bf0: 6e76 6572 7369 6f6e 2066 6f72 2032 3230  nversion for 220
+00012c00: 3235 3020 5265 7634 204d 4158 3139 3738  250 Rev4 MAX1978
+00012c10: 4554 4d2d 5420 3356 3320 6275 6666 6572  ETM-T 3V3 buffer
+00012c20: 202d 3e20 3132 2d62 6974 2044 4143 202d   -> 12-bit DAC -
+00012c30: 3e20 6465 6743 0a20 2020 2020 2020 2020  > degC.         
+00012c40: 2020 2020 2020 2063 6f65 6666 7320 3d20         coeffs = 
+00012c50: 5b20 312e 3537 3132 3937 3139 3437 3835  [ 1.571297194785
+00012c60: 3331 3233 652b 3030 302c 0a20 2020 2020  3123e+000,.     
+00012c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012c80: 2020 2020 2020 312e 3434 3533 3339 3138        1.44533918
+00012c90: 3839 3036 3130 3731 652d 3030 322c 0a20  89061071e-002,. 
+00012ca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012cb0: 2020 2020 2020 2020 202d 312e 3835 3334           -1.8534
+00012cc0: 3038 3631 3533 3434 3035 3932 652d 3030  086153440592e-00
+00012cd0: 362c 0a20 2020 2020 2020 2020 2020 2020  6,.             
+00012ce0: 2020 2020 2020 2020 2020 2020 2020 342e                4.
+00012cf0: 3235 3533 3335 3634 3730 3439 3436 3236  2553356470494626
+00012d00: 652d 3031 3020 5d0a 2020 2020 2020 2020  e-010 ].        
+00012d10: 2020 2020 2020 2020 666f 7220 692c 2063          for i, c
+00012d20: 6f65 6666 2069 6e20 656e 756d 6572 6174  oeff in enumerat
+00012d30: 6528 636f 6566 6673 293a 0a20 2020 2020  e(coeffs):.     
+00012d40: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+00012d50: 6567 4320 2b3d 2063 6f65 6666 202a 2070  egC += coeff * p
+00012d60: 6f77 2872 6177 2c20 6929 0a20 2020 2020  ow(raw, i).     
+00012d70: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+00012d80: 6f67 2e64 6562 7567 2866 2267 6574 5f6c  og.debug(f"get_l
+00012d90: 6173 6572 5f74 656d 7065 7261 7475 7265  aser_temperature
+00012da0: 5f64 6567 433a 2064 6567 4320 7b64 6567  _degC: degC {deg
+00012db0: 433a 677d 2061 6674 6572 2061 6464 696e  C:g} after addin
+00012dc0: 6720 7b63 6f65 6666 7d20 7820 2870 6f77  g {coeff} x (pow
+00012dd0: 287b 7261 777d 2c20 7b69 7d29 203d 207b  ({raw}, {i}) = {
+00012de0: 706f 7728 7261 772c 2069 293a 677d 2922  pow(raw, i):g})"
+00012df0: 290a 2020 2020 2020 2020 2020 2020 656c  ).            el
+00012e00: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00012e10: 2020 2020 2320 7768 656e 206e 6f74 2075      # when not u
+00012e20: 7369 6e67 2054 4543 2049 430a 2020 2020  sing TEC IC.    
+00012e30: 2020 2020 2020 2020 2020 2020 766f 6c74              volt
+00012e40: 6167 6520 2020 203d 2032 2e35 202a 2072  age    = 2.5 * r
+00012e50: 6177 202f 2034 3039 360a 2020 2020 2020  aw / 4096.      
+00012e60: 2020 2020 2020 2020 2020 7265 7369 7374            resist
+00012e70: 616e 6365 203d 2032 3134 3530 2e30 202a  ance = 21450.0 *
+00012e80: 2076 6f6c 7461 6765 202f 2028 322e 3520   voltage / (2.5 
+00012e90: 2d20 766f 6c74 6167 6529 2023 204c 4220  - voltage) # LB 
+00012ea0: 636f 6e66 6972 6d65 640a 0a20 2020 2020  confirmed..     
+00012eb0: 2020 2020 2020 2020 2020 2069 6620 7265             if re
+00012ec0: 7369 7374 616e 6365 203c 2030 3a0a 2020  sistance < 0:.  
+00012ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012ee0: 2020 6d73 673d 2267 6574 5f6c 6173 6572    msg="get_laser
+00012ef0: 5f74 656d 7065 7261 7475 7265 5f64 6567  _temperature_deg
+00012f00: 433a 2063 616e 2774 2063 6f6d 7075 7465  C: can't compute
+00012f10: 2064 6567 433a 2072 6177 203d 2030 7825   degC: raw = 0x%
+00012f20: 3034 782c 2076 6f6c 7461 6765 203d 2025  04x, voltage = %
+00012f30: 662c 2072 6573 6973 7461 6e63 6520 3d20  f, resistance = 
+00012f40: 2566 2220 2520 280a 2020 2020 2020 2020  %f" % (.        
+00012f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012f60: 7261 772c 2076 6f6c 7461 6765 2c20 7265  raw, voltage, re
+00012f70: 7369 7374 616e 6365 290a 2020 2020 2020  sistance).      
+00012f80: 2020 2020 2020 2020 2020 2020 2020 6c6f                lo
+00012f90: 672e 6572 726f 7228 6d73 6729 0a20 2020  g.error(msg).   
+00012fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012fb0: 2072 6574 7572 6e20 5370 6563 7472 6f6d   return Spectrom
+00012fc0: 6574 6572 5265 7370 6f6e 7365 2864 6174  eterResponse(dat
+00012fd0: 613d 4e6f 6e65 2c20 6572 726f 725f 6c65  a=None, error_le
+00012fe0: 7665 6c3d 4572 726f 724c 6576 656c 2e6c  vel=ErrorLevel.l
+00012ff0: 6f77 2c20 6572 726f 725f 6d73 673d 6d73  ow, error_msg=ms
+00013000: 6729 0a0a 2020 2020 2020 2020 2020 2020  g)..            
+00013010: 2020 2020 6c6f 6756 616c 2020 2020 203d      logVal     =
+00013020: 206d 6174 682e 6c6f 6728 7265 7369 7374   math.log(resist
+00013030: 616e 6365 202f 2031 3030 3030 2e30 290a  ance / 10000.0).
+00013040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013050: 696e 7369 6465 4d61 696e 203d 206c 6f67  insideMain = log
+00013060: 5661 6c20 2b20 3339 3737 2e30 202f 2028  Val + 3977.0 / (
+00013070: 3235 202b 2032 3733 2e30 290a 2020 2020  25 + 273.0).    
+00013080: 2020 2020 2020 2020 2020 2020 6465 6743              degC
+00013090: 2020 2020 2020 203d 2033 3937 372e 3020         = 3977.0 
+000130a0: 2f20 696e 7369 6465 4d61 696e 202d 2032  / insideMain - 2
+000130b0: 3733 2e30 0a0a 2020 2020 2020 2020 2020  73.0..          
+000130c0: 2020 6c6f 672e 6465 6275 6728 224c 6173    log.debug("Las
+000130d0: 6572 2074 656d 7065 7261 7475 7265 3a20  er temperature: 
+000130e0: 252e 3266 2064 6567 2043 2028 3078 2530  %.2f deg C (0x%0
+000130f0: 3478 2072 6177 2922 2025 2028 6465 6743  4x raw)" % (degC
+00013100: 2c20 7261 7729 290a 2020 2020 2020 2020  , raw)).        
+00013110: 6578 6365 7074 3a0a 2020 2020 2020 2020  except:.        
+00013120: 2020 2020 6d73 6720 3d20 2265 7863 6570      msg = "excep
+00013130: 7469 6f6e 2063 6f6d 7075 7469 6e67 206c  tion computing l
+00013140: 6173 6572 2074 656d 7065 7261 7475 7265  aser temperature
+00013150: 220a 2020 2020 2020 2020 2020 2020 6c6f  ".            lo
+00013160: 672e 6572 726f 7228 6d73 672c 2065 7863  g.error(msg, exc
+00013170: 5f69 6e66 6f3d 3129 0a20 2020 2020 2020  _info=1).       
+00013180: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
+00013190: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
+000131a0: 2864 6174 613d 4e6f 6e65 2c20 6572 726f  (data=None, erro
+000131b0: 725f 6c65 7665 6c3d 4572 726f 724c 6576  r_level=ErrorLev
+000131c0: 656c 2e6c 6f77 2c20 6572 726f 725f 6d73  el.low, error_ms
+000131d0: 673d 6d73 6729 0a0a 2020 2020 2020 2020  g=msg)..        
+000131e0: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
+000131f0: 7465 7252 6573 706f 6e73 6528 6461 7461  terResponse(data
+00013200: 3d64 6567 4329 0a0a 2020 2020 2320 2323  =degC)..    # ##
+00013210: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00013220: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00013230: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00013240: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00013250: 2323 2323 2323 2323 0a20 2020 2023 2044  ########.    # D
+00013260: 6574 6563 746f 7220 5465 6d70 6572 6174  etector Temperat
+00013270: 7572 650a 2020 2020 2320 2323 2323 2323  ure.    # ######
+00013280: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00013290: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000132a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000132b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000132c0: 2323 2323 0a0a 2020 2020 2323 2040 6e6f  ####..    ## @no
+000132d0: 7465 2062 6967 2d65 6e64 6961 6e2c 2072  te big-endian, r
+000132e0: 6576 6572 7365 206f 6620 6765 745f 6c61  everse of get_la
+000132f0: 7365 725f 7465 6d70 6572 6174 7572 655f  ser_temperature_
+00013300: 7261 770a 2020 2020 6465 6620 6765 745f  raw.    def get_
+00013310: 6465 7465 6374 6f72 5f74 656d 7065 7261  detector_tempera
+00013320: 7475 7265 5f72 6177 2873 656c 6629 3a0a  ture_raw(self):.
+00013330: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00013340: 656c 662e 5f67 6574 5f63 6f64 6528 3078  elf._get_code(0x
+00013350: 6437 2c20 6c61 6265 6c3d 2247 4554 5f43  d7, label="GET_C
+00013360: 4344 5f54 454d 5022 2c20 6d73 625f 6c65  CD_TEMP", msb_le
+00013370: 6e3d 3229 0a0a 2020 2020 6465 6620 6765  n=2)..    def ge
+00013380: 745f 6465 7465 6374 6f72 5f74 656d 7065  t_detector_tempe
+00013390: 7261 7475 7265 5f64 6567 4328 7365 6c66  rature_degC(self
+000133a0: 2c20 7261 773a 2066 6c6f 6174 203d 204e  , raw: float = N
+000133b0: 6f6e 6529 3a0a 2020 2020 2020 2020 6966  one):.        if
+000133c0: 2072 6177 2069 7320 4e6f 6e65 3a0a 2020   raw is None:.  
+000133d0: 2020 2020 2020 2020 2020 7261 7720 3d20            raw = 
+000133e0: 7365 6c66 2e67 6574 5f64 6574 6563 746f  self.get_detecto
+000133f0: 725f 7465 6d70 6572 6174 7572 655f 7261  r_temperature_ra
+00013400: 7728 292e 6461 7461 0a0a 2020 2020 2020  w().data..      
+00013410: 2020 6966 2072 6177 2069 7320 4e6f 6e65    if raw is None
+00013420: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00013430: 7475 726e 2072 6177 0a0a 2020 2020 2020  turn raw..      
+00013440: 2020 6465 6743 203d 2073 656c 662e 7365    degC = self.se
+00013450: 7474 696e 6773 2e65 6570 726f 6d2e 6164  ttings.eeprom.ad
+00013460: 635f 746f 5f64 6567 435f 636f 6566 6673  c_to_degC_coeffs
+00013470: 5b30 5d20 2020 2020 2020 2020 2020 2020  [0]             
+00013480: 5c0a 2020 2020 2020 2020 2020 2020 202b  \.             +
+00013490: 2073 656c 662e 7365 7474 696e 6773 2e65   self.settings.e
+000134a0: 6570 726f 6d2e 6164 635f 746f 5f64 6567  eprom.adc_to_deg
+000134b0: 435f 636f 6566 6673 5b31 5d20 2a20 7261  C_coeffs[1] * ra
+000134c0: 7720 2020 2020 2020 5c0a 2020 2020 2020  w       \.      
+000134d0: 2020 2020 2020 202b 2073 656c 662e 7365         + self.se
+000134e0: 7474 696e 6773 2e65 6570 726f 6d2e 6164  ttings.eeprom.ad
+000134f0: 635f 746f 5f64 6567 435f 636f 6566 6673  c_to_degC_coeffs
+00013500: 5b32 5d20 2a20 7261 7720 2a20 7261 770a  [2] * raw * raw.
+00013510: 2020 2020 2020 2020 6c6f 672e 6465 6275          log.debu
+00013520: 6728 2244 6574 6563 746f 7220 7465 6d70  g("Detector temp
+00013530: 6572 6174 7572 653a 2025 2e32 6620 6465  erature: %.2f de
+00013540: 6720 4320 2830 7825 3034 7820 7261 7729  g C (0x%04x raw)
+00013550: 2220 2520 2864 6567 432c 2072 6177 2929  " % (degC, raw))
+00013560: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00013570: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
+00013580: 6f6e 7365 2864 6174 613d 6465 6743 290a  onse(data=degC).
+00013590: 0a20 2020 2064 6566 2073 6574 5f64 6574  .    def set_det
+000135a0: 6563 746f 725f 7465 635f 7365 7470 6f69  ector_tec_setpoi
+000135b0: 6e74 5f64 6567 4328 7365 6c66 2c20 6465  nt_degC(self, de
+000135c0: 6743 3a20 666c 6f61 7429 3a0a 2020 2020  gC: float):.    
+000135d0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+000135e0: 4174 7465 6d70 7420 746f 2073 6574 2074  Attempt to set t
+000135f0: 6865 2043 4344 2063 6f6f 6c65 7220 7365  he CCD cooler se
+00013600: 7470 6f69 6e74 2e20 5665 7269 6679 2074  tpoint. Verify t
+00013610: 6861 7420 6974 2069 7320 7769 7468 696e  hat it is within
+00013620: 2061 6e0a 2020 2020 2020 2020 6163 6365   an.        acce
+00013630: 7074 6162 6c65 2072 616e 6765 2e20 4964  ptable range. Id
+00013640: 6561 6c6c 7920 7468 6973 2069 7320 746f  eally this is to
+00013650: 2070 7265 7665 6e74 2063 6f6e 6465 6e73   prevent condens
+00013660: 6174 696f 6e20 616e 6420 6f74 6865 720a  ation and other.
+00013670: 2020 2020 2020 2020 6973 7375 6573 2e20          issues. 
+00013680: 5468 6973 2076 616c 7565 2069 7320 6120  This value is a 
+00013690: 6465 6661 756c 7420 616e 6420 6973 2068  default and is h
+000136a0: 7567 656c 7920 6465 7065 6e64 656e 7420  ugely dependent 
+000136b0: 6f6e 2074 6865 0a20 2020 2020 2020 2065  on the.        e
+000136c0: 6e76 6972 6f6e 6d65 6e74 616c 2063 6f6e  nvironmental con
+000136d0: 6469 7469 6f6e 732e 0a20 2020 2020 2020  ditions..       
+000136e0: 2022 2222 0a20 2020 2020 2020 2069 6620   """.        if 
+000136f0: 6e6f 7420 7365 6c66 2e73 6574 7469 6e67  not self.setting
+00013700: 732e 6565 7072 6f6d 2e68 6173 5f63 6f6f  s.eeprom.has_coo
+00013710: 6c69 6e67 3a0a 2020 2020 2020 2020 2020  ling:.          
+00013720: 2020 6c6f 672e 6572 726f 7228 2275 6e61    log.error("una
+00013730: 626c 6520 746f 2063 6f6e 7472 6f6c 2054  ble to control T
+00013740: 4543 3a20 4545 5052 4f4d 2072 6570 6f72  EC: EEPROM repor
+00013750: 7473 206e 6f20 636f 6f6c 696e 6722 290a  ts no cooling").
+00013760: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00013770: 726e 2053 7065 6374 726f 6d65 7465 7252  rn SpectrometerR
+00013780: 6573 706f 6e73 6528 6461 7461 3d46 616c  esponse(data=Fal
+00013790: 7365 2c20 6572 726f 725f 6c76 6c3d 4572  se, error_lvl=Er
+000137a0: 726f 724c 6576 656c 2e6c 6f77 2c20 6572  rorLevel.low, er
+000137b0: 726f 725f 6d73 673d 2275 6e61 626c 6520  ror_msg="unable 
+000137c0: 746f 2063 6f6e 7472 6f6c 2054 4543 3a20  to control TEC: 
+000137d0: 4545 5052 4f4d 2072 6570 6f72 7473 206e  EEPROM reports n
+000137e0: 6f20 636f 6f6c 696e 6722 290a 0a20 2020  o cooling")..   
+000137f0: 2020 2020 2069 6620 6465 6743 203c 2073       if degC < s
+00013800: 656c 662e 7365 7474 696e 6773 2e65 6570  elf.settings.eep
+00013810: 726f 6d2e 6d69 6e5f 7465 6d70 5f64 6567  rom.min_temp_deg
+00013820: 433a 0a20 2020 2020 2020 2020 2020 206c  C:.            l
+00013830: 6f67 2e63 7269 7469 6361 6c28 2273 6574  og.critical("set
+00013840: 5f64 6574 6563 746f 725f 7465 635f 7365  _detector_tec_se
+00013850: 7470 6f69 6e74 5f64 6567 433a 2073 6574  tpoint_degC: set
+00013860: 706f 696e 7420 2566 2062 656c 6f77 206d  point %f below m
+00013870: 696e 2025 6622 2c20 6465 6743 2c20 7365  in %f", degC, se
+00013880: 6c66 2e73 6574 7469 6e67 732e 6565 7072  lf.settings.eepr
+00013890: 6f6d 2e6d 696e 5f74 656d 705f 6465 6743  om.min_temp_degC
+000138a0: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+000138b0: 7475 726e 2053 7065 6374 726f 6d65 7465  turn Spectromete
+000138c0: 7252 6573 706f 6e73 6528 6461 7461 3d46  rResponse(data=F
+000138d0: 616c 7365 2c20 6572 726f 725f 6c76 6c3d  alse, error_lvl=
+000138e0: 4572 726f 724c 6576 656c 2e6c 6f77 2c20  ErrorLevel.low, 
+000138f0: 6572 726f 725f 6d73 673d 2273 6574 706f  error_msg="setpo
+00013900: 696e 7420 6265 6c6f 7720 6d69 6e69 6d75  int below minimu
+00013910: 6d22 290a 0a20 2020 2020 2020 2069 6620  m")..        if 
+00013920: 6465 6743 203e 2073 656c 662e 7365 7474  degC > self.sett
+00013930: 696e 6773 2e65 6570 726f 6d2e 6d61 785f  ings.eeprom.max_
+00013940: 7465 6d70 5f64 6567 433a 0a20 2020 2020  temp_degC:.     
+00013950: 2020 2020 2020 206c 6f67 2e63 7269 7469         log.criti
+00013960: 6361 6c28 2273 6574 5f64 6574 6563 746f  cal("set_detecto
+00013970: 725f 7465 635f 7365 7470 6f69 6e74 5f64  r_tec_setpoint_d
+00013980: 6567 433a 2073 6574 706f 696e 7420 2566  egC: setpoint %f
+00013990: 2065 7863 6565 6473 206d 6178 2025 6622   exceeds max %f"
+000139a0: 2c20 6465 6743 2c20 7365 6c66 2e73 6574  , degC, self.set
+000139b0: 7469 6e67 732e 6565 7072 6f6d 2e6d 6178  tings.eeprom.max
+000139c0: 5f74 656d 705f 6465 6743 290a 2020 2020  _temp_degC).    
+000139d0: 2020 2020 2020 2020 7265 7475 726e 2053          return S
+000139e0: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
+000139f0: 6e73 6528 6461 7461 3d46 616c 7365 2c20  nse(data=False, 
+00013a00: 6572 726f 725f 6c76 6c3d 4572 726f 724c  error_lvl=ErrorL
+00013a10: 6576 656c 2e6c 6f77 2c20 6572 726f 725f  evel.low, error_
+00013a20: 6d73 673d 2273 6574 706f 696e 7420 6265  msg="setpoint be
+00013a30: 796f 6e64 206d 6178 2229 0a0a 2020 2020  yond max")..    
+00013a40: 2020 2020 7261 7720 3d20 696e 7428 726f      raw = int(ro
+00013a50: 756e 6428 7365 6c66 2e73 6574 7469 6e67  und(self.setting
+00013a60: 732e 6565 7072 6f6d 2e64 6567 435f 746f  s.eeprom.degC_to
+00013a70: 5f64 6163 5f63 6f65 6666 735b 305d 0a20  _dac_coeffs[0]. 
+00013a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013a90: 2020 2020 202b 2073 656c 662e 7365 7474       + self.sett
+00013aa0: 696e 6773 2e65 6570 726f 6d2e 6465 6743  ings.eeprom.degC
+00013ab0: 5f74 6f5f 6461 635f 636f 6566 6673 5b31  _to_dac_coeffs[1
+00013ac0: 5d20 2a20 6465 6743 0a20 2020 2020 2020  ] * degC.       
+00013ad0: 2020 2020 2020 2020 2020 2020 2020 202b                 +
+00013ae0: 2073 656c 662e 7365 7474 696e 6773 2e65   self.settings.e
+00013af0: 6570 726f 6d2e 6465 6743 5f74 6f5f 6461  eprom.degC_to_da
+00013b00: 635f 636f 6566 6673 5b32 5d20 2a20 6465  c_coeffs[2] * de
+00013b10: 6743 202a 2064 6567 4329 290a 0a20 2020  gC * degC))..   
+00013b20: 2020 2020 2023 2052 4f55 4e44 2028 646f       # ROUND (do
+00013b30: 6e27 7420 6d61 736b 2920 746f 2031 322d  n't mask) to 12-
+00013b40: 6269 7420 4441 430a 2020 2020 2020 2020  bit DAC.        
+00013b50: 7261 7720 3d20 6d61 7828 302c 206d 696e  raw = max(0, min
+00013b60: 2872 6177 2c20 3078 6666 6629 290a 0a20  (raw, 0xfff)).. 
+00013b70: 2020 2020 2020 206c 6f67 2e64 6562 7567         log.debug
+00013b80: 2822 5365 7420 4343 4420 5445 4320 5365  ("Set CCD TEC Se
+00013b90: 7470 6f69 6e74 3a20 252e 3266 2064 6567  tpoint: %.2f deg
+00013ba0: 2043 2028 7261 7720 4144 4320 3078 2530   C (raw ADC 0x%0
+00013bb0: 3478 2922 2c20 6465 6743 2c20 7261 7729  4x)", degC, raw)
+00013bc0: 0a20 2020 2020 2020 206f 6b20 3d20 7365  .        ok = se
+00013bd0: 6c66 2e5f 7365 6e64 5f63 6f64 6528 3078  lf._send_code(0x
+00013be0: 6438 2c20 7261 772c 206c 6162 656c 3d22  d8, raw, label="
+00013bf0: 5345 545f 4445 5445 4354 4f52 5f54 4543  SET_DETECTOR_TEC
+00013c00: 5f53 4554 504f 494e 5422 290a 2020 2020  _SETPOINT").    
+00013c10: 2020 2020 7365 6c66 2e73 6574 7469 6e67      self.setting
+00013c20: 732e 7374 6174 652e 7465 635f 7365 7470  s.state.tec_setp
+00013c30: 6f69 6e74 5f64 6567 4320 3d20 6465 6743  oint_degC = degC
+00013c40: 0a20 2020 2020 2020 2073 656c 662e 6465  .        self.de
+00013c50: 7465 6374 6f72 5f74 6563 5f73 6574 706f  tector_tec_setpo
+00013c60: 696e 745f 6861 735f 6265 656e 5f73 6574  int_has_been_set
+00013c70: 203d 2054 7275 650a 2020 2020 2020 2020   = True.        
+00013c80: 7265 7475 726e 206f 6b0a 0a20 2020 2064  return ok..    d
+00013c90: 6566 2067 6574 5f64 6574 6563 746f 725f  ef get_detector_
+00013ca0: 7465 635f 7365 7470 6f69 6e74 5f64 6567  tec_setpoint_deg
+00013cb0: 4328 7365 6c66 293a 0a20 2020 2020 2020  C(self):.       
+00013cc0: 2069 6620 7365 6c66 2e64 6574 6563 746f   if self.detecto
+00013cd0: 725f 7465 635f 7365 7470 6f69 6e74 5f68  r_tec_setpoint_h
+00013ce0: 6173 5f62 6565 6e5f 7365 743a 0a20 2020  as_been_set:.   
+00013cf0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00013d00: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
+00013d10: 6f6e 7365 2873 656c 662e 7365 7474 696e  onse(self.settin
+00013d20: 6773 2e73 7461 7465 2e74 6563 5f73 6574  gs.state.tec_set
+00013d30: 706f 696e 745f 6465 6743 290a 2020 2020  point_degC).    
+00013d40: 2020 2020 6c6f 672e 6572 726f 7228 2244      log.error("D
+00013d50: 6574 6563 746f 7220 5445 4320 7365 7470  etector TEC setp
+00013d60: 6f69 6e74 2068 6173 206e 6f74 2079 6574  oint has not yet
+00013d70: 2062 6565 6e20 6170 706c 6965 6422 290a   been applied").
+00013d80: 2020 2020 2020 2020 7265 7475 726e 2053          return S
+00013d90: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
+00013da0: 6e73 6528 6461 7461 3d30 2e30 290a 0a20  nse(data=0.0).. 
+00013db0: 2020 2064 6566 2067 6574 5f64 6574 6563     def get_detec
+00013dc0: 746f 725f 7465 635f 7365 7470 6f69 6e74  tor_tec_setpoint
+00013dd0: 5f72 6177 2873 656c 6629 3a0a 2020 2020  _raw(self):.    
+00013de0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+00013df0: 6765 745f 6461 6328 3029 0a0a 2020 2020  get_dac(0)..    
+00013e00: 2323 2040 746f 646f 2072 656e 616d 6520  ## @todo rename 
+00013e10: 7365 745f 6465 7465 6374 6f72 5f74 6563  set_detector_tec
+00013e20: 5f65 6e61 626c 650a 2020 2020 6465 6620  _enable.    def 
+00013e30: 7365 745f 7465 635f 656e 6162 6c65 2873  set_tec_enable(s
+00013e40: 656c 662c 2066 6c61 673a 2062 6f6f 6c29  elf, flag: bool)
+00013e50: 3a0a 2020 2020 2020 2020 6966 206e 6f74  :.        if not
+00013e60: 2073 656c 662e 7365 7474 696e 6773 2e65   self.settings.e
+00013e70: 6570 726f 6d2e 6861 735f 636f 6f6c 696e  eprom.has_coolin
+00013e80: 673a 0a20 2020 2020 2020 2020 2020 206c  g:.            l
+00013e90: 6f67 2e64 6562 7567 2822 756e 6162 6c65  og.debug("unable
+00013ea0: 2074 6f20 636f 6e74 726f 6c20 5445 433a   to control TEC:
+00013eb0: 2045 4550 524f 4d20 7265 706f 7274 7320   EEPROM reports 
+00013ec0: 6e6f 2063 6f6f 6c69 6e67 2229 0a20 2020  no cooling").   
+00013ed0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00013ee0: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
+00013ef0: 6f6e 7365 2864 6174 613d 4661 6c73 652c  onse(data=False,
+00013f00: 2065 7272 6f72 5f6d 7367 3d22 756e 6162   error_msg="unab
+00013f10: 6c65 2074 6f20 636f 6e74 726f 6c20 5445  le to control TE
+00013f20: 433a 2045 4550 524f 4d20 7265 706f 7274  C: EEPROM report
+00013f30: 7320 6e6f 2063 6f6f 6c69 6e67 2229 0a0a  s no cooling")..
+00013f40: 2020 2020 2020 2020 6966 206e 6f74 2073          if not s
+00013f50: 656c 662e 7365 7474 696e 6773 2e65 6570  elf.settings.eep
+00013f60: 726f 6d2e 6861 735f 6465 7465 6374 6f72  rom.has_detector
+00013f70: 5f74 6563 5f63 616c 6962 7261 7469 6f6e  _tec_calibration
+00013f80: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
+00013f90: 6c6f 672e 6465 6275 6728 2275 6e61 626c  log.debug("unabl
+00013fa0: 6520 746f 2063 6f6e 7472 6f6c 2054 4543  e to control TEC
+00013fb0: 3a20 4545 5052 4f4d 206d 6973 7369 6e67  : EEPROM missing
+00013fc0: 2076 616c 6964 2054 4543 2063 616c 6962   valid TEC calib
+00013fd0: 7261 7469 6f6e 2229 0a20 2020 2020 2020  ration").       
+00013fe0: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
+00013ff0: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
+00014000: 2864 6174 613d 4661 6c73 652c 2065 7272  (data=False, err
+00014010: 6f72 5f6d 7367 3d22 756e 6162 6c65 2074  or_msg="unable t
+00014020: 6f20 636f 6e74 726f 6c20 5445 433a 2045  o control TEC: E
+00014030: 4550 524f 4d20 6d69 7373 696e 6720 7661  EPROM missing va
+00014040: 6c69 6420 5445 4320 6361 6c69 6272 6174  lid TEC calibrat
+00014050: 696f 6e22 290a 0a20 2020 2020 2020 2076  ion")..        v
+00014060: 616c 7565 203d 2031 2069 6620 666c 6167  alue = 1 if flag
+00014070: 2065 6c73 6520 300a 0a20 2020 2020 2020   else 0..       
+00014080: 2069 6620 6e6f 7420 7365 6c66 2e64 6574   if not self.det
+00014090: 6563 746f 725f 7465 635f 7365 7470 6f69  ector_tec_setpoi
+000140a0: 6e74 5f68 6173 5f62 6565 6e5f 7365 743a  nt_has_been_set:
+000140b0: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
+000140c0: 4074 6f64 6f20 7368 6f75 6c64 2074 6869  @todo should thi
+000140d0: 7320 6e6f 7420 6265 2065 6570 726f 6d2e  s not be eeprom.
+000140e0: 7374 6172 7475 705f 7465 6d70 5f64 6567  startup_temp_deg
+000140f0: 430a 2020 2020 2020 2020 2020 2020 6c6f  C.            lo
+00014100: 672e 6465 6275 6728 2264 6566 6175 6c74  g.debug("default
+00014110: 696e 6720 5445 4320 7365 7470 6f69 6e74  ing TEC setpoint
+00014120: 2074 6f20 6d69 6e20 2573 222c 2073 656c   to min %s", sel
+00014130: 662e 7365 7474 696e 6773 2e65 6570 726f  f.settings.eepro
+00014140: 6d2e 6d69 6e5f 7465 6d70 5f64 6567 4329  m.min_temp_degC)
+00014150: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00014160: 662e 7365 745f 6465 7465 6374 6f72 5f74  f.set_detector_t
+00014170: 6563 5f73 6574 706f 696e 745f 6465 6743  ec_setpoint_degC
+00014180: 2873 656c 662e 7365 7474 696e 6773 2e65  (self.settings.e
+00014190: 6570 726f 6d2e 6d69 6e5f 7465 6d70 5f64  eprom.min_temp_d
+000141a0: 6567 4329 0a0a 2020 2020 2020 2020 6c6f  egC)..        lo
+000141b0: 672e 6465 6275 6728 2253 656e 6420 6465  g.debug("Send de
+000141c0: 7465 6374 6f72 2054 4543 2065 6e61 626c  tector TEC enabl
+000141d0: 653a 2025 7322 2c20 7661 6c75 6529 0a20  e: %s", value). 
+000141e0: 2020 2020 2020 206f 6b20 3d20 7365 6c66         ok = self
+000141f0: 2e5f 7365 6e64 5f63 6f64 6528 3078 6436  ._send_code(0xd6
+00014200: 2c20 7661 6c75 652c 206c 6162 656c 3d22  , value, label="
+00014210: 5345 545f 4445 5445 4354 4f52 5f54 4543  SET_DETECTOR_TEC
+00014220: 5f45 4e41 424c 4522 290a 2020 2020 2020  _ENABLE").      
+00014230: 2020 6966 206f 6b2e 6461 7461 3a0a 2020    if ok.data:.  
+00014240: 2020 2020 2020 2020 2020 7365 6c66 2e73            self.s
+00014250: 6574 7469 6e67 732e 7374 6174 652e 7465  ettings.state.te
+00014260: 635f 656e 6162 6c65 6420 3d20 666c 6167  c_enabled = flag
+00014270: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00014280: 6f6b 0a0a 2020 2020 2320 2323 2323 2323  ok..    # ######
+00014290: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000142a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000142b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000142c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000142d0: 2323 2323 0a20 2020 2023 2054 7269 6767  ####.    # Trigg
+000142e0: 6572 696e 670a 2020 2020 2320 2323 2323  ering.    # ####
+000142f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00014300: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00014310: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00014320: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00014330: 2323 2323 2323 0a0a 2020 2020 6465 6620  ######..    def 
+00014340: 7365 745f 7472 6967 6765 725f 736f 7572  set_trigger_sour
+00014350: 6365 2873 656c 662c 2076 616c 7565 3a20  ce(self, value: 
+00014360: 626f 6f6c 293a 0a20 2020 2020 2020 2022  bool):.        "
+00014370: 2222 0a20 2020 2020 2020 2053 6574 2074  "".        Set t
+00014380: 6865 2073 6f75 7263 6520 666f 7220 696e  he source for in
+00014390: 636f 6d69 6e67 2061 6371 7569 7369 7469  coming acquisiti
+000143a0: 6f6e 2074 7269 6767 6572 732e 0a20 2020  on triggers..   
+000143b0: 2020 2020 2040 7061 7261 6d20 7661 6c75       @param valu
+000143c0: 6520 6569 7468 6572 2030 2066 6f72 2022  e either 0 for "
+000143d0: 696e 7465 726e 616c 2220 6f72 2031 2066  internal" or 1 f
+000143e0: 6f72 2022 6578 7465 726e 616c 220a 2020  or "external".  
+000143f0: 2020 2020 2020 5769 7468 2069 6e74 6572        With inter
+00014400: 6e61 6c20 7472 6967 6765 7269 6e67 2028  nal triggering (
+00014410: 7468 6520 6465 6661 756c 7429 2c20 7468  the default), th
+00014420: 6520 7370 6563 7472 6f6d 6574 6572 2065  e spectrometer e
+00014430: 7870 6563 7473 2074 6865 0a20 2020 2020  xpects the.     
+00014440: 2020 2055 5342 2068 6f73 7420 746f 2065     USB host to e
+00014450: 7870 6c69 6369 746c 7920 7365 6e64 2061  xplicitly send a
+00014460: 2053 5441 5254 5f41 4351 5549 5349 5449   START_ACQUISITI
+00014470: 4f4e 2028 4143 5155 4952 4529 206f 7063  ON (ACQUIRE) opc
+00014480: 6f64 6520 746f 0a20 2020 2020 2020 2062  ode to.        b
+00014490: 6567 696e 2065 6163 6820 696e 7465 6772  egin each integr
+000144a0: 6174 696f 6e2e 2020 496e 2065 7874 6572  ation.  In exter
+000144b0: 6e61 6c20 7472 6967 6765 7269 6e67 2c20  nal triggering, 
+000144c0: 7468 6520 7370 6563 7472 6f6d 6574 6572  the spectrometer
+000144d0: 0a20 2020 2020 2020 2077 6169 7473 2066  .        waits f
+000144e0: 6f72 2074 6865 2072 6973 696e 6720 6564  or the rising ed
+000144f0: 6765 206f 6e20 6120 7369 676e 616c 2063  ge on a signal c
+00014500: 6f6e 6e65 6374 6564 2074 6f20 6120 7069  onnected to a pi
+00014510: 6e20 6f6e 2074 6865 204f 454d 0a20 2020  n on the OEM.   
+00014520: 2020 2020 2061 6363 6573 736f 7279 2063       accessory c
+00014530: 6f6e 6e65 6374 6f72 2e0a 2020 2020 2020  onnector..      
+00014540: 2020 5465 6368 6e69 6361 6c6c 7920 6f6e    Technically on
+00014550: 2041 524d 2c20 7468 6520 6d69 6372 6f63   ARM, the microc
+00014560: 6f6e 7472 6f6c 6c65 7220 6973 2063 6f6e  ontroller is con
+00014570: 7469 6e75 6f75 736c 7920 6d6f 6e69 746f  tinuously monito
+00014580: 7269 6e67 0a20 2020 2020 2020 2062 6f74  ring.        bot
+00014590: 6820 7468 6520 6578 7465 726e 616c 2070  h the external p
+000145a0: 696e 2061 6e64 206c 6973 7465 6e69 6e67  in and listening
+000145b0: 2066 6f72 2069 6e74 6572 6e61 6c20 736f   for internal so
+000145c0: 6674 7761 7265 206f 7063 6f64 6573 2e0a  ftware opcodes..
+000145d0: 2020 2020 2020 2020 4f6e 2074 6865 2046          On the F
+000145e0: 5832 2079 6f75 206e 6565 6420 746f 2065  X2 you need to e
+000145f0: 7870 6c69 6369 746c 7920 706c 6163 6520  xplicitly place 
+00014600: 7468 6520 6d69 6372 6f63 6f6e 7472 6f6c  the microcontrol
+00014610: 6c65 7220 696e 746f 0a20 2020 2020 2020  ler into.       
+00014620: 2065 7874 6572 6e61 6c20 7472 6967 6765   external trigge
+00014630: 7269 6e67 206d 6f64 6520 746f 2061 7661  ring mode to ava
+00014640: 696c 2074 6865 2066 6561 7475 7265 2e0a  il the feature..
+00014650: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00014660: 2020 2020 7365 6c66 2e73 6574 7469 6e67      self.setting
+00014670: 732e 7374 6174 652e 7472 6967 6765 725f  s.state.trigger_
+00014680: 736f 7572 6365 203d 2076 616c 7565 0a20  source = value. 
+00014690: 2020 2020 2020 206c 6f67 2e64 6562 7567         log.debug
+000146a0: 2822 7472 6967 6765 725f 736f 7572 6365  ("trigger_source
+000146b0: 206e 6f77 2025 7322 2c20 7661 6c75 6529   now %s", value)
+000146c0: 0a0a 2020 2020 2020 2020 2320 446f 6e27  ..        # Don'
+000146d0: 7420 7365 6e64 2074 6865 206f 7063 6f64  t send the opcod
+000146e0: 6520 6f6e 2041 524d 2e20 5365 6520 6973  e on ARM. See is
+000146f0: 7375 6520 2332 206f 6e20 5761 7361 7463  sue #2 on Wasatc
+00014700: 6855 5342 2070 726f 6a65 6374 0a20 2020  hUSB project.   
+00014710: 2020 2020 2069 6620 7365 6c66 2e73 6574       if self.set
+00014720: 7469 6e67 732e 6973 5f61 726d 2829 3a0a  tings.is_arm():.
+00014730: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00014740: 726e 2053 7065 6374 726f 6d65 7465 7252  rn SpectrometerR
+00014750: 6573 706f 6e73 6528 6461 7461 3d46 616c  esponse(data=Fal
+00014760: 7365 290a 0a20 2020 2020 2020 206d 7362  se)..        msb
+00014770: 203d 2030 0a20 2020 2020 2020 206c 7362   = 0.        lsb
+00014780: 203d 2076 616c 7565 0a20 2020 2020 2020   = value.       
+00014790: 2062 7566 203d 205b 305d 202a 2038 0a0a   buf = [0] * 8..
+000147a0: 2020 2020 2020 2020 2320 4d5a 3a20 7468          # MZ: th
+000147b0: 6973 2069 7320 7765 6972 642e 2e2e 7765  is is weird...we
+000147c0: 2772 6520 7365 6e64 696e 6720 7468 6520  're sending the 
+000147d0: 6275 6666 6572 206f 6e20 616e 2046 5832  buffer on an FX2
+000147e0: 2d6f 6e6c 7920 636f 6d6d 616e 640a 2020  -only command.  
+000147f0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+00014800: 662e 5f73 656e 645f 636f 6465 2830 7864  f._send_code(0xd
+00014810: 322c 206c 7362 2c20 6d73 622c 2062 7566  2, lsb, msb, buf
+00014820: 2c20 6c61 6265 6c3d 2253 4554 5f54 5249  , label="SET_TRI
+00014830: 4747 4552 5f53 4f55 5243 4522 290a 0a20  GGER_SOURCE").. 
+00014840: 2020 2023 2023 2323 2323 2323 2323 2323     # ###########
+00014850: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00014860: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00014870: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00014880: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
+00014890: 2020 2020 2320 4869 6768 2d47 6169 6e20      # High-Gain 
+000148a0: 4d6f 6465 0a20 2020 2023 2023 2323 2323  Mode.    # #####
+000148b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000148c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000148d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000148e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000148f0: 2323 2323 230a 0a20 2020 2023 230a 2020  #####..    ##.  
+00014900: 2020 2320 4346 5f53 454c 4543 5420 6973    # CF_SELECT is
+00014910: 2063 6f6e 6669 6775 7265 6420 7573 696e   configured usin
+00014920: 6720 6269 7420 3220 6f66 2074 6865 2046  g bit 2 of the F
+00014930: 5047 4120 636f 6e66 6967 7572 6174 696f  PGA configuratio
+00014940: 6e20 7265 6769 7374 6572 0a20 2020 2023  n register.    #
+00014950: 2030 7831 322e 2020 5468 6973 2062 6974   0x12.  This bit
+00014960: 2063 616e 2062 6520 7365 7420 7573 696e   can be set usin
+00014970: 6720 7665 6e64 6f72 2063 6f6d 6d61 6e64  g vendor command
+00014980: 7320 3078 6562 2074 6f20 5345 5420 616e  s 0xeb to SET an
+00014990: 6420 3078 6563 0a20 2020 2023 2074 6f20  d 0xec.    # to 
+000149a0: 4745 542e 2020 4e6f 7465 2074 6861 7420  GET.  Note that 
+000149b0: 7468 6520 7365 7420 636f 6d6d 616e 6420  the set command 
+000149c0: 6973 2065 7870 6563 7469 6e67 2061 2035  is expecting a 5
+000149d0: 2d62 7974 6520 756e 7369 676e 6564 0a20  -byte unsigned. 
+000149e0: 2020 2023 2076 616c 7565 2c20 7468 6520     # value, the 
+000149f0: 6869 6768 6573 7420 6279 7465 206f 6620  highest byte of 
+00014a00: 7768 6963 6820 7765 2070 6173 7320 6173  which we pass as
+00014a10: 2070 6172 7420 6f66 2061 6e20 382d 6279   part of an 8-by
+00014a20: 7465 2062 7566 6665 722e 0a20 2020 2023  te buffer..    #
+00014a30: 204e 6f74 2073 7572 6520 7768 792e 0a20   Not sure why.. 
+00014a40: 2020 2064 6566 2073 6574 5f68 6967 685f     def set_high_
+00014a50: 6761 696e 5f6d 6f64 655f 656e 6162 6c65  gain_mode_enable
+00014a60: 2873 656c 662c 2066 6c61 673a 2062 6f6f  (self, flag: boo
+00014a70: 6c29 3a0a 2020 2020 2020 2020 6c6f 672e  l):.        log.
+00014a80: 6465 6275 6728 2253 6574 2068 6967 6820  debug("Set high 
+00014a90: 6761 696e 206d 6f64 653a 2025 7322 2c20  gain mode: %s", 
+00014aa0: 666c 6167 290a 2020 2020 2020 2020 6966  flag).        if
+00014ab0: 206e 6f74 2073 656c 662e 7365 7474 696e   not self.settin
+00014ac0: 6773 2e69 735f 696e 6761 6173 2829 3a0a  gs.is_ingaas():.
+00014ad0: 2020 2020 2020 2020 2020 2020 6c6f 672e              log.
+00014ae0: 6465 6275 6728 2253 4554 5f48 4947 485f  debug("SET_HIGH_
+00014af0: 4741 494e 5f4d 4f44 455f 454e 4142 4c45  GAIN_MODE_ENABLE
+00014b00: 206f 6e6c 7920 7375 7070 6f72 7465 6420   only supported 
+00014b10: 6f6e 2049 6e47 6141 7322 290a 2020 2020  on InGaAs").    
+00014b20: 2020 2020 2020 2020 7265 7475 726e 2053          return S
+00014b30: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
+00014b40: 6e73 6528 6461 7461 3d46 616c 7365 2c65  nse(data=False,e
+00014b50: 7272 6f72 5f6d 7367 3d22 4869 6768 2047  rror_msg="High G
+00014b60: 6169 6e20 6e6f 7420 7375 7070 6f72 7420  ain not support 
+00014b70: 6f6e 2074 6869 7320 7370 6563 7472 6f6d  on this spectrom
+00014b80: 6574 6572 2229 0a0a 2020 2020 2020 2020  eter")..        
+00014b90: 7661 6c75 6520 3d20 3120 6966 2066 6c61  value = 1 if fla
+00014ba0: 6720 656c 7365 2030 0a0a 2020 2020 2020  g else 0..      
+00014bb0: 2020 2320 7468 6973 2069 7320 646f 6e65    # this is done
+00014bc0: 2061 7574 6f6d 6174 6963 616c 6c79 206f   automatically o
+00014bd0: 6e20 4152 4d2c 2062 7574 2066 6f72 2074  n ARM, but for t
+00014be0: 6869 7320 6f70 636f 6465 2077 6520 646f  his opcode we do
+00014bf0: 2069 7420 6f6e 2046 5832 2061 7320 7765   it on FX2 as we
+00014c00: 6c6c 0a20 2020 2020 2020 2062 7566 203d  ll.        buf =
+00014c10: 205b 305d 202a 2038 0a0a 2020 2020 2020   [0] * 8..      
+00014c20: 2020 7365 6c66 2e73 6574 7469 6e67 732e    self.settings.
+00014c30: 7374 6174 652e 6869 6768 5f67 6169 6e5f  state.high_gain_
+00014c40: 6d6f 6465 5f65 6e61 626c 6564 203d 2066  mode_enabled = f
+00014c50: 6c61 670a 2020 2020 2020 2020 7265 7475  lag.        retu
+00014c60: 726e 2073 656c 662e 5f73 656e 645f 636f  rn self._send_co
+00014c70: 6465 2830 7865 622c 2077 5661 6c75 653d  de(0xeb, wValue=
+00014c80: 7661 6c75 652c 2077 496e 6465 783d 302c  value, wIndex=0,
+00014c90: 2064 6174 615f 6f72 5f77 4c65 6e67 7468   data_or_wLength
+00014ca0: 3d62 7566 2c20 6c61 6265 6c3d 2253 4554  =buf, label="SET
+00014cb0: 5f48 4947 485f 4741 494e 5f4d 4f44 455f  _HIGH_GAIN_MODE_
+00014cc0: 454e 4142 4c45 2229 0a0a 2020 2020 6465  ENABLE")..    de
+00014cd0: 6620 6765 745f 6869 6768 5f67 6169 6e5f  f get_high_gain_
+00014ce0: 6d6f 6465 5f65 6e61 626c 6564 2873 656c  mode_enabled(sel
+00014cf0: 6629 3a0a 2020 2020 2020 2020 6966 206e  f):.        if n
+00014d00: 6f74 2073 656c 662e 7365 7474 696e 6773  ot self.settings
+00014d10: 2e69 735f 696e 6761 6173 2829 3a0a 2020  .is_ingaas():.  
+00014d20: 2020 2020 2020 2020 2020 6c6f 672e 6465            log.de
+00014d30: 6275 6728 2247 4554 5f48 4947 485f 4741  bug("GET_HIGH_GA
+00014d40: 494e 5f4d 4f44 455f 454e 4142 4c45 206f  IN_MODE_ENABLE o
+00014d50: 6e6c 7920 7375 7070 6f72 7465 6420 6f6e  nly supported on
+00014d60: 2049 6e47 6141 7322 290a 2020 2020 2020   InGaAs").      
+00014d70: 2020 2020 2020 7265 7475 726e 2053 7065        return Spe
+00014d80: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
+00014d90: 6528 7365 6c66 2e73 6574 7469 6e67 732e  e(self.settings.
+00014da0: 6565 7072 6f6d 2e68 6967 685f 6761 696e  eeprom.high_gain
+00014db0: 5f6d 6f64 655f 656e 6162 6c65 6429 0a0a  _mode_enabled)..
+00014dc0: 2020 2020 2020 2020 7365 6c66 2e73 6574          self.set
+00014dd0: 7469 6e67 732e 7374 6174 652e 6869 6768  tings.state.high
+00014de0: 5f67 6169 6e5f 6d6f 6465 5f65 6e61 626c  _gain_mode_enabl
+00014df0: 6564 203d 2030 2021 3d20 7365 6c66 2e5f  ed = 0 != self._
+00014e00: 6765 745f 636f 6465 2830 7865 632c 206c  get_code(0xec, l
+00014e10: 7362 5f6c 656e 3d31 2c20 6c61 6265 6c3d  sb_len=1, label=
+00014e20: 2247 4554 5f48 4947 485f 4741 494e 5f4d  "GET_HIGH_GAIN_M
+00014e30: 4f44 455f 454e 4142 4c45 4422 290a 2020  ODE_ENABLED").  
+00014e40: 2020 2020 2020 7265 7475 726e 2053 7065        return Spe
+00014e50: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
+00014e60: 6528 7365 6c66 2e73 6574 7469 6e67 732e  e(self.settings.
+00014e70: 7374 6174 652e 6869 6768 5f67 6169 6e5f  state.high_gain_
+00014e80: 6d6f 6465 5f65 6e61 626c 6564 290a 0a20  mode_enabled).. 
+00014e90: 2020 2023 2323 2323 2323 2323 2323 2323     #############
+00014ea0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00014eb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00014ec0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00014ed0: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
+00014ee0: 2020 2020 2320 4c61 7365 7220 636f 6d6d      # Laser comm
+00014ef0: 616e 6473 0a20 2020 2023 2323 2323 2323  ands.    #######
+00014f00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00014f10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00014f20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00014f30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00014f40: 2323 2323 230a 0a20 2020 2064 6566 2067  #####..    def g
+00014f50: 6574 5f6f 7074 5f6c 6173 6572 5f63 6f6e  et_opt_laser_con
+00014f60: 7472 6f6c 2873 656c 6629 3a0a 2020 2020  trol(self):.    
+00014f70: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+00014f80: 6765 745f 7570 7065 725f 636f 6465 2830  get_upper_code(0
+00014f90: 7830 392c 206c 6162 656c 3d22 4745 545f  x09, label="GET_
+00014fa0: 4f50 545f 4c41 5345 525f 434f 4e54 524f  OPT_LASER_CONTRO
+00014fb0: 4c22 2c20 6d73 625f 6c65 6e3d 3129 0a0a  L", msb_len=1)..
+00014fc0: 2020 2020 6465 6620 6765 745f 6f70 745f      def get_opt_
+00014fd0: 6861 735f 6c61 7365 7228 7365 6c66 293a  has_laser(self):
+00014fe0: 0a20 2020 2020 2020 2076 616c 7565 203d  .        value =
+00014ff0: 2073 656c 662e 6765 745f 7570 7065 725f   self.get_upper_
+00015000: 636f 6465 2830 7830 382c 206c 6162 656c  code(0x08, label
+00015010: 3d22 4745 545f 4f50 545f 4841 535f 4c41  ="GET_OPT_HAS_LA
+00015020: 5345 5222 2c20 6d73 625f 6c65 6e3d 3129  SER", msb_len=1)
+00015030: 2e64 6174 610a 2020 2020 2020 2020 6176  .data.        av
+00015040: 6169 6c61 626c 6520 3d20 3020 213d 2076  ailable = 0 != v
+00015050: 616c 7565 0a20 2020 2020 2020 2069 6620  alue.        if 
+00015060: 6176 6169 6c61 626c 6520 213d 2073 656c  available != sel
+00015070: 662e 7365 7474 696e 6773 2e65 6570 726f  f.settings.eepro
+00015080: 6d2e 6861 735f 6c61 7365 723a 0a20 2020  m.has_laser:.   
+00015090: 2020 2020 2020 2020 206c 6f67 2e65 7272           log.err
+000150a0: 6f72 2822 4f50 545f 4841 535f 4c41 5345  or("OPT_HAS_LASE
+000150b0: 5220 6f70 636f 6465 2072 6573 756c 7420  R opcode result 
+000150c0: 2573 2021 3d20 4545 5052 4f4d 2068 6173  %s != EEPROM has
+000150d0: 5f6c 6173 6572 2025 7320 2875 7369 6e67  _laser %s (using
+000150e0: 206f 7063 6f64 6529 222c 0a20 2020 2020   opcode)",.     
+000150f0: 2020 2020 2020 2020 2020 2076 616c 7565             value
+00015100: 2c20 7365 6c66 2e73 6574 7469 6e67 732e  , self.settings.
+00015110: 6565 7072 6f6d 2e68 6173 5f6c 6173 6572  eeprom.has_laser
+00015120: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+00015130: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
+00015140: 706f 6e73 6528 6461 7461 3d61 7661 696c  ponse(data=avail
+00015150: 6162 6c65 290a 0a20 2020 2064 6566 2067  able)..    def g
+00015160: 6574 5f6c 6173 6572 5f74 656d 7065 7261  et_laser_tempera
+00015170: 7475 7265 5f72 6177 2873 656c 6629 3a0a  ture_raw(self):.
+00015180: 2020 2020 2020 2020 2222 2220 406e 6f74          """ @not
+00015190: 6520 6c69 7474 6c65 2d65 6e64 6961 6e2c  e little-endian,
+000151a0: 2072 6576 6572 7365 206f 6620 6765 745f   reverse of get_
+000151b0: 6465 7465 6374 6f72 5f74 656d 7065 7261  detector_tempera
+000151c0: 7475 7265 5f72 6177 2022 2222 0a20 2020  ture_raw """.   
+000151d0: 2020 2020 2023 2066 6c69 7020 746f 2070       # flip to p
+000151e0: 7269 6d61 7279 2041 4443 2069 6620 6e65  rimary ADC if ne
+000151f0: 6564 6564 0a20 2020 2020 2020 2069 6620  eded.        if 
+00015200: 7365 6c66 2e73 6574 7469 6e67 732e 7374  self.settings.st
+00015210: 6174 652e 7365 6c65 6374 6564 5f61 6463  ate.selected_adc
+00015220: 2069 7320 4e6f 6e65 206f 7220 7365 6c66   is None or self
+00015230: 2e73 6574 7469 6e67 732e 7374 6174 652e  .settings.state.
+00015240: 7365 6c65 6374 6564 5f61 6463 2021 3d20  selected_adc != 
+00015250: 303a 0a20 2020 2020 2020 2020 2020 2023  0:.            #
+00015260: 204d 5a3a 2075 6e63 6c65 6172 2069 6620   MZ: unclear if 
+00015270: 7468 6973 2069 7320 6e65 6564 6564 206f  this is needed o
+00015280: 6e20 5369 470a 2020 2020 2020 2020 2020  n SiG.          
+00015290: 2020 7365 6c66 2e73 656c 6563 745f 6164    self.select_ad
+000152a0: 6328 3029 0a0a 2020 2020 2020 2020 7265  c(0)..        re
+000152b0: 7375 6c74 203d 2073 656c 662e 5f67 6574  sult = self._get
+000152c0: 5f63 6f64 6528 3078 6435 2c20 774c 656e  _code(0xd5, wLen
+000152d0: 6774 683d 322c 206c 6162 656c 3d22 4745  gth=2, label="GE
+000152e0: 545f 4144 4322 2c20 6c73 625f 6c65 6e3d  T_ADC", lsb_len=
+000152f0: 3229 0a20 2020 2020 2020 2069 6620 6e6f  2).        if no
+00015300: 7420 7265 7375 6c74 2e64 6174 613a 0a20  t result.data:. 
+00015310: 2020 2020 2020 2020 2020 206c 6f67 2e64             log.d
+00015320: 6562 7567 2822 556e 6162 6c65 2074 6f20  ebug("Unable to 
+00015330: 7265 6164 206c 6173 6572 2074 656d 7065  read laser tempe
+00015340: 7261 7475 7265 2229 0a20 2020 2020 2020  rature").       
+00015350: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
+00015360: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
+00015370: 2830 290a 2020 2020 2020 2020 7265 7375  (0).        resu
+00015380: 6c74 2e64 6174 6120 3d20 7265 7375 6c74  lt.data = result
+00015390: 2e64 6174 6120 2620 3078 6666 6620 2320  .data & 0xfff # 
+000153a0: 636c 616d 7020 746f 2031 322d 6269 740a  clamp to 12-bit.
+000153b0: 2020 2020 2020 2020 7265 7475 726e 2072          return r
+000153c0: 6573 756c 740a 0a20 2020 2064 6566 2073  esult..    def s
+000153d0: 6574 5f73 656c 6563 7465 645f 6c61 7365  et_selected_lase
+000153e0: 7228 7365 6c66 2c20 7661 6c75 653a 2069  r(self, value: i
+000153f0: 6e74 293a 0a20 2020 2020 2020 2022 2222  nt):.        """
+00015400: 0a20 2020 2020 2020 204f 6e20 7370 6563  .        On spec
+00015410: 7472 6f6d 6574 6572 7320 7375 7070 6f72  trometers suppor
+00015420: 7469 6e67 2074 776f 206c 6173 6572 732c  ting two lasers,
+00015430: 2073 656c 6563 7420 7468 6520 7072 696d   select the prim
+00015440: 6172 7920 2830 2920 6f72 0a20 2020 2020  ary (0) or.     
+00015450: 2020 2073 6563 6f6e 6461 7279 2028 3129     secondary (1)
+00015460: 2e20 204c 6173 6572 2045 6e61 626c 652c  .  Laser Enable,
+00015470: 206c 6173 6572 2070 6f77 6572 2065 7463   laser power etc
+00015480: 2073 686f 756c 6420 616c 6c20 7468 656e   should all then
+00015490: 0a20 2020 2020 2020 2061 6666 6563 7420  .        affect 
+000154a0: 7468 6520 6375 7272 656e 746c 792d 7365  the currently-se
+000154b0: 6c65 6374 6564 206c 6173 6572 2e0a 2020  lected laser..  
+000154c0: 2020 2020 2020 4077 6172 6e69 6e67 2063        @warning c
+000154d0: 6f6e 666c 6963 7473 2077 6974 6820 4745  onflicts with GE
+000154e0: 545f 5241 4d41 4e5f 4d4f 4445 5f45 4e41  T_RAMAN_MODE_ENA
+000154f0: 424c 450a 2020 2020 2020 2020 2222 220a  BLE.        """.
+00015500: 2020 2020 2020 2020 6e20 3d20 3120 6966          n = 1 if
+00015510: 2076 616c 7565 2065 6c73 6520 300a 0a20   value else 0.. 
+00015520: 2020 2020 2020 2069 6620 6e6f 7420 7365         if not se
+00015530: 6c66 2e73 6574 7469 6e67 732e 6565 7072  lf.settings.eepr
+00015540: 6f6d 2e68 6173 5f6c 6173 6572 3a0a 2020  om.has_laser:.  
+00015550: 2020 2020 2020 2020 2020 6c6f 672e 6572            log.er
+00015560: 726f 7228 2275 6e61 626c 6520 746f 2063  ror("unable to c
+00015570: 6f6e 7472 6f6c 206c 6173 6572 3a20 4545  ontrol laser: EE
+00015580: 5052 4f4d 2072 6570 6f72 7473 206e 6f20  PROM reports no 
+00015590: 6c61 7365 7220 696e 7374 616c 6c65 6422  laser installed"
+000155a0: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+000155b0: 7475 726e 2053 7065 6374 726f 6d65 7465  turn Spectromete
+000155c0: 7252 6573 706f 6e73 6528 6461 7461 3d46  rResponse(data=F
+000155d0: 616c 7365 2c65 7272 6f72 5f6d 7367 3d22  alse,error_msg="
+000155e0: 4e6f 206c 6173 6572 2069 6e73 7461 6c6c  No laser install
+000155f0: 6572 2229 0a0a 2020 2020 2020 2020 6c6f  er")..        lo
+00015600: 672e 6465 6275 6728 2273 656c 6563 7469  g.debug("selecti
+00015610: 6e67 206c 6173 6572 2025 6422 2c20 6e29  ng laser %d", n)
+00015620: 0a20 2020 2020 2020 2073 656c 662e 7365  .        self.se
+00015630: 7474 696e 6773 2e73 7461 7465 2e73 656c  ttings.state.sel
+00015640: 6563 7465 645f 6c61 7365 7220 3d20 6e0a  ected_laser = n.
+00015650: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00015660: 7365 6c66 2e5f 7365 6e64 5f63 6f64 6528  self._send_code(
+00015670: 6252 6571 7565 7374 2020 2020 2020 2020  bRequest        
+00015680: 3d20 3078 6666 2c0a 2020 2020 2020 2020  = 0xff,.        
+00015690: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000156a0: 2020 2020 2020 7756 616c 7565 2020 2020        wValue    
+000156b0: 2020 2020 2020 3d20 3078 3135 2c0a 2020        = 0x15,.  
+000156c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000156d0: 2020 2020 2020 2020 2020 2020 7749 6e64              wInd
+000156e0: 6578 2020 2020 2020 2020 2020 3d20 6e2c  ex          = n,
+000156f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00015700: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+00015710: 6174 615f 6f72 5f77 4c65 6e67 7468 203d  ata_or_wLength =
+00015720: 205b 305d 202a 2038 2c0a 2020 2020 2020   [0] * 8,.      
+00015730: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015740: 2020 2020 2020 2020 6c61 6265 6c20 2020          label   
+00015750: 2020 2020 2020 2020 3d20 2253 4554 5f53          = "SET_S
+00015760: 454c 4543 5445 445f 4c41 5345 5222 290a  ELECTED_LASER").
+00015770: 0a20 2020 2064 6566 2067 6574 5f73 656c  .    def get_sel
+00015780: 6563 7465 645f 6c61 7365 7228 7365 6c66  ected_laser(self
+00015790: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+000157a0: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
+000157b0: 7370 6f6e 7365 2864 6174 613d 7365 6c66  sponse(data=self
+000157c0: 2e73 6574 7469 6e67 732e 7374 6174 652e  .settings.state.
+000157d0: 7365 6c65 6374 6564 5f6c 6173 6572 290a  selected_laser).
+000157e0: 0a20 2020 2064 6566 2067 6574 5f6c 6173  .    def get_las
+000157f0: 6572 5f65 6e61 626c 6564 2873 656c 6629  er_enabled(self)
+00015800: 3a0a 2020 2020 2020 2020 7265 7320 3d20  :.        res = 
+00015810: 7365 6c66 2e5f 6765 745f 636f 6465 2830  self._get_code(0
+00015820: 7865 322c 206c 6162 656c 3d22 4745 545f  xe2, label="GET_
+00015830: 4c41 5345 525f 454e 4142 4c45 4422 2c20  LASER_ENABLED", 
+00015840: 6d73 625f 6c65 6e3d 3129 0a20 2020 2020  msb_len=1).     
+00015850: 2020 2066 6c61 6720 3d20 3020 213d 2072     flag = 0 != r
+00015860: 6573 2e64 6174 610a 0a20 2020 2020 2020  es.data..       
+00015870: 2069 6620 7365 6c66 2e64 6576 6963 655f   if self.device_
+00015880: 6964 2e70 6964 203d 3d20 3078 3430 3030  id.pid == 0x4000
+00015890: 3a0a 2020 2020 2020 2020 2020 2020 2320  :.            # 
+000158a0: 4d5a 3a20 6765 745f 6c61 7365 725f 656e  MZ: get_laser_en
+000158b0: 6162 6c65 6420 6e6f 7420 6375 7272 656e  abled not curren
+000158c0: 746c 7920 726f 6275 7374 206f 6e20 5369  tly robust on Si
+000158d0: 4720 3a2d 280a 2020 2020 2020 2020 2020  G :-(.          
+000158e0: 2020 7265 7475 726e 2053 7065 6374 726f    return Spectro
+000158f0: 6d65 7465 7252 6573 706f 6e73 6528 6461  meterResponse(da
+00015900: 7461 3d73 656c 662e 7365 7474 696e 6773  ta=self.settings
+00015910: 2e73 7461 7465 2e6c 6173 6572 5f65 6e61  .state.laser_ena
+00015920: 626c 6564 290a 0a20 2020 2020 2020 206c  bled)..        l
+00015930: 6f67 2e64 6562 7567 2866 2267 6574 5f6c  og.debug(f"get_l
+00015940: 6173 6572 5f65 6e61 626c 6564 3a20 7b66  aser_enabled: {f
+00015950: 6c61 677d 2028 7374 6f72 696e 6720 746f  lag} (storing to
+00015960: 207b 7365 6c66 2e73 6574 7469 6e67 732e   {self.settings.
+00015970: 7374 6174 657d 2922 290a 2020 2020 2020  state})").      
+00015980: 2020 7365 6c66 2e73 6574 7469 6e67 732e    self.settings.
+00015990: 7374 6174 652e 6c61 7365 725f 656e 6162  state.laser_enab
+000159a0: 6c65 6420 3d20 666c 6167 0a20 2020 2020  led = flag.     
+000159b0: 2020 2072 6574 7572 6e20 5370 6563 7472     return Spectr
+000159c0: 6f6d 6574 6572 5265 7370 6f6e 7365 2864  ometerResponse(d
+000159d0: 6174 613d 666c 6167 290a 0a20 2020 2064  ata=flag)..    d
+000159e0: 6566 2073 6574 5f6c 6173 6572 5f65 6e61  ef set_laser_ena
+000159f0: 626c 6528 7365 6c66 2c20 666c 6167 3a20  ble(self, flag: 
+00015a00: 626f 6f6c 293a 0a20 2020 2020 2020 2022  bool):.        "
+00015a10: 2222 0a20 2020 2020 2020 2054 7572 6e20  "".        Turn 
+00015a20: 7468 6520 6c61 7365 7220 6f6e 206f 7220  the laser on or 
+00015a30: 6f66 662e 0a20 2020 2020 2020 2049 6620  off..        If 
+00015a40: 6c61 7365 7220 706f 7765 7220 6861 736e  laser power hasn
+00015a50: 2774 2079 6574 2062 6565 6e20 6578 7465  't yet been exte
+00015a60: 726e 616c 6c79 2063 6f6e 6669 6775 7265  rnally configure
+00015a70: 642c 2061 7070 6c69 6573 2074 6865 2064  d, applies the d
+00015a80: 6566 6175 6c74 0a20 2020 2020 2020 206f  efault.        o
+00015a90: 6620 6675 6c6c 2d70 6f77 6572 2e20 2054  f full-power.  T
+00015aa0: 6865 206e 6577 2073 7461 7465 2077 696c  he new state wil
+00015ab0: 6c20 6265 2061 7070 6c69 6564 2069 6d6d  l be applied imm
+00015ac0: 6564 6961 7465 6c79 2e0a 2020 2020 2020  ediately..      
+00015ad0: 2020 4070 6172 616d 2066 6c61 6720 2849    @param flag (I
+00015ae0: 6e70 7574 2920 626f 6f6c 2028 5472 7565  nput) bool (True
+00015af0: 2074 7572 6e73 206c 6173 6572 206f 6e2c   turns laser on,
+00015b00: 2046 616c 7365 2074 7572 6e73 206c 6173   False turns las
+00015b10: 6572 206f 6666 290a 2020 2020 2020 2020  er off).        
+00015b20: 4072 6574 7572 6e73 2077 6865 7468 6572  @returns whether
+00015b30: 2074 6865 206e 6577 2073 7461 7465 2077   the new state w
+00015b40: 6173 2061 7070 6c69 6564 0a20 2020 2020  as applied.     
+00015b50: 2020 2022 2222 0a20 2020 2020 2020 2069     """.        i
+00015b60: 6620 6e6f 7420 7365 6c66 2e73 6574 7469  f not self.setti
+00015b70: 6e67 732e 6565 7072 6f6d 2e68 6173 5f6c  ngs.eeprom.has_l
+00015b80: 6173 6572 3a0a 2020 2020 2020 2020 2020  aser:.          
+00015b90: 2020 6c6f 672e 6572 726f 7228 2275 6e61    log.error("una
+00015ba0: 626c 6520 746f 2063 6f6e 7472 6f6c 206c  ble to control l
+00015bb0: 6173 6572 3a20 4545 5052 4f4d 2072 6570  aser: EEPROM rep
+00015bc0: 6f72 7473 206e 6f20 6c61 7365 7220 696e  orts no laser in
+00015bd0: 7374 616c 6c65 6422 290a 2020 2020 2020  stalled").      
+00015be0: 2020 2020 2020 7265 7475 726e 2053 7065        return Spe
+00015bf0: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
+00015c00: 6528 6461 7461 3d46 616c 7365 2c20 6572  e(data=False, er
+00015c10: 726f 725f 6d73 673d 226e 6f20 6c61 7365  ror_msg="no lase
+00015c20: 7220 696e 7374 616c 6c65 6422 290a 0a20  r installed").. 
+00015c30: 2020 2020 2020 2023 2041 524d 2073 6565         # ARM see
+00015c40: 6d73 2074 6f20 7265 7175 6972 6520 7468  ms to require th
+00015c50: 6174 206c 6173 6572 2070 6f77 6572 2062  at laser power b
+00015c60: 6520 7365 7420 6265 666f 7265 2074 6865  e set before the
+00015c70: 206c 6173 6572 2069 7320 656e 6162 6c65   laser is enable
+00015c80: 640a 2020 2020 2020 2020 6966 2073 656c  d.        if sel
+00015c90: 662e 6e65 7874 5f61 7070 6c69 6564 5f6c  f.next_applied_l
+00015ca0: 6173 6572 5f70 6f77 6572 2069 7320 4e6f  aser_power is No
+00015cb0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+00015cc0: 7365 6c66 2e73 6574 5f6c 6173 6572 5f70  self.set_laser_p
+00015cd0: 6f77 6572 5f70 6572 6328 3130 302e 3029  ower_perc(100.0)
+00015ce0: 0a0a 2020 2020 2020 2020 7365 6c66 2e73  ..        self.s
+00015cf0: 6574 7469 6e67 732e 7374 6174 652e 6c61  ettings.state.la
+00015d00: 7365 725f 656e 6162 6c65 6420 3d20 666c  ser_enabled = fl
+00015d10: 6167 0a20 2020 2020 2020 2073 656c 662e  ag.        self.
+00015d20: 5f73 6574 5f6c 6173 6572 5f65 6e61 626c  _set_laser_enabl
+00015d30: 655f 696d 6d65 6469 6174 6528 666c 6167  e_immediate(flag
+00015d40: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+00015d50: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
+00015d60: 706f 6e73 6528 6461 7461 3d54 7275 6529  ponse(data=True)
+00015d70: 0a0a 2020 2020 6465 6620 5f73 6574 5f6c  ..    def _set_l
+00015d80: 6173 6572 5f65 6e61 626c 655f 696d 6d65  aser_enable_imme
+00015d90: 6469 6174 6528 7365 6c66 2c20 666c 6167  diate(self, flag
+00015da0: 3a20 626f 6f6c 293a 0a20 2020 2020 2020  : bool):.       
+00015db0: 2022 2222 0a20 2020 2020 2020 2054 6865   """.        The
+00015dc0: 2075 7365 7220 6861 7320 7265 7175 6573   user has reques
+00015dd0: 7465 6420 746f 2075 7064 6174 6520 7468  ted to update th
+00015de0: 6520 6c61 7365 7220 6669 7269 6e67 2073  e laser firing s
+00015df0: 7461 7465 2028 6f6e 206f 7220 6f66 6629  tate (on or off)
+00015e00: 2c0a 2020 2020 2020 2020 736f 2061 7070  ,.        so app
+00015e10: 6c79 2074 6865 206e 6577 206c 6173 6572  ly the new laser
+00015e20: 2073 7461 7465 2074 6f20 7468 6520 7370   state to the sp
+00015e30: 6563 7472 6f6d 6574 6572 2069 6d6d 6564  ectrometer immed
+00015e40: 6961 7465 6c79 2e0a 0a20 2020 2020 2020  iately...       
+00015e50: 2042 6563 6175 7365 2074 6865 2061 6269   Because the abi
+00015e60: 6c69 7479 2074 6f20 696d 6d65 6469 6174  lity to immediat
+00015e70: 656c 7920 6469 7361 626c 6520 6120 6c61  ely disable a la
+00015e80: 7365 7220 6973 2061 2073 6166 6574 792d  ser is a safety-
+00015e90: 7265 6c61 7465 640a 2020 2020 2020 2020  related.        
+00015ea0: 6665 6174 7572 6520 286e 6f74 696e 6720  feature (noting 
+00015eb0: 7468 6174 2074 7275 6c79 2073 6166 6574  that truly safet
+00015ec0: 792d 6372 6974 6963 616c 2063 6170 6162  y-critical capab
+00015ed0: 696c 6974 6965 7320 7368 6f75 6c64 2062  ilities should b
+00015ee0: 650a 2020 2020 2020 2020 696d 706c 656d  e.        implem
+00015ef0: 656e 7465 6420 696e 2068 6172 6477 6172  ented in hardwar
+00015f00: 652c 2061 6e64 2067 656e 6572 616c 6c79  e, and generally
+00015f10: 2063 616e 2774 2062 6520 726f 6275 7374   can't be robust
+00015f20: 6c79 2061 6368 6965 7665 6420 7468 726f  ly achieved thro
+00015f30: 7567 680a 2020 2020 2020 2020 5079 7468  ugh.        Pyth
+00015f40: 6f6e 2073 6372 6970 7473 292c 2074 6869  on scripts), thi
+00015f50: 7320 6675 6e63 7469 6f6e 2074 616b 6573  s function takes
+00015f60: 2074 6865 2075 6e75 7375 616c 2073 7465   the unusual ste
+00015f70: 7020 6f66 206c 6f6f 7069 6e67 206f 7665  p of looping ove
+00015f80: 720a 2020 2020 2020 2020 6d75 6c74 6970  r.        multip
+00015f90: 6c65 2061 7474 656d 7074 7320 746f 2073  le attempts to s
+00015fa0: 6574 2074 6865 206c 6173 6572 2073 7461  et the laser sta
+00015fb0: 7465 2075 6e74 696c 2065 6974 6865 7220  te until either 
+00015fc0: 7468 6520 636f 6d6d 616e 6420 7375 6363  the command succ
+00015fd0: 6565 6473 2c0a 2020 2020 2020 2020 6f72  eeds,.        or
+00015fe0: 2033 2063 6f6e 7365 6375 7469 7665 2066   3 consecutive f
+00015ff0: 6169 6c75 7265 7320 6861 7665 206f 6363  ailures have occ
+00016000: 7572 6564 2e0a 0a20 2020 2020 2020 2054  ured...        T
+00016010: 6869 7320 6265 6861 7669 6f72 2077 6173  his behavior was
+00016020: 2061 6464 6564 2061 6674 6572 2061 2064   added after a d
+00016030: 6576 656c 6f70 6d65 6e74 616c 2c20 756e  evelopmental, un
+00016040: 7265 6c65 6173 6564 2070 726f 746f 7479  released prototy
+00016050: 7065 2077 6173 0a20 2020 2020 2020 2066  pe was.        f
+00016060: 6f75 6e64 2074 6f20 6f63 6361 7369 6f6e  ound to occasion
+00016070: 616c 6c79 2064 726f 7020 5553 4220 7061  ally drop USB pa
+00016080: 636b 6574 732c 2061 6e64 2077 6173 2074  ckets, and was t
+00016090: 6865 7265 666f 7265 2073 7573 6365 7074  herefore suscept
+000160a0: 6962 6c65 2074 6f0a 2020 2020 2020 2020  ible to.        
+000160b0: 696e 6164 7665 7274 656e 746c 7920 6661  inadvertently fa
+000160c0: 696c 696e 6720 746f 2064 6973 6162 6c65  iling to disable
+000160d0: 2074 6865 206c 6173 6572 2075 706f 6e20   the laser upon 
+000160e0: 636f 6d6d 616e 642e 0a0a 2020 2020 2020  command...      
+000160f0: 2020 4070 7269 7661 7465 2028 6173 2063    @private (as c
+00016100: 616c 6c65 7273 2061 7265 2072 6563 6f6d  allers are recom
+00016110: 6d65 6e64 6564 2074 6f20 7573 6520 7365  mended to use se
+00016120: 745f 6c61 7365 725f 656e 6162 6c65 290a  t_laser_enable).
+00016130: 2020 2020 2020 2020 4070 6172 616d 2066          @param f
+00016140: 6c61 6720 2849 6e70 7574 2920 7768 6574  lag (Input) whet
+00016150: 6865 7220 7468 6520 6c61 7365 7220 7368  her the laser sh
+00016160: 6f75 6c64 2062 6520 6f6e 2028 7472 7565  ould be on (true
+00016170: 2920 6f72 206f 6666 2028 6661 6c73 6529  ) or off (false)
+00016180: 0a20 2020 2020 2020 2040 7265 7475 726e  .        @return
+00016190: 7320 7472 7565 2069 6620 6e65 7720 7374  s true if new st
+000161a0: 6174 6520 7761 7320 7375 6363 6573 7366  ate was successf
+000161b0: 756c 6c79 2061 7070 6c69 6564 0a20 2020  ully applied.   
+000161c0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+000161d0: 206c 6f67 2e64 6562 7567 2822 5365 6e64   log.debug("Send
+000161e0: 206c 6173 6572 2065 6e61 626c 653a 2025   laser enable: %
+000161f0: 7322 2c20 666c 6167 290a 2020 2020 2020  s", flag).      
+00016200: 2020 6966 2066 6c61 673a 0a20 2020 2020    if flag:.     
+00016210: 2020 2020 2020 2073 656c 662e 6c61 7374         self.last
+00016220: 5f61 7070 6c69 6564 5f6c 6173 6572 5f70  _applied_laser_p
+00016230: 6f77 6572 203d 2030 2e30 0a20 2020 2020  ower = 0.0.     
+00016240: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00016250: 2020 2020 2073 656c 662e 6c61 7374 5f61       self.last_a
+00016260: 7070 6c69 6564 5f6c 6173 6572 5f70 6f77  pplied_laser_pow
+00016270: 6572 203d 2073 656c 662e 6e65 7874 5f61  er = self.next_a
+00016280: 7070 6c69 6564 5f6c 6173 6572 5f70 6f77  pplied_laser_pow
+00016290: 6572 0a0a 2020 2020 2020 2020 7365 6c66  er..        self
+000162a0: 2e73 6574 5f73 7472 6f62 655f 656e 6162  .set_strobe_enab
+000162b0: 6c65 2866 6c61 6729 0a0a 2020 2020 2020  le(flag)..      
+000162c0: 2020 6966 2073 656c 662e 7365 7474 696e    if self.settin
+000162d0: 6773 2e69 735f 7873 2829 3a0a 2020 2020  gs.is_xs():.    
+000162e0: 2020 2020 2020 2020 2320 5365 7269 6573          # Series
+000162f0: 2d58 5320 6765 744c 6173 6572 456e 6162  -XS getLaserEnab
+00016300: 6c65 2064 6f65 736e 2774 2070 726f 7669  le doesn't provi
+00016310: 6465 2069 6d6d 6564 6961 7465 2063 6f6e  de immediate con
+00016320: 6669 726d 6174 696f 6e20 0a20 2020 2020  firmation .     
+00016330: 2020 2020 2020 2023 2062 6563 6175 7365         # because
+00016340: 2069 7427 7320 636f 6d69 6e67 6c65 6420   it's comingled 
+00016350: 7769 7468 206c 6173 6572 5761 7463 6864  with laserWatchd
+00016360: 6f67 5365 6320 616e 6420 7072 6f62 6162  ogSec and probab
+00016370: 6c79 200a 2020 2020 2020 2020 2020 2020  ly .            
+00016380: 2320 6c61 7365 7244 656c 6179 5365 630a  # laserDelaySec.
+00016390: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+000163a0: 726e 2053 7065 6374 726f 6d65 7465 7252  rn SpectrometerR
+000163b0: 6573 706f 6e73 6528 6461 7461 3d54 7275  esponse(data=Tru
+000163c0: 6529 0a0a 2020 2020 2020 2020 2320 7472  e)..        # tr
+000163d0: 7920 746f 2076 6572 6966 7920 6c61 7365  y to verify lase
+000163e0: 7245 6e61 626c 6520 776f 726b 6564 0a20  rEnable worked. 
+000163f0: 2020 2020 2020 2074 7269 6573 203d 2030         tries = 0
+00016400: 0a20 2020 2020 2020 2077 6869 6c65 2054  .        while T
+00016410: 7275 653a 0a20 2020 2020 2020 2020 2020  rue:.           
+00016420: 2072 6573 203d 2073 656c 662e 6765 745f   res = self.get_
+00016430: 6c61 7365 725f 656e 6162 6c65 6428 290a  laser_enabled().
+00016440: 2020 2020 2020 2020 2020 2020 6966 2066              if f
+00016450: 6c61 6720 3d3d 2072 6573 2e64 6174 613a  lag == res.data:
+00016460: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00016470: 2072 6574 7572 6e20 5370 6563 7472 6f6d   return Spectrom
+00016480: 6574 6572 5265 7370 6f6e 7365 2864 6174  eterResponse(dat
+00016490: 613d 5472 7565 290a 2020 2020 2020 2020  a=True).        
+000164a0: 2020 2020 7472 6965 7320 2b3d 2031 0a20      tries += 1. 
+000164b0: 2020 2020 2020 2020 2020 2069 6620 7472             if tr
+000164c0: 6965 7320 3e20 333a 0a20 2020 2020 2020  ies > 3:.       
+000164d0: 2020 2020 2020 2020 206c 6f67 2e63 7269           log.cri
+000164e0: 7469 6361 6c28 226c 6173 6572 5f65 6e61  tical("laser_ena
+000164f0: 626c 6520 2573 2063 6f6d 6d61 6e64 2066  ble %s command f
+00016500: 6169 6c65 642c 2067 6976 696e 6720 7570  ailed, giving up
+00016510: 222c 2066 6c61 6729 0a20 2020 2020 2020  ", flag).       
+00016520: 2020 2020 2020 2020 2073 656c 662e 7175           self.qu
+00016530: 6575 655f 6d65 7373 6167 6528 226d 6172  eue_message("mar
+00016540: 7175 6565 5f65 7272 6f72 222c 2022 6c61  quee_error", "la
+00016550: 7365 7220 7365 7474 696e 6720 6661 696c  ser setting fail
+00016560: 6564 2229 0a20 2020 2020 2020 2020 2020  ed").           
+00016570: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
+00016580: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
+00016590: 2864 6174 613d 4661 6c73 652c 6572 726f  (data=False,erro
+000165a0: 725f 6d73 673d 226c 6173 6572 2073 6574  r_msg="laser set
+000165b0: 7469 6e67 2066 6169 6c65 6422 2c65 7272  ting failed",err
+000165c0: 6f72 5f6c 766c 3d45 7272 6f72 4c65 7665  or_lvl=ErrorLeve
+000165d0: 6c2e 6d65 6469 756d 290a 2020 2020 2020  l.medium).      
+000165e0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+000165f0: 2020 2020 2020 2020 2020 2020 6c6f 672e              log.
+00016600: 6572 726f 7228 226c 6173 6572 5f65 6e61  error("laser_ena
+00016610: 626c 6520 2573 2063 6f6d 6d61 6e64 2066  ble %s command f
+00016620: 6169 6c65 642c 2072 652d 7472 7969 6e67  ailed, re-trying
+00016630: 222c 2066 6c61 6729 0a20 2020 2020 2020  ", flag).       
+00016640: 2020 2020 2020 2020 2073 656c 662e 7365           self.se
+00016650: 745f 7374 726f 6265 5f65 6e61 626c 6528  t_strobe_enable(
+00016660: 666c 6167 290a 0a20 2020 2064 6566 2073  flag)..    def s
+00016670: 6574 5f6c 6173 6572 5f70 6f77 6572 5f6d  et_laser_power_m
+00016680: 5728 7365 6c66 2c20 6d57 5f69 6e3a 2069  W(self, mW_in: i
+00016690: 6e74 293a 0a20 2020 2020 2020 2069 6620  nt):.        if 
+000166a0: 6d57 5f69 6e20 6973 204e 6f6e 6520 6f72  mW_in is None or
+000166b0: 206e 6f74 2073 656c 662e 7365 7474 696e   not self.settin
+000166c0: 6773 2e65 6570 726f 6d2e 6861 735f 6c61  gs.eeprom.has_la
+000166d0: 7365 725f 706f 7765 725f 6361 6c69 6272  ser_power_calibr
+000166e0: 6174 696f 6e28 293a 0a20 2020 2020 2020  ation():.       
+000166f0: 2020 2020 206c 6f67 2e65 7272 6f72 2822       log.error("
+00016700: 4545 5052 4f4d 2064 6f65 736e 2774 2068  EEPROM doesn't h
+00016710: 6176 6520 6c61 7365 7220 706f 7765 7220  ave laser power 
+00016720: 6361 6c69 6272 6174 696f 6e22 290a 2020  calibration").  
+00016730: 2020 2020 2020 2020 2020 7365 6c66 2e73            self.s
+00016740: 6574 7469 6e67 732e 7374 6174 652e 6c61  ettings.state.la
+00016750: 7365 725f 706f 7765 725f 6d57 203d 2030  ser_power_mW = 0
+00016760: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00016770: 662e 7365 7474 696e 6773 2e73 7461 7465  f.settings.state
+00016780: 2e6c 6173 6572 5f70 6f77 6572 5f70 6572  .laser_power_per
+00016790: 6320 3d20 300a 2020 2020 2020 2020 2020  c = 0.          
+000167a0: 2020 7365 6c66 2e73 6574 7469 6e67 732e    self.settings.
+000167b0: 7374 6174 652e 7573 655f 6d57 203d 2046  state.use_mW = F
+000167c0: 616c 7365 0a20 2020 2020 2020 2020 2020  alse.           
+000167d0: 2072 6574 7572 6e20 5370 6563 7472 6f6d   return Spectrom
+000167e0: 6574 6572 5265 7370 6f6e 7365 2864 6174  eterResponse(dat
+000167f0: 613d 4661 6c73 652c 6572 726f 725f 6d73  a=False,error_ms
+00016800: 673d 226e 6f20 6c61 7365 7220 706f 7765  g="no laser powe
+00016810: 7220 6361 6c69 6272 6174 696f 6e22 290a  r calibration").
+00016820: 0a20 2020 2020 2020 206d 5720 3d20 6d69  .        mW = mi
+00016830: 6e28 7365 6c66 2e73 6574 7469 6e67 732e  n(self.settings.
+00016840: 6565 7072 6f6d 2e6d 6178 5f6c 6173 6572  eeprom.max_laser
+00016850: 5f70 6f77 6572 5f6d 572c 206d 6178 2873  _power_mW, max(s
+00016860: 656c 662e 7365 7474 696e 6773 2e65 6570  elf.settings.eep
+00016870: 726f 6d2e 6d69 6e5f 6c61 7365 725f 706f  rom.min_laser_po
+00016880: 7765 725f 6d57 2c20 6d57 5f69 6e29 290a  wer_mW, mW_in)).
+00016890: 0a20 2020 2020 2020 2070 6572 6320 3d20  .        perc = 
+000168a0: 7365 6c66 2e73 6574 7469 6e67 732e 6565  self.settings.ee
+000168b0: 7072 6f6d 2e6c 6173 6572 5f70 6f77 6572  prom.laser_power
+000168c0: 5f6d 575f 746f 5f70 6572 6365 6e74 286d  _mW_to_percent(m
+000168d0: 5729 0a20 2020 2020 2020 206c 6f67 2e64  W).        log.d
+000168e0: 6562 7567 2822 7365 745f 6c61 7365 725f  ebug("set_laser_
+000168f0: 706f 7765 725f 6d57 3a20 7261 6e67 6520  power_mW: range 
+00016900: 2825 2e32 662c 2025 2e32 6629 2c20 7265  (%.2f, %.2f), re
+00016910: 7175 6573 7465 6420 252e 3266 2c20 6170  quested %.2f, ap
+00016920: 7072 6f76 6564 2025 2e32 662c 2070 6572  proved %.2f, per
+00016930: 6365 6e74 203d 2025 2e32 6622 2c0a 2020  cent = %.2f",.  
+00016940: 2020 2020 2020 2020 2020 7365 6c66 2e73            self.s
+00016950: 6574 7469 6e67 732e 6565 7072 6f6d 2e6d  ettings.eeprom.m
+00016960: 696e 5f6c 6173 6572 5f70 6f77 6572 5f6d  in_laser_power_m
+00016970: 572c 0a20 2020 2020 2020 2020 2020 2073  W,.            s
+00016980: 656c 662e 7365 7474 696e 6773 2e65 6570  elf.settings.eep
+00016990: 726f 6d2e 6d61 785f 6c61 7365 725f 706f  rom.max_laser_po
+000169a0: 7765 725f 6d57 2c0a 2020 2020 2020 2020  wer_mW,.        
+000169b0: 2020 2020 6d57 5f69 6e2c 0a20 2020 2020      mW_in,.     
+000169c0: 2020 2020 2020 206d 572c 0a20 2020 2020         mW,.     
+000169d0: 2020 2020 2020 2070 6572 6329 0a20 2020         perc).   
+000169e0: 2020 2020 2073 656c 662e 7365 7474 696e       self.settin
+000169f0: 6773 2e73 7461 7465 2e6c 6173 6572 5f70  gs.state.laser_p
+00016a00: 6f77 6572 5f6d 5720 3d20 6d57 0a20 2020  ower_mW = mW.   
+00016a10: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+00016a20: 2e73 6574 5f6c 6173 6572 5f70 6f77 6572  .set_laser_power
+00016a30: 5f70 6572 6328 7065 7263 2c20 7365 745f  _perc(perc, set_
+00016a40: 696e 5f70 6572 633d 4661 6c73 6529 0a0a  in_perc=False)..
+00016a50: 2020 2020 2323 0a20 2020 2023 2040 6272      ##.    # @br
+00016a60: 6965 6620 5365 7473 2077 6865 7468 6572  ief Sets whether
+00016a70: 2074 6865 2050 574d 2070 756c 7365 2070   the PWM pulse p
+00016a80: 6572 696f 6420 6973 2031 3030 30c2 b573  eriod is 1000..s
+00016a90: 2028 6869 6768 2d72 6573 6f6c 7574 696f   (high-resolutio
+00016aa0: 6e2c 2064 6566 6175 6c74 290a 2020 2020  n, default).    
+00016ab0: 2320 6f72 2031 3030 c2b5 7320 286c 6f77  # or 100..s (low
+00016ac0: 2d72 6573 6f6c 7574 696f 6e2c 206c 6567  -resolution, leg
+00016ad0: 6163 7929 2e0a 2020 2020 230a 2020 2020  acy)..    #.    
+00016ae0: 2320 4070 6172 616d 2066 6c61 6720 2849  # @param flag (I
+00016af0: 6e70 7574 2920 5472 7565 2066 6f72 2031  nput) True for 1
+00016b00: 3030 30c2 b573 2050 574d 2070 6572 696f  000..s PWM perio
+00016b10: 6420 2868 6967 682d 7265 736f 6c75 7469  d (high-resoluti
+00016b20: 6f6e 2c20 6465 6661 756c 7429 2c20 0a20  on, default), . 
+00016b30: 2020 2023 2020 2020 2020 2020 4661 6c73     #        Fals
+00016b40: 6520 666f 7220 3130 30c2 b573 2028 6c6f  e for 100..s (lo
+00016b50: 772d 7265 736f 6c75 7469 6f6e 290a 2020  w-resolution).  
+00016b60: 2020 2320 0a20 2020 2023 204c 6173 6572    # .    # Laser
+00016b70: 2070 6f77 6572 2069 7320 636f 6e74 726f   power is contro
+00016b80: 6c6c 6564 2076 6961 2050 574d 2028 5075  lled via PWM (Pu
+00016b90: 6c73 6520 5769 6474 6820 4d6f 6475 6c61  lse Width Modula
+00016ba0: 7469 6f6e 292c 2065 7373 656e 7469 616c  tion), essential
+00016bb0: 6c79 200a 2020 2020 2320 6120 7371 7561  ly .    # a squa
+00016bc0: 7265 2077 6176 6520 7768 6f73 6520 2264  re wave whose "d
+00016bd0: 7574 7920 6379 636c 6522 2028 6869 6768  uty cycle" (high
+00016be0: 2076 7320 6c6f 7729 2c20 6578 7072 6573   vs low), expres
+00016bf0: 7365 6420 6173 2061 2070 6572 6365 6e74  sed as a percent
+00016c00: 6167 652c 0a20 2020 2023 2072 6570 7265  age,.    # repre
+00016c10: 7365 6e74 7320 7468 6520 616d 6f75 6e74  sents the amount
+00016c20: 206f 6620 7469 6d65 2074 6865 206c 6173   of time the las
+00016c30: 6572 2069 7320 6163 7475 616c 6c79 2066  er is actually f
+00016c40: 6972 696e 672e 2049 6620 7468 6520 6475  iring. If the du
+00016c50: 7479 0a20 2020 2023 2063 7963 6c65 2069  ty.    # cycle i
+00016c60: 7320 3333 252c 2074 6865 206c 6173 6572  s 33%, the laser
+00016c70: 2077 696c 6c20 6265 2066 6972 696e 6720   will be firing 
+00016c80: 312f 3320 6f66 2074 6865 2074 696d 652c  1/3 of the time,
+00016c90: 2072 6570 7265 7365 6e74 696e 670a 2020   representing.  
+00016ca0: 2020 2320 6170 7072 6f78 696d 6174 656c    # approximatel
+00016cb0: 7920 6f6e 652d 7468 6972 6420 6f66 2022  y one-third of "
+00016cc0: 6675 6c6c 2070 6f77 6572 222e 2020 0a20  full power".  . 
+00016cd0: 2020 2023 200a 2020 2020 2320 2849 7427     # .    # (It'
+00016ce0: 7320 6e6f 7420 2265 7861 6374 6c79 2220  s not "exactly" 
+00016cf0: 6f6e 652d 7468 6972 6420 6265 6361 7573  one-third becaus
+00016d00: 6520 7468 6520 6c61 7365 7220 6e65 6564  e the laser need
+00016d10: 7320 6120 6d6f 6d65 6e74 2074 6f20 0a20  s a moment to . 
+00016d20: 2020 2023 2073 7461 626c 697a 6520 7768     # stablize wh
+00016d30: 656e 2065 6e65 7267 697a 6564 2c20 616e  en energized, an
+00016d40: 6420 7468 6174 2022 7374 6172 742d 7570  d that "start-up
+00016d50: 2220 696e 7374 6162 696c 6974 7920 6973  " instability is
+00016d60: 2069 6e63 7265 6173 6564 200a 2020 2020   increased .    
+00016d70: 2320 7768 656e 2079 6f75 2772 6520 636f  # when you're co
+00016d80: 6e73 7461 6e74 6c79 2070 756c 7369 6e67  nstantly pulsing
+00016d90: 2074 6865 206c 6173 6572 206f 6e2d 616e   the laser on-an
+00016da0: 642d 6f66 662e 290a 2020 2020 2320 0a20  d-off.).    # . 
+00016db0: 2020 2023 2054 6869 7320 6675 6e63 7469     # This functi
+00016dc0: 6f6e 2069 7320 7573 6564 2074 6f20 6465  on is used to de
+00016dd0: 7465 726d 696e 6520 7468 6520 4c45 4e47  termine the LENG
+00016de0: 5448 2028 7065 7269 6f64 2920 6f66 2074  TH (period) of t
+00016df0: 6861 7420 5057 4d0a 2020 2020 2320 7371  hat PWM.    # sq
+00016e00: 7561 7265 2077 6176 652e 2020 4265 6361  uare wave.  Beca
+00016e10: 7573 6520 7468 6520 6c61 7365 7227 7320  use the laser's 
+00016e20: 5057 4d20 7061 7261 6d65 7465 7273 2061  PWM parameters a
+00016e30: 7265 2061 6c6c 2073 7065 6369 6669 6564  re all specified
+00016e40: 2069 6e0a 2020 2020 2320 6d69 6372 6f73   in.    # micros
+00016e50: 6563 6f6e 6473 2028 c2b5 7329 2c20 6120  econds (..s), a 
+00016e60: 6c6f 6e67 6572 2070 6572 696f 6420 616c  longer period al
+00016e70: 6c6f 7773 2067 7265 6174 6572 2070 7265  lows greater pre
+00016e80: 6369 7369 6f6e 2028 7265 736f 6c75 7469  cision (resoluti
+00016e90: 6f6e 290a 2020 2020 2320 696e 2073 7065  on).    # in spe
+00016ea0: 6369 6679 696e 6720 7468 6520 6475 7479  cifying the duty
+00016eb0: 2063 7963 6c65 2e0a 2020 2020 2320 0a20   cycle..    # . 
+00016ec0: 2020 2023 2048 6973 746f 7269 6361 6c6c     # Historicall
+00016ed0: 792c 2057 6173 6174 6368 2073 7065 6374  y, Wasatch spect
+00016ee0: 726f 6d65 7465 7273 2075 7365 6420 6120  rometers used a 
+00016ef0: 5057 4d20 7065 7269 6f64 206f 6620 3130  PWM period of 10
+00016f00: 30c2 b573 2c20 6d65 616e 696e 670a 2020  0..s, meaning.  
+00016f10: 2020 2320 7468 6520 7075 6c73 6520 7769    # the pulse wi
+00016f20: 6474 6820 2874 696d 6520 6561 6368 2077  dth (time each w
+00016f30: 6176 6520 7761 7320 6869 6768 2920 636f  ave was high) co
+00016f40: 756c 6420 6f6e 6c79 2062 6520 7365 7420  uld only be set 
+00016f50: 6672 6f6d 2031 2d39 39c2 b573 2c0a 2020  from 1-99..s,.  
+00016f60: 2020 2320 6769 7669 6e67 2061 6e20 6573    # giving an es
+00016f70: 7365 6e74 6961 6c20 6c61 7365 7220 706f  sential laser po
+00016f80: 7765 7220 7265 736f 6c75 7469 6f6e 206f  wer resolution o
+00016f90: 6620 3125 2e20 2054 6861 7420 6265 6861  f 1%.  That beha
+00016fa0: 7669 6f72 2063 616e 0a20 2020 2023 2062  vior can.    # b
+00016fb0: 6520 7265 7374 6f72 6564 2062 7920 7365  e restored by se
+00016fc0: 7474 696e 6720 7468 6973 2076 616c 7565  tting this value
+00016fd0: 2046 616c 7365 2e0a 2020 2020 2320 0a20   False..    # . 
+00016fe0: 2020 2023 204d 6f72 6520 7265 6365 6e74     # More recent
+00016ff0: 6c79 2c20 7765 2776 6520 696e 6372 6561  ly, we've increa
+00017000: 7365 6420 7468 6520 6465 6661 756c 7420  sed the default 
+00017010: 5057 4d20 7075 6c73 6520 7065 7269 6f64  PWM pulse period
+00017020: 2074 6f20 3130 3030 c2b5 7320 0a20 2020   to 1000..s .   
+00017030: 2023 2028 316d 7329 2e20 5369 6e63 6520   # (1ms). Since 
+00017040: 7468 6520 7075 6c73 6520 7769 6474 6820  the pulse width 
+00017050: 6973 2073 7469 6c6c 2073 6574 2069 6e20  is still set in 
+00017060: c2b5 732c 2074 6861 7420 616c 6c6f 7773  ..s, that allows
+00017070: 2061 6e0a 2020 2020 2320 6566 6665 6374   an.    # effect
+00017080: 6976 6520 6c61 7365 7220 706f 7765 7220  ive laser power 
+00017090: 7265 736f 6c75 7469 6f6e 206f 6620 302e  resolution of 0.
+000170a0: 3125 2e20 2054 6869 7320 6973 2074 6865  1%.  This is the
+000170b0: 206e 6577 2064 6566 6175 6c74 2c0a 2020   new default,.  
+000170c0: 2020 2320 616e 6420 6361 6e20 6265 2065    # and can be e
+000170d0: 7870 6c69 6369 746c 7920 7265 7175 6573  xplicitly reques
+000170e0: 7465 6420 6279 2073 6574 7469 6e67 2074  ted by setting t
+000170f0: 6869 7320 7661 6c75 6520 746f 2054 7275  his value to Tru
+00017100: 652e 0a20 2020 2023 0a20 2020 2023 2040  e..    #.    # @
+00017110: 7761 726e 696e 6720 4e6f 7465 2074 6861  warning Note tha
+00017120: 7420 7468 6973 2066 756e 6374 696f 6e20  t this function 
+00017130: 6973 2070 726f 7669 6465 6420 666f 7220  is provided for 
+00017140: 6361 7365 7320 7768 6572 6520 7468 6520  cases where the 
+00017150: 6c61 7365 7220 706f 7765 7220 0a20 2020  laser power .   
+00017160: 2023 2069 7320 7365 7420 6173 2061 2070   # is set as a p
+00017170: 6572 6365 6e74 6167 652e 2020 5768 656e  ercentage.  When
+00017180: 2073 6574 7469 6e67 206c 6173 6572 2070   setting laser p
+00017190: 6f77 6572 2074 6872 6f75 6768 206d 696c  ower through mil
+000171a0: 6c69 5761 7474 732c 2075 7369 6e67 0a20  liWatts, using. 
+000171b0: 2020 2023 2074 6865 206f 6e62 6f61 7264     # the onboard
+000171c0: 206c 6173 6572 2070 6f77 6572 2063 616c   laser power cal
+000171d0: 6962 7261 7469 6f6e 2c20 6974 2069 7320  ibration, it is 
+000171e0: 696d 706f 7274 616e 7420 746f 2075 7365  important to use
+000171f0: 2074 6865 2073 616d 650a 2020 2020 2320   the same.    # 
+00017200: 7265 736f 6c75 7469 6f6e 2061 7320 7761  resolution as wa
+00017210: 7320 696e 2065 6666 6563 7420 7768 656e  s in effect when
+00017220: 2074 6865 2063 616c 6962 7261 7469 6f6e   the calibration
+00017230: 2077 6173 2067 656e 6572 6174 6564 2e20   was generated. 
+00017240: 2041 6c6c 2057 6173 6174 6368 0a20 2020   All Wasatch.   
+00017250: 2023 206c 6173 6572 2070 6f77 6572 2063   # laser power c
+00017260: 616c 6962 7261 7469 6f6e 7320 6172 6520  alibrations are 
+00017270: 6765 6e65 7261 7465 6420 696e 2022 6869  generated in "hi
+00017280: 6768 2d72 6573 6f6c 7574 696f 6e2c 2220  gh-resolution," 
+00017290: 736f 2074 6869 7320 0a20 2020 2023 2066  so this .    # f
+000172a0: 756e 6374 696f 6e20 5348 4f55 4c44 204e  unction SHOULD N
+000172b0: 4f54 2062 6520 7365 7420 2246 616c 7365  OT be set "False
+000172c0: 2220 286c 6f77 2d72 6573 2920 6966 2073  " (low-res) if s
+000172d0: 6574 7469 6e67 206c 6173 6572 2070 6f77  etting laser pow
+000172e0: 6572 2069 6e20 6d57 2e0a 2020 2020 6465  er in mW..    de
+000172f0: 6620 7365 745f 6c61 7365 725f 706f 7765  f set_laser_powe
+00017300: 725f 6869 6768 5f72 6573 6f6c 7574 696f  r_high_resolutio
+00017310: 6e28 7365 6c66 2c20 666c 6167 3a20 626f  n(self, flag: bo
+00017320: 6f6c 293a 0a20 2020 2020 2020 2073 656c  ol):.        sel
+00017330: 662e 7365 7474 696e 6773 2e73 7461 7465  f.settings.state
+00017340: 2e6c 6173 6572 5f70 6f77 6572 5f68 6967  .laser_power_hig
+00017350: 685f 7265 736f 6c75 7469 6f6e 203d 2054  h_resolution = T
+00017360: 7275 6520 6966 2066 6c61 6720 656c 7365  rue if flag else
+00017370: 2046 616c 7365 0a20 2020 2020 2020 2072   False.        r
+00017380: 6574 7572 6e20 5370 6563 7472 6f6d 6574  eturn Spectromet
+00017390: 6572 5265 7370 6f6e 7365 2829 0a0a 2020  erResponse()..  
+000173a0: 2020 6465 6620 7365 745f 6c61 7365 725f    def set_laser_
+000173b0: 706f 7765 725f 7265 7175 6972 655f 6d6f  power_require_mo
+000173c0: 6475 6c61 7469 6f6e 2873 656c 662c 2066  dulation(self, f
+000173d0: 6c61 673a 2062 6f6f 6c29 3a0a 2020 2020  lag: bool):.    
+000173e0: 2020 2020 7365 6c66 2e73 6574 7469 6e67      self.setting
+000173f0: 732e 7374 6174 652e 6c61 7365 725f 706f  s.state.laser_po
+00017400: 7765 725f 7265 7175 6972 655f 6d6f 6475  wer_require_modu
+00017410: 6c61 7469 6f6e 203d 2054 7275 6520 6966  lation = True if
+00017420: 2066 6c61 6720 656c 7365 2046 616c 7365   flag else False
+00017430: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00017440: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
+00017450: 6f6e 7365 2829 0a0a 2020 2020 2323 0a20  onse()..    ##. 
+00017460: 2020 2023 2040 746f 646f 2073 7570 706f     # @todo suppo
+00017470: 7274 2066 6c6f 6174 696e 672d 706f 696e  rt floating-poin
+00017480: 7420 7661 6c75 652c 2061 7320 7765 2068  t value, as we h
+00017490: 6176 6520 6120 3132 2d62 6974 2041 4443  ave a 12-bit ADC
+000174a0: 2061 6e64 2063 616e 2070 726f 7669 6465   and can provide
+000174b0: 0a20 2020 2023 2061 2062 6974 206d 6f72  .    # a bit mor
+000174c0: 6520 7072 6563 6973 696f 6e20 7468 616e  e precision than
+000174d0: 2031 3030 2064 6973 6372 6574 6520 7374   100 discrete st
+000174e0: 6570 7320 2867 6f61 6c20 746f 2073 7570  eps (goal to sup
+000174f0: 706f 7274 2030 2e31 202d 202e 3132 3525  port 0.1 - .125%
+00017500: 2072 6573 6f6c 7574 696f 6e29 0a20 2020   resolution).   
+00017510: 2064 6566 2073 6574 5f6c 6173 6572 5f70   def set_laser_p
+00017520: 6f77 6572 5f70 6572 6328 7365 6c66 2c20  ower_perc(self, 
+00017530: 7661 6c75 655f 696e 3a20 666c 6f61 742c  value_in: float,
+00017540: 2073 6574 5f69 6e5f 7065 7263 3a20 626f   set_in_perc: bo
+00017550: 6f6c 203d 2054 7275 6529 3a0a 2020 2020  ol = True):.    
+00017560: 2020 2020 6966 206e 6f74 2073 656c 662e      if not self.
+00017570: 7365 7474 696e 6773 2e65 6570 726f 6d2e  settings.eeprom.
+00017580: 6861 735f 6c61 7365 723a 0a20 2020 2020  has_laser:.     
+00017590: 2020 2020 2020 206c 6f67 2e65 7272 6f72         log.error
+000175a0: 2822 756e 6162 6c65 2074 6f20 636f 6e74  ("unable to cont
+000175b0: 726f 6c20 6c61 7365 723a 2045 4550 524f  rol laser: EEPRO
+000175c0: 4d20 7265 706f 7274 7320 6e6f 206c 6173  M reports no las
+000175d0: 6572 2069 6e73 7461 6c6c 6564 2229 0a20  er installed"). 
+000175e0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+000175f0: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
+00017600: 7370 6f6e 7365 2864 6174 613d 4661 6c73  sponse(data=Fals
+00017610: 652c 6572 726f 725f 6d73 673d 226e 6f20  e,error_msg="no 
+00017620: 6c61 7365 7220 696e 7374 616c 6c65 6422  laser installed"
+00017630: 290a 0a20 2020 2020 2020 2076 616c 7565  )..        value
+00017640: 203d 2066 6c6f 6174 286d 6178 2830 2c20   = float(max(0, 
+00017650: 6d69 6e28 3130 302c 2076 616c 7565 5f69  min(100, value_i
+00017660: 6e29 2929 0a20 2020 2020 2020 2073 656c  n))).        sel
+00017670: 662e 7365 7474 696e 6773 2e73 7461 7465  f.settings.state
+00017680: 2e6c 6173 6572 5f70 6f77 6572 5f70 6572  .laser_power_per
+00017690: 6320 3d20 7661 6c75 650a 2020 2020 2020  c = value.      
+000176a0: 2020 6c6f 672e 6465 6275 6728 2273 6574    log.debug("set
+000176b0: 5f6c 6173 6572 5f70 6f77 6572 5f70 6572  _laser_power_per
+000176c0: 633a 2072 616e 6765 2028 302c 2031 3030  c: range (0, 100
+000176d0: 292c 2072 6571 7565 7374 6564 2025 2e32  ), requested %.2
+000176e0: 662c 2061 7070 6c79 696e 6720 252e 3266  f, applying %.2f
+000176f0: 222c 2076 616c 7565 5f69 6e2c 2076 616c  ", value_in, val
+00017700: 7565 290a 0a20 2020 2020 2020 2069 6620  ue)..        if 
+00017710: 7365 745f 696e 5f70 6572 633a 0a20 2020  set_in_perc:.   
+00017720: 2020 2020 2020 2020 2023 2061 7070 6172           # appar
+00017730: 656e 746c 7920 7468 6520 6c61 7365 7220  ently the laser 
+00017740: 706f 7765 7220 7761 7320 6578 706c 6963  power was explic
+00017750: 6974 6c79 2063 6f6d 6d61 6e64 6564 2061  itly commanded a
+00017760: 7320 6120 7065 7263 656e 7461 6765 0a20  s a percentage. 
+00017770: 2020 2020 2020 2020 2020 2023 206f 6620             # of 
+00017780: 6675 6c6c 2c20 616e 6420 6e6f 7420 2263  full, and not "c
+00017790: 6f6d 7075 7465 6420 6672 6f6d 206d 5722  omputed from mW"
+000177a0: 2075 7369 6e67 2061 2063 616c 6962 7261   using a calibra
+000177b0: 7469 6f6e 2c20 736f 2063 6c65 6172 0a20  tion, so clear. 
+000177c0: 2020 2020 2020 2020 2020 2023 2074 6865             # the
+000177d0: 206d 5720 7365 7470 6f69 6e74 0a20 2020   mW setpoint.   
+000177e0: 2020 2020 2020 2020 2073 656c 662e 7365           self.se
+000177f0: 7474 696e 6773 2e73 7461 7465 2e6c 6173  ttings.state.las
+00017800: 6572 5f70 6f77 6572 5f6d 5720 3d20 300a  er_power_mW = 0.
+00017810: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00017820: 7365 6c66 2e73 6574 5f6c 6173 6572 5f70  self.set_laser_p
+00017830: 6f77 6572 5f70 6572 635f 696d 6d65 6469  ower_perc_immedi
+00017840: 6174 6528 7661 6c75 6529 0a0a 2020 2020  ate(value)..    
+00017850: 2323 0a20 2020 2023 2053 6574 7320 6c61  ##.    # Sets la
+00017860: 7365 7220 706f 7765 7220 286d 6f64 756c  ser power (modul
+00017870: 6174 6564 2070 756c 7365 2077 6964 7468  ated pulse width
+00017880: 2920 7768 6963 6820 7769 6c6c 2062 6520  ) which will be 
+00017890: 7573 6564 206e 6578 7420 7469 6d65 2074  used next time t
+000178a0: 6865 0a20 2020 2023 206c 6173 6572 2069  he.    # laser i
+000178b0: 7320 7475 726e 6564 206f 6e20 286f 7220  s turned on (or 
+000178c0: 6368 616e 6765 6420 696d 6d65 6469 6174  changed immediat
+000178d0: 656c 792c 2069 6620 7468 6520 6c61 7365  ely, if the lase
+000178e0: 7220 6973 2061 6c72 6561 6479 2065 6e61  r is already ena
+000178f0: 626c 6564 292e 0a20 2020 2023 204c 6173  bled)..    # Las
+00017900: 6572 2070 6f77 6572 2069 7320 6465 7465  er power is dete
+00017910: 726d 696e 6564 2062 7920 6120 636f 6d62  rmined by a comb
+00017920: 696e 6174 696f 6e20 6f66 2074 6865 2070  ination of the p
+00017930: 756c 7365 2077 6964 7468 2c0a 2020 2020  ulse width,.    
+00017940: 2320 7065 7269 6f64 2061 6e64 206d 6f64  # period and mod
+00017950: 756c 6174 696f 6e20 6265 696e 6720 656e  ulation being en
+00017960: 6162 6c65 642e 2054 6865 7265 2061 7265  abled. There are
+00017970: 206d 616e 7920 636f 6d62 696e 6174 696f   many combinatio
+00017980: 6e73 206f 660a 2020 2020 2320 7468 6573  ns of.    # thes
+00017990: 6520 7661 6c75 6573 2074 6861 7420 7769  e values that wi
+000179a0: 6c6c 2070 726f 6475 6365 2061 2067 6976  ll produce a giv
+000179b0: 656e 2070 6572 6365 6e74 6167 6520 6f66  en percentage of
+000179c0: 2074 6865 2074 6f74 616c 206c 6173 6572   the total laser
+000179d0: 0a20 2020 2023 2070 6f77 6572 2074 6872  .    # power thr
+000179e0: 6f75 6768 2070 756c 7365 2077 6964 7468  ough pulse width
+000179f0: 206d 6f64 756c 6174 696f 6e2e 2054 6865   modulation. The
+00017a00: 7265 2069 7320 6e6f 2027 6765 7420 6c61  re is no 'get la
+00017a10: 7365 7220 706f 7765 7227 0a20 2020 2023  ser power'.    #
+00017a20: 2063 6f6e 7472 6f6c 206d 6573 7361 6765   control message
+00017a30: 206f 6e20 7468 6520 6465 7669 6365 2e0a   on the device..
+00017a40: 2020 2020 230a 2020 2020 2320 536f 6d65      #.    # Some
+00017a50: 206f 6620 7468 6520 676f 616c 7320 6f66   of the goals of
+00017a60: 2045 6e6c 6967 6874 656e 2061 7265 2066   Enlighten are f
+00017a70: 6f72 2069 7420 746f 2062 6520 7374 6162  or it to be stab
+00017a80: 6c65 2c20 616e 6420 6120 7265 6173 6f6e  le, and a reason
+00017a90: 0a20 2020 2023 2077 6520 6861 7665 2073  .    # we have s
+00017aa0: 616c 6573 2e20 4475 7269 6e67 2073 7065  ales. During spe
+00017ab0: 6374 726f 6d65 7465 7220 6275 696c 6473  ctrometer builds
+00017ac0: 2c20 6974 2077 6173 2064 6973 636f 7665  , it was discove
+00017ad0: 7265 6420 7468 6174 0a20 2020 2023 2074  red that.    # t
+00017ae0: 6865 206c 6173 6572 2070 6f77 6572 2073  he laser power s
+00017af0: 6574 7469 6e67 7320 7765 7265 206e 6f74  ettings were not
+00017b00: 2069 6d70 6c65 6d65 6e74 6564 2e20 4475   implemented. Du
+00017b10: 7269 6e67 2074 6865 0a20 2020 2023 2069  ring the.    # i
+00017b20: 6d70 6c65 6d65 6e74 6174 696f 6e20 7072  mplementation pr
+00017b30: 6f63 6573 732c 2069 7420 7761 7320 6469  ocess, it was di
+00017b40: 7363 6f76 6572 6564 2074 6861 7420 7468  scovered that th
+00017b50: 6520 6c61 7365 7220 6d6f 6475 6c61 7469  e laser modulati
+00017b60: 6f6e 2c0a 2020 2020 2320 7075 6c73 6520  on,.    # pulse 
+00017b70: 7065 7269 6f64 2061 6e64 2070 756c 7365  period and pulse
+00017b80: 2077 6964 7468 2063 6f6d 6d61 6e64 7320   width commands 
+00017b90: 646f 206e 6f74 2063 6f6e 666f 726d 2074  do not conform t
+00017ba0: 6f0a 2020 2020 2320 7370 6563 6966 6963  o.    # specific
+00017bb0: 6174 696f 6e2e 2057 6865 7265 2079 6f75  ation. Where you
+00017bc0: 2063 616e 2073 6574 2069 6e74 6567 7261   can set integra
+00017bd0: 7469 6f6e 2074 696d 6520 3130 3020 6d73  tion time 100 ms
+00017be0: 2077 6974 6820 7468 650a 2020 2020 2320   with the.    # 
+00017bf0: 636f 6d6d 616e 643a 0a20 2020 2023 0a20  command:.    #. 
+00017c00: 2020 2023 2064 6576 6963 652e 6374 726c     # device.ctrl
+00017c10: 5f74 7261 6e73 6665 7228 626d 5265 7175  _transfer(bmRequ
+00017c20: 6573 7454 7970 653d 6465 7669 6365 5f74  estType=device_t
+00017c30: 6f5f 686f 7374 2c0a 2020 2020 2320 2020  o_host,.    #   
 00017c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017c50: 2020 2020 2020 2020 2020 2077 496e 6465             wInde
-00017c60: 7820 2020 2020 2020 2020 203d 2031 2069  x          = 1 i
-00017c70: 6620 666c 6167 2065 6c73 6520 302c 0d0a  f flag else 0,..
-00017c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017c90: 2020 2020 2020 2020 2020 2020 2020 6461                da
-00017ca0: 7461 5f6f 725f 774c 656e 6774 6820 3d20  ta_or_wLength = 
-00017cb0: 5b30 5d20 2a20 382c 0d0a 2020 2020 2020  [0] * 8,..      
-00017cc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017cd0: 2020 2020 2020 2020 6c61 6265 6c20 2020          label   
-00017ce0: 2020 2020 2020 2020 3d20 2253 4554 5f52          = "SET_R
-00017cf0: 414d 414e 5f4d 4f44 455f 454e 4142 4c45  AMAN_MODE_ENABLE
-00017d00: 2229 0d0a 0d0a 2020 2020 6465 6620 6765  ")....    def ge
-00017d10: 745f 7261 6d61 6e5f 6465 6c61 795f 6d73  t_raman_delay_ms
-00017d20: 2873 656c 6629 3a20 2320 2d3e 2053 7065  (self): # -> Spe
-00017d30: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
-00017d40: 6520 0d0a 2020 2020 2020 2020 7265 7320  e ..        res 
-00017d50: 3d20 7365 6c66 2e67 6574 5f75 7070 6572  = self.get_upper
-00017d60: 5f63 6f64 6528 3078 3139 2c20 6c61 6265  _code(0x19, labe
-00017d70: 6c3d 2247 4554 5f52 414d 414e 5f44 454c  l="GET_RAMAN_DEL
-00017d80: 4159 5f4d 5322 2c20 6d73 625f 6c65 6e3d  AY_MS", msb_len=
-00017d90: 3229 0d0a 2020 2020 2020 2020 7365 6c66  2)..        self
-00017da0: 2e73 6574 7469 6e67 732e 7374 6174 652e  .settings.state.
-00017db0: 7261 6d61 6e5f 6465 6c61 795f 6d73 203d  raman_delay_ms =
-00017dc0: 2072 6573 2e64 6174 610d 0a20 2020 2020   res.data..     
-00017dd0: 2020 2072 6574 7572 6e20 7265 730d 0a0d     return res...
-00017de0: 0a20 2020 2064 6566 2073 6574 5f72 616d  .    def set_ram
-00017df0: 616e 5f64 656c 6179 5f6d 7328 7365 6c66  an_delay_ms(self
-00017e00: 2c20 6d73 3a20 696e 7429 3a20 2320 2d3e  , ms: int): # ->
-00017e10: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
-00017e20: 706f 6e73 6520 0d0a 2020 2020 2020 2020  ponse ..        
-00017e30: 6966 206e 6f74 2073 656c 662e 7365 7474  if not self.sett
-00017e40: 696e 6773 2e69 735f 6d69 6372 6f28 293a  ings.is_micro():
-00017e50: 0d0a 2020 2020 2020 2020 2020 2020 6c6f  ..            lo
-00017e60: 672e 6465 6275 6728 2252 616d 616e 2064  g.debug("Raman d
-00017e70: 656c 6179 206f 6e6c 7920 7375 7070 6f72  elay only suppor
-00017e80: 7465 6420 6f6e 2053 6572 6965 732d 5853  ted on Series-XS
-00017e90: 2229 0d0a 2020 2020 2020 2020 2020 2020  ")..            
-00017ea0: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
-00017eb0: 7465 7252 6573 706f 6e73 6528 6461 7461  terResponse(data
-00017ec0: 3d46 616c 7365 2c65 7272 6f72 5f6d 7367  =False,error_msg
-00017ed0: 3d22 7261 6d61 6e20 6465 6c61 7920 6e6f  ="raman delay no
-00017ee0: 7420 7375 7070 6f72 7465 6422 290d 0a0d  t supported")...
-00017ef0: 0a20 2020 2020 2020 2023 2073 656e 6420  .        # send 
-00017f00: 7661 6c75 6520 6173 2062 6967 2d65 6e64  value as big-end
-00017f10: 6961 6e0d 0a20 2020 2020 2020 206d 7362  ian..        msb
-00017f20: 203d 2028 6d73 203e 3e20 3829 2026 2030   = (ms >> 8) & 0
-00017f30: 7866 660d 0a20 2020 2020 2020 206c 7362  xff..        lsb
-00017f40: 203d 2020 6d73 2020 2020 2020 2026 2030   =  ms       & 0
-00017f50: 7866 660d 0a20 2020 2020 2020 2076 616c  xff..        val
-00017f60: 7565 203d 2028 6d73 6220 3c3c 2038 2920  ue = (msb << 8) 
-00017f70: 7c20 6c73 620d 0a0d 0a20 2020 2020 2020  | lsb....       
-00017f80: 2073 656c 662e 7365 7474 696e 6773 2e73   self.settings.s
-00017f90: 7461 7465 2e72 616d 616e 5f64 656c 6179  tate.raman_delay
-00017fa0: 5f6d 7320 3d20 6d73 0d0a 2020 2020 2020  _ms = ms..      
-00017fb0: 2020 7265 7475 726e 2073 656c 662e 5f73    return self._s
-00017fc0: 656e 645f 636f 6465 2862 5265 7175 6573  end_code(bReques
-00017fd0: 7420 2020 2020 2020 203d 2030 7866 662c  t        = 0xff,
-00017fe0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00017ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018000: 7756 616c 7565 2020 2020 2020 2020 2020  wValue          
-00018010: 3d20 3078 3230 2c0d 0a20 2020 2020 2020  = 0x20,..       
-00018020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018030: 2020 2020 2020 2077 496e 6465 7820 2020         wIndex   
-00018040: 2020 2020 2020 203d 2076 616c 7565 2c0d         = value,.
-00018050: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00018060: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-00018070: 6174 615f 6f72 5f77 4c65 6e67 7468 203d  ata_or_wLength =
-00018080: 205b 305d 202a 2038 2c0d 0a20 2020 2020   [0] * 8,..     
-00018090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000180a0: 2020 2020 2020 2020 206c 6162 656c 2020           label  
-000180b0: 2020 2020 2020 2020 203d 2022 5345 545f           = "SET_
-000180c0: 5241 4d41 4e5f 4445 4c41 595f 4d53 2229  RAMAN_DELAY_MS")
-000180d0: 0d0a 0d0a 2020 2020 6465 6620 6765 745f  ....    def get_
-000180e0: 6c61 7365 725f 7761 7463 6864 6f67 5f73  laser_watchdog_s
-000180f0: 6563 2873 656c 6629 3a20 2320 2d3e 2053  ec(self): # -> S
-00018100: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
-00018110: 6e73 6520 0d0a 2020 2020 2020 2020 7265  nse ..        re
-00018120: 7320 3d20 7365 6c66 2e67 6574 5f75 7070  s = self.get_upp
-00018130: 6572 5f63 6f64 6528 3078 3137 2c20 6c61  er_code(0x17, la
-00018140: 6265 6c3d 2247 4554 5f4c 4153 4552 5f57  bel="GET_LASER_W
-00018150: 4154 4348 444f 475f 5345 4322 2c20 6d73  ATCHDOG_SEC", ms
-00018160: 625f 6c65 6e3d 3229 0d0a 2020 2020 2020  b_len=2)..      
-00018170: 2020 7365 6c66 2e73 6574 7469 6e67 732e    self.settings.
-00018180: 7374 6174 652e 6c61 7365 725f 7761 7463  state.laser_watc
-00018190: 6864 6f67 5f73 6563 203d 2072 6573 2e64  hdog_sec = res.d
-000181a0: 6174 610d 0a20 2020 2020 2020 2072 6574  ata..        ret
-000181b0: 7572 6e20 7265 730d 0a0d 0a20 2020 2023  urn res....    #
-000181c0: 2040 6e6f 7465 2075 6e74 696c 2074 6869   @note until thi
-000181d0: 7320 6368 616e 6765 2069 7320 6d69 6d69  s change is mimi
-000181e0: 636b 2764 2069 6e20 7468 6520 5354 4d33  ck'd in the STM3
-000181f0: 3220 2861 6e64 2061 6674 6572 2074 6861  2 (and after tha
-00018200: 742c 2075 6e74 696c 2074 6865 2046 5047  t, until the FPG
-00018210: 410d 0a20 2020 2023 2020 2020 2020 206c  A..    #       l
-00018220: 6f67 6963 2069 7473 656c 6620 6973 2066  ogic itself is f
-00018230: 6978 6564 292c 2061 6c77 6179 7320 7365  ixed), always se
-00018240: 6e64 2061 2044 4953 4142 4c45 5f4c 4153  nd a DISABLE_LAS
-00018250: 4552 2062 6566 6f72 6520 6368 616e 6769  ER before changi
-00018260: 6e67 2074 6865 200d 0a20 2020 2023 2020  ng the ..    #  
-00018270: 2020 2020 2077 6174 6368 646f 6720 7065       watchdog pe
-00018280: 7269 6f64 2e0d 0a20 2020 2064 6566 2073  riod...    def s
-00018290: 6574 5f6c 6173 6572 5f77 6174 6368 646f  et_laser_watchdo
-000182a0: 675f 7365 6328 7365 6c66 2c20 7365 6329  g_sec(self, sec)
-000182b0: 3a0d 0a20 2020 2020 2020 2069 6620 6e6f  :..        if no
-000182c0: 7420 7365 6c66 2e73 6574 7469 6e67 732e  t self.settings.
-000182d0: 6973 5f6d 6963 726f 2829 3a0d 0a20 2020  is_micro():..   
-000182e0: 2020 2020 2020 2020 206c 6f67 2e65 7272           log.err
-000182f0: 6f72 2822 4c61 7365 7220 7761 7463 6864  or("Laser watchd
-00018300: 6f67 206f 6e6c 7920 7375 7070 6f72 7465  og only supporte
-00018310: 6420 6f6e 2053 6572 6965 732d 5853 2229  d on Series-XS")
-00018320: 0d0a 2020 2020 2020 2020 2020 2020 7265  ..            re
-00018330: 7475 726e 2053 7065 6374 726f 6d65 7465  turn Spectromete
-00018340: 7252 6573 706f 6e73 6528 6461 7461 3d46  rResponse(data=F
-00018350: 616c 7365 2c65 7272 6f72 5f6d 7367 3d22  alse,error_msg="
-00018360: 6c61 7365 7220 7761 7463 6864 6f67 206e  laser watchdog n
-00018370: 6f74 2073 7570 706f 7274 6564 2229 0d0a  ot supported")..
-00018380: 0d0a 2020 2020 2020 2020 6966 2028 2866  ..        if ((f
-00018390: 6d74 203a 3d20 7365 6c66 2e73 6574 7469  mt := self.setti
-000183a0: 6e67 732e 6565 7072 6f6d 2e66 6f72 6d61  ngs.eeprom.forma
-000183b0: 7429 203c 2031 3529 3a0d 0a20 2020 2020  t) < 15):..     
-000183c0: 2020 2020 2020 206c 6f67 2e69 6e66 6f28         log.info(
-000183d0: 6622 4545 5052 4f4d 2066 6f72 6d61 7420  f"EEPROM format 
-000183e0: 7b66 6d74 7d20 646f 6573 206e 6f74 2073  {fmt} does not s
-000183f0: 7570 706f 7274 206c 6173 6572 2077 6174  upport laser wat
-00018400: 6368 646f 6722 290d 0a20 2020 2020 2020  chdog")..       
-00018410: 2020 2020 2072 6574 7572 6e0d 0a0d 0a20       return.... 
-00018420: 2020 2020 2020 2023 2072 656d 6f76 6520         # remove 
-00018430: 7468 6973 2063 616c 6c20 6166 7465 7220  this call after 
-00018440: 7468 6520 5365 7269 6573 2d58 5320 4152  the Series-XS AR
-00018450: 4d20 2f20 4650 4741 2077 6174 6368 646f  M / FPGA watchdo
-00018460: 6720 6172 6520 6669 7865 640d 0a20 2020  g are fixed..   
-00018470: 2020 2020 2023 204d 5a3a 2061 7265 2074       # MZ: are t
-00018480: 6865 7920 6669 7865 643f 2063 616e 2049  hey fixed? can I
-00018490: 2072 656d 6f76 6520 7468 6973 3f0d 0a20   remove this?.. 
-000184a0: 2020 2020 2020 2073 656c 662e 7365 745f         self.set_
-000184b0: 6c61 7365 725f 656e 6162 6c65 2846 616c  laser_enable(Fal
-000184c0: 7365 290d 0a0d 0a20 2020 2020 2020 2023  se)....        #
-000184d0: 2073 656e 6420 7661 6c75 6520 6173 2062   send value as b
-000184e0: 6967 2d65 6e64 6961 6e0d 0a20 2020 2020  ig-endian..     
-000184f0: 2020 206d 7362 203d 2028 7365 6320 3e3e     msb = (sec >>
-00018500: 2038 2920 2620 3078 6666 0d0a 2020 2020   8) & 0xff..    
-00018510: 2020 2020 6c73 6220 3d20 2073 6563 2020      lsb =  sec  
-00018520: 2020 2020 2026 2030 7866 660d 0a20 2020       & 0xff..   
-00018530: 2020 2020 2076 616c 7565 203d 2028 6d73       value = (ms
-00018540: 6220 3c3c 2038 2920 7c20 6c73 620d 0a0d  b << 8) | lsb...
-00018550: 0a20 2020 2020 2020 2073 656c 662e 7365  .        self.se
-00018560: 7474 696e 6773 2e73 7461 7465 2e6c 6173  ttings.state.las
-00018570: 6572 5f77 6174 6368 646f 675f 7365 6320  er_watchdog_sec 
-00018580: 3d20 7365 630d 0a20 2020 2020 2020 2072  = sec..        r
-00018590: 6574 7572 6e20 7365 6c66 2e5f 7365 6e64  eturn self._send
-000185a0: 5f63 6f64 6528 6252 6571 7565 7374 2020  _code(bRequest  
-000185b0: 2020 2020 2020 3d20 3078 6666 2c0d 0a20        = 0xff,.. 
-000185c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000185d0: 2020 2020 2020 2020 2020 2020 2077 5661               wVa
-000185e0: 6c75 6520 2020 2020 2020 2020 203d 2030  lue          = 0
-000185f0: 7831 382c 0d0a 2020 2020 2020 2020 2020  x18,..          
+00017c50: 2020 2062 5265 7175 6573 743d 3078 4442     bRequest=0xDB
+00017c60: 2c0a 2020 2020 2320 2020 2020 2020 2020  ,.    #         
+00017c70: 2020 2020 2020 2020 2020 2020 2077 5661               wVa
+00017c80: 6c75 653d 3130 302c 0a20 2020 2023 2020  lue=100,.    #  
+00017c90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017ca0: 2020 2020 7749 6e64 6578 3d30 2c0a 2020      wIndex=0,.  
+00017cb0: 2020 2320 2020 2020 2020 2020 2020 2020    #             
+00017cc0: 2020 2020 2020 2020 2064 6174 615f 6f72           data_or
+00017cd0: 5f77 4c65 6e67 7468 3d30 290a 2020 2020  _wLength=0).    
+00017ce0: 230a 2020 2020 2320 5468 6520 6c61 7365  #.    # The lase
+00017cf0: 7220 7075 6c73 6520 7065 7269 6f64 206d  r pulse period m
+00017d00: 7573 7420 6265 2073 6574 2077 6865 7265  ust be set where
+00017d10: 2074 6865 2077 5661 6c75 6520 616e 640a   the wValue and.
+00017d20: 2020 2020 2320 6461 7461 5f6f 725f 774c      # data_or_wL
+00017d30: 656e 6774 6820 7061 7261 6d65 7465 7273  ength parameters
+00017d40: 2061 7265 2065 7175 616c 2e20 536f 2069   are equal. So i
+00017d50: 6620 796f 7520 7761 6e74 6564 2061 2070  f you wanted a p
+00017d60: 756c 7365 0a20 2020 2023 2070 6572 696f  ulse.    # perio
+00017d70: 6420 6f66 2031 3030 2c20 796f 7520 6d75  d of 100, you mu
+00017d80: 7374 2073 7065 6369 6679 2074 6865 2076  st specify the v
+00017d90: 616c 7565 2069 6e20 626f 7468 2070 6c61  alue in both pla
+00017da0: 6365 733a 0a20 2020 2023 0a20 2020 2023  ces:.    #.    #
+00017db0: 202e 2e2e 0a20 2020 2023 2020 2020 2020   ....    #      
+00017dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017dd0: 7756 616c 7565 3d31 3030 2c0a 2020 2020  wValue=100,.    
+00017de0: 2320 2020 2020 2020 2020 2020 2020 2020  #               
+00017df0: 2020 2020 2020 2064 6174 615f 6f72 5f77         data_or_w
+00017e00: 4c65 6e67 7468 3d31 3030 290a 2020 2020  Length=100).    
+00017e10: 2320 2e2e 2e0a 2020 2020 230a 2020 2020  # ....    #.    
+00017e20: 2320 5468 6973 2069 6e20 7475 726e 2069  # This in turn i
+00017e30: 6d70 6c69 6573 2074 6861 7420 7468 6520  mplies that the 
+00017e40: 6c65 6761 6379 2066 6972 6d77 6172 6520  legacy firmware 
+00017e50: 6861 7320 6120 6c6f 6e67 206d 6173 6b65  has a long maske
+00017e60: 640a 2020 2020 2320 6973 7375 6520 7768  d.    # issue wh
+00017e70: 656e 2072 6561 6469 6e67 2074 6865 2076  en reading the v
+00017e80: 616c 7565 2074 6f20 7570 6461 7465 2066  alue to update f
+00017e90: 726f 6d20 7468 6520 6461 7461 5f6f 725f  rom the data_or_
+00017ea0: 774c 656e 6774 680a 2020 2020 2320 7061  wLength.    # pa
+00017eb0: 7261 6d65 7465 7220 696e 7374 6561 6420  rameter instead 
+00017ec0: 6f66 2074 6865 2077 5661 6c75 6520 6669  of the wValue fi
+00017ed0: 656c 642e 2054 6869 7320 6973 206f 6e6c  eld. This is onl
+00017ee0: 7920 6163 6375 7261 7465 2066 6f72 2074  y accurate for t
+00017ef0: 6865 0a20 2020 2023 206c 6173 6572 206d  he.    # laser m
+00017f00: 6f64 756c 6174 696f 6e20 7265 6c61 7465  odulation relate
+00017f10: 6420 6675 6e63 7469 6f6e 732e 0a20 2020  d functions..   
+00017f20: 2023 0a20 2020 2023 2054 6869 7320 6973   #.    # This is
+00017f30: 2062 6163 6b65 6420 7570 2062 7920 7468   backed up by th
+00017f40: 6520 4461 7368 2076 3320 5374 726f 6b65  e Dash v3 Stroke
+00017f50: 7243 6f6e 7472 6f6c 2044 4c4c 2069 6d70  rControl DLL imp
+00017f60: 6c65 6d65 6e74 6174 696f 6e2e 0a20 2020  lementation..   
+00017f70: 2023 2049 7420 7761 7320 6469 7363 6f76   # It was discov
+00017f80: 6572 6564 2074 6861 7420 7468 6520 5374  ered that the St
+00017f90: 726f 6b65 7243 6f6e 7472 6f6c 2044 4c4c  rokerControl DLL
+00017fa0: 2073 6574 7320 7468 6520 7756 616c 7565   sets the wValue
+00017fb0: 2061 6e64 0a20 2020 2023 2064 6174 6120   and.    # data 
+00017fc0: 6f72 2077 4c65 6e67 7468 2070 6172 616d  or wLength param
+00017fd0: 6574 6572 7320 746f 2074 6865 2073 616d  eters to the sam
+00017fe0: 6520 7661 6c75 6520 6174 2065 7665 7279  e value at every
+00017ff0: 2063 6f6e 7472 6f6c 0a20 2020 2023 206d   control.    # m
+00018000: 6573 7361 6765 2077 7269 7465 2e0a 2020  essage write..  
+00018010: 2020 230a 2020 2020 2320 5468 6520 6578    #.    # The ex
+00018020: 6369 7469 6e67 2074 616b 6561 7761 7920  citing takeaway 
+00018030: 6865 7265 2069 7320 7468 6174 2045 6e6c  here is that Enl
+00018040: 6967 6874 656e 2069 7320 7374 6162 6c65  ighten is stable
+00018050: 2065 6e6f 7567 682e 0a20 2020 2023 2054   enough..    # T
+00018060: 7572 6e69 6e67 2074 6865 206c 6173 6572  urning the laser
+00018070: 206f 6e20 7769 7468 2074 6865 2064 6174   on with the dat
+00018080: 6120 6f72 2077 4c65 6e67 7468 2070 6172  a or wLength par
+00018090: 616d 6574 6572 206e 6f74 2073 6574 0a20  ameter not set. 
+000180a0: 2020 2023 2063 6f72 7265 6374 6c79 2077     # correctly w
+000180b0: 696c 6c20 6361 7573 6520 6120 6861 7264  ill cause a hard
+000180c0: 7761 7265 2066 6169 6c75 7265 2061 6e64  ware failure and
+000180d0: 2063 6f6d 706c 6574 6520 6465 7669 6365   complete device
+000180e0: 206c 6f63 6b75 700a 2020 2020 2320 7265   lockup.    # re
+000180f0: 7175 6972 696e 6720 6120 706f 7765 7220  quiring a power 
+00018100: 6379 636c 652e 0a20 2020 2023 0a20 2020  cycle..    #.   
+00018110: 2023 2066 6964 3a0a 2020 2020 2320 2020   # fid:.    #   
+00018120: 2020 4352 4954 4943 414c 2048 6172 6477    CRITICAL Hardw
+00018130: 6172 6520 4661 696c 7572 6520 4649 4420  are Failure FID 
+00018140: 5365 6e64 2043 6f64 6520 5072 6f62 6c65  Send Code Proble
+00018150: 6d20 7769 7468 0a20 2020 2023 2020 2020  m with.    #    
+00018160: 2020 2020 2020 2020 2020 6374 726c 2074            ctrl t
+00018170: 7261 6e73 6665 723a 205b 4572 726e 6f20  ransfer: [Errno 
+00018180: 4e6f 6e65 5d20 3131 0a20 2020 2023 0a20  None] 11.    #. 
+00018190: 2020 2023 2055 6e6c 696b 6520 4461 7368     # Unlike Dash
+000181a0: 2077 6869 6368 206d 6179 206c 6f63 6b75   which may locku
+000181b0: 7020 616e 6420 7265 7175 6972 6520 6b69  p and require ki
+000181c0: 6c6c 696e 6720 7468 6520 6170 706c 6963  lling the applic
+000181d0: 6174 696f 6e2c 0a20 2020 2023 2045 6e6c  ation,.    # Enl
+000181e0: 6967 6874 656e 2064 6f65 7320 6e6f 7420  ighten does not 
+000181f0: 6c6f 636b 2075 702e 2054 6865 2045 6e6c  lock up. The Enl
+00018200: 6967 6874 656e 2063 6f64 6520 6261 7365  ighten code base
+00018210: 2068 6173 206e 6f77 2062 6565 6e0a 2020   has now been.  
+00018220: 2020 2320 7573 6564 2074 6f20 756e 6d61    # used to unma
+00018230: 736b 2061 6e20 6973 7375 6520 7468 6174  sk an issue that
+00018240: 2068 6173 2062 6565 6e20 6c75 726b 696e   has been lurkin
+00018250: 6720 7769 7468 206f 7572 206c 6567 6163  g with our legac
+00018260: 790a 2020 2020 2320 6669 726d 7761 7265  y.    # firmware
+00018270: 2066 6f72 2063 6c6f 7365 2074 6f20 3620   for close to 6 
+00018280: 7965 6172 732e 2057 6527 7665 2064 6574  years. We've det
+00018290: 6563 7465 6420 7468 6973 206f 7574 206f  ected this out o
+000182a0: 660a 2020 2020 2320 7370 6563 6966 6963  f.    # specific
+000182b0: 6174 696f 6e20 6172 6561 206f 6620 7468  ation area of th
+000182c0: 6520 636f 6465 2062 6566 6f72 6520 6974  e code before it
+000182d0: 2063 616e 2061 6476 6572 7365 6c79 2069   can adversely i
+000182e0: 6d70 6163 7420 610a 2020 2020 2320 6375  mpact a.    # cu
+000182f0: 7374 6f6d 6572 2e20 2222 220a 2020 2020  stomer. """.    
+00018300: 230a 2020 2020 2320 4173 206c 6f6e 6720  #.    # As long 
+00018310: 6173 206c 6173 6572 2070 6f77 6572 2069  as laser power i
+00018320: 7320 6d6f 6475 6c61 7465 6420 7573 696e  s modulated usin
+00018330: 6720 6120 7065 7269 6f64 206f 6620 3130  g a period of 10
+00018340: 3075 732c 0a20 2020 2023 2077 6974 6820  0us,.    # with 
+00018350: 6120 6e65 6365 7373 6172 696c 792d 696e  a necessarily-in
+00018360: 7465 6772 616c 2070 756c 7365 2077 6964  tegral pulse wid
+00018370: 7468 206f 6620 312d 3939 7573 2c20 7468  th of 1-99us, th
+00018380: 656e 2069 7427 730a 2020 2020 2320 6e6f  en it's.    # no
+00018390: 7420 7068 7973 6963 616c 6c79 2070 6f73  t physically pos
+000183a0: 7369 626c 6520 746f 2073 7570 706f 7274  sible to support
+000183b0: 2066 7261 6374 696f 6e61 6c20 706f 7765   fractional powe
+000183c0: 7220 6c65 7665 6c73 2e0a 2020 2020 230a  r levels..    #.
+000183d0: 2020 2020 2320 4074 6f64 6f20 7461 6c6b      # @todo talk
+000183e0: 2074 6f20 4a61 736f 6e20 6162 6f75 7420   to Jason about 
+000183f0: 6368 616e 6769 6e67 206d 6f64 756c 6174  changing modulat
+00018400: 696f 6e20 5045 5249 4f44 2074 6f20 6c6f  ion PERIOD to lo
+00018410: 6e67 6572 0a20 2020 2023 2020 2020 2076  nger.    #     v
+00018420: 616c 7565 2028 3230 3075 733f 2034 3030  alue (200us? 400
+00018430: 3f20 3130 3030 3f29 2c20 4f52 2077 6865  ? 1000?), OR whe
+00018440: 7468 6572 2070 756c 7365 2057 4944 5448  ther pulse WIDTH
+00018450: 2063 616e 2062 650a 2020 2020 2320 2020   can be.    #   
+00018460: 2020 696e 2073 6d61 6c6c 6572 2075 6e69    in smaller uni
+00018470: 7420 2835 3030 6e73 3f20 3130 306e 733f  t (500ns? 100ns?
+00018480: 290a 2020 2020 6465 6620 7365 745f 6c61  ).    def set_la
+00018490: 7365 725f 706f 7765 725f 7065 7263 5f69  ser_power_perc_i
+000184a0: 6d6d 6564 6961 7465 2873 656c 662c 2076  mmediate(self, v
+000184b0: 616c 7565 3a20 666c 6f61 7429 3a0a 0a20  alue: float):.. 
+000184c0: 2020 2020 2020 2023 206c 6173 6572 2063         # laser c
+000184d0: 616e 2066 6c69 636b 6572 2069 6620 7765  an flicker if we
+000184e0: 2772 6520 6f6e 2074 6865 2077 726f 6e67  're on the wrong
+000184f0: 2041 4443 3f0a 0a20 2020 2020 2020 2023   ADC?..        #
+00018500: 2064 6f6e 2774 2077 616e 7420 616e 7974   don't want anyt
+00018510: 6869 6e67 2077 6569 7264 2077 6865 6e20  hing weird when 
+00018520: 7061 7373 696e 6720 6f76 6572 2055 5342  passing over USB
+00018530: 0a20 2020 2020 2020 2076 616c 7565 203d  .        value =
+00018540: 2066 6c6f 6174 286d 6178 2830 2c20 6d69   float(max(0, mi
+00018550: 6e28 3130 302c 2076 616c 7565 2929 290a  n(100, value))).
+00018560: 0a20 2020 2020 2020 2023 2049 6620 6675  .        # If fu
+00018570: 6c6c 2070 6f77 6572 2028 616e 6420 616c  ll power (and al
+00018580: 6c6f 7765 6429 2c20 6469 7361 626c 6520  lowed), disable 
+00018590: 6d6f 6475 6c61 7469 6f6e 2061 6e64 2065  modulation and e
+000185a0: 7869 740a 2020 2020 2020 2020 6966 2076  xit.        if v
+000185b0: 616c 7565 203e 3d20 3130 303a 0a20 2020  alue >= 100:.   
+000185c0: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
+000185d0: 2e73 6574 7469 6e67 732e 7374 6174 652e  .settings.state.
+000185e0: 6c61 7365 725f 706f 7765 725f 7265 7175  laser_power_requ
+000185f0: 6972 655f 6d6f 6475 6c61 7469 6f6e 3a0a  ire_modulation:.
 00018600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018610: 2020 2020 7749 6e64 6578 2020 2020 2020      wIndex      
-00018620: 2020 2020 3d20 7661 6c75 652c 0d0a 2020      = value,..  
-00018630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018640: 2020 2020 2020 2020 2020 2020 6461 7461              data
-00018650: 5f6f 725f 774c 656e 6774 6820 3d20 5b30  _or_wLength = [0
-00018660: 5d20 2a20 382c 0d0a 2020 2020 2020 2020  ] * 8,..        
-00018670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018680: 2020 2020 2020 6c61 6265 6c20 2020 2020        label     
-00018690: 2020 2020 2020 3d20 2253 4554 5f4c 4153        = "SET_LAS
-000186a0: 4552 5f57 4154 4348 444f 475f 5345 4322  ER_WATCHDOG_SEC"
-000186b0: 290d 0a0d 0a20 2020 2064 6566 2075 7064  )....    def upd
-000186c0: 6174 655f 6c61 7365 725f 7761 7463 6864  ate_laser_watchd
-000186d0: 6f67 2873 656c 6629 3a20 2320 2d3e 2053  og(self): # -> S
-000186e0: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
-000186f0: 6e73 6520 0d0a 2020 2020 2020 2020 2222  nse ..        ""
-00018700: 220d 0a20 2020 2020 2020 2041 7574 6f6d  "..        Autom
-00018710: 6174 6963 616c 6c79 2073 6574 2074 6865  atically set the
-00018720: 206c 6173 6572 2077 6174 6368 646f 6720   laser watchdog 
-00018730: 6c6f 6e67 2065 6e6f 7567 6820 746f 2068  long enough to h
-00018740: 616e 646c 6520 7468 6520 6375 7272 656e  andle the curren
-00018750: 740d 0a20 2020 2020 2020 2069 6e74 6567  t..        integ
-00018760: 7261 7469 6f6e 2074 696d 652c 2061 7373  ration time, ass
-00018770: 756d 696e 6720 7765 2068 6176 6520 746f  uming we have to
-00018780: 2070 6572 666f 726d 2036 2074 6872 6f77   perform 6 throw
-00018790: 6177 6179 7320 6f6e 2074 6865 2073 656e  aways on the sen
-000187a0: 736f 720d 0a20 2020 2020 2020 2069 6e20  sor..        in 
-000187b0: 6361 7365 2069 7420 7765 6e74 2074 6f20  case it went to 
-000187c0: 736c 6565 702e 0d0a 0d0a 2020 2020 2020  sleep.....      
-000187d0: 2020 406e 6f74 6520 7765 2061 7265 206e    @note we are n
-000187e0: 6f74 2063 7572 7265 6e74 6c79 2075 7369  ot currently usi
-000187f0: 6e67 2074 6869 7320 6675 6e63 7469 6f6e  ng this function
-00018800: 0d0a 2020 2020 2020 2020 2222 220d 0a20  ..        """.. 
-00018810: 2020 2020 2020 2069 6620 6e6f 7420 7365         if not se
-00018820: 6c66 2e73 6574 7469 6e67 732e 6973 5f6d  lf.settings.is_m
-00018830: 6963 726f 2829 206f 7220 6e6f 7420 7365  icro() or not se
-00018840: 6c66 2e73 6574 7469 6e67 732e 6565 7072  lf.settings.eepr
-00018850: 6f6d 2e68 6173 5f6c 6173 6572 3a0d 0a20  om.has_laser:.. 
-00018860: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00018870: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
-00018880: 7370 6f6e 7365 2864 6174 613d 4661 6c73  sponse(data=Fals
-00018890: 652c 6572 726f 725f 6d73 673d 2275 7064  e,error_msg="upd
-000188a0: 6174 6520 6c61 7365 7220 7761 7463 6864  ate laser watchd
-000188b0: 6f67 206e 6f74 2073 7570 706f 7274 6564  og not supported
-000188c0: 2229 0d0a 0d0a 2020 2020 2020 2020 696e  ")....        in
-000188d0: 745f 6d73 203d 2073 656c 662e 7365 7474  t_ms = self.sett
-000188e0: 696e 6773 2e73 7461 7465 2e69 6e74 6567  ings.state.integ
-000188f0: 7261 7469 6f6e 5f74 696d 655f 6d73 0d0a  ration_time_ms..
-00018900: 2020 2020 2020 2020 7363 616e 7320 203d          scans  =
-00018910: 2073 656c 662e 7365 7474 696e 6773 2e73   self.settings.s
-00018920: 7461 7465 2e73 6361 6e73 5f74 6f5f 6176  tate.scans_to_av
-00018930: 6572 6167 650d 0a20 2020 2020 2020 200d  erage..        .
-00018940: 0a20 2020 2020 2020 2074 6872 6f77 6177  .        throwaw
-00018950: 6179 735f 7365 6320 3d20 696e 745f 6d73  ays_sec = int_ms
-00018960: 202a 2028 3820 2b20 7363 616e 7329 202f   * (8 + scans) /
-00018970: 2031 3030 302e 300d 0a20 2020 2020 2020   1000.0..       
-00018980: 2077 6174 6368 646f 675f 7365 6320 3d20   watchdog_sec = 
-00018990: 696e 7428 6d61 7828 3130 2c20 7468 726f  int(max(10, thro
-000189a0: 7761 7761 7973 5f73 6563 2929 202a 2032  waways_sec)) * 2
-000189b0: 0d0a 2020 2020 2020 2020 6c6f 672e 6465  ..        log.de
-000189c0: 6275 6728 6622 7570 6461 7469 6e67 206c  bug(f"updating l
-000189d0: 6173 6572 2077 6174 6368 646f 6720 746f  aser watchdog to
-000189e0: 207b 7761 7463 6864 6f67 5f73 6563 7d20   {watchdog_sec} 
-000189f0: 6261 7365 6420 6f6e 2069 6e74 6567 7261  based on integra
-00018a00: 7469 6f6e 2074 696d 6520 7b69 6e74 5f6d  tion time {int_m
-00018a10: 737d 6d73 2061 6e64 207b 7363 616e 737d  s}ms and {scans}
-00018a20: 2061 7665 7261 6769 6e67 2229 0d0a 0d0a   averaging")....
-00018a30: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00018a40: 656c 662e 7365 745f 6c61 7365 725f 7761  elf.set_laser_wa
-00018a50: 7463 6864 6f67 5f73 6563 2877 6174 6368  tchdog_sec(watch
-00018a60: 646f 675f 7365 6329 0d0a 0d0a 2020 2020  dog_sec)....    
-00018a70: 6465 6620 7365 745f 7665 7274 6963 616c  def set_vertical
-00018a80: 5f62 696e 6e69 6e67 2873 656c 662c 206c  _binning(self, l
-00018a90: 696e 6573 3a20 7475 706c 655b 696e 742c  ines: tuple[int,
-00018aa0: 2069 6e74 5d29 3a20 2320 2d3e 2053 7065   int]): # -> Spe
-00018ab0: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
-00018ac0: 6520 0d0a 2020 2020 2020 2020 2320 6368  e ..        # ch
-00018ad0: 6563 6b20 666f 7220 6c65 6761 6379 2076  eck for legacy v
-00018ae0: 6973 2073 696e 6365 2074 6865 7920 646f  is since they do
-00018af0: 6e27 7420 6c69 6b65 2076 6572 7469 6361  n't like vertica
-00018b00: 6c20 6269 6e6e 696e 670d 0a20 2020 2020  l binning..     
-00018b10: 2020 2069 6620 7365 6c66 2e73 6574 7469     if self.setti
-00018b20: 6e67 732e 6670 6761 5f66 6972 6d77 6172  ngs.fpga_firmwar
-00018b30: 655f 7665 7273 696f 6e20 3d3d 2022 3030  e_version == "00
-00018b40: 302d 3030 3822 2061 6e64 2073 656c 662e  0-008" and self.
-00018b50: 7365 7474 696e 6773 2e6d 6963 726f 636f  settings.microco
-00018b60: 6e74 726f 6c6c 6572 5f66 6972 6d77 6172  ntroller_firmwar
-00018b70: 655f 7665 7273 696f 6e20 3d3d 2022 302e  e_version == "0.
-00018b80: 312e 302e 3722 3a0d 0a20 2020 2020 2020  1.0.7":..       
-00018b90: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
-00018ba0: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
-00018bb0: 2864 6174 613d 4661 6c73 6529 0d0a 2020  (data=False)..  
-00018bc0: 2020 2020 2020 6966 206e 6f74 2073 656c        if not sel
-00018bd0: 662e 7365 7474 696e 6773 2e69 735f 6d69  f.settings.is_mi
-00018be0: 6372 6f28 293a 0d0a 2020 2020 2020 2020  cro():..        
-00018bf0: 2020 2020 6c6f 672e 6465 6275 6728 2256      log.debug("V
-00018c00: 6572 7469 6361 6c20 4269 6e6e 696e 6720  ertical Binning 
-00018c10: 6f6e 6c79 2063 6f6e 6669 6775 7261 626c  only configurabl
-00018c20: 6520 6f6e 2053 6572 6965 732d 5853 2229  e on Series-XS")
-00018c30: 0d0a 2020 2020 2020 2020 2020 2020 7265  ..            re
-00018c40: 7475 726e 2053 7065 6374 726f 6d65 7465  turn Spectromete
-00018c50: 7252 6573 706f 6e73 6528 6461 7461 3d46  rResponse(data=F
-00018c60: 616c 7365 2c65 7272 6f72 5f6d 7367 3d22  alse,error_msg="
-00018c70: 7665 7274 6963 616c 2062 696e 6e69 6e67  vertical binning
-00018c80: 206e 6f74 2073 7570 706f 7274 6564 2229   not supported")
-00018c90: 0d0a 0d0a 2020 2020 2020 2020 7472 793a  ....        try:
-00018ca0: 0d0a 2020 2020 2020 2020 2020 2020 7374  ..            st
-00018cb0: 6172 7420 3d20 6c69 6e65 735b 305d 0d0a  art = lines[0]..
-00018cc0: 2020 2020 2020 2020 2020 2020 656e 6420              end 
-00018cd0: 2020 3d20 6c69 6e65 735b 315d 0d0a 2020    = lines[1]..  
-00018ce0: 2020 2020 2020 6578 6365 7074 3a0d 0a20        except:.. 
-00018cf0: 2020 2020 2020 2020 2020 206c 6f67 2e65             log.e
-00018d00: 7272 6f72 2822 7365 745f 7665 7274 6963  rror("set_vertic
-00018d10: 616c 5f62 696e 6e69 6e67 2072 6571 7569  al_binning requi
-00018d20: 7265 7320 6120 7475 706c 6520 6f66 2028  res a tuple of (
-00018d30: 7374 6172 742c 2073 746f 7029 206c 696e  start, stop) lin
-00018d40: 6573 2229 0d0a 2020 2020 2020 2020 2020  es")..          
-00018d50: 2020 7265 7475 726e 2053 7065 6374 726f    return Spectro
-00018d60: 6d65 7465 7252 6573 706f 6e73 6528 6461  meterResponse(da
-00018d70: 7461 3d46 616c 7365 2c65 7272 6f72 5f6d  ta=False,error_m
-00018d80: 7367 3d22 696e 7661 6c69 6420 7374 6172  sg="invalid star
-00018d90: 7420 616e 6420 7374 6f70 206c 696e 6573  t and stop lines
-00018da0: 2229 0d0a 0d0a 2020 2020 2020 2020 6966  ")....        if
-00018db0: 2073 7461 7274 203c 2030 206f 7220 656e   start < 0 or en
-00018dc0: 6420 3c20 303a 0d0a 2020 2020 2020 2020  d < 0:..        
-00018dd0: 2020 2020 6c6f 672e 6572 726f 7228 2273      log.error("s
-00018de0: 6574 5f76 6572 7469 6361 6c5f 6269 6e6e  et_vertical_binn
-00018df0: 696e 6720 7265 7175 6972 6573 2061 2074  ing requires a t
-00018e00: 7570 6c65 206f 6620 504f 5349 5449 5645  uple of POSITIVE
-00018e10: 2028 7374 6172 742c 2073 746f 7029 206c   (start, stop) l
-00018e20: 696e 6573 2229 0d0a 2020 2020 2020 2020  ines")..        
-00018e30: 2020 2020 7265 7475 726e 2053 7065 6374      return Spect
-00018e40: 726f 6d65 7465 7252 6573 706f 6e73 6528  rometerResponse(
-00018e50: 6461 7461 3d46 616c 7365 2c65 7272 6f72  data=False,error
-00018e60: 5f6d 7367 3d22 696e 7661 6c69 6420 7374  _msg="invalid st
-00018e70: 6172 7420 616e 6420 7374 6f70 206c 696e  art and stop lin
-00018e80: 6573 2229 0d0a 0d0a 2020 2020 2020 2020  es")....        
-00018e90: 2320 656e 666f 7263 6520 6173 6365 6e64  # enforce ascend
-00018ea0: 696e 6720 6f72 6465 7220 2861 6c73 6f2c  ing order (also,
-00018eb0: 206e 6f74 6520 7468 6174 2073 746f 7020   note that stop 
-00018ec0: 6c69 6e65 2069 7320 226c 6173 7420 6c69  line is "last li
-00018ed0: 6e65 2062 696e 6e65 6420 2b20 3122 2c20  ne binned + 1", 
-00018ee0: 736f 2073 746f 7020 6d75 7374 2062 6520  so stop must be 
-00018ef0: 3e20 7374 6172 7429 0d0a 2020 2020 2020  > start)..      
-00018f00: 2020 6966 2073 7461 7274 203e 3d20 656e    if start >= en
-00018f10: 643a 0d0a 2020 2020 2020 2020 2020 2020  d:..            
-00018f20: 2320 2873 7461 7274 2c20 656e 6429 203d  # (start, end) =
-00018f30: 2028 656e 642c 2073 7461 7274 290d 0a20   (end, start).. 
-00018f40: 2020 2020 2020 2020 2020 206c 6f67 2e65             log.e
-00018f50: 7272 6f72 2822 7365 745f 7665 7274 6963  rror("set_vertic
-00018f60: 616c 5f62 696e 6e69 6e67 2072 6571 7569  al_binning requi
-00018f70: 7265 7320 6173 6365 6e64 696e 6720 6f72  res ascending or
-00018f80: 6465 7220 2869 676e 6f72 696e 6720 2564  der (ignoring %d
-00018f90: 2c20 2564 2922 2c20 7374 6172 742c 2065  , %d)", start, e
-00018fa0: 6e64 290d 0a20 2020 2020 2020 2020 2020  nd)..           
-00018fb0: 2072 6574 7572 6e20 5370 6563 7472 6f6d   return Spectrom
-00018fc0: 6574 6572 5265 7370 6f6e 7365 2864 6174  eterResponse(dat
-00018fd0: 613d 4661 6c73 652c 6572 726f 725f 6d73  a=False,error_ms
-00018fe0: 673d 2269 6e76 616c 6964 2073 7461 7274  g="invalid start
-00018ff0: 2061 6e64 2073 746f 7020 6c69 6e65 7322   and stop lines"
-00019000: 290d 0a0d 0a20 2020 2020 2020 206f 6b31  )....        ok1
-00019010: 203d 2073 656c 662e 5f73 656e 645f 636f   = self._send_co
-00019020: 6465 2862 5265 7175 6573 7420 2020 2020  de(bRequest     
-00019030: 2020 203d 2030 7866 662c 0d0a 2020 2020     = 0xff,..    
-00019040: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019050: 2020 2020 2020 2020 2077 5661 6c75 6520           wValue 
-00019060: 2020 2020 2020 2020 203d 2030 7832 312c           = 0x21,
-00019070: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00019080: 2020 2020 2020 2020 2020 2020 2020 2077                 w
-00019090: 496e 6465 7820 2020 2020 2020 2020 203d  Index          =
-000190a0: 2073 7461 7274 2c0d 0a20 2020 2020 2020   start,..       
-000190b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000190c0: 2020 2020 2020 6461 7461 5f6f 725f 774c        data_or_wL
-000190d0: 656e 6774 6820 3d20 5b30 5d20 2a20 382c  ength = [0] * 8,
-000190e0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000190f0: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-00019100: 6162 656c 2020 2020 2020 2020 2020 203d  abel           =
-00019110: 2022 5345 545f 4343 445f 5354 4152 545f   "SET_CCD_START_
-00019120: 4c49 4e45 2229 0d0a 2020 2020 2020 2020  LINE")..        
-00019130: 6966 206f 6b31 2e65 7272 6f72 5f6d 7367  if ok1.error_msg
-00019140: 2021 3d20 2727 3a0d 0a20 2020 2020 2020   != '':..       
-00019150: 2020 2020 2072 6574 7572 6e20 6f6b 310d       return ok1.
-00019160: 0a0d 0a20 2020 2020 2020 206f 6b32 203d  ...        ok2 =
-00019170: 2073 656c 662e 5f73 656e 645f 636f 6465   self._send_code
-00019180: 2862 5265 7175 6573 7420 2020 2020 2020  (bRequest       
-00019190: 203d 2030 7866 662c 0d0a 2020 2020 2020   = 0xff,..      
-000191a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000191b0: 2020 2020 2020 2077 5661 6c75 6520 2020         wValue   
-000191c0: 2020 2020 2020 203d 2030 7832 332c 0d0a         = 0x23,..
-000191d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000191e0: 2020 2020 2020 2020 2020 2020 2077 496e               wIn
-000191f0: 6465 7820 2020 2020 2020 2020 203d 2065  dex          = e
-00019200: 6e64 2c0d 0a20 2020 2020 2020 2020 2020  nd,..           
-00019210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019220: 2020 6461 7461 5f6f 725f 774c 656e 6774    data_or_wLengt
-00019230: 6820 3d20 5b30 5d20 2a20 382c 0d0a 2020  h = [0] * 8,..  
-00019240: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019250: 2020 2020 2020 2020 2020 206c 6162 656c             label
-00019260: 2020 2020 2020 2020 2020 203d 2022 5345             = "SE
-00019270: 545f 4343 445f 5354 4f50 5f4c 494e 4522  T_CCD_STOP_LINE"
-00019280: 290d 0a20 2020 2020 2020 2069 6620 6f6b  )..        if ok
-00019290: 322e 6572 726f 725f 6d73 6720 213d 2027  2.error_msg != '
-000192a0: 273a 0d0a 2020 2020 2020 2020 2020 2020  ':..            
-000192b0: 7265 7475 726e 206f 6b32 0d0a 2020 2020  return ok2..    
-000192c0: 2020 2020 7265 7475 726e 2053 7065 6374      return Spect
-000192d0: 726f 6d65 7465 7252 6573 706f 6e73 6528  rometerResponse(
-000192e0: 6461 7461 3d6f 6b31 2e64 6174 6120 616e  data=ok1.data an
-000192f0: 6420 6f6b 322e 6461 7461 290d 0a0d 0a20  d ok2.data).... 
-00019300: 2020 2023 2320 0d0a 2020 2020 2320 4070     ## ..    # @p
-00019310: 6172 616d 7320 6d6f 6465 3a20 696e 7465  arams mode: inte
-00019320: 6772 616c 2076 616c 7565 2030 2d33 0d0a  gral value 0-3..
-00019330: 2020 2020 230d 0a20 2020 2023 205c 7665      #..    # \ve
-00019340: 7262 6f73 650d 0a20 2020 2023 206d 6f64  rbose..    # mod
-00019350: 6520 2041 4443 2028 4144 2920 2020 5069  e  ADC (AD)   Pi
-00019360: 7865 6c20 5769 6474 6820 284f 4429 0d0a  xel Width (OD)..
-00019370: 2020 2020 2320 6230 3020 2020 3130 2d62      # b00   10-b
-00019380: 6974 2020 2020 2031 302d 6269 740d 0a20  it     10-bit.. 
-00019390: 2020 2023 2062 3031 2020 2031 302d 6269     # b01   10-bi
-000193a0: 7420 2020 2020 3132 2d62 6974 0d0a 2020  t     12-bit..  
-000193b0: 2020 2320 6231 3020 2020 3132 2d62 6974    # b10   12-bit
-000193c0: 2020 2020 2031 302d 6269 740d 0a20 2020       10-bit..   
-000193d0: 2023 2062 3131 2020 2031 322d 6269 7420   # b11   12-bit 
-000193e0: 2020 2020 3132 2d62 6974 0d0a 2020 2020      12-bit..    
-000193f0: 2320 5c65 6e64 7665 7262 6f73 650d 0a20  # \endverbose.. 
-00019400: 2020 2064 6566 2073 6574 5f70 6978 656c     def set_pixel
-00019410: 5f6d 6f64 6528 7365 6c66 2c20 6d6f 6465  _mode(self, mode
-00019420: 3a20 666c 6f61 7429 3a20 2320 2d3e 2053  : float): # -> S
-00019430: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
-00019440: 6e73 6520 0d0a 2020 2020 2020 2020 6966  nse ..        if
-00019450: 206e 6f74 2073 656c 662e 7365 7474 696e   not self.settin
-00019460: 6773 2e69 735f 6d69 6372 6f28 293a 0d0a  gs.is_micro():..
-00019470: 2020 2020 2020 2020 2020 2020 6c6f 672e              log.
-00019480: 6465 6275 6728 2250 6978 656c 204d 6f64  debug("Pixel Mod
-00019490: 6520 6f6e 6c79 2063 6f6e 6669 6775 7261  e only configura
-000194a0: 626c 6520 6f6e 2053 6572 6965 732d 5853  ble on Series-XS
-000194b0: 2229 0d0a 2020 2020 2020 2020 2020 2020  ")..            
-000194c0: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
-000194d0: 7465 7252 6573 706f 6e73 6528 6461 7461  terResponse(data
-000194e0: 3d46 616c 7365 2c65 7272 6f72 5f6d 7367  =False,error_msg
-000194f0: 3d22 7069 7865 6c20 6d6f 6465 206e 6f74  ="pixel mode not
-00019500: 2073 7570 706f 7274 6564 2229 0d0a 0d0a   supported")....
-00019510: 2020 2020 2020 2020 2320 7765 206f 6e6c          # we onl
-00019520: 7920 6361 7265 2061 626f 7574 2074 6865  y care about the
-00019530: 2074 776f 206c 6561 7374 2d73 6967 6e69   two least-signi
-00019540: 6669 6361 6e74 2062 6974 730d 0a20 2020  ficant bits..   
-00019550: 2020 2020 206d 6f64 6520 3d20 696e 7428       mode = int(
-00019560: 726f 756e 6428 6d6f 6465 2929 2026 2030  round(mode)) & 0
-00019570: 7833 200d 0a0d 0a20 2020 2020 2020 2072  x3 ....        r
-00019580: 6573 756c 7420 3d20 7365 6c66 2e5f 7365  esult = self._se
-00019590: 6e64 5f63 6f64 6528 6252 6571 7565 7374  nd_code(bRequest
-000195a0: 203d 2030 7866 642c 0d0a 2020 2020 2020   = 0xfd,..      
-000195b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000195c0: 2020 2020 2020 2020 2020 7756 616c 7565            wValue
-000195d0: 2020 203d 206d 6f64 652c 0d0a 2020 2020     = mode,..    
-000195e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000195f0: 2020 2020 2020 2020 2020 2020 6c61 6265              labe
-00019600: 6c20 2020 203d 2022 5345 545f 5049 5845  l    = "SET_PIXE
-00019610: 4c5f 4d4f 4445 2229 0d0a 0d0a 2020 2020  L_MODE")....    
-00019620: 2020 2020 6c6f 672e 6465 6275 6728 2277      log.debug("w
-00019630: 6169 7469 6e67 2031 7365 632e 2e2e 2229  aiting 1sec...")
-00019640: 0d0a 2020 2020 2020 2020 736c 6565 7028  ..        sleep(
-00019650: 3129 0d0a 0d0a 2020 2020 2020 2020 7265  1)....        re
-00019660: 7475 726e 2072 6573 756c 740d 0a0d 0a20  turn result.... 
-00019670: 2020 2064 6566 2063 6c65 6172 5f72 6567     def clear_reg
-00019680: 696f 6e73 2873 656c 6629 3a20 2320 2d3e  ions(self): # ->
-00019690: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
-000196a0: 706f 6e73 6520 0d0a 2020 2020 2020 2020  ponse ..        
-000196b0: 7831 203d 2073 656c 662e 7365 7474 696e  x1 = self.settin
-000196c0: 6773 2e65 6570 726f 6d2e 6163 7469 7665  gs.eeprom.active
-000196d0: 5f70 6978 656c 735f 686f 7269 7a6f 6e74  _pixels_horizont
-000196e0: 616c 0d0a 2020 2020 2020 2020 7931 203d  al..        y1 =
-000196f0: 2073 656c 662e 7365 7474 696e 6773 2e65   self.settings.e
-00019700: 6570 726f 6d2e 6163 7469 7665 5f70 6978  eprom.active_pix
-00019710: 656c 735f 7665 7274 6963 616c 0d0a 2020  els_vertical..  
-00019720: 2020 2020 2020 6c6f 672e 6465 6275 6728        log.debug(
-00019730: 6622 7265 7365 7474 696e 6773 2064 6574  f"resettings det
-00019740: 6563 746f 7220 746f 2066 756c 6c20 287b  ector to full ({
-00019750: 7831 7d2c 207b 7931 7d29 2065 7874 656e  x1}, {y1}) exten
-00019760: 7422 290d 0a0d 0a20 2020 2020 2020 2073  t")....        s
-00019770: 656c 662e 7365 7474 696e 6773 2e73 7461  elf.settings.sta
-00019780: 7465 2e72 6567 696f 6e20 3d20 4e6f 6e65  te.region = None
-00019790: 0d0a 2020 2020 2020 2020 7365 6c66 2e73  ..        self.s
-000197a0: 6574 7469 6e67 732e 7570 6461 7465 5f77  ettings.update_w
-000197b0: 6176 6563 616c 2829 0d0a 0d0a 2020 2020  avecal()....    
-000197c0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-000197d0: 7365 745f 6465 7465 6374 6f72 5f72 6f69  set_detector_roi
-000197e0: 285b 302c 2030 2c20 7931 2c20 302c 2078  ([0, 0, y1, 0, x
-000197f0: 315d 2c20 7374 6f72 653d 4661 6c73 6529  1], store=False)
-00019800: 0d0a 0d0a 2020 2020 6465 6620 7365 745f  ....    def set_
-00019810: 7369 6e67 6c65 5f72 6567 696f 6e28 7365  single_region(se
-00019820: 6c66 2c20 6e3a 2069 6e74 293a 2023 202d  lf, n: int): # -
-00019830: 3e20 5370 6563 7472 6f6d 6574 6572 5265  > SpectrometerRe
-00019840: 7370 6f6e 7365 200d 0a20 2020 2020 2020  sponse ..       
-00019850: 2022 2222 0d0a 2020 2020 2020 2020 5468   """..        Th
-00019860: 6973 2066 756e 6374 696f 6e20 7573 6573  is function uses
-00019870: 2074 6865 2074 6865 206d 756c 7469 2d72   the the multi-r
-00019880: 6567 696f 6e20 6665 6174 7572 6520 746f  egion feature to
-00019890: 2073 656c 6563 7420 6a75 7374 2061 2073   select just a s
-000198a0: 696e 676c 6520 0d0a 2020 2020 2020 2020  ingle ..        
-000198b0: 7072 652d 636f 6e66 6967 7572 6564 2072  pre-configured r
-000198c0: 6567 696f 6e20 6174 2061 2074 696d 652e  egion at a time.
-000198d0: 2020 5768 6963 6865 7665 7220 7265 6769    Whichever regi
-000198e0: 6f6e 2069 7320 7365 6c65 6374 6564 2c20  on is selected, 
-000198f0: 7468 6174 200d 0a20 2020 2020 2020 2072  that ..        r
-00019900: 6567 696f 6e27 7320 7061 7261 6d65 7465  egion's paramete
-00019910: 7273 2061 7265 2077 7269 7474 656e 2074  rs are written t
-00019920: 6f20 2272 6567 696f 6e20 3022 206f 6620  o "region 0" of 
-00019930: 7468 6520 7370 6563 7472 6f6d 6574 6572  the spectrometer
-00019940: 2c20 616e 640d 0a20 2020 2020 2020 2074  , and..        t
-00019950: 6865 2067 6c6f 6261 6c20 7761 7665 6361  he global waveca
-00019960: 6c20 6973 2075 7064 6174 6564 2074 6f20  l is updated to 
-00019970: 7573 6520 7468 6174 2072 6567 696f 6e27  use that region'
-00019980: 7320 6361 6c69 6272 6174 696f 6e2e 0d0a  s calibration...
-00019990: 2020 2020 2020 200d 0a20 2020 2020 2020         ..       
-000199a0: 2040 746f 646f 2063 6f6e 7369 6465 7220   @todo consider 
-000199b0: 636c 6561 725f 7265 6769 6f6e 2829 2066  clear_region() f
-000199c0: 756e 6374 696f 6e20 746f 2072 6573 746f  unction to resto
-000199d0: 7265 2070 6879 7369 6361 6c20 524f 4920  re physical ROI 
-000199e0: 746f 200d 0a20 2020 2020 2020 2020 2020  to ..           
-000199f0: 2028 302c 2061 6374 6976 655f 7665 7274   (0, active_vert
-00019a00: 6963 616c 5f70 6978 656c 732c 2030 2c20  ical_pixels, 0, 
-00019a10: 6163 7469 7665 5f68 6f72 697a 6f6e 7461  active_horizonta
-00019a20: 6c5f 7069 7865 6c73 290d 0a20 2020 2020  l_pixels)..     
-00019a30: 2020 2020 2020 2028 6c65 6176 6520 7761         (leave wa
-00019a40: 7665 6361 6c20 616c 6f6e 653f 290d 0a20  vecal alone?).. 
-00019a50: 2020 2020 2020 2022 2222 0d0a 2020 2020         """..    
-00019a60: 2020 2020 6966 2073 656c 662e 7365 7474      if self.sett
-00019a70: 696e 6773 2e73 7461 7465 2e64 6574 6563  ings.state.detec
-00019a80: 746f 725f 7265 6769 6f6e 7320 6973 204e  tor_regions is N
-00019a90: 6f6e 653a 0d0a 2020 2020 2020 2020 2020  one:..          
-00019aa0: 2020 6c6f 672e 6465 6275 6728 6622 6e6f    log.debug(f"no
-00019ab0: 2064 6574 6563 746f 7220 7265 6769 6f6e   detector region
-00019ac0: 7320 636f 6e66 6967 7572 6564 2229 0d0a  s configured")..
-00019ad0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00019ae0: 726e 2053 7065 6374 726f 6d65 7465 7252  rn SpectrometerR
-00019af0: 6573 706f 6e73 6528 6461 7461 3d46 616c  esponse(data=Fal
-00019b00: 7365 2c65 7272 6f72 5f6d 7367 3d22 6e6f  se,error_msg="no
-00019b10: 2072 6567 696f 6e73 2063 6f6e 6669 6775   regions configu
-00019b20: 7265 6422 290d 0a0d 0a20 2020 2020 2020  red")....       
-00019b30: 2072 6f69 203d 2073 656c 662e 7365 7474   roi = self.sett
-00019b40: 696e 6773 2e73 7461 7465 2e64 6574 6563  ings.state.detec
-00019b50: 746f 725f 7265 6769 6f6e 732e 6765 745f  tor_regions.get_
-00019b60: 726f 6928 6e29 0d0a 2020 2020 2020 2020  roi(n)..        
-00019b70: 6966 2072 6f69 2069 7320 4e6f 6e65 3a0d  if roi is None:.
-00019b80: 0a20 2020 2020 2020 2020 2020 206c 6f67  .            log
-00019b90: 2e64 6562 7567 2866 2275 6e63 6f6e 6669  .debug(f"unconfi
-00019ba0: 6775 7265 6420 7265 6769 6f6e 207b 6e7d  gured region {n}
-00019bb0: 2028 6d61 7820 7b73 656c 662e 7365 7474   (max {self.sett
-00019bc0: 696e 6773 2e65 6570 726f 6d2e 7265 6769  ings.eeprom.regi
-00019bd0: 6f6e 5f63 6f75 6e74 7d22 290d 0a20 2020  on_count}")..   
-00019be0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00019bf0: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
-00019c00: 6f6e 7365 2864 6174 613d 4661 6c73 652c  onse(data=False,
-00019c10: 6572 726f 725f 6d73 673d 2275 6e63 6f6e  error_msg="uncon
-00019c20: 6669 6775 7265 6420 7265 6769 6f6e 2229  figured region")
-00019c30: 0d0a 0d0a 2020 2020 2020 2020 6c6f 672e  ....        log.
-00019c40: 6465 6275 6728 6622 7365 745f 7369 6e67  debug(f"set_sing
-00019c50: 6c65 5f72 6567 696f 6e3a 2061 7070 6c79  le_region: apply
-00019c60: 696e 6720 7265 6769 6f6e 207b 6e7d 3a20  ing region {n}: 
-00019c70: 7b72 6f69 7d22 290d 0a20 2020 2020 2020  {roi}")..       
-00019c80: 2073 656c 662e 7365 7474 696e 6773 2e73   self.settings.s
-00019c90: 6574 5f73 696e 676c 655f 7265 6769 6f6e  et_single_region
-00019ca0: 286e 290d 0a0d 0a20 2020 2020 2020 2023  (n)....        #
-00019cb0: 2073 656e 6420 6120 2266 616b 6522 2052   send a "fake" R
-00019cc0: 4f49 2064 6f77 6e73 7472 6561 6d2c 206f  OI downstream, o
-00019cd0: 7665 7272 6964 696e 6720 746f 2070 6f73  verriding to pos
-00019ce0: 6974 696f 6e20 300d 0a20 2020 2020 2020  ition 0..       
-00019cf0: 2073 656c 662e 7365 745f 6465 7465 6374   self.set_detect
-00019d00: 6f72 5f72 6f69 285b 302c 2072 6f69 2e79  or_roi([0, roi.y
-00019d10: 302c 2072 6f69 2e79 312c 2072 6f69 2e78  0, roi.y1, roi.x
-00019d20: 302c 2072 6f69 2e78 315d 2c20 7374 6f72  0, roi.x1], stor
-00019d30: 653d 4661 6c73 6529 0d0a 2020 2020 2020  e=False)..      
-00019d40: 2020 7265 7475 726e 2053 7053 7065 6374    return SpSpect
-00019d50: 726f 6d65 7465 7252 6573 706f 6e73 6528  rometerResponse(
-00019d60: 290d 0a0d 0a20 2020 2064 6566 2073 6574  )....    def set
-00019d70: 5f64 6574 6563 746f 725f 726f 6928 7365  _detector_roi(se
-00019d80: 6c66 2c20 6172 6773 3a20 6c69 7374 5b66  lf, args: list[f
-00019d90: 6c6f 6174 5d2c 2073 746f 7265 3a20 626f  loat], store: bo
-00019da0: 6f6c 203d 2054 7275 6529 3a20 2320 2d3e  ol = True): # ->
-00019db0: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
-00019dc0: 706f 6e73 6520 0d0a 2020 2020 2020 2020  ponse ..        
-00019dd0: 2222 220d 0a20 2020 2020 2020 204e 6f74  """..        Not
-00019de0: 6520 7468 6973 206f 6e6c 7920 7365 6e64  e this only send
-00019df0: 7320 7468 6520 524f 4920 646f 776e 7374  s the ROI downst
-00019e00: 7265 616d 2074 6f20 7468 6520 7370 6563  ream to the spec
-00019e10: 7472 6f6d 6574 6572 2028 616e 6420 7374  trometer (and st
-00019e20: 6f72 6573 0d0a 2020 2020 2020 2020 6974  ores..        it
-00019e30: 2069 6e20 4465 7465 6374 6f72 5265 6769   in DetectorRegi
-00019e40: 6f6e 7329 2e20 2049 6620 796f 7520 7761  ons).  If you wa
-00019e50: 6e74 2074 6f20 7570 6461 7465 2074 6865  nt to update the
-00019e60: 2077 6176 6563 616c 2061 6e64 2073 746f   wavecal and sto
-00019e70: 7265 0d0a 2020 2020 2020 2020 7468 6520  re..        the 
-00019e80: 2273 656c 6563 7465 6422 2072 6567 696f  "selected" regio
-00019e90: 6e20 696e 6465 782c 2075 7365 2073 6574  n index, use set
-00019ea0: 5f72 6567 696f 6e28 2920 696e 7374 6561  _region() instea
-00019eb0: 6420 2877 6869 6368 2063 616c 6c73 2074  d (which calls t
-00019ec0: 6869 7329 2e0d 0a20 2020 2020 2020 200d  his)...        .
-00019ed0: 0a20 2020 2020 2020 2059 6f75 2073 686f  .        You sho
-00019ee0: 756c 6420 7573 6520 7365 745f 7265 6769  uld use set_regi
-00019ef0: 6f6e 2829 2069 6620 796f 7520 6172 6520  on() if you are 
-00019f00: 7365 6c65 6374 696e 6720 6f6e 6520 6f66  selecting one of
-00019f10: 2074 6865 2073 7461 6e64 6172 640d 0a20   the standard.. 
-00019f20: 2020 2020 2020 2072 6567 696f 6e73 2061         regions a
-00019f30: 6c72 6561 6479 2063 6f6e 6669 6775 7265  lready configure
-00019f40: 6420 6f6e 2074 6865 2045 4550 524f 4d2e  d on the EEPROM.
-00019f50: 2020 596f 7520 7368 6f75 6c64 2075 7365    You should use
-00019f60: 2073 6574 5f64 6574 6563 746f 725f 726f   set_detector_ro
-00019f70: 6928 290d 0a20 2020 2020 2020 2069 6620  i()..        if 
-00019f80: 796f 7527 7265 206d 616b 696e 6720 6164  you're making ad
-00019f90: 2d68 6f63 2052 4f49 7320 7768 6963 6820  -hoc ROIs which 
-00019fa0: 6172 656e 2774 2063 6f6e 6669 6775 7265  aren't configure
-00019fb0: 6420 6f6e 2074 6865 2045 4550 524f 4d2e  d on the EEPROM.
-00019fc0: 0d0a 2020 2020 2020 2020 0d0a 2020 2020  ..        ..    
-00019fd0: 2020 2020 4070 6172 616d 2061 7267 733a      @param args:
-00019fe0: 2065 6974 6865 7220 6120 4465 7465 6374   either a Detect
-00019ff0: 6f72 524f 4920 6f72 2061 2074 7570 6c65  orROI or a tuple
-0001a000: 206f 6620 2872 6567 696f 6e2c 2079 302c   of (region, y0,
-0001a010: 2079 312c 2078 302c 2078 3129 0d0a 2020   y1, x0, x1)..  
-0001a020: 2020 2020 2020 2222 220d 0a20 2020 2020        """..     
-0001a030: 2020 2069 6620 6e6f 7420 7365 6c66 2e73     if not self.s
-0001a040: 6574 7469 6e67 732e 6973 5f6d 6963 726f  ettings.is_micro
-0001a050: 2829 3a0d 0a20 2020 2020 2020 2020 2020  ():..           
-0001a060: 206c 6f67 2e64 6562 7567 2822 4465 7465   log.debug("Dete
-0001a070: 6374 6f72 2052 4f49 206f 6e6c 7920 636f  ctor ROI only co
-0001a080: 6e66 6967 7572 6162 6c65 206f 6e20 5365  nfigurable on Se
-0001a090: 7269 6573 2d58 5322 290d 0a20 2020 2020  ries-XS")..     
-0001a0a0: 2020 2020 2020 2072 6574 7572 6e20 5370         return Sp
-0001a0b0: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-0001a0c0: 7365 2864 6174 613d 4661 6c73 652c 6572  se(data=False,er
-0001a0d0: 726f 725f 6d73 673d 2244 6574 6563 746f  ror_msg="Detecto
-0001a0e0: 7220 524f 4920 6e6f 7420 636f 6e66 6967  r ROI not config
-0001a0f0: 7572 6162 6c65 2229 0d0a 0d0a 2020 2020  urable")....    
-0001a100: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
-0001a110: 6528 6172 6773 2c20 4465 7465 6374 6f72  e(args, Detector
-0001a120: 524f 4929 3a0d 0a20 2020 2020 2020 2020  ROI):..         
-0001a130: 2020 2072 6f69 203d 2061 7267 730d 0a20     roi = args.. 
-0001a140: 2020 2020 2020 2020 2020 206c 6f67 2e64             log.d
-0001a150: 6562 7567 2866 2270 6173 7365 6420 4465  ebug(f"passed De
-0001a160: 7465 6374 6f72 524f 493a 207b 726f 697d  tectorROI: {roi}
-0001a170: 2229 0d0a 2020 2020 2020 2020 656c 7365  ")..        else
-0001a180: 3a0d 0a20 2020 2020 2020 2020 2020 2023  :..            #
-0001a190: 2063 6f6e 7665 7274 2061 7267 7320 746f   convert args to
-0001a1a0: 2052 4f49 0d0a 2020 2020 2020 2020 2020   ROI..          
-0001a1b0: 2020 6c6f 672e 6465 6275 6728 6622 6372    log.debug(f"cr
-0001a1c0: 6561 7469 6e67 2044 6574 6563 746f 7252  eating DetectorR
-0001a1d0: 4f49 2066 726f 6d20 6172 6773 3a20 7b61  OI from args: {a
-0001a1e0: 7267 737d 2229 0d0a 0d0a 2020 2020 2020  rgs}")....      
-0001a1f0: 2020 2020 2020 6966 206c 656e 2861 7267        if len(arg
-0001a200: 7329 2021 3d20 353a 0d0a 2020 2020 2020  s) != 5:..      
-0001a210: 2020 2020 2020 2020 2020 6c6f 672e 6572            log.er
-0001a220: 726f 7228 6622 696e 7661 6c69 6420 6465  ror(f"invalid de
-0001a230: 7465 6374 6f72 2072 6f69 2061 7267 733a  tector roi args:
-0001a240: 207b 6172 6773 7d22 290d 0a20 2020 2020   {args}")..     
-0001a250: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-0001a260: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
-0001a270: 7370 6f6e 7365 2864 6174 613d 4661 6c73  sponse(data=Fals
-0001a280: 652c 6572 726f 725f 6d73 673d 2269 6e76  e,error_msg="inv
-0001a290: 616c 6964 2072 6f69 2061 7267 7322 290d  alid roi args").
-0001a2a0: 0a0d 0a20 2020 2020 2020 2020 2020 2072  ...            r
-0001a2b0: 6567 696f 6e20 3d20 696e 7428 726f 756e  egion = int(roun
-0001a2c0: 6428 6172 6773 5b30 5d29 290d 0a20 2020  d(args[0]))..   
-0001a2d0: 2020 2020 2020 2020 2079 3020 2020 2020           y0     
-0001a2e0: 3d20 696e 7428 726f 756e 6428 6172 6773  = int(round(args
-0001a2f0: 5b31 5d29 290d 0a20 2020 2020 2020 2020  [1]))..         
-0001a300: 2020 2079 3120 2020 2020 3d20 696e 7428     y1     = int(
-0001a310: 726f 756e 6428 6172 6773 5b32 5d29 290d  round(args[2])).
-0001a320: 0a20 2020 2020 2020 2020 2020 2078 3020  .            x0 
-0001a330: 2020 2020 3d20 696e 7428 726f 756e 6428      = int(round(
-0001a340: 6172 6773 5b33 5d29 290d 0a20 2020 2020  args[3]))..     
-0001a350: 2020 2020 2020 2078 3120 2020 2020 3d20         x1     = 
-0001a360: 696e 7428 726f 756e 6428 6172 6773 5b34  int(round(args[4
-0001a370: 5d29 290d 0a0d 0a20 2020 2020 2020 2020  ]))....         
-0001a380: 2020 2069 6620 6e6f 7420 2830 203c 3d20     if not (0 <= 
-0001a390: 7265 6769 6f6e 203c 3d20 3320 616e 6420  region <= 3 and 
-0001a3a0: 5c0d 0a20 2020 2020 2020 2020 2020 2020  \..             
-0001a3b0: 2020 2020 2020 2079 3020 3c20 7931 2061         y0 < y1 a
-0001a3c0: 6e64 205c 0d0a 2020 2020 2020 2020 2020  nd \..          
-0001a3d0: 2020 2020 2020 2020 2020 7830 203c 2078            x0 < x
-0001a3e0: 3120 616e 6420 5c0d 0a20 2020 2020 2020  1 and \..       
-0001a3f0: 2020 2020 2020 2020 2020 2020 2079 3020               y0 
-0001a400: 3e3d 2030 2061 6e64 205c 0d0a 2020 2020  >= 0 and \..    
-0001a410: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a420: 7830 203e 3d20 3020 616e 6420 5c0d 0a20  x0 >= 0 and \.. 
-0001a430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a440: 2020 2079 3120 3c3d 2073 656c 662e 7365     y1 <= self.se
-0001a450: 7474 696e 6773 2e65 6570 726f 6d2e 6163  ttings.eeprom.ac
-0001a460: 7469 7665 5f70 6978 656c 735f 686f 7269  tive_pixels_hori
-0001a470: 7a6f 6e74 616c 2061 6e64 205c 0d0a 2020  zontal and \..  
-0001a480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a490: 2020 7831 203c 3d20 7365 6c66 2e73 6574    x1 <= self.set
-0001a4a0: 7469 6e67 732e 6565 7072 6f6d 2e61 6374  tings.eeprom.act
-0001a4b0: 6976 655f 7069 7865 6c73 5f68 6f72 697a  ive_pixels_horiz
-0001a4c0: 6f6e 7461 6c29 3a0d 0a20 2020 2020 2020  ontal):..       
-0001a4d0: 2020 2020 2020 2020 206c 6f67 2e65 7272           log.err
-0001a4e0: 6f72 2866 2269 6e76 616c 6964 2064 6574  or(f"invalid det
-0001a4f0: 6563 746f 7220 726f 693a 207b 6172 6773  ector roi: {args
-0001a500: 7d22 290d 0a20 2020 2020 2020 2020 2020  }")..           
-0001a510: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
-0001a520: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
-0001a530: 2864 6174 613d 4661 6c73 652c 6572 726f  (data=False,erro
-0001a540: 725f 6d73 673d 2269 6e76 616c 6964 2072  r_msg="invalid r
-0001a550: 6f69 2061 7267 7322 290d 0a20 2020 2020  oi args")..     
-0001a560: 2020 2020 2020 2072 6f69 203d 2044 6574         roi = Det
-0001a570: 6563 746f 7252 4f49 2872 6567 696f 6e2c  ectorROI(region,
-0001a580: 2079 302c 2079 312c 2078 302c 2078 3129   y0, y1, x0, x1)
-0001a590: 0d0a 2020 2020 2020 2020 2020 2020 6c6f  ..            lo
-0001a5a0: 672e 6465 6275 6728 6622 6372 6561 7465  g.debug(f"create
-0001a5b0: 6420 4465 7465 6374 6f72 524f 493a 207b  d DetectorROI: {
-0001a5c0: 726f 697d 2229 0d0a 0d0a 2020 2020 2020  roi}")....      
-0001a5d0: 2020 2320 6465 7465 726d 696e 6520 7072    # determine pr
-0001a5e0: 6576 696f 7573 2074 6f74 616c 2070 6978  evious total pix
-0001a5f0: 656c 730d 0a20 2020 2020 2020 2073 656c  els..        sel
-0001a600: 662e 7072 6576 5f70 6978 656c 7320 3d20  f.prev_pixels = 
-0001a610: 7365 6c66 2e73 6574 7469 6e67 732e 7069  self.settings.pi
-0001a620: 7865 6c73 2829 0d0a 2020 2020 2020 2020  xels()..        
-0001a630: 6c6f 672e 6465 6275 6728 6622 7072 6576  log.debug(f"prev
-0001a640: 5f70 6978 656c 7320 3d20 7b73 656c 662e  _pixels = {self.
-0001a650: 7072 6576 5f70 6978 656c 737d 2229 0d0a  prev_pixels}")..
-0001a660: 0d0a 2020 2020 2020 2020 6966 2073 746f  ..        if sto
-0001a670: 7265 3a0d 0a20 2020 2020 2020 2020 2020  re:..           
-0001a680: 2069 6620 7365 6c66 2e73 6574 7469 6e67   if self.setting
-0001a690: 732e 7374 6174 652e 6465 7465 6374 6f72  s.state.detector
-0001a6a0: 5f72 6567 696f 6e73 2069 7320 4e6f 6e65  _regions is None
-0001a6b0: 3a0d 0a20 2020 2020 2020 2020 2020 2020  :..             
-0001a6c0: 2020 206c 6f67 2e64 6562 7567 2822 6372     log.debug("cr
-0001a6d0: 6561 7469 6e67 2044 6574 6563 746f 7252  eating DetectorR
-0001a6e0: 6567 696f 6e73 2229 0d0a 2020 2020 2020  egions")..      
-0001a6f0: 2020 2020 2020 2020 2020 7365 6c66 2e73            self.s
-0001a700: 6574 7469 6e67 732e 7374 6174 652e 6465  ettings.state.de
-0001a710: 7465 6374 6f72 5f72 6567 696f 6e73 203d  tector_regions =
-0001a720: 2044 6574 6563 746f 7252 6567 696f 6e73   DetectorRegions
-0001a730: 2829 0d0a 0d0a 2020 2020 2020 2020 2020  ()....          
-0001a740: 2020 2320 7468 6973 2069 7320 6120 6e6f    # this is a no
-0001a750: 2d6f 7020 6966 2069 7427 7320 616c 7265  -op if it's alre
-0001a760: 6164 7920 7072 6573 656e 7420 616e 6420  ady present and 
-0001a770: 756e 6368 616e 6765 640d 0a20 2020 2020  unchanged..     
-0001a780: 2020 2020 2020 206c 6f67 2e64 6562 7567         log.debug
-0001a790: 2822 7361 7669 6e67 2044 6574 6563 746f  ("saving Detecto
-0001a7a0: 7252 4f49 2069 6e20 4465 7465 6374 6f72  rROI in Detector
-0001a7b0: 5265 6769 6f6e 7322 290d 0a20 2020 2020  Regions")..     
-0001a7c0: 2020 2020 2020 2073 656c 662e 7365 7474         self.sett
-0001a7d0: 696e 6773 2e73 7461 7465 2e64 6574 6563  ings.state.detec
-0001a7e0: 746f 725f 7265 6769 6f6e 732e 6164 6428  tor_regions.add(
-0001a7f0: 726f 6929 0d0a 0d0a 2020 2020 2020 2020  roi)....        
-0001a800: 6c6f 672e 6465 6275 6728 6622 746f 7461  log.debug(f"tota
-0001a810: 6c5f 7069 7865 6c73 206e 6f77 207b 7365  l_pixels now {se
-0001a820: 6c66 2e73 6574 7469 6e67 732e 7069 7865  lf.settings.pixe
-0001a830: 6c73 2829 7d22 290d 0a0d 0a20 2020 2020  ls()}")....     
-0001a840: 2020 2062 7566 203d 2075 7469 6c73 2e75     buf = utils.u
-0001a850: 696e 7431 365f 746f 5f6c 6974 746c 655f  int16_to_little_
-0001a860: 656e 6469 616e 285b 2072 6f69 2e79 302c  endian([ roi.y0,
-0001a870: 2072 6f69 2e79 312c 2072 6f69 2e78 302c   roi.y1, roi.x0,
-0001a880: 2072 6f69 2e78 3120 5d29 0d0a 2020 2020   roi.x1 ])..    
-0001a890: 2020 2020 6c6f 672e 6465 6275 6728 2277      log.debug("w
-0001a8a0: 6f75 6c64 2073 656e 6420 6275 663a 2025  ould send buf: %
-0001a8b0: 7322 2c20 6275 6629 0d0a 0d0a 2020 2020  s", buf)....    
-0001a8c0: 2020 2020 7265 7375 6c74 203d 2073 656c      result = sel
-0001a8d0: 662e 5f73 656e 645f 636f 6465 2862 5265  f._send_code(bRe
-0001a8e0: 7175 6573 7420 2020 2020 2020 203d 2030  quest        = 0
-0001a8f0: 7866 662c 0d0a 2020 2020 2020 2020 2020  xff,..          
-0001a900: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a910: 2020 2020 2020 7756 616c 7565 2020 2020        wValue    
-0001a920: 2020 2020 2020 3d20 3078 3235 2c0d 0a20        = 0x25,.. 
-0001a930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a940: 2020 2020 2020 2020 2020 2020 2020 2077                 w
-0001a950: 496e 6465 7820 2020 2020 2020 2020 203d  Index          =
-0001a960: 2072 6f69 2e72 6567 696f 6e2c 0d0a 2020   roi.region,..  
-0001a970: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a980: 2020 2020 2020 2020 2020 2020 2020 6461                da
-0001a990: 7461 5f6f 725f 774c 656e 6774 6820 3d20  ta_or_wLength = 
-0001a9a0: 6275 662c 0d0a 2020 2020 2020 2020 2020  buf,..          
-0001a9b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a9c0: 2020 2020 2020 6c61 6265 6c20 2020 2020        label     
-0001a9d0: 2020 2020 2020 3d20 2253 4554 5f44 4554        = "SET_DET
-0001a9e0: 4543 544f 525f 524f 4922 290d 0a0d 0a20  ECTOR_ROI").... 
-0001a9f0: 2020 2020 2020 206c 6f67 2e64 6562 7567         log.debug
-0001aa00: 2822 7761 6974 696e 6720 3173 6563 2e2e  ("waiting 1sec..
-0001aa10: 2e22 290d 0a20 2020 2020 2020 2073 6c65  .")..        sle
-0001aa20: 6570 2831 290d 0a0d 0a20 2020 2020 2020  ep(1)....       
-0001aa30: 2023 204a 7573 7420 696e 2063 6173 652c   # Just in case,
-0001aa40: 2066 6c6f 7773 2074 6865 2075 7064 6174   flows the updat
-0001aa50: 6564 2044 6574 6563 746f 7252 6567 696f  ed DetectorRegio
-0001aa60: 6e73 206f 626a 6563 7420 7570 7374 7265  ns object upstre
-0001aa70: 616d 0d0a 2020 2020 2020 2020 2320 736f  am..        # so
-0001aa80: 2063 616c 6c65 7220 6861 7320 6163 6365   caller has acce
-0001aa90: 7373 2074 6f20 6974 2e0d 0a20 2020 2020  ss to it...     
-0001aaa0: 2020 2069 6620 7374 6f72 653a 0d0a 2020     if store:..  
-0001aab0: 2020 2020 2020 2020 2020 7365 6c66 2e71            self.q
-0001aac0: 7565 7565 5f6d 6573 7361 6765 2822 6465  ueue_message("de
-0001aad0: 7465 6374 6f72 5f72 6567 696f 6e73 222c  tector_regions",
-0001aae0: 2073 656c 662e 7365 7474 696e 6773 2e73   self.settings.s
-0001aaf0: 7461 7465 2e64 6574 6563 746f 725f 7265  tate.detector_re
-0001ab00: 6769 6f6e 7329 0d0a 0d0a 2020 2020 2020  gions)....      
-0001ab10: 2020 7265 7475 726e 2072 6573 756c 740d    return result.
-0001ab20: 0a0d 0a20 2020 2064 6566 2067 6574 5f66  ...    def get_f
-0001ab30: 7067 615f 636f 6e66 6967 7572 6174 696f  pga_configuratio
-0001ab40: 6e5f 7265 6769 7374 6572 2873 656c 662c  n_register(self,
-0001ab50: 206c 6162 656c 3a20 7374 7220 3d20 2222   label: str = ""
-0001ab60: 293a 2023 202d 3e20 5370 6563 7472 6f6d  ): # -> Spectrom
-0001ab70: 6574 6572 5265 7370 6f6e 7365 200d 0a20  eterResponse .. 
-0001ab80: 2020 2020 2020 2072 6177 203d 2073 656c         raw = sel
-0001ab90: 662e 5f67 6574 5f63 6f64 6528 3078 6233  f._get_code(0xb3
-0001aba0: 2c20 6c73 625f 6c65 6e3d 322c 206c 6162  , lsb_len=2, lab
-0001abb0: 656c 3d22 4745 545f 4650 4741 5f43 4f4e  el="GET_FPGA_CON
-0001abc0: 4649 4755 5241 5449 4f4e 5f52 4547 4953  FIGURATION_REGIS
-0001abd0: 5445 5222 290d 0a20 2020 2020 2020 206c  TER")..        l
-0001abe0: 6f67 2e64 6562 7567 2866 2246 5047 4120  og.debug(f"FPGA 
-0001abf0: 436f 6e66 6967 7572 6174 696f 6e20 5265  Configuration Re
-0001ac00: 6769 7374 6572 3a20 3078 7b72 6177 3a30  gister: 0x{raw:0
-0001ac10: 3478 7d20 287b 6c61 6265 6c7d 2922 290d  4x} ({label})").
-0001ac20: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0001ac30: 7261 770d 0a0d 0a20 2020 2023 2023 2323  raw....    # ###
-0001ac40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ac50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ac60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ac70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ac80: 2323 2323 2323 230d 0a20 2020 2023 0d0a  #######..    #..
-0001ac90: 2020 2020 2320 2020 2020 2020 2020 2020      #           
-0001aca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001acb0: 4163 6365 7373 6f72 7920 436f 6e6e 6563  Accessory Connec
-0001acc0: 746f 720d 0a20 2020 2023 0d0a 2020 2020  tor..    #..    
-0001acd0: 2320 2323 2323 2323 2323 2323 2323 2323  # ##############
-0001ace0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001acf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ad00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ad10: 2323 2323 2323 2323 2323 2323 0d0a 0d0a  ############....
-0001ad20: 2020 2020 2320 2323 2323 2323 2323 2323      # ##########
-0001ad30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ad40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ad50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ad60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ad70: 0d0a 2020 2020 2320 4163 6365 7373 6f72  ..    # Accessor
-0001ad80: 7920 456e 6162 6c65 0d0a 2020 2020 2320  y Enable..    # 
-0001ad90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ada0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001adb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001adc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001add0: 2323 2323 2323 2323 2323 0d0a 0d0a 2020  ##########....  
-0001ade0: 2020 2323 2040 746f 646f 2063 6861 6e67    ## @todo chang
-0001adf0: 6520 6f70 636f 6465 2028 636f 6e66 6c69  e opcode (confli
-0001ae00: 6374 7320 7769 7468 2047 4554 5f44 4554  cts with GET_DET
-0001ae10: 4543 544f 525f 5354 4152 545f 4c49 4e45  ECTOR_START_LINE
-0001ae20: 290d 0a20 2020 2064 6566 2073 6574 5f61  )..    def set_a
-0001ae30: 6363 6573 736f 7279 5f65 6e61 626c 6528  ccessory_enable(
-0001ae40: 7365 6c66 2c20 666c 6167 3a20 626f 6f6c  self, flag: bool
-0001ae50: 293a 2023 202d 3e20 5370 6563 7472 6f6d  ): # -> Spectrom
-0001ae60: 6574 6572 5265 7370 6f6e 7365 200d 0a20  eterResponse .. 
-0001ae70: 2020 2020 2020 2069 6620 6e6f 7420 7365         if not se
-0001ae80: 6c66 2e73 6574 7469 6e67 732e 6973 5f67  lf.settings.is_g
-0001ae90: 656e 3135 2829 3a0d 0a20 2020 2020 2020  en15():..       
-0001aea0: 2020 2020 206c 6f67 2e64 6562 7567 2822       log.debug("
-0001aeb0: 6163 6365 7373 6f72 7920 7265 7175 6972  accessory requir
-0001aec0: 6573 2047 656e 2031 2e35 2229 0d0a 2020  es Gen 1.5")..  
-0001aed0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0001aee0: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
-0001aef0: 706f 6e73 6528 6461 7461 3d46 616c 7365  ponse(data=False
-0001af00: 2c65 7272 6f72 5f6d 7367 3d22 7265 7175  ,error_msg="requ
-0001af10: 6972 6573 2067 656e 312e 3522 290d 0a20  ires gen1.5").. 
-0001af20: 2020 2020 2020 2076 616c 7565 203d 2031         value = 1
-0001af30: 2069 6620 666c 6167 2065 6c73 6520 300d   if flag else 0.
-0001af40: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0001af50: 7365 6c66 2e5f 7365 6e64 5f63 6f64 6528  self._send_code(
-0001af60: 6252 6571 7565 7374 2020 2020 2020 2020  bRequest        
-0001af70: 3d20 3078 3232 2c0d 0a20 2020 2020 2020  = 0x22,..       
-0001af80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001af90: 2020 2020 2020 2077 5661 6c75 6520 2020         wValue   
-0001afa0: 2020 2020 2020 203d 2076 616c 7565 2c0d         = value,.
-0001afb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001afc0: 2020 2020 2020 2020 2020 2020 2020 2077                 w
-0001afd0: 496e 6465 7820 2020 2020 2020 2020 203d  Index          =
-0001afe0: 2030 2c0d 0a20 2020 2020 2020 2020 2020   0,..           
-0001aff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b000: 2020 2064 6174 615f 6f72 5f77 4c65 6e67     data_or_wLeng
-0001b010: 7468 203d 205b 305d 202a 2038 2c0d 0a20  th = [0] * 8,.. 
-0001b020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b030: 2020 2020 2020 2020 2020 2020 206c 6162               lab
-0001b040: 656c 2020 2020 2020 2020 2020 203d 2022  el           = "
-0001b050: 5345 545f 4143 4345 5353 4f52 595f 454e  SET_ACCESSORY_EN
-0001b060: 4142 4c45 2229 0d0a 0d0a 2020 2020 2323  ABLE")....    ##
-0001b070: 2040 746f 646f 2066 696e 6420 6f75 7420   @todo find out 
-0001b080: 6f70 636f 6465 0d0a 2020 2020 6465 6620  opcode..    def 
-0001b090: 6765 745f 6469 7363 7265 7465 735f 656e  get_discretes_en
-0001b0a0: 6162 6c65 6428 7365 6c66 293a 2023 202d  abled(self): # -
-0001b0b0: 3e20 5370 6563 7472 6f6d 6574 6572 5265  > SpectrometerRe
-0001b0c0: 7370 6f6e 7365 200d 0a20 2020 2020 2020  sponse ..       
-0001b0d0: 2069 6620 6e6f 7420 7365 6c66 2e73 6574   if not self.set
-0001b0e0: 7469 6e67 732e 6973 5f67 656e 3135 2829  tings.is_gen15()
-0001b0f0: 3a0d 0a20 2020 2020 2020 2020 2020 206c  :..            l
-0001b100: 6f67 2e65 7272 6f72 2822 6163 6365 7373  og.error("access
-0001b110: 6f72 7920 7265 7175 6972 6573 2047 656e  ory requires Gen
-0001b120: 2031 2e35 2229 0d0a 2020 2020 2020 2020   1.5")..        
-0001b130: 2020 2020 7265 7475 726e 2053 7065 6374      return Spect
-0001b140: 726f 6d65 7465 7252 6573 706f 6e73 6528  rometerResponse(
-0001b150: 6461 7461 3d46 616c 7365 2c65 7272 6f72  data=False,error
-0001b160: 5f6d 7367 3d22 7265 7175 6972 6573 2067  _msg="requires g
-0001b170: 656e 312e 3522 290d 0a20 2020 2020 2020  en1.5")..       
-0001b180: 2023 2072 6574 7572 6e20 7365 6c66 2e5f   # return self._
-0001b190: 6765 745f 636f 6465 2830 7833 372c 206c  get_code(0x37, l
-0001b1a0: 6162 656c 3d22 4745 545f 4143 4345 5353  abel="GET_ACCESS
-0001b1b0: 4f52 595f 454e 4142 4c45 4422 2c20 6d73  ORY_ENABLED", ms
-0001b1c0: 625f 6c65 6e3d 3129 0d0a 0d0a 2020 2020  b_len=1)....    
-0001b1d0: 2320 2323 2323 2323 2323 2323 2323 2323  # ##############
-0001b1e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b1f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b200: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b210: 2323 2323 2323 2323 2323 2323 0d0a 2020  ############..  
-0001b220: 2020 2320 4661 6e0d 0a20 2020 2023 2023    # Fan..    # #
-0001b230: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b240: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b250: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b260: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b270: 2323 2323 2323 2323 230d 0a0d 0a20 2020  #########....   
-0001b280: 2064 6566 2073 6574 5f66 616e 5f65 6e61   def set_fan_ena
-0001b290: 626c 6528 7365 6c66 2c20 666c 6167 3a20  ble(self, flag: 
-0001b2a0: 626f 6f6c 293a 2023 202d 3e20 5370 6563  bool): # -> Spec
-0001b2b0: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
-0001b2c0: 200d 0a20 2020 2020 2020 2069 6620 6e6f   ..        if no
-0001b2d0: 7420 7365 6c66 2e73 6574 7469 6e67 732e  t self.settings.
-0001b2e0: 6973 5f67 656e 3135 2829 3a0d 0a20 2020  is_gen15():..   
-0001b2f0: 2020 2020 2020 2020 206c 6f67 2e64 6562           log.deb
-0001b300: 7567 2822 6661 6e20 7265 7175 6972 6573  ug("fan requires
-0001b310: 2047 656e 2031 2e35 2229 0d0a 2020 2020   Gen 1.5")..    
-0001b320: 2020 2020 2020 2020 7265 7475 726e 2053          return S
-0001b330: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
-0001b340: 6e73 6528 6461 7461 3d46 616c 7365 2c65  nse(data=False,e
-0001b350: 7272 6f72 5f6d 7367 3d22 6661 6e20 7265  rror_msg="fan re
-0001b360: 7175 6972 6573 2067 656e 3135 2e22 290d  quires gen15.").
-0001b370: 0a20 2020 2020 2020 2076 616c 7565 203d  .        value =
-0001b380: 2031 2069 6620 666c 6167 2065 6c73 6520   1 if flag else 
-0001b390: 300d 0a20 2020 2020 2020 2072 6574 7572  0..        retur
-0001b3a0: 6e20 7365 6c66 2e5f 7365 6e64 5f63 6f64  n self._send_cod
-0001b3b0: 6528 6252 6571 7565 7374 2020 2020 2020  e(bRequest      
-0001b3c0: 2020 3d20 3078 3336 2c0d 0a20 2020 2020    = 0x36,..     
-0001b3d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b3e0: 2020 2020 2020 2020 2077 5661 6c75 6520           wValue 
-0001b3f0: 2020 2020 2020 2020 203d 2076 616c 7565           = value
-0001b400: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-0001b410: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b420: 2077 496e 6465 7820 2020 2020 2020 2020   wIndex         
-0001b430: 203d 2030 2c0d 0a20 2020 2020 2020 2020   = 0,..         
+00018610: 6c6f 672e 6465 6275 6728 2231 3030 2520  log.debug("100% 
+00018620: 706f 7765 7220 7265 7175 6573 7465 642c  power requested,
+00018630: 2079 6574 206c 6173 6572 206d 6f64 756c   yet laser modul
+00018640: 6174 696f 6e20 7265 7175 6972 6564 2c20  ation required, 
+00018650: 736f 206e 6f74 2064 6973 6162 6c69 6e67  so not disabling
+00018660: 206d 6f64 756c 6174 696f 6e22 290a 2020   modulation").  
+00018670: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+00018680: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018690: 6c6f 672e 6465 6275 6728 2254 7572 6e69  log.debug("Turni
+000186a0: 6e67 206f 6666 206c 6173 6572 206d 6f64  ng off laser mod
+000186b0: 756c 6174 696f 6e20 2866 756c 6c20 706f  ulation (full po
+000186c0: 7765 7229 2229 0a20 2020 2020 2020 2020  wer)").         
+000186d0: 2020 2020 2020 2073 656c 662e 6e65 7874         self.next
+000186e0: 5f61 7070 6c69 6564 5f6c 6173 6572 5f70  _applied_laser_p
+000186f0: 6f77 6572 203d 2031 3030 2e30 0a20 2020  ower = 100.0.   
+00018700: 2020 2020 2020 2020 2020 2020 206c 6f67               log
+00018710: 2e64 6562 7567 2822 6e65 7874 5f61 7070  .debug("next_app
+00018720: 6c69 6564 5f6c 6173 6572 5f70 6f77 6572  lied_laser_power
+00018730: 203d 2031 3030 2e30 2229 0a20 2020 2020   = 100.0").     
+00018740: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00018750: 6e20 7365 6c66 2e73 6574 5f6d 6f64 5f65  n self.set_mod_e
+00018760: 6e61 626c 6528 4661 6c73 6529 0a0a 2020  nable(False)..  
+00018770: 2020 2020 2020 7065 7269 6f64 5f75 7320        period_us 
+00018780: 3d20 3130 3030 2069 6620 7365 6c66 2e73  = 1000 if self.s
+00018790: 6574 7469 6e67 732e 7374 6174 652e 6c61  ettings.state.la
+000187a0: 7365 725f 706f 7765 725f 6869 6768 5f72  ser_power_high_r
+000187b0: 6573 6f6c 7574 696f 6e20 656c 7365 2031  esolution else 1
+000187c0: 3030 0a20 2020 2020 2020 2077 6964 7468  00.        width
+000187d0: 5f75 7320 3d20 696e 7428 726f 756e 6428  _us = int(round(
+000187e0: 312e 3020 2a20 7661 6c75 6520 2a20 7065  1.0 * value * pe
+000187f0: 7269 6f64 5f75 7320 2f20 3130 302e 302c  riod_us / 100.0,
+00018800: 2030 2929 2023 206e 6f74 6520 7468 6174   0)) # note that
+00018810: 2076 616c 7565 2069 7320 696e 2072 616e   value is in ran
+00018820: 6765 2028 302c 2031 3030 2920 6e6f 7420  ge (0, 100) not 
+00018830: 2830 2c20 3129 0a0a 2020 2020 2020 2020  (0, 1)..        
+00018840: 2320 7075 6c73 6520 7769 6474 6820 6361  # pulse width ca
+00018850: 6e27 7420 6265 206c 6f6e 6765 7220 7468  n't be longer th
+00018860: 616e 2070 6572 696f 642c 206f 7220 7368  an period, or sh
+00018870: 6f72 7465 7220 7468 616e 2031 7573 0a20  orter than 1us. 
+00018880: 2020 2020 2020 2077 6964 7468 5f75 7320         width_us 
+00018890: 3d20 6d61 7828 312c 206d 696e 2877 6964  = max(1, min(wid
+000188a0: 7468 5f75 732c 2070 6572 696f 645f 7573  th_us, period_us
+000188b0: 2929 0a0a 2020 2020 2020 2020 2320 4368  ))..        # Ch
+000188c0: 616e 6765 2074 6865 2070 756c 7365 2070  ange the pulse p
+000188d0: 6572 696f 642e 2020 4e6f 7465 2074 6861  eriod.  Note tha
+000188e0: 7420 7765 2772 6520 6e6f 7420 7061 7273  t we're not pars
+000188f0: 696e 6720 696e 746f 2034 302d 6269 740a  ing into 40-bit.
+00018900: 2020 2020 2020 2020 2320 6265 6361 7573          # becaus
+00018910: 6520 7468 6973 2069 6d70 6c65 6d65 6e74  e this implement
+00018920: 6174 696f 6e20 6973 2068 6172 642d 636f  ation is hard-co
+00018930: 6465 6420 746f 2065 6974 6865 7220 3130  ded to either 10
+00018940: 3020 6f72 2031 3030 3075 730a 2020 2020  0 or 1000us.    
+00018950: 2020 2020 2320 2862 6f74 6820 6669 7474      # (both fitt
+00018960: 696e 6720 7765 6c6c 2077 6974 6869 6e20  ing well within 
+00018970: 7569 6e74 3136 290a 2020 2020 2020 2020  uint16).        
+00018980: 7265 7375 6c74 203d 2073 656c 662e 7365  result = self.se
+00018990: 745f 6d6f 645f 7065 7269 6f64 5f75 7328  t_mod_period_us(
+000189a0: 7065 7269 6f64 5f75 7329 0a20 2020 2020  period_us).     
+000189b0: 2020 2023 2069 6620 7265 7375 6c74 2e64     # if result.d
+000189c0: 6174 6120 6973 204e 6f6e 653a 0a20 2020  ata is None:.   
+000189d0: 2020 2020 2023 2020 2020 206c 6f67 2e63       #     log.c
+000189e0: 7269 7469 6361 6c28 2248 6172 6477 6172  ritical("Hardwar
+000189f0: 6520 4661 696c 7572 6520 746f 2073 656e  e Failure to sen
+00018a00: 6420 6c61 7365 7220 6d6f 642e 2070 756c  d laser mod. pul
+00018a10: 7365 2070 6572 696f 6422 290a 2020 2020  se period").    
+00018a20: 2020 2020 2320 2020 2020 7265 7475 726e      #     return
+00018a30: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
+00018a40: 706f 6e73 6528 6461 7461 3d46 616c 7365  ponse(data=False
+00018a50: 2c65 7272 6f72 5f6d 7367 3d22 6661 696c  ,error_msg="fail
+00018a60: 6564 2074 6f20 7365 6e64 206c 6173 6572  ed to send laser
+00018a70: 206d 6f64 2229 0a0a 2020 2020 2020 2020   mod")..        
+00018a80: 2320 5365 7420 7468 6520 7075 6c73 6520  # Set the pulse 
+00018a90: 7769 6474 6820 746f 2074 6865 2030 2d31  width to the 0-1
+00018aa0: 3030 2070 6572 6365 6e74 6167 6520 6f66  00 percentage of
+00018ab0: 2070 6f77 6572 0a20 2020 2020 2020 2072   power.        r
+00018ac0: 6573 756c 7420 3d20 7365 6c66 2e73 6574  esult = self.set
+00018ad0: 5f6d 6f64 5f77 6964 7468 5f75 7328 7769  _mod_width_us(wi
+00018ae0: 6474 685f 7573 290a 2020 2020 2020 2020  dth_us).        
+00018af0: 2320 6966 2072 6573 756c 742e 6461 7461  # if result.data
+00018b00: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+00018b10: 2020 2320 2020 2020 6c6f 672e 6372 6974    #     log.crit
+00018b20: 6963 616c 2822 4861 7264 7761 7265 2046  ical("Hardware F
+00018b30: 6169 6c75 7265 2074 6f20 7365 6e64 2070  ailure to send p
+00018b40: 756c 7365 2077 6964 7468 2229 0a20 2020  ulse width").   
+00018b50: 2020 2020 2023 2020 2020 2072 6574 7572       #     retur
+00018b60: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
+00018b70: 7370 6f6e 7365 2864 6174 613d 4661 6c73  sponse(data=Fals
+00018b80: 652c 6572 726f 725f 6d73 673d 2266 6169  e,error_msg="fai
+00018b90: 6c65 6420 746f 2073 656e 6420 7075 6c73  led to send puls
+00018ba0: 6520 7769 6474 6822 290a 0a20 2020 2020  e width")..     
+00018bb0: 2020 2023 2045 6e61 626c 6520 6d6f 6475     # Enable modu
+00018bc0: 6c61 7469 6f6e 0a20 2020 2020 2020 2072  lation.        r
+00018bd0: 6573 756c 7420 3d20 7365 6c66 2e73 6574  esult = self.set
+00018be0: 5f6d 6f64 5f65 6e61 626c 6528 5472 7565  _mod_enable(True
+00018bf0: 290a 2020 2020 2020 2020 2320 6966 2072  ).        # if r
+00018c00: 6573 756c 742e 6461 7461 2069 7320 4e6f  esult.data is No
+00018c10: 6e65 3a0a 2020 2020 2020 2020 2320 2020  ne:.        #   
+00018c20: 2020 6c6f 672e 6372 6974 6963 616c 2822    log.critical("
+00018c30: 4861 7264 7761 7265 2046 6169 6c75 7265  Hardware Failure
+00018c40: 2074 6f20 7365 6e64 206c 6173 6572 206d   to send laser m
+00018c50: 6f64 756c 6174 696f 6e22 290a 2020 2020  odulation").    
+00018c60: 2020 2020 2320 2020 2020 7265 7475 726e      #     return
+00018c70: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
+00018c80: 706f 6e73 6528 6461 7461 3d46 616c 7365  ponse(data=False
+00018c90: 2c65 7272 6f72 5f6d 7367 3d22 6661 696c  ,error_msg="fail
+00018ca0: 6564 2074 6f20 7365 6e64 206c 6173 6572  ed to send laser
+00018cb0: 206d 6f64 756c 6174 696f 6e22 290a 0a20   modulation").. 
+00018cc0: 2020 2020 2020 206c 6f67 2e64 6562 7567         log.debug
+00018cd0: 2822 4c61 7365 7220 706f 7765 7220 7365  ("Laser power se
+00018ce0: 7420 746f 3a20 2564 222c 2076 616c 7565  t to: %d", value
+00018cf0: 290a 0a20 2020 2020 2020 2073 656c 662e  )..        self.
+00018d00: 6e65 7874 5f61 7070 6c69 6564 5f6c 6173  next_applied_las
+00018d10: 6572 5f70 6f77 6572 203d 2076 616c 7565  er_power = value
+00018d20: 0a20 2020 2020 2020 206c 6f67 2e64 6562  .        log.deb
+00018d30: 7567 2822 6e65 7874 5f61 7070 6c69 6564  ug("next_applied
+00018d40: 5f6c 6173 6572 5f70 6f77 6572 203d 2025  _laser_power = %
+00018d50: 7322 2c20 7365 6c66 2e6e 6578 745f 6170  s", self.next_ap
+00018d60: 706c 6965 645f 6c61 7365 725f 706f 7765  plied_laser_powe
+00018d70: 7229 0a0a 2020 2020 2020 2020 7265 7475  r)..        retu
+00018d80: 726e 2072 6573 756c 740a 0a20 2020 2023  rn result..    #
+00018d90: 230a 2020 2020 2320 406e 6f74 6520 6e65  #.    # @note ne
+00018da0: 7665 7220 7573 6564 2c20 7072 6f76 6964  ver used, provid
+00018db0: 6564 2066 6f72 204f 454d 0a20 2020 2064  ed for OEM.    d
+00018dc0: 6566 2067 6574 5f6c 6173 6572 5f74 656d  ef get_laser_tem
+00018dd0: 7065 7261 7475 7265 5f73 6574 706f 696e  perature_setpoin
+00018de0: 745f 7261 7728 7365 6c66 293a 0a20 2020  t_raw(self):.   
+00018df0: 2020 2020 2069 6620 6e6f 7420 7365 6c66       if not self
+00018e00: 2e73 6574 7469 6e67 732e 6565 7072 6f6d  .settings.eeprom
+00018e10: 2e68 6173 5f6c 6173 6572 3a0a 2020 2020  .has_laser:.    
+00018e20: 2020 2020 2020 2020 6c6f 672e 6572 726f          log.erro
+00018e30: 7228 2275 6e61 626c 6520 746f 2063 6f6e  r("unable to con
+00018e40: 7472 6f6c 206c 6173 6572 3a20 4545 5052  trol laser: EEPR
+00018e50: 4f4d 2072 6570 6f72 7473 206e 6f20 6c61  OM reports no la
+00018e60: 7365 7220 696e 7374 616c 6c65 6422 290a  ser installed").
+00018e70: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00018e80: 726e 2053 7065 6374 726f 6d65 7465 7252  rn SpectrometerR
+00018e90: 6573 706f 6e73 6528 6461 7461 3d4e 6f6e  esponse(data=Non
+00018ea0: 652c 6572 726f 725f 6d73 673d 226e 6f20  e,error_msg="no 
+00018eb0: 6c61 7365 7220 696e 7374 616c 6c65 6422  laser installed"
+00018ec0: 290a 0a20 2020 2020 2020 2072 6574 7572  )..        retur
+00018ed0: 6e20 7365 6c66 2e5f 6765 745f 636f 6465  n self._get_code
+00018ee0: 2830 7865 382c 206c 6162 656c 3d22 4745  (0xe8, label="GE
+00018ef0: 545f 4c41 5345 525f 5445 435f 5345 5450  T_LASER_TEC_SETP
+00018f00: 4f49 4e54 2229 0a0a 2020 2020 6465 6620  OINT")..    def 
+00018f10: 7365 745f 6c61 7365 725f 7465 6d70 6572  set_laser_temper
+00018f20: 6174 7572 655f 7365 7470 6f69 6e74 5f72  ature_setpoint_r
+00018f30: 6177 2873 656c 662c 2076 616c 7565 3a20  aw(self, value: 
+00018f40: 696e 7429 3a0a 2020 2020 2020 2020 6c6f  int):.        lo
+00018f50: 672e 6465 6275 6728 6622 5365 6e64 206c  g.debug(f"Send l
+00018f60: 6173 6572 2074 656d 7065 7261 7475 7265  aser temperature
+00018f70: 2073 6574 706f 696e 7420 7261 773a 2030   setpoint raw: 0
+00018f80: 787b 7661 6c75 653a 3033 787d 2229 0a20  x{value:03x}"). 
+00018f90: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+00018fa0: 6c66 2e5f 7365 6e64 5f63 6f64 6528 3078  lf._send_code(0x
+00018fb0: 6537 2c20 7661 6c75 652c 206c 6162 656c  e7, value, label
+00018fc0: 3d22 5345 545f 4c41 5345 525f 5445 435f  ="SET_LASER_TEC_
+00018fd0: 5345 5450 4f49 4e54 2229 0a0a 2020 2020  SETPOINT")..    
+00018fe0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00018ff0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019000: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019010: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019020: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
+00019030: 2023 2064 6967 6974 616c 2070 6f74 206f   # digital pot o
+00019040: 6e20 3232 3032 3530 2052 6576 3441 2b0a  n 220250 Rev4A+.
+00019050: 2020 2020 2323 2323 2323 2323 2323 2323      ############
+00019060: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019070: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019080: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019090: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000190a0: 0a0a 2020 2020 6465 6620 7365 745f 6c61  ..    def set_la
+000190b0: 7365 725f 706f 7765 725f 6174 7465 6e75  ser_power_attenu
+000190c0: 6174 6f72 2873 656c 662c 2076 616c 7565  ator(self, value
+000190d0: 293a 0a20 2020 2020 2020 2063 6d64 203d  ):.        cmd =
+000190e0: 2022 5345 545f 4c41 5345 525f 4154 5445   "SET_LASER_ATTE
+000190f0: 4e55 4154 4f52 220a 2020 2020 2020 2020  NUATOR".        
+00019100: 6966 206e 6f74 2073 656c 662e 7365 7474  if not self.sett
+00019110: 696e 6773 2e69 735f 7873 2829 3a0a 2020  ings.is_xs():.  
+00019120: 2020 2020 2020 2020 2020 6d73 6720 3d20            msg = 
+00019130: 6622 7b63 6d64 7d20 6973 206f 6e6c 7920  f"{cmd} is only 
+00019140: 6176 6169 6c61 626c 6520 6f6e 2058 532d  available on XS-
+00019150: 5365 7269 6573 2077 6974 6820 3232 3032  Series with 2202
+00019160: 3530 2052 6576 3441 2b22 0a20 2020 2020  50 Rev4A+".     
+00019170: 2020 2020 2020 206c 6f67 2e64 6562 7567         log.debug
+00019180: 286d 7367 290a 2020 2020 2020 2020 2020  (msg).          
+00019190: 2020 7265 7475 726e 2053 7065 6374 726f    return Spectro
+000191a0: 6d65 7465 7252 6573 706f 6e73 6528 6461  meterResponse(da
+000191b0: 7461 3d4e 6f6e 652c 2065 7272 6f72 5f6d  ta=None, error_m
+000191c0: 7367 3d6d 7367 290a 0a20 2020 2020 2020  sg=msg)..       
+000191d0: 2023 2064 6967 6974 616c 2070 6f74 656e   # digital poten
+000191e0: 7469 6f6d 6574 6572 2069 7320 382d 6269  tiometer is 8-bi
+000191f0: 740a 2020 2020 2020 2020 7661 6c75 6520  t.        value 
+00019200: 3d20 6d61 7828 302c 206d 696e 2830 7866  = max(0, min(0xf
+00019210: 662c 2069 6e74 2872 6f75 6e64 2876 616c  f, int(round(val
+00019220: 7565 2929 2929 0a0a 2020 2020 2020 2020  ue))))..        
+00019230: 7265 7475 726e 2073 656c 662e 5f73 656e  return self._sen
+00019240: 645f 636f 6465 2830 7838 322c 2076 616c  d_code(0x82, val
+00019250: 7565 2c20 6c61 6265 6c3d 636d 6429 0a0a  ue, label=cmd)..
+00019260: 2020 2020 6465 6620 6765 745f 6c61 7365      def get_lase
+00019270: 725f 706f 7765 725f 6174 7465 6e75 6174  r_power_attenuat
+00019280: 6f72 2873 656c 6629 3a0a 2020 2020 2020  or(self):.      
+00019290: 2020 636d 6420 3d20 2247 4554 5f4c 4153    cmd = "GET_LAS
+000192a0: 4552 5f41 5454 454e 5541 544f 5222 0a20  ER_ATTENUATOR". 
+000192b0: 2020 2020 2020 2069 6620 6e6f 7420 7365         if not se
+000192c0: 6c66 2e73 6574 7469 6e67 732e 6973 5f78  lf.settings.is_x
+000192d0: 7328 293a 0a20 2020 2020 2020 2020 2020  s():.           
+000192e0: 206d 7367 203d 2066 227b 636d 647d 2069   msg = f"{cmd} i
+000192f0: 7320 6f6e 6c79 2061 7661 696c 6162 6c65  s only available
+00019300: 206f 6e20 5853 2d53 6572 6965 7320 7769   on XS-Series wi
+00019310: 7468 2032 3230 3235 3020 5265 7634 412b  th 220250 Rev4A+
+00019320: 220a 2020 2020 2020 2020 2020 2020 6c6f  ".            lo
+00019330: 672e 6465 6275 6728 6d73 6729 0a20 2020  g.debug(msg).   
+00019340: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00019350: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
+00019360: 6f6e 7365 2864 6174 613d 4e6f 6e65 2c20  onse(data=None, 
+00019370: 6572 726f 725f 6d73 673d 6d73 6729 0a0a  error_msg=msg)..
+00019380: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00019390: 656c 662e 5f67 6574 5f63 6f64 6528 3078  elf._get_code(0x
+000193a0: 3833 2c20 6d73 625f 6c65 6e3d 312c 206c  83, msb_len=1, l
+000193b0: 6162 656c 3d63 6d64 290a 0a20 2020 2023  abel=cmd)..    #
+000193c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000193d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000193e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000193f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019400: 2323 2323 2323 2323 2323 230a 2020 2020  ###########.    
+00019410: 2320 6c61 7365 7220 696e 7465 726c 6f63  # laser interloc
+00019420: 6b0a 2020 2020 2323 2323 2323 2323 2323  k.    ##########
+00019430: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019440: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019450: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019460: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019470: 2323 0a0a 2020 2020 6465 6620 6765 745f  ##..    def get_
+00019480: 6c61 7365 725f 696e 7465 726c 6f63 6b28  laser_interlock(
+00019490: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
+000194a0: 2222 204c 6567 6163 7920 7772 6170 7065  "" Legacy wrappe
+000194b0: 7220 6f76 6572 2063 616e 5f6c 6173 6572  r over can_laser
+000194c0: 5f66 6972 652e 2022 2222 0a20 2020 2020  _fire. """.     
+000194d0: 2020 2072 6574 7572 6e20 7365 6c66 2e63     return self.c
+000194e0: 616e 5f6c 6173 6572 5f66 6972 6528 290a  an_laser_fire().
+000194f0: 0a20 2020 2064 6566 2063 616e 5f6c 6173  .    def can_las
+00019500: 6572 5f66 6972 6528 7365 6c66 293a 0a20  er_fire(self):. 
+00019510: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+00019520: 2020 2040 6e6f 7465 206f 6e6c 7920 776f     @note only wo
+00019530: 726b 7320 6f6e 2046 5832 2d62 6173 6564  rks on FX2-based
+00019540: 2073 7065 6374 726f 6d65 7465 7273 2077   spectrometers w
+00019550: 6974 6820 4657 203e 3d20 3130 2e30 2e30  ith FW >= 10.0.0
+00019560: 2e31 310a 2020 2020 2020 2020 4072 6574  .11.        @ret
+00019570: 7572 6e73 2054 7275 6520 6966 2074 6865  urns True if the
+00019580: 7265 2069 7320 6120 6c61 7365 7220 616e  re is a laser an
+00019590: 6420 6569 7468 6572 2074 6865 2069 6e74  d either the int
+000195a0: 6572 6c6f 636b 2069 730a 2020 2020 2020  erlock is.      
+000195b0: 2020 2063 6c6f 7365 6420 2869 6e20 6669     closed (in fi
+000195c0: 7269 6e67 2070 6f73 6974 696f 6e29 2c20  ring position), 
+000195d0: 6f72 2074 6865 7265 2069 7320 6e6f 2072  or there is no r
+000195e0: 6561 6461 626c 650a 2020 2020 2020 2020  eadable.        
+000195f0: 2069 6e74 6572 6c6f 636b 0a20 2020 2020   interlock.     
+00019600: 2020 2022 2222 0a20 2020 2020 2020 2069     """.        i
+00019610: 6620 6e6f 7420 7365 6c66 2e73 6574 7469  f not self.setti
+00019620: 6e67 732e 6565 7072 6f6d 2e68 6173 5f6c  ngs.eeprom.has_l
+00019630: 6173 6572 3a0a 2020 2020 2020 2020 2020  aser:.          
+00019640: 2020 6c6f 672e 6572 726f 7228 2245 4550    log.error("EEP
+00019650: 524f 4d20 7265 706f 7274 7320 6e6f 206c  ROM reports no l
+00019660: 6173 6572 2069 6e73 7461 6c6c 6564 2229  aser installed")
+00019670: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00019680: 7572 6e20 5370 6563 7472 6f6d 6574 6572  urn Spectrometer
+00019690: 5265 7370 6f6e 7365 2864 6174 613d 4661  Response(data=Fa
+000196a0: 6c73 652c 6572 726f 725f 6d73 673d 226e  lse,error_msg="n
+000196b0: 6f20 6c61 7365 7220 696e 7374 616c 6c65  o laser installe
+000196c0: 6422 290a 0a20 2020 2020 2020 2069 6620  d")..        if 
+000196d0: 6e6f 7420 7365 6c66 2e73 6574 7469 6e67  not self.setting
+000196e0: 732e 6565 7072 6f6d 2e68 6173 5f69 6e74  s.eeprom.has_int
+000196f0: 6572 6c6f 636b 5f66 6565 6462 6163 6b3a  erlock_feedback:
+00019700: 0a20 2020 2020 2020 2020 2020 206c 6f67  .            log
+00019710: 2e64 6562 7567 2822 4341 4e5f 4c41 5345  .debug("CAN_LASE
+00019720: 525f 4649 5245 2072 6571 7569 7265 7320  R_FIRE requires 
+00019730: 6861 735f 696e 7465 726c 6f63 6b5f 6665  has_interlock_fe
+00019740: 6564 6261 636b 2028 6465 6661 756c 7469  edback (defaulti
+00019750: 6e67 2054 7275 6529 2229 0a20 2020 2020  ng True)").     
+00019760: 2020 2020 2020 2072 6574 7572 6e20 5370         return Sp
+00019770: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
+00019780: 7365 2864 6174 613d 5472 7565 290a 0a20  se(data=True).. 
+00019790: 2020 2020 2020 2072 6573 203d 2073 656c         res = sel
+000197a0: 662e 5f67 6574 5f63 6f64 6528 3078 6566  f._get_code(0xef
+000197b0: 2c20 6c61 6265 6c3d 2243 414e 5f4c 4153  , label="CAN_LAS
+000197c0: 4552 5f46 4952 4522 2c20 6d73 625f 6c65  ER_FIRE", msb_le
+000197d0: 6e3d 3129 0a20 2020 2020 2020 2072 6573  n=1).        res
+000197e0: 2e64 6174 6120 3d20 3020 213d 2072 6573  .data = 0 != res
+000197f0: 2e64 6174 610a 2020 2020 2020 2020 7265  .data.        re
+00019800: 7475 726e 2072 6573 0a0a 2020 2020 6465  turn res..    de
+00019810: 6620 6973 5f6c 6173 6572 5f66 6972 696e  f is_laser_firin
+00019820: 6728 7365 6c66 293a 0a20 2020 2020 2020  g(self):.       
+00019830: 2022 2222 0a20 2020 2020 2020 2043 6865   """.        Che
+00019840: 636b 2069 6620 7468 6520 6c61 7365 7220  ck if the laser 
+00019850: 6163 7475 616c 6c79 2049 5320 6669 7269  actually IS firi
+00019860: 6e67 2c20 696e 6465 7065 6e64 656e 7420  ng, independent 
+00019870: 6f66 206c 6173 6572 5f65 6e61 626c 6520  of laser_enable 
+00019880: 6f72 200a 2020 2020 2020 2020 6361 6e5f  or .        can_
+00019890: 6c61 7365 725f 6669 7265 2e0a 0a20 2020  laser_fire...   
+000198a0: 2020 2020 2040 7265 7475 726e 7320 5370       @returns Sp
+000198b0: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
+000198c0: 7365 0a20 2020 2020 2020 2022 2222 0a20  se.        """. 
+000198d0: 2020 2020 2020 2069 6620 6e6f 7420 7365         if not se
+000198e0: 6c66 2e73 6574 7469 6e67 732e 6565 7072  lf.settings.eepr
+000198f0: 6f6d 2e68 6173 5f69 6e74 6572 6c6f 636b  om.has_interlock
+00019900: 5f66 6565 6462 6163 6b3a 0a20 2020 2020  _feedback:.     
+00019910: 2020 2020 2020 206c 6f67 2e64 6562 7567         log.debug
+00019920: 2822 4953 5f4c 4153 4552 5f46 4952 494e  ("IS_LASER_FIRIN
+00019930: 4720 7265 7175 6972 6573 2068 6173 5f69  G requires has_i
+00019940: 6e74 6572 6c6f 636b 5f66 6565 6462 6163  nterlock_feedbac
+00019950: 6b20 2864 6566 6175 6c74 696e 6720 746f  k (defaulting to
+00019960: 206c 6173 6572 5f65 6e61 626c 6564 2922   laser_enabled)"
+00019970: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+00019980: 7475 726e 2073 656c 662e 6765 745f 6c61  turn self.get_la
+00019990: 7365 725f 656e 6162 6c65 6428 290a 0a20  ser_enabled().. 
+000199a0: 2020 2020 2020 2072 6573 203d 2073 656c         res = sel
+000199b0: 662e 6765 745f 7570 7065 725f 636f 6465  f.get_upper_code
+000199c0: 2830 7830 642c 206c 6162 656c 3d22 4953  (0x0d, label="IS
+000199d0: 5f4c 4153 4552 5f46 4952 494e 4722 2c20  _LASER_FIRING", 
+000199e0: 6d73 625f 6c65 6e3d 3129 0a20 2020 2020  msb_len=1).     
+000199f0: 2020 2072 6573 2e64 6174 6120 3d20 3020     res.data = 0 
+00019a00: 213d 2072 6573 2e64 6174 610a 2020 2020  != res.data.    
+00019a10: 2020 2020 7265 7475 726e 2072 6573 0a0a      return res..
+00019a20: 2020 2020 2323 2323 2323 2323 2323 2323      ############
+00019a30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019a40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019a50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019a60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019a70: 0a20 2020 2023 2028 656e 6420 6f66 206c  .    # (end of l
+00019a80: 6173 6572 2063 6f6d 6d61 6e64 7329 0a20  aser commands). 
+00019a90: 2020 2023 2323 2323 2323 2323 2323 2323     #############
+00019aa0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019ab0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019ac0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019ad0: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
+00019ae0: 0a20 2020 2064 6566 2072 6573 6574 5f66  .    def reset_f
+00019af0: 7067 6128 7365 6c66 293a 0a20 2020 2020  pga(self):.     
+00019b00: 2020 206c 6f67 2e64 6562 7567 2822 6669     log.debug("fi
+00019b10: 643a 2072 6573 6574 7469 6e67 2046 5047  d: resetting FPG
+00019b20: 4122 290a 2020 2020 2020 2020 7265 7375  A").        resu
+00019b30: 6c74 203d 2073 656c 662e 5f73 656e 645f  lt = self._send_
+00019b40: 636f 6465 2830 7862 352c 206c 6162 656c  code(0xb5, label
+00019b50: 3d22 5245 5345 545f 4650 4741 2229 0a20  ="RESET_FPGA"). 
+00019b60: 2020 2020 2020 206c 6f67 2e64 6562 7567         log.debug
+00019b70: 2822 6669 643a 2073 6c65 6570 696e 6720  ("fid: sleeping 
+00019b80: 3373 6563 2229 0a20 2020 2020 2020 2073  3sec").        s
+00019b90: 6c65 6570 2833 290a 2020 2020 2020 2020  leep(3).        
+00019ba0: 7265 7475 726e 2072 6573 756c 740a 0a20  return result.. 
+00019bb0: 2020 2023 230a 2020 2020 2320 5265 6164     ##.    # Read
+00019bc0: 2074 6865 2074 7269 6767 6572 2073 6f75   the trigger sou
+00019bd0: 7263 6520 7365 7474 696e 6720 6672 6f6d  rce setting from
+00019be0: 2074 6865 2064 6576 6963 652e 0a20 2020   the device..   
+00019bf0: 2023 0a20 2020 2023 202d 2030 203d 2069   #.    # - 0 = i
+00019c00: 6e74 6572 6e61 6c0a 2020 2020 2320 2d20  nternal.    # - 
+00019c10: 3120 3d20 6578 7465 726e 616c 0a20 2020  1 = external.   
+00019c20: 2023 0a20 2020 2023 2055 7365 2063 6175   #.    # Use cau
+00019c30: 7469 6f6e 2077 6865 6e20 696e 7465 7270  tion when interp
+00019c40: 7265 7469 6e67 2074 6865 206c 6172 6765  reting the large
+00019c50: 7220 6265 6861 7669 6f72 206f 660a 2020  r behavior of.  
+00019c60: 2020 2320 7468 6520 6465 7669 6365 2061    # the device a
+00019c70: 7320 4152 4d20 616e 6420 4658 3220 696d  s ARM and FX2 im
+00019c80: 706c 656d 656e 7461 7469 6f6e 7320 6469  plementations di
+00019c90: 6666 6572 2061 7320 6f66 2032 3031 372d  ffer as of 2017-
+00019ca0: 3038 2d30 320a 2020 2020 230a 2020 2020  08-02.    #.    
+00019cb0: 2320 406e 6f74 6520 6e65 7665 7220 6361  # @note never ca
+00019cc0: 6c6c 6564 2062 7920 454e 4c49 4748 5445  lled by ENLIGHTE
+00019cd0: 4e20 2d20 7072 6f76 6964 6564 2066 6f72  N - provided for
+00019ce0: 204f 454d 730a 2020 2020 6465 6620 6765   OEMs.    def ge
+00019cf0: 745f 7472 6967 6765 725f 736f 7572 6365  t_trigger_source
+00019d00: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00019d10: 7661 6c75 6520 3d20 7365 6c66 2e5f 6765  value = self._ge
+00019d20: 745f 636f 6465 2830 7864 332c 206c 6162  t_code(0xd3, lab
+00019d30: 656c 3d22 4745 545f 5452 4947 4745 525f  el="GET_TRIGGER_
+00019d40: 534f 5552 4345 222c 206d 7362 5f6c 656e  SOURCE", msb_len
+00019d50: 3d31 290a 2020 2020 2020 2020 7365 6c66  =1).        self
+00019d60: 2e73 6574 7469 6e67 732e 7374 6174 652e  .settings.state.
+00019d70: 7472 6967 6765 725f 736f 7572 6365 203d  trigger_source =
+00019d80: 2076 616c 7565 2e64 6174 610a 2020 2020   value.data.    
+00019d90: 2020 2020 7265 7475 726e 2076 616c 7565      return value
+00019da0: 0a0a 2020 2020 2323 0a20 2020 2023 2040  ..    ##.    # @
+00019db0: 6e6f 7465 206e 6f74 2063 616c 6c65 6420  note not called 
+00019dc0: 6279 2045 4e4c 4947 4854 454e 0a20 2020  by ENLIGHTEN.   
+00019dd0: 2023 2040 7761 726e 696e 6720 636f 6e66   # @warning conf
+00019de0: 6c69 6374 7320 7769 7468 2047 4554 5f53  licts with GET_S
+00019df0: 454c 4543 5445 445f 4c41 5345 520a 2020  ELECTED_LASER.  
+00019e00: 2020 6465 6620 6765 745f 7261 6d61 6e5f    def get_raman_
+00019e10: 6d6f 6465 5f65 6e61 626c 6564 5f4e 4f54  mode_enabled_NOT
+00019e20: 5f55 5345 4428 7365 6c66 293a 0a20 2020  _USED(self):.   
+00019e30: 2020 2020 2072 6573 203d 2073 656c 662e       res = self.
+00019e40: 6765 745f 7570 7065 725f 636f 6465 2830  get_upper_code(0
+00019e50: 7831 352c 206c 6162 656c 3d22 4745 545f  x15, label="GET_
+00019e60: 5241 4d41 4e5f 4d4f 4445 5f45 4e41 424c  RAMAN_MODE_ENABL
+00019e70: 4544 222c 206d 7362 5f6c 656e 3d31 290a  ED", msb_len=1).
+00019e80: 2020 2020 2020 2020 7265 732e 6461 7461          res.data
+00019e90: 203d 2030 2021 3d20 7265 732e 6461 7461   = 0 != res.data
+00019ea0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00019eb0: 7265 730a 0a20 2020 2023 230a 2020 2020  res..    ##.    
+00019ec0: 2320 456e 6162 6c65 2022 5261 6d61 6e20  # Enable "Raman 
+00019ed0: 6d6f 6465 2220 2861 7574 6f6d 6174 6963  mode" (automatic
+00019ee0: 206c 6173 6572 2920 696e 2074 6865 2073   laser) in the s
+00019ef0: 7065 6374 726f 6d65 7465 7220 6669 726d  pectrometer firm
+00019f00: 7761 7265 2e0a 2020 2020 6465 6620 7365  ware..    def se
+00019f10: 745f 7261 6d61 6e5f 6d6f 6465 5f65 6e61  t_raman_mode_ena
+00019f20: 626c 655f 4e4f 545f 5553 4544 2873 656c  ble_NOT_USED(sel
+00019f30: 662c 2066 6c61 673a 2062 6f6f 6c29 3a0a  f, flag: bool):.
+00019f40: 2020 2020 2020 2020 6966 206e 6f74 2073          if not s
+00019f50: 656c 662e 7365 7474 696e 6773 2e69 735f  elf.settings.is_
+00019f60: 6d69 6372 6f28 293a 0a20 2020 2020 2020  micro():.       
+00019f70: 2020 2020 206c 6f67 2e64 6562 7567 2822       log.debug("
+00019f80: 5261 6d61 6e20 6d6f 6465 206f 6e6c 7920  Raman mode only 
+00019f90: 7375 7070 6f72 7465 6420 6f6e 2053 6572  supported on Ser
+00019fa0: 6965 732d 5853 2229 0a20 2020 2020 2020  ies-XS").       
+00019fb0: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
+00019fc0: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
+00019fd0: 2864 6174 613d 4661 6c73 652c 6572 726f  (data=False,erro
+00019fe0: 725f 6d73 673d 2272 616d 616e 206d 6f64  r_msg="raman mod
+00019ff0: 6520 6e6f 7420 7375 7070 6f72 7465 6422  e not supported"
+0001a000: 290a 0a20 2020 2020 2020 2072 6574 7572  )..        retur
+0001a010: 6e20 7365 6c66 2e5f 7365 6e64 5f63 6f64  n self._send_cod
+0001a020: 6528 6252 6571 7565 7374 2020 2020 2020  e(bRequest      
+0001a030: 2020 3d20 3078 6666 2c0a 2020 2020 2020    = 0xff,.      
+0001a040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a050: 2020 2020 2020 2020 7756 616c 7565 2020          wValue  
+0001a060: 2020 2020 2020 2020 3d20 3078 3136 2c0a          = 0x16,.
+0001a070: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a080: 2020 2020 2020 2020 2020 2020 2020 7749                wI
+0001a090: 6e64 6578 2020 2020 2020 2020 2020 3d20  ndex          = 
+0001a0a0: 3120 6966 2066 6c61 6720 656c 7365 2030  1 if flag else 0
+0001a0b0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0001a0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a0d0: 6461 7461 5f6f 725f 774c 656e 6774 6820  data_or_wLength 
+0001a0e0: 3d20 5b30 5d20 2a20 382c 0a20 2020 2020  = [0] * 8,.     
+0001a0f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a100: 2020 2020 2020 2020 206c 6162 656c 2020           label  
+0001a110: 2020 2020 2020 2020 203d 2022 5345 545f           = "SET_
+0001a120: 5241 4d41 4e5f 4d4f 4445 5f45 4e41 424c  RAMAN_MODE_ENABL
+0001a130: 4522 290a 0a20 2020 2064 6566 2067 6574  E")..    def get
+0001a140: 5f72 616d 616e 5f64 656c 6179 5f6d 7328  _raman_delay_ms(
+0001a150: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
+0001a160: 6573 203d 2073 656c 662e 6765 745f 7570  es = self.get_up
+0001a170: 7065 725f 636f 6465 2830 7831 392c 206c  per_code(0x19, l
+0001a180: 6162 656c 3d22 4745 545f 5241 4d41 4e5f  abel="GET_RAMAN_
+0001a190: 4445 4c41 595f 4d53 222c 206d 7362 5f6c  DELAY_MS", msb_l
+0001a1a0: 656e 3d32 290a 2020 2020 2020 2020 7365  en=2).        se
+0001a1b0: 6c66 2e73 6574 7469 6e67 732e 7374 6174  lf.settings.stat
+0001a1c0: 652e 7261 6d61 6e5f 6465 6c61 795f 6d73  e.raman_delay_ms
+0001a1d0: 203d 2072 6573 2e64 6174 610a 2020 2020   = res.data.    
+0001a1e0: 2020 2020 7265 7475 726e 2072 6573 0a0a      return res..
+0001a1f0: 2020 2020 6465 6620 7365 745f 7261 6d61      def set_rama
+0001a200: 6e5f 6465 6c61 795f 6d73 2873 656c 662c  n_delay_ms(self,
+0001a210: 206d 733a 2069 6e74 293a 0a20 2020 2020   ms: int):.     
+0001a220: 2020 2069 6620 6e6f 7420 7365 6c66 2e73     if not self.s
+0001a230: 6574 7469 6e67 732e 6973 5f6d 6963 726f  ettings.is_micro
+0001a240: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
+0001a250: 6c6f 672e 6465 6275 6728 2252 616d 616e  log.debug("Raman
+0001a260: 2064 656c 6179 206f 6e6c 7920 7375 7070   delay only supp
+0001a270: 6f72 7465 6420 6f6e 2053 6572 6965 732d  orted on Series-
+0001a280: 5853 2229 0a20 2020 2020 2020 2020 2020  XS").           
+0001a290: 2072 6574 7572 6e20 5370 6563 7472 6f6d   return Spectrom
+0001a2a0: 6574 6572 5265 7370 6f6e 7365 2864 6174  eterResponse(dat
+0001a2b0: 613d 4661 6c73 652c 6572 726f 725f 6d73  a=False,error_ms
+0001a2c0: 673d 2272 616d 616e 2064 656c 6179 206e  g="raman delay n
+0001a2d0: 6f74 2073 7570 706f 7274 6564 2229 0a0a  ot supported")..
+0001a2e0: 2020 2020 2020 2020 2320 7365 6e64 2076          # send v
+0001a2f0: 616c 7565 2061 7320 6269 672d 656e 6469  alue as big-endi
+0001a300: 616e 0a20 2020 2020 2020 206d 7362 203d  an.        msb =
+0001a310: 2028 6d73 203e 3e20 3829 2026 2030 7866   (ms >> 8) & 0xf
+0001a320: 660a 2020 2020 2020 2020 6c73 6220 3d20  f.        lsb = 
+0001a330: 206d 7320 2020 2020 2020 2620 3078 6666   ms       & 0xff
+0001a340: 0a20 2020 2020 2020 2076 616c 7565 203d  .        value =
+0001a350: 2028 6d73 6220 3c3c 2038 2920 7c20 6c73   (msb << 8) | ls
+0001a360: 620a 0a20 2020 2020 2020 2073 656c 662e  b..        self.
+0001a370: 7365 7474 696e 6773 2e73 7461 7465 2e72  settings.state.r
+0001a380: 616d 616e 5f64 656c 6179 5f6d 7320 3d20  aman_delay_ms = 
+0001a390: 6d73 0a20 2020 2020 2020 2072 6574 7572  ms.        retur
+0001a3a0: 6e20 7365 6c66 2e5f 7365 6e64 5f63 6f64  n self._send_cod
+0001a3b0: 6528 6252 6571 7565 7374 2020 2020 2020  e(bRequest      
+0001a3c0: 2020 3d20 3078 6666 2c0a 2020 2020 2020    = 0xff,.      
+0001a3d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a3e0: 2020 2020 2020 2020 7756 616c 7565 2020          wValue  
+0001a3f0: 2020 2020 2020 2020 3d20 3078 3230 2c0a          = 0x20,.
+0001a400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a410: 2020 2020 2020 2020 2020 2020 2020 7749                wI
+0001a420: 6e64 6578 2020 2020 2020 2020 2020 3d20  ndex          = 
+0001a430: 7661 6c75 652c 0a20 2020 2020 2020 2020  value,.         
+0001a440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a450: 2020 2020 2064 6174 615f 6f72 5f77 4c65       data_or_wLe
+0001a460: 6e67 7468 203d 205b 305d 202a 2038 2c0a  ngth = [0] * 8,.
+0001a470: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a480: 2020 2020 2020 2020 2020 2020 2020 6c61                la
+0001a490: 6265 6c20 2020 2020 2020 2020 2020 3d20  bel           = 
+0001a4a0: 2253 4554 5f52 414d 414e 5f44 454c 4159  "SET_RAMAN_DELAY
+0001a4b0: 5f4d 5322 290a 0a20 2020 2064 6566 2067  _MS")..    def g
+0001a4c0: 6574 5f6c 6173 6572 5f77 6174 6368 646f  et_laser_watchdo
+0001a4d0: 675f 7365 6328 7365 6c66 293a 0a20 2020  g_sec(self):.   
+0001a4e0: 2020 2020 2072 6573 203d 2073 656c 662e       res = self.
+0001a4f0: 6765 745f 7570 7065 725f 636f 6465 2830  get_upper_code(0
+0001a500: 7831 372c 206c 6162 656c 3d22 4745 545f  x17, label="GET_
+0001a510: 4c41 5345 525f 5741 5443 4844 4f47 5f53  LASER_WATCHDOG_S
+0001a520: 4543 222c 206d 7362 5f6c 656e 3d32 290a  EC", msb_len=2).
+0001a530: 2020 2020 2020 2020 7365 6c66 2e73 6574          self.set
+0001a540: 7469 6e67 732e 7374 6174 652e 6c61 7365  tings.state.lase
+0001a550: 725f 7761 7463 6864 6f67 5f73 6563 203d  r_watchdog_sec =
+0001a560: 2072 6573 2e64 6174 610a 2020 2020 2020   res.data.      
+0001a570: 2020 7265 7475 726e 2072 6573 0a0a 2020    return res..  
+0001a580: 2020 2320 406e 6f74 6520 756e 7469 6c20    # @note until 
+0001a590: 7468 6973 2063 6861 6e67 6520 6973 206d  this change is m
+0001a5a0: 696d 6963 6b27 6420 696e 2074 6865 2053  imick'd in the S
+0001a5b0: 544d 3332 2028 616e 6420 6166 7465 7220  TM32 (and after 
+0001a5c0: 7468 6174 2c20 756e 7469 6c20 7468 6520  that, until the 
+0001a5d0: 4650 4741 0a20 2020 2023 2020 2020 2020  FPGA.    #      
+0001a5e0: 206c 6f67 6963 2069 7473 656c 6620 6973   logic itself is
+0001a5f0: 2066 6978 6564 292c 2061 6c77 6179 7320   fixed), always 
+0001a600: 7365 6e64 2061 2044 4953 4142 4c45 5f4c  send a DISABLE_L
+0001a610: 4153 4552 2062 6566 6f72 6520 6368 616e  ASER before chan
+0001a620: 6769 6e67 2074 6865 200a 2020 2020 2320  ging the .    # 
+0001a630: 2020 2020 2020 7761 7463 6864 6f67 2070        watchdog p
+0001a640: 6572 696f 642e 0a20 2020 2064 6566 2073  eriod..    def s
+0001a650: 6574 5f6c 6173 6572 5f77 6174 6368 646f  et_laser_watchdo
+0001a660: 675f 7365 6328 7365 6c66 2c20 7365 6329  g_sec(self, sec)
+0001a670: 3a0a 2020 2020 2020 2020 6966 206e 6f74  :.        if not
+0001a680: 2073 656c 662e 7365 7474 696e 6773 2e69   self.settings.i
+0001a690: 735f 6d69 6372 6f28 293a 0a20 2020 2020  s_micro():.     
+0001a6a0: 2020 2020 2020 206c 6f67 2e65 7272 6f72         log.error
+0001a6b0: 2822 4c61 7365 7220 7761 7463 6864 6f67  ("Laser watchdog
+0001a6c0: 206f 6e6c 7920 7375 7070 6f72 7465 6420   only supported 
+0001a6d0: 6f6e 2053 6572 6965 732d 5853 2229 0a20  on Series-XS"). 
+0001a6e0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0001a6f0: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
+0001a700: 7370 6f6e 7365 2864 6174 613d 4661 6c73  sponse(data=Fals
+0001a710: 652c 6572 726f 725f 6d73 673d 226c 6173  e,error_msg="las
+0001a720: 6572 2077 6174 6368 646f 6720 6e6f 7420  er watchdog not 
+0001a730: 7375 7070 6f72 7465 6422 290a 0a20 2020  supported")..   
+0001a740: 2020 2020 2023 2072 656d 6f76 6520 7468       # remove th
+0001a750: 6973 2063 616c 6c20 6166 7465 7220 7468  is call after th
+0001a760: 6520 5365 7269 6573 2d58 5320 4152 4d20  e Series-XS ARM 
+0001a770: 2f20 4650 4741 2077 6174 6368 646f 6720  / FPGA watchdog 
+0001a780: 6172 6520 6669 7865 640a 2020 2020 2020  are fixed.      
+0001a790: 2020 2320 4d5a 3a20 6172 6520 7468 6579    # MZ: are they
+0001a7a0: 2066 6978 6564 3f20 6361 6e20 4920 7265   fixed? can I re
+0001a7b0: 6d6f 7665 2074 6869 733f 0a20 2020 2020  move this?.     
+0001a7c0: 2020 2023 2073 656c 662e 7365 745f 6c61     # self.set_la
+0001a7d0: 7365 725f 656e 6162 6c65 2846 616c 7365  ser_enable(False
+0001a7e0: 290a 0a20 2020 2020 2020 2023 2073 656e  )..        # sen
+0001a7f0: 6420 7661 6c75 6520 6173 2062 6967 2d65  d value as big-e
+0001a800: 6e64 6961 6e0a 2020 2020 2020 2020 6d73  ndian.        ms
+0001a810: 6220 3d20 2873 6563 203e 3e20 3829 2026  b = (sec >> 8) &
+0001a820: 2030 7866 660a 2020 2020 2020 2020 6c73   0xff.        ls
+0001a830: 6220 3d20 2073 6563 2020 2020 2020 2026  b =  sec       &
+0001a840: 2030 7866 660a 2020 2020 2020 2020 7661   0xff.        va
+0001a850: 6c75 6520 3d20 286d 7362 203c 3c20 3829  lue = (msb << 8)
+0001a860: 207c 206c 7362 0a0a 2020 2020 2020 2020   | lsb..        
+0001a870: 7365 6c66 2e73 6574 7469 6e67 732e 7374  self.settings.st
+0001a880: 6174 652e 6c61 7365 725f 7761 7463 6864  ate.laser_watchd
+0001a890: 6f67 5f73 6563 203d 2073 6563 0a20 2020  og_sec = sec.   
+0001a8a0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+0001a8b0: 2e5f 7365 6e64 5f63 6f64 6528 6252 6571  ._send_code(bReq
+0001a8c0: 7565 7374 2020 2020 2020 2020 3d20 3078  uest        = 0x
+0001a8d0: 6666 2c0a 2020 2020 2020 2020 2020 2020  ff,.            
+0001a8e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a8f0: 2020 7756 616c 7565 2020 2020 2020 2020    wValue        
+0001a900: 2020 3d20 3078 3138 2c0a 2020 2020 2020    = 0x18,.      
+0001a910: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a920: 2020 2020 2020 2020 7749 6e64 6578 2020          wIndex  
+0001a930: 2020 2020 2020 2020 3d20 7661 6c75 652c          = value,
+0001a940: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001a950: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+0001a960: 6174 615f 6f72 5f77 4c65 6e67 7468 203d  ata_or_wLength =
+0001a970: 205b 305d 202a 2038 2c0a 2020 2020 2020   [0] * 8,.      
+0001a980: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a990: 2020 2020 2020 2020 6c61 6265 6c20 2020          label   
+0001a9a0: 2020 2020 2020 2020 3d20 2253 4554 5f4c          = "SET_L
+0001a9b0: 4153 4552 5f57 4154 4348 444f 475f 5345  ASER_WATCHDOG_SE
+0001a9c0: 4322 290a 0a20 2020 2064 6566 2075 7064  C")..    def upd
+0001a9d0: 6174 655f 6c61 7365 725f 7761 7463 6864  ate_laser_watchd
+0001a9e0: 6f67 2873 656c 6629 3a0a 2020 2020 2020  og(self):.      
+0001a9f0: 2020 2222 220a 2020 2020 2020 2020 4175    """.        Au
+0001aa00: 746f 6d61 7469 6361 6c6c 7920 7365 7420  tomatically set 
+0001aa10: 7468 6520 6c61 7365 7220 7761 7463 6864  the laser watchd
+0001aa20: 6f67 206c 6f6e 6720 656e 6f75 6768 2074  og long enough t
+0001aa30: 6f20 6861 6e64 6c65 2074 6865 2063 7572  o handle the cur
+0001aa40: 7265 6e74 0a20 2020 2020 2020 2069 6e74  rent.        int
+0001aa50: 6567 7261 7469 6f6e 2074 696d 652c 2061  egration time, a
+0001aa60: 7373 756d 696e 6720 7765 2068 6176 6520  ssuming we have 
+0001aa70: 746f 2070 6572 666f 726d 2036 2074 6872  to perform 6 thr
+0001aa80: 6f77 6177 6179 7320 6f6e 2074 6865 2073  owaways on the s
+0001aa90: 656e 736f 720a 2020 2020 2020 2020 696e  ensor.        in
+0001aaa0: 2063 6173 6520 6974 2077 656e 7420 746f   case it went to
+0001aab0: 2073 6c65 6570 2e0a 0a20 2020 2020 2020   sleep...       
+0001aac0: 2040 6e6f 7465 2077 6520 6172 6520 6e6f   @note we are no
+0001aad0: 7420 6375 7272 656e 746c 7920 7573 696e  t currently usin
+0001aae0: 6720 7468 6973 2066 756e 6374 696f 6e0a  g this function.
+0001aaf0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+0001ab00: 2020 2020 6966 206e 6f74 2073 656c 662e      if not self.
+0001ab10: 7365 7474 696e 6773 2e69 735f 6d69 6372  settings.is_micr
+0001ab20: 6f28 2920 6f72 206e 6f74 2073 656c 662e  o() or not self.
+0001ab30: 7365 7474 696e 6773 2e65 6570 726f 6d2e  settings.eeprom.
+0001ab40: 6861 735f 6c61 7365 723a 0a20 2020 2020  has_laser:.     
+0001ab50: 2020 2020 2020 2072 6574 7572 6e20 5370         return Sp
+0001ab60: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
+0001ab70: 7365 2864 6174 613d 4661 6c73 652c 6572  se(data=False,er
+0001ab80: 726f 725f 6d73 673d 2275 7064 6174 6520  ror_msg="update 
+0001ab90: 6c61 7365 7220 7761 7463 6864 6f67 206e  laser watchdog n
+0001aba0: 6f74 2073 7570 706f 7274 6564 2229 0a0a  ot supported")..
+0001abb0: 2020 2020 2020 2020 696e 745f 6d73 203d          int_ms =
+0001abc0: 2073 656c 662e 7365 7474 696e 6773 2e73   self.settings.s
+0001abd0: 7461 7465 2e69 6e74 6567 7261 7469 6f6e  tate.integration
+0001abe0: 5f74 696d 655f 6d73 0a20 2020 2020 2020  _time_ms.       
+0001abf0: 2073 6361 6e73 2020 3d20 7365 6c66 2e73   scans  = self.s
+0001ac00: 6574 7469 6e67 732e 7374 6174 652e 7363  ettings.state.sc
+0001ac10: 616e 735f 746f 5f61 7665 7261 6765 0a20  ans_to_average. 
+0001ac20: 2020 2020 2020 200a 2020 2020 2020 2020         .        
+0001ac30: 7468 726f 7761 7761 7973 5f73 6563 203d  throwaways_sec =
+0001ac40: 2069 6e74 5f6d 7320 2a20 2838 202b 2073   int_ms * (8 + s
+0001ac50: 6361 6e73 2920 2f20 3130 3030 2e30 0a20  cans) / 1000.0. 
+0001ac60: 2020 2020 2020 2077 6174 6368 646f 675f         watchdog_
+0001ac70: 7365 6320 3d20 696e 7428 6d61 7828 3130  sec = int(max(10
+0001ac80: 2c20 7468 726f 7761 7761 7973 5f73 6563  , throwaways_sec
+0001ac90: 2929 202a 2032 0a20 2020 2020 2020 206c  )) * 2.        l
+0001aca0: 6f67 2e64 6562 7567 2866 2275 7064 6174  og.debug(f"updat
+0001acb0: 696e 6720 6c61 7365 7220 7761 7463 6864  ing laser watchd
+0001acc0: 6f67 2074 6f20 7b77 6174 6368 646f 675f  og to {watchdog_
+0001acd0: 7365 637d 2062 6173 6564 206f 6e20 696e  sec} based on in
+0001ace0: 7465 6772 6174 696f 6e20 7469 6d65 207b  tegration time {
+0001acf0: 696e 745f 6d73 7d6d 7320 616e 6420 7b73  int_ms}ms and {s
+0001ad00: 6361 6e73 7d20 6176 6572 6167 696e 6722  cans} averaging"
+0001ad10: 290a 0a20 2020 2020 2020 2072 6574 7572  )..        retur
+0001ad20: 6e20 7365 6c66 2e73 6574 5f6c 6173 6572  n self.set_laser
+0001ad30: 5f77 6174 6368 646f 675f 7365 6328 7761  _watchdog_sec(wa
+0001ad40: 7463 6864 6f67 5f73 6563 290a 0a20 2020  tchdog_sec)..   
+0001ad50: 2064 6566 2073 6574 5f76 6572 7469 6361   def set_vertica
+0001ad60: 6c5f 6269 6e6e 696e 6728 7365 6c66 2c20  l_binning(self, 
+0001ad70: 6c69 6e65 733a 2074 7570 6c65 5b69 6e74  lines: tuple[int
+0001ad80: 2c20 696e 745d 293a 0a20 2020 2020 2020  , int]):.       
+0001ad90: 2023 2063 6865 636b 2066 6f72 206c 6567   # check for leg
+0001ada0: 6163 7920 7669 7320 7369 6e63 6520 7468  acy vis since th
+0001adb0: 6579 2064 6f6e 2774 206c 696b 6520 7665  ey don't like ve
+0001adc0: 7274 6963 616c 2062 696e 6e69 6e67 0a20  rtical binning. 
+0001add0: 2020 2020 2020 2069 6620 7365 6c66 2e73         if self.s
+0001ade0: 6574 7469 6e67 732e 6670 6761 5f66 6972  ettings.fpga_fir
+0001adf0: 6d77 6172 655f 7665 7273 696f 6e20 3d3d  mware_version ==
+0001ae00: 2022 3030 302d 3030 3822 2061 6e64 2073   "000-008" and s
+0001ae10: 656c 662e 7365 7474 696e 6773 2e6d 6963  elf.settings.mic
+0001ae20: 726f 636f 6e74 726f 6c6c 6572 5f66 6972  rocontroller_fir
+0001ae30: 6d77 6172 655f 7665 7273 696f 6e20 3d3d  mware_version ==
+0001ae40: 2022 302e 312e 302e 3722 3a0a 2020 2020   "0.1.0.7":.    
+0001ae50: 2020 2020 2020 2020 7265 7475 726e 2053          return S
+0001ae60: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
+0001ae70: 6e73 6528 6461 7461 3d46 616c 7365 290a  nse(data=False).
+0001ae80: 2020 2020 2020 2020 6966 206e 6f74 2073          if not s
+0001ae90: 656c 662e 7365 7474 696e 6773 2e69 735f  elf.settings.is_
+0001aea0: 6d69 6372 6f28 293a 0a20 2020 2020 2020  micro():.       
+0001aeb0: 2020 2020 206c 6f67 2e64 6562 7567 2822       log.debug("
+0001aec0: 5665 7274 6963 616c 2042 696e 6e69 6e67  Vertical Binning
+0001aed0: 206f 6e6c 7920 636f 6e66 6967 7572 6162   only configurab
+0001aee0: 6c65 206f 6e20 5365 7269 6573 2d58 5322  le on Series-XS"
+0001aef0: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+0001af00: 7475 726e 2053 7065 6374 726f 6d65 7465  turn Spectromete
+0001af10: 7252 6573 706f 6e73 6528 6461 7461 3d46  rResponse(data=F
+0001af20: 616c 7365 2c65 7272 6f72 5f6d 7367 3d22  alse,error_msg="
+0001af30: 7665 7274 6963 616c 2062 696e 6e69 6e67  vertical binning
+0001af40: 206e 6f74 2073 7570 706f 7274 6564 2229   not supported")
+0001af50: 0a0a 2020 2020 2020 2020 7472 793a 0a20  ..        try:. 
+0001af60: 2020 2020 2020 2020 2020 2073 7461 7274             start
+0001af70: 203d 206c 696e 6573 5b30 5d0a 2020 2020   = lines[0].    
+0001af80: 2020 2020 2020 2020 656e 6420 2020 3d20          end   = 
+0001af90: 6c69 6e65 735b 315d 0a20 2020 2020 2020  lines[1].       
+0001afa0: 2065 7863 6570 743a 0a20 2020 2020 2020   except:.       
+0001afb0: 2020 2020 206c 6f67 2e65 7272 6f72 2822       log.error("
+0001afc0: 7365 745f 7665 7274 6963 616c 5f62 696e  set_vertical_bin
+0001afd0: 6e69 6e67 2072 6571 7569 7265 7320 6120  ning requires a 
+0001afe0: 7475 706c 6520 6f66 2028 7374 6172 742c  tuple of (start,
+0001aff0: 2073 746f 7029 206c 696e 6573 2229 0a20   stop) lines"). 
+0001b000: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0001b010: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
+0001b020: 7370 6f6e 7365 2864 6174 613d 4661 6c73  sponse(data=Fals
+0001b030: 652c 6572 726f 725f 6d73 673d 2269 6e76  e,error_msg="inv
+0001b040: 616c 6964 2073 7461 7274 2061 6e64 2073  alid start and s
+0001b050: 746f 7020 6c69 6e65 7322 290a 0a20 2020  top lines")..   
+0001b060: 2020 2020 2069 6620 7374 6172 7420 3c20       if start < 
+0001b070: 3020 6f72 2065 6e64 203c 2030 3a0a 2020  0 or end < 0:.  
+0001b080: 2020 2020 2020 2020 2020 6c6f 672e 6572            log.er
+0001b090: 726f 7228 2273 6574 5f76 6572 7469 6361  ror("set_vertica
+0001b0a0: 6c5f 6269 6e6e 696e 6720 7265 7175 6972  l_binning requir
+0001b0b0: 6573 2061 2074 7570 6c65 206f 6620 504f  es a tuple of PO
+0001b0c0: 5349 5449 5645 2028 7374 6172 742c 2073  SITIVE (start, s
+0001b0d0: 746f 7029 206c 696e 6573 2229 0a20 2020  top) lines").   
+0001b0e0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0001b0f0: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
+0001b100: 6f6e 7365 2864 6174 613d 4661 6c73 652c  onse(data=False,
+0001b110: 6572 726f 725f 6d73 673d 2269 6e76 616c  error_msg="inval
+0001b120: 6964 2073 7461 7274 2061 6e64 2073 746f  id start and sto
+0001b130: 7020 6c69 6e65 7322 290a 0a20 2020 2020  p lines")..     
+0001b140: 2020 2023 2065 6e66 6f72 6365 2061 7363     # enforce asc
+0001b150: 656e 6469 6e67 206f 7264 6572 2028 616c  ending order (al
+0001b160: 736f 2c20 6e6f 7465 2074 6861 7420 7374  so, note that st
+0001b170: 6f70 206c 696e 6520 6973 2022 6c61 7374  op line is "last
+0001b180: 206c 696e 6520 6269 6e6e 6564 202b 2031   line binned + 1
+0001b190: 222c 2073 6f20 7374 6f70 206d 7573 7420  ", so stop must 
+0001b1a0: 6265 203e 2073 7461 7274 290a 2020 2020  be > start).    
+0001b1b0: 2020 2020 6966 2073 7461 7274 203e 3d20      if start >= 
+0001b1c0: 656e 643a 0a20 2020 2020 2020 2020 2020  end:.           
+0001b1d0: 2023 2028 7374 6172 742c 2065 6e64 2920   # (start, end) 
+0001b1e0: 3d20 2865 6e64 2c20 7374 6172 7429 0a20  = (end, start). 
+0001b1f0: 2020 2020 2020 2020 2020 206c 6f67 2e65             log.e
+0001b200: 7272 6f72 2822 7365 745f 7665 7274 6963  rror("set_vertic
+0001b210: 616c 5f62 696e 6e69 6e67 2072 6571 7569  al_binning requi
+0001b220: 7265 7320 6173 6365 6e64 696e 6720 6f72  res ascending or
+0001b230: 6465 7220 2869 676e 6f72 696e 6720 2564  der (ignoring %d
+0001b240: 2c20 2564 2922 2c20 7374 6172 742c 2065  , %d)", start, e
+0001b250: 6e64 290a 2020 2020 2020 2020 2020 2020  nd).            
+0001b260: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
+0001b270: 7465 7252 6573 706f 6e73 6528 6461 7461  terResponse(data
+0001b280: 3d46 616c 7365 2c65 7272 6f72 5f6d 7367  =False,error_msg
+0001b290: 3d22 696e 7661 6c69 6420 7374 6172 7420  ="invalid start 
+0001b2a0: 616e 6420 7374 6f70 206c 696e 6573 2229  and stop lines")
+0001b2b0: 0a0a 2020 2020 2020 2020 6f6b 3120 3d20  ..        ok1 = 
+0001b2c0: 7365 6c66 2e5f 7365 6e64 5f63 6f64 6528  self._send_code(
+0001b2d0: 6252 6571 7565 7374 2020 2020 2020 2020  bRequest        
+0001b2e0: 3d20 3078 6666 2c0a 2020 2020 2020 2020  = 0xff,.        
+0001b2f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b300: 2020 2020 2077 5661 6c75 6520 2020 2020       wValue     
+0001b310: 2020 2020 203d 2030 7832 312c 0a20 2020       = 0x21,.   
+0001b320: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b330: 2020 2020 2020 2020 2020 7749 6e64 6578            wIndex
+0001b340: 2020 2020 2020 2020 2020 3d20 7374 6172            = star
+0001b350: 742c 0a20 2020 2020 2020 2020 2020 2020  t,.             
+0001b360: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b370: 6461 7461 5f6f 725f 774c 656e 6774 6820  data_or_wLength 
+0001b380: 3d20 5b30 5d20 2a20 382c 0a20 2020 2020  = [0] * 8,.     
+0001b390: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b3a0: 2020 2020 2020 2020 6c61 6265 6c20 2020          label   
+0001b3b0: 2020 2020 2020 2020 3d20 2253 4554 5f43          = "SET_C
+0001b3c0: 4344 5f53 5441 5254 5f4c 494e 4522 290a  CD_START_LINE").
+0001b3d0: 2020 2020 2020 2020 6966 206f 6b31 2e65          if ok1.e
+0001b3e0: 7272 6f72 5f6d 7367 2021 3d20 2727 3a0a  rror_msg != '':.
+0001b3f0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0001b400: 726e 206f 6b31 0a0a 2020 2020 2020 2020  rn ok1..        
+0001b410: 6f6b 3220 3d20 7365 6c66 2e5f 7365 6e64  ok2 = self._send
+0001b420: 5f63 6f64 6528 6252 6571 7565 7374 2020  _code(bRequest  
+0001b430: 2020 2020 2020 3d20 3078 6666 2c0a 2020        = 0xff,.  
 0001b440: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b450: 2020 2020 2064 6174 615f 6f72 5f77 4c65       data_or_wLe
-0001b460: 6e67 7468 203d 205b 305d 202a 2038 2c0d  ngth = [0] * 8,.
-0001b470: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001b480: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-0001b490: 6162 656c 2020 2020 2020 2020 2020 203d  abel           =
-0001b4a0: 2022 5345 545f 4641 4e5f 454e 4142 4c45   "SET_FAN_ENABLE
-0001b4b0: 2229 0d0a 0d0a 2020 2020 6465 6620 6765  ")....    def ge
-0001b4c0: 745f 6661 6e5f 656e 6162 6c65 6428 7365  t_fan_enabled(se
-0001b4d0: 6c66 293a 2023 202d 3e20 5370 6563 7472  lf): # -> Spectr
-0001b4e0: 6f6d 6574 6572 5265 7370 6f6e 7365 200d  ometerResponse .
-0001b4f0: 0a20 2020 2020 2020 2069 6620 6e6f 7420  .        if not 
-0001b500: 7365 6c66 2e73 6574 7469 6e67 732e 6973  self.settings.is
-0001b510: 5f67 656e 3135 2829 3a0d 0a20 2020 2020  _gen15():..     
-0001b520: 2020 2020 2020 206c 6f67 2e65 7272 6f72         log.error
-0001b530: 2822 6661 6e20 7265 7175 6972 6573 2047  ("fan requires G
-0001b540: 656e 2031 2e35 2229 0d0a 2020 2020 2020  en 1.5")..      
-0001b550: 2020 2020 2020 7265 7475 726e 2053 7065        return Spe
-0001b560: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
-0001b570: 6528 6461 7461 3d46 616c 7365 2c65 7272  e(data=False,err
-0001b580: 6f72 5f6d 7367 3d22 6661 6e20 7265 7175  or_msg="fan requ
-0001b590: 6972 6573 2067 656e 312e 3522 290d 0a20  ires gen1.5").. 
-0001b5a0: 2020 2020 2020 2072 6574 7572 6e20 5370         return Sp
-0001b5b0: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-0001b5c0: 7365 2864 6174 613d 3020 213d 2073 656c  se(data=0 != sel
-0001b5d0: 662e 5f67 6574 5f63 6f64 6528 3078 3337  f._get_code(0x37
-0001b5e0: 2c20 6c61 6265 6c3d 2247 4554 5f46 414e  , label="GET_FAN
-0001b5f0: 5f45 4e41 424c 4544 222c 206d 7362 5f6c  _ENABLED", msb_l
-0001b600: 656e 3d31 2929 0d0a 0d0a 2020 2020 2320  en=1))....    # 
-0001b610: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b620: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b630: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b640: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b650: 2323 2323 2323 2323 2323 0d0a 2020 2020  ##########..    
-0001b660: 2320 4c61 6d70 0d0a 2020 2020 2320 2323  # Lamp..    # ##
-0001b670: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b680: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b690: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b6a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b6b0: 2323 2323 2323 2323 0d0a 0d0a 2020 2020  ########....    
-0001b6c0: 6465 6620 7365 745f 6c61 6d70 5f65 6e61  def set_lamp_ena
-0001b6d0: 626c 6528 7365 6c66 2c20 666c 6167 3a20  ble(self, flag: 
-0001b6e0: 626f 6f6c 293a 2023 202d 3e20 5370 6563  bool): # -> Spec
-0001b6f0: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
-0001b700: 200d 0a20 2020 2020 2020 2069 6620 6e6f   ..        if no
-0001b710: 7420 7365 6c66 2e73 6574 7469 6e67 732e  t self.settings.
-0001b720: 6973 5f67 656e 3135 2829 3a0d 0a20 2020  is_gen15():..   
-0001b730: 2020 2020 2020 2020 206c 6f67 2e64 6562           log.deb
-0001b740: 7567 2822 6c61 6d70 2072 6571 7569 7265  ug("lamp require
-0001b750: 7320 4765 6e20 312e 3522 290d 0a20 2020  s Gen 1.5")..   
-0001b760: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0001b770: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
-0001b780: 6f6e 7365 2864 6174 613d 4661 6c73 652c  onse(data=False,
-0001b790: 6572 726f 725f 6d73 673d 226c 616d 7020  error_msg="lamp 
-0001b7a0: 7265 7175 6972 6573 2067 656e 312e 3522  requires gen1.5"
-0001b7b0: 290d 0a20 2020 2020 2020 2076 616c 7565  )..        value
-0001b7c0: 203d 2031 2069 6620 666c 6167 2065 6c73   = 1 if flag els
-0001b7d0: 6520 300d 0a20 2020 2020 2020 2072 6574  e 0..        ret
-0001b7e0: 7572 6e20 7365 6c66 2e5f 7365 6e64 5f63  urn self._send_c
-0001b7f0: 6f64 6528 6252 6571 7565 7374 2020 2020  ode(bRequest    
-0001b800: 2020 2020 3d20 3078 3332 2c0d 0a20 2020      = 0x32,..   
-0001b810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b820: 2020 2020 2020 2020 2020 2077 5661 6c75             wValu
-0001b830: 6520 2020 2020 2020 2020 203d 2076 616c  e          = val
-0001b840: 7565 2c0d 0a20 2020 2020 2020 2020 2020  ue,..           
+0001b450: 2020 2020 2020 2020 2020 2077 5661 6c75             wValu
+0001b460: 6520 2020 2020 2020 2020 203d 2030 7832  e          = 0x2
+0001b470: 332c 0a20 2020 2020 2020 2020 2020 2020  3,.             
+0001b480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b490: 7749 6e64 6578 2020 2020 2020 2020 2020  wIndex          
+0001b4a0: 3d20 656e 642c 0a20 2020 2020 2020 2020  = end,.         
+0001b4b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b4c0: 2020 2020 6461 7461 5f6f 725f 774c 656e      data_or_wLen
+0001b4d0: 6774 6820 3d20 5b30 5d20 2a20 382c 0a20  gth = [0] * 8,. 
+0001b4e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b4f0: 2020 2020 2020 2020 2020 2020 6c61 6265              labe
+0001b500: 6c20 2020 2020 2020 2020 2020 3d20 2253  l           = "S
+0001b510: 4554 5f43 4344 5f53 544f 505f 4c49 4e45  ET_CCD_STOP_LINE
+0001b520: 2229 0a20 2020 2020 2020 2069 6620 6f6b  ").        if ok
+0001b530: 322e 6572 726f 725f 6d73 6720 213d 2027  2.error_msg != '
+0001b540: 273a 0a20 2020 2020 2020 2020 2020 2072  ':.            r
+0001b550: 6574 7572 6e20 6f6b 320a 2020 2020 2020  eturn ok2.      
+0001b560: 2020 7265 7475 726e 2053 7065 6374 726f    return Spectro
+0001b570: 6d65 7465 7252 6573 706f 6e73 6528 6461  meterResponse(da
+0001b580: 7461 3d6f 6b31 2e64 6174 6120 616e 6420  ta=ok1.data and 
+0001b590: 6f6b 322e 6461 7461 290a 0a20 2020 2023  ok2.data)..    #
+0001b5a0: 2320 0a20 2020 2023 2040 7061 7261 6d20  # .    # @param 
+0001b5b0: 6d6f 6465 3a20 696e 7465 6772 616c 2076  mode: integral v
+0001b5c0: 616c 7565 2030 2d33 0a20 2020 2023 0a20  alue 0-3.    #. 
+0001b5d0: 2020 2023 205c 7665 7262 6174 696d 0a20     # \verbatim. 
+0001b5e0: 2020 2023 206d 6f64 6520 2041 4443 2028     # mode  ADC (
+0001b5f0: 4144 2920 2020 5069 7865 6c20 5769 6474  AD)   Pixel Widt
+0001b600: 6820 284f 4429 0a20 2020 2023 2062 3030  h (OD).    # b00
+0001b610: 2020 2031 302d 6269 7420 2020 2020 3130     10-bit     10
+0001b620: 2d62 6974 0a20 2020 2023 2062 3031 2020  -bit.    # b01  
+0001b630: 2031 302d 6269 7420 2020 2020 3132 2d62   10-bit     12-b
+0001b640: 6974 0a20 2020 2023 2062 3130 2020 2031  it.    # b10   1
+0001b650: 322d 6269 7420 2020 2020 3130 2d62 6974  2-bit     10-bit
+0001b660: 0a20 2020 2023 2062 3131 2020 2031 322d  .    # b11   12-
+0001b670: 6269 7420 2020 2020 3132 2d62 6974 0a20  bit     12-bit. 
+0001b680: 2020 2023 205c 656e 6476 6572 6261 7469     # \endverbati
+0001b690: 6d0a 2020 2020 6465 6620 7365 745f 7069  m.    def set_pi
+0001b6a0: 7865 6c5f 6d6f 6465 2873 656c 662c 206d  xel_mode(self, m
+0001b6b0: 6f64 653a 2066 6c6f 6174 293a 0a20 2020  ode: float):.   
+0001b6c0: 2020 2020 2069 6620 6e6f 7420 7365 6c66       if not self
+0001b6d0: 2e73 6574 7469 6e67 732e 6973 5f6d 6963  .settings.is_mic
+0001b6e0: 726f 2829 3a0a 2020 2020 2020 2020 2020  ro():.          
+0001b6f0: 2020 6c6f 672e 6465 6275 6728 2250 6978    log.debug("Pix
+0001b700: 656c 204d 6f64 6520 6f6e 6c79 2063 6f6e  el Mode only con
+0001b710: 6669 6775 7261 626c 6520 6f6e 2053 6572  figurable on Ser
+0001b720: 6965 732d 5853 2229 0a20 2020 2020 2020  ies-XS").       
+0001b730: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
+0001b740: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
+0001b750: 2864 6174 613d 4661 6c73 652c 6572 726f  (data=False,erro
+0001b760: 725f 6d73 673d 2270 6978 656c 206d 6f64  r_msg="pixel mod
+0001b770: 6520 6e6f 7420 7375 7070 6f72 7465 6422  e not supported"
+0001b780: 290a 0a20 2020 2020 2020 2023 2077 6520  )..        # we 
+0001b790: 6f6e 6c79 2063 6172 6520 6162 6f75 7420  only care about 
+0001b7a0: 7468 6520 7477 6f20 6c65 6173 742d 7369  the two least-si
+0001b7b0: 676e 6966 6963 616e 7420 6269 7473 0a20  gnificant bits. 
+0001b7c0: 2020 2020 2020 206d 6f64 6520 3d20 696e         mode = in
+0001b7d0: 7428 726f 756e 6428 6d6f 6465 2929 2026  t(round(mode)) &
+0001b7e0: 2030 7833 200a 0a20 2020 2020 2020 2072   0x3 ..        r
+0001b7f0: 6573 756c 7420 3d20 7365 6c66 2e5f 7365  esult = self._se
+0001b800: 6e64 5f63 6f64 6528 6252 6571 7565 7374  nd_code(bRequest
+0001b810: 203d 2030 7866 642c 0a20 2020 2020 2020   = 0xfd,.       
+0001b820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b830: 2020 2020 2020 2020 2077 5661 6c75 6520           wValue 
+0001b840: 2020 3d20 6d6f 6465 2c0a 2020 2020 2020    = mode,.      
 0001b850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b860: 2020 2077 496e 6465 7820 2020 2020 2020     wIndex       
-0001b870: 2020 203d 2030 2c0d 0a20 2020 2020 2020     = 0,..       
-0001b880: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b890: 2020 2020 2020 2064 6174 615f 6f72 5f77         data_or_w
-0001b8a0: 4c65 6e67 7468 203d 205b 305d 202a 2038  Length = [0] * 8
-0001b8b0: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-0001b8c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b8d0: 206c 6162 656c 2020 2020 2020 2020 2020   label          
-0001b8e0: 203d 2022 5345 545f 4c41 4d50 5f45 4e41   = "SET_LAMP_ENA
-0001b8f0: 424c 4522 290d 0a0d 0a20 2020 2064 6566  BLE")....    def
-0001b900: 2067 6574 5f6c 616d 705f 656e 6162 6c65   get_lamp_enable
-0001b910: 6428 7365 6c66 293a 2023 202d 3e20 5370  d(self): # -> Sp
-0001b920: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-0001b930: 7365 200d 0a20 2020 2020 2020 2069 6620  se ..        if 
-0001b940: 6e6f 7420 7365 6c66 2e73 6574 7469 6e67  not self.setting
-0001b950: 732e 6973 5f67 656e 3135 2829 3a0d 0a20  s.is_gen15():.. 
-0001b960: 2020 2020 2020 2020 2020 206c 6f67 2e65             log.e
-0001b970: 7272 6f72 2822 6c61 6d70 2072 6571 7569  rror("lamp requi
-0001b980: 7265 7320 4765 6e20 312e 3522 290d 0a20  res Gen 1.5").. 
-0001b990: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-0001b9a0: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
-0001b9b0: 7370 6f6e 7365 2864 6174 613d 4661 6c73  sponse(data=Fals
-0001b9c0: 652c 6572 726f 725f 6d73 673d 226c 616d  e,error_msg="lam
-0001b9d0: 7020 7265 7175 6972 6573 2067 656e 312e  p requires gen1.
-0001b9e0: 3522 290d 0a20 2020 2020 2020 2072 6573  5")..        res
-0001b9f0: 203d 2073 656c 662e 5f67 6574 5f63 6f64   = self._get_cod
-0001ba00: 6528 3078 3333 2c20 6c61 6265 6c3d 2247  e(0x33, label="G
-0001ba10: 4554 5f4c 414d 505f 454e 4142 4c45 4422  ET_LAMP_ENABLED"
-0001ba20: 2c20 6d73 625f 6c65 6e3d 3129 0d0a 2020  , msb_len=1)..  
-0001ba30: 2020 2020 2020 7265 732e 6461 7461 203d        res.data =
-0001ba40: 2030 2021 3d20 7265 732e 6461 7461 0d0a   0 != res.data..
-0001ba50: 2020 2020 2020 2020 7265 7475 726e 2072          return r
-0001ba60: 6573 0d0a 0d0a 2020 2020 2320 2323 2323  es....    # ####
-0001ba70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ba80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ba90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001baa0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001bab0: 2323 2323 2323 0d0a 2020 2020 2320 5368  ######..    # Sh
-0001bac0: 7574 7465 720d 0a20 2020 2023 2023 2323  utter..    # ###
-0001bad0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001bae0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001baf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001bb00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001bb10: 2323 2323 2323 230d 0a0d 0a20 2020 2064  #######....    d
-0001bb20: 6566 2073 6574 5f73 6875 7474 6572 5f65  ef set_shutter_e
-0001bb30: 6e61 626c 6528 7365 6c66 2c20 666c 6167  nable(self, flag
-0001bb40: 3a20 626f 6f6c 293a 2023 202d 3e20 5370  : bool): # -> Sp
-0001bb50: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-0001bb60: 7365 200d 0a20 2020 2020 2020 2069 6620  se ..        if 
-0001bb70: 6e6f 7420 2873 656c 662e 7365 7474 696e  not (self.settin
-0001bb80: 6773 2e69 735f 6765 6e31 3528 2920 616e  gs.is_gen15() an
-0001bb90: 6420 7365 6c66 2e73 6574 7469 6e67 732e  d self.settings.
-0001bba0: 6565 7072 6f6d 2e68 6173 5f73 6875 7474  eeprom.has_shutt
-0001bbb0: 6572 293a 0d0a 2020 2020 2020 2020 2020  er):..          
-0001bbc0: 2020 6c6f 672e 6465 6275 6728 2273 6875    log.debug("shu
-0001bbd0: 7474 6572 2072 6571 7569 7265 7320 4765  tter requires Ge
-0001bbe0: 6e20 312e 3520 616e 6420 6861 735f 7368  n 1.5 and has_sh
-0001bbf0: 7574 7465 7220 666c 6167 2229 0d0a 2020  utter flag")..  
-0001bc00: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0001bc10: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
-0001bc20: 706f 6e73 6528 6461 7461 3d46 616c 7365  ponse(data=False
-0001bc30: 2c65 7272 6f72 5f6d 7367 3d22 7368 7574  ,error_msg="shut
-0001bc40: 7465 7220 7265 7175 6972 6573 2067 656e  ter requires gen
-0001bc50: 312e 3522 290d 0a20 2020 2020 2020 2076  1.5")..        v
-0001bc60: 616c 7565 203d 2031 2069 6620 666c 6167  alue = 1 if flag
-0001bc70: 2065 6c73 6520 300d 0a20 2020 2020 2020   else 0..       
-0001bc80: 2072 6574 7572 6e20 7365 6c66 2e5f 7365   return self._se
-0001bc90: 6e64 5f63 6f64 6528 6252 6571 7565 7374  nd_code(bRequest
-0001bca0: 2020 2020 2020 2020 3d20 3078 3330 2c0d          = 0x30,.
-0001bcb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001bcc0: 2020 2020 2020 2020 2020 2020 2020 2077                 w
-0001bcd0: 5661 6c75 6520 2020 2020 2020 2020 203d  Value          =
-0001bce0: 2076 616c 7565 2c0d 0a20 2020 2020 2020   value,..       
-0001bcf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001bd00: 2020 2020 2020 2077 496e 6465 7820 2020         wIndex   
-0001bd10: 2020 2020 2020 203d 2030 2c0d 0a20 2020         = 0,..   
-0001bd20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001bd30: 2020 2020 2020 2020 2020 2064 6174 615f             data_
-0001bd40: 6f72 5f77 4c65 6e67 7468 203d 205b 305d  or_wLength = [0]
-0001bd50: 202a 2038 2c0d 0a20 2020 2020 2020 2020   * 8,..         
-0001bd60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001bd70: 2020 2020 206c 6162 656c 2020 2020 2020       label      
-0001bd80: 2020 2020 203d 2022 5345 545f 5348 5554       = "SET_SHUT
-0001bd90: 5445 525f 454e 4142 4c45 2229 0d0a 0d0a  TER_ENABLE")....
-0001bda0: 2020 2020 6465 6620 6765 745f 7368 7574      def get_shut
-0001bdb0: 7465 725f 656e 6162 6c65 6428 7365 6c66  ter_enabled(self
-0001bdc0: 293a 2023 202d 3e20 5370 6563 7472 6f6d  ): # -> Spectrom
-0001bdd0: 6574 6572 5265 7370 6f6e 7365 200d 0a20  eterResponse .. 
-0001bde0: 2020 2020 2020 2069 6620 6e6f 7420 2873         if not (s
-0001bdf0: 656c 662e 7365 7474 696e 6773 2e69 735f  elf.settings.is_
-0001be00: 6765 6e31 3528 2920 616e 6420 7365 6c66  gen15() and self
-0001be10: 2e73 6574 7469 6e67 732e 6565 7072 6f6d  .settings.eeprom
-0001be20: 2e68 6173 5f73 6875 7474 6572 293a 0d0a  .has_shutter):..
-0001be30: 2020 2020 2020 2020 2020 2020 6c6f 672e              log.
-0001be40: 6465 6275 6728 2273 6875 7474 6572 2072  debug("shutter r
-0001be50: 6571 7569 7265 7320 4765 6e20 312e 3520  equires Gen 1.5 
-0001be60: 616e 6420 6861 735f 7368 7574 7465 7220  and has_shutter 
-0001be70: 666c 6167 2229 0d0a 2020 2020 2020 2020  flag")..        
-0001be80: 2020 2020 7265 7475 726e 2053 7065 6374      return Spect
-0001be90: 726f 6d65 7465 7252 6573 706f 6e73 6528  rometerResponse(
-0001bea0: 6461 7461 3d46 616c 7365 2c65 7272 6f72  data=False,error
-0001beb0: 5f6d 7367 3d22 7368 7574 7465 7220 7265  _msg="shutter re
-0001bec0: 7175 6972 6573 2067 656e 312e 3522 290d  quires gen1.5").
-0001bed0: 0a20 2020 2020 2020 2072 6573 203d 2053  .        res = S
-0001bee0: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
-0001bef0: 6e73 6528 6461 7461 3d30 2021 3d20 7365  nse(data=0 != se
-0001bf00: 6c66 2e5f 6765 745f 636f 6465 2830 7833  lf._get_code(0x3
-0001bf10: 312c 206c 6162 656c 3d22 4745 545f 5348  1, label="GET_SH
-0001bf20: 5554 5445 525f 454e 4142 4c45 4422 2c20  UTTER_ENABLED", 
-0001bf30: 6d73 625f 6c65 6e3d 3129 290d 0a20 2020  msb_len=1))..   
-0001bf40: 2020 2020 2072 6573 2e64 6174 6120 3d20       res.data = 
-0001bf50: 3020 213d 2072 6573 2e64 6174 610d 0a20  0 != res.data.. 
-0001bf60: 2020 2020 2020 2072 6574 7572 6e20 7265         return re
-0001bf70: 7320 0d0a 0d0a 2020 2020 2320 2323 2323  s ....    # ####
-0001bf80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001bf90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001bfa0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001bfb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001bfc0: 2323 2323 2323 0d0a 2020 2020 2320 4c61  ######..    # La
-0001bfd0: 7365 7220 4d6f 6475 6c61 7469 6f6e 2061  ser Modulation a
-0001bfe0: 6e64 2043 6f6e 7469 6e75 6f75 7320 5374  nd Continuous St
-0001bff0: 726f 6265 0d0a 2020 2020 2320 2323 2323  robe..    # ####
-0001c000: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c010: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c020: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c030: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c040: 2323 2323 2323 0d0a 0d0a 2020 2020 6465  ######....    de
-0001c050: 6620 7365 745f 6d6f 645f 656e 6162 6c65  f set_mod_enable
-0001c060: 2873 656c 662c 2066 6c61 673a 2062 6f6f  (self, flag: boo
-0001c070: 6c29 3a20 2320 2d3e 2053 7065 6374 726f  l): # -> Spectro
-0001c080: 6d65 7465 7252 6573 706f 6e73 6520 0d0a  meterResponse ..
-0001c090: 2020 2020 2020 2020 7365 6c66 2e73 6574          self.set
-0001c0a0: 7469 6e67 732e 7374 6174 652e 6d6f 645f  tings.state.mod_
-0001c0b0: 656e 6162 6c65 6420 3d20 666c 6167 0d0a  enabled = flag..
-0001c0c0: 2020 2020 2020 2020 7661 6c75 6520 3d20          value = 
-0001c0d0: 3120 6966 2066 6c61 6720 656c 7365 2030  1 if flag else 0
-0001c0e0: 0d0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-0001c0f0: 2073 656c 662e 5f73 656e 645f 636f 6465   self._send_code
-0001c100: 2830 7862 642c 2076 616c 7565 2c20 6c61  (0xbd, value, la
-0001c110: 6265 6c3d 2253 4554 5f4d 4f44 5f45 4e41  bel="SET_MOD_ENA
-0001c120: 424c 4522 290d 0a0d 0a20 2020 2064 6566  BLE")....    def
-0001c130: 2067 6574 5f6d 6f64 5f65 6e61 626c 6564   get_mod_enabled
-0001c140: 2873 656c 6629 3a20 2320 2d3e 2053 7065  (self): # -> Spe
-0001c150: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
-0001c160: 6520 0d0a 2020 2020 2020 2020 7265 7320  e ..        res 
-0001c170: 3d20 7365 6c66 2e5f 6765 745f 636f 6465  = self._get_code
-0001c180: 2830 7865 332c 206c 6162 656c 3d22 4745  (0xe3, label="GE
-0001c190: 545f 4d4f 445f 454e 4142 4c45 4422 2c20  T_MOD_ENABLED", 
-0001c1a0: 6d73 625f 6c65 6e3d 3129 0d0a 2020 2020  msb_len=1)..    
-0001c1b0: 2020 2020 6966 2072 6573 2e65 7272 6f72      if res.error
-0001c1c0: 5f6d 7367 2021 3d20 2727 3a0d 0a20 2020  _msg != '':..   
-0001c1d0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0001c1e0: 7265 730d 0a20 2020 2020 2020 2066 6c61  res..        fla
-0001c1f0: 6720 3d20 3020 213d 2072 6573 2e64 6174  g = 0 != res.dat
-0001c200: 610d 0a20 2020 2020 2020 2073 656c 662e  a..        self.
-0001c210: 7365 7474 696e 6773 2e73 7461 7465 2e6d  settings.state.m
-0001c220: 6f64 5f65 6e61 626c 6564 203d 2066 6c61  od_enabled = fla
-0001c230: 670d 0a20 2020 2020 2020 2072 6574 7572  g..        retur
-0001c240: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
-0001c250: 7370 6f6e 7365 2864 6174 613d 666c 6167  sponse(data=flag
-0001c260: 290d 0a0d 0a20 2020 2064 6566 2073 6574  )....    def set
-0001c270: 5f6d 6f64 5f70 6572 696f 645f 7573 2873  _mod_period_us(s
-0001c280: 656c 662c 2075 733a 2066 6c6f 6174 293a  elf, us: float):
-0001c290: 2023 202d 3e20 5370 6563 7472 6f6d 6574   # -> Spectromet
-0001c2a0: 6572 5265 7370 6f6e 7365 200d 0a20 2020  erResponse ..   
-0001c2b0: 2020 2020 2073 656c 662e 7365 7474 696e       self.settin
-0001c2c0: 6773 2e73 7461 7465 2e6d 6f64 5f70 6572  gs.state.mod_per
-0001c2d0: 696f 645f 7573 203d 2075 730d 0a20 2020  iod_us = us..   
-0001c2e0: 2020 2020 2028 6c73 772c 206d 7377 2c20       (lsw, msw, 
-0001c2f0: 6275 6629 203d 2073 656c 662e 5f74 6f34  buf) = self._to4
-0001c300: 3062 6974 2875 7329 0d0a 2020 2020 2020  0bit(us)..      
-0001c310: 2020 7265 7475 726e 2073 656c 662e 5f73    return self._s
-0001c320: 656e 645f 636f 6465 2830 7863 372c 206c  end_code(0xc7, l
-0001c330: 7377 2c20 6d73 772c 2062 7566 2c20 6c61  sw, msw, buf, la
-0001c340: 6265 6c3d 2253 4554 5f4d 4f44 5f50 4552  bel="SET_MOD_PER
-0001c350: 494f 4422 290d 0a0d 0a20 2020 2064 6566  IOD")....    def
-0001c360: 2067 6574 5f6d 6f64 5f70 6572 696f 645f   get_mod_period_
-0001c370: 7573 2873 656c 6629 3a20 2320 2d3e 2053  us(self): # -> S
-0001c380: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
-0001c390: 6e73 6520 0d0a 2020 2020 2020 2020 7265  nse ..        re
-0001c3a0: 7375 6c74 203d 2073 656c 662e 5f67 6574  sult = self._get
-0001c3b0: 5f63 6f64 6528 3078 6362 2c20 6c61 6265  _code(0xcb, labe
-0001c3c0: 6c3d 2247 4554 5f4d 4f44 5f50 4552 494f  l="GET_MOD_PERIO
-0001c3d0: 4422 2c20 6c73 625f 6c65 6e3d 3529 0d0a  D", lsb_len=5)..
-0001c3e0: 2020 2020 2020 2020 7365 6c66 2e73 6574          self.set
-0001c3f0: 7469 6e67 732e 7374 6174 652e 6d6f 645f  tings.state.mod_
-0001c400: 7065 7269 6f64 5f75 7320 3d20 7265 7375  period_us = resu
-0001c410: 6c74 0d0a 2020 2020 2020 2020 7265 7475  lt..        retu
-0001c420: 726e 2072 6573 756c 740d 0a0d 0a20 2020  rn result....   
-0001c430: 2064 6566 2073 6574 5f6d 6f64 5f77 6964   def set_mod_wid
-0001c440: 7468 5f75 7328 7365 6c66 2c20 7573 3a20  th_us(self, us: 
-0001c450: 666c 6f61 7429 3a20 2320 2d3e 2053 7065  float): # -> Spe
-0001c460: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
-0001c470: 6520 0d0a 2020 2020 2020 2020 7365 6c66  e ..        self
-0001c480: 2e73 6574 7469 6e67 732e 7374 6174 652e  .settings.state.
-0001c490: 6d6f 645f 7769 6474 685f 7573 203d 2075  mod_width_us = u
-0001c4a0: 730d 0a20 2020 2020 2020 2028 6c73 772c  s..        (lsw,
-0001c4b0: 206d 7377 2c20 6275 6629 203d 2073 656c   msw, buf) = sel
-0001c4c0: 662e 5f74 6f34 3062 6974 2875 7329 0d0a  f._to40bit(us)..
-0001c4d0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-0001c4e0: 656c 662e 5f73 656e 645f 636f 6465 2830  elf._send_code(0
-0001c4f0: 7864 622c 206c 7377 2c20 6d73 772c 2062  xdb, lsw, msw, b
-0001c500: 7566 2c20 6c61 6265 6c3d 2253 4554 5f4d  uf, label="SET_M
-0001c510: 4f44 5f57 4944 5448 2229 0d0a 0d0a 2020  OD_WIDTH")....  
-0001c520: 2020 6465 6620 6765 745f 6d6f 645f 7769    def get_mod_wi
-0001c530: 6474 685f 7573 2873 656c 6629 3a20 2320  dth_us(self): # 
-0001c540: 2d3e 2053 7065 6374 726f 6d65 7465 7252  -> SpectrometerR
-0001c550: 6573 706f 6e73 6520 0d0a 2020 2020 2020  esponse ..      
-0001c560: 2020 7265 7375 6c74 203d 2073 656c 662e    result = self.
-0001c570: 5f67 6574 5f63 6f64 6528 3078 6463 2c20  _get_code(0xdc, 
-0001c580: 6c61 6265 6c3d 2247 4554 5f4d 4f44 5f57  label="GET_MOD_W
-0001c590: 4944 5448 222c 206c 7362 5f6c 656e 3d35  IDTH", lsb_len=5
-0001c5a0: 290d 0a20 2020 2020 2020 2073 656c 662e  )..        self.
-0001c5b0: 7365 7474 696e 6773 2e73 7461 7465 2e6d  settings.state.m
-0001c5c0: 6f64 5f77 6964 7468 5f75 7320 3d20 7265  od_width_us = re
-0001c5d0: 7375 6c74 2e64 6174 610d 0a20 2020 2020  sult.data..     
-0001c5e0: 2020 2072 6574 7572 6e20 7265 7375 6c74     return result
-0001c5f0: 0d0a 0d0a 2020 2020 6465 6620 7365 745f  ....    def set_
-0001c600: 6d6f 645f 6465 6c61 795f 7573 2873 656c  mod_delay_us(sel
-0001c610: 662c 2075 733a 2066 6c6f 6174 293a 2023  f, us: float): #
-0001c620: 202d 3e20 5370 6563 7472 6f6d 6574 6572   -> Spectrometer
-0001c630: 5265 7370 6f6e 7365 200d 0a20 2020 2020  Response ..     
-0001c640: 2020 2073 656c 662e 7365 7474 696e 6773     self.settings
-0001c650: 2e73 7461 7465 2e6d 6f64 5f64 656c 6179  .state.mod_delay
-0001c660: 5f75 7320 3d20 7573 0d0a 2020 2020 2020  _us = us..      
-0001c670: 2020 286c 7377 2c20 6d73 772c 2062 7566    (lsw, msw, buf
-0001c680: 2920 3d20 7365 6c66 2e5f 746f 3430 6269  ) = self._to40bi
-0001c690: 7428 7573 290d 0a20 2020 2020 2020 2072  t(us)..        r
-0001c6a0: 6574 7572 6e20 7365 6c66 2e5f 7365 6e64  eturn self._send
-0001c6b0: 5f63 6f64 6528 3078 6336 2c20 6c73 772c  _code(0xc6, lsw,
-0001c6c0: 206d 7377 2c20 6275 662c 206c 6162 656c   msw, buf, label
-0001c6d0: 3d22 5345 545f 4d4f 445f 4445 4c41 5922  ="SET_MOD_DELAY"
-0001c6e0: 290d 0a0d 0a20 2020 2064 6566 2067 6574  )....    def get
-0001c6f0: 5f6d 6f64 5f64 656c 6179 5f75 7328 7365  _mod_delay_us(se
-0001c700: 6c66 293a 2023 202d 3e20 5370 6563 7472  lf): # -> Spectr
-0001c710: 6f6d 6574 6572 5265 7370 6f6e 7365 200d  ometerResponse .
-0001c720: 0a20 2020 2020 2020 2072 6573 756c 7420  .        result 
-0001c730: 3d20 7365 6c66 2e5f 6765 745f 636f 6465  = self._get_code
-0001c740: 2830 7863 612c 206c 6162 656c 3d22 4745  (0xca, label="GE
-0001c750: 545f 4d4f 445f 4445 4c41 5922 2c20 6c73  T_MOD_DELAY", ls
-0001c760: 625f 6c65 6e3d 3529 0d0a 2020 2020 2020  b_len=5)..      
-0001c770: 2020 7365 6c66 2e73 6574 7469 6e67 732e    self.settings.
-0001c780: 7374 6174 652e 6d6f 645f 6465 6c61 795f  state.mod_delay_
-0001c790: 7573 203d 2072 6573 756c 742e 6461 7461  us = result.data
-0001c7a0: 0d0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-0001c7b0: 2072 6573 756c 740d 0a0d 0a20 2020 2064   result....    d
-0001c7c0: 6566 2073 6574 5f6d 6f64 5f64 7572 6174  ef set_mod_durat
-0001c7d0: 696f 6e5f 7573 5f4e 4f54 5f55 5345 4428  ion_us_NOT_USED(
-0001c7e0: 7365 6c66 2c20 7573 3a20 666c 6f61 7429  self, us: float)
-0001c7f0: 3a20 2320 2d3e 2053 7065 6374 726f 6d65  : # -> Spectrome
-0001c800: 7465 7252 6573 706f 6e73 6520 0d0a 2020  terResponse ..  
-0001c810: 2020 2020 2020 7365 6c66 2e73 6574 7469        self.setti
-0001c820: 6e67 732e 7374 6174 652e 6d6f 645f 6475  ngs.state.mod_du
-0001c830: 7261 7469 6f6e 5f75 7320 3d20 7573 0d0a  ration_us = us..
-0001c840: 2020 2020 2020 2020 286c 7377 2c20 6d73          (lsw, ms
-0001c850: 772c 2062 7566 2920 3d20 7365 6c66 2e5f  w, buf) = self._
-0001c860: 746f 3430 6269 7428 7573 290d 0a20 2020  to40bit(us)..   
-0001c870: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-0001c880: 2e5f 7365 6e64 5f63 6f64 6528 3078 6239  ._send_code(0xb9
-0001c890: 2c20 6c73 772c 206d 7377 2c20 6275 662c  , lsw, msw, buf,
-0001c8a0: 206c 6162 656c 3d22 5345 545f 4d4f 445f   label="SET_MOD_
-0001c8b0: 4455 5241 5449 4f4e 2229 0d0a 0d0a 2020  DURATION")....  
-0001c8c0: 2020 6465 6620 6765 745f 6d6f 645f 6475    def get_mod_du
-0001c8d0: 7261 7469 6f6e 5f75 7328 7365 6c66 293a  ration_us(self):
-0001c8e0: 2023 202d 3e20 5370 6563 7472 6f6d 6574   # -> Spectromet
-0001c8f0: 6572 5265 7370 6f6e 7365 200d 0a20 2020  erResponse ..   
-0001c900: 2020 2020 2072 6573 756c 7420 3d20 7365       result = se
-0001c910: 6c66 2e5f 6765 745f 636f 6465 2830 7863  lf._get_code(0xc
-0001c920: 332c 206c 6162 656c 3d22 4745 545f 4d4f  3, label="GET_MO
-0001c930: 445f 4455 5241 5449 4f4e 222c 206c 7362  D_DURATION", lsb
-0001c940: 5f6c 656e 3d35 290d 0a20 2020 2020 2020  _len=5)..       
-0001c950: 2073 656c 662e 7365 7474 696e 6773 2e73   self.settings.s
-0001c960: 7461 7465 2e6d 6f64 5f64 7572 6174 696f  tate.mod_duratio
-0001c970: 6e5f 7573 203d 2072 6573 756c 742e 6461  n_us = result.da
-0001c980: 7461 0d0a 2020 2020 2020 2020 7265 7475  ta..        retu
-0001c990: 726e 2072 6573 756c 740d 0a0d 0a20 2020  rn result....   
-0001c9a0: 2023 2320 7468 6973 2069 7320 6120 7379   ## this is a sy
-0001c9b0: 6e6f 6e79 6d20 666f 7220 5f73 6574 5f6c  nonym for _set_l
-0001c9c0: 6173 6572 5f65 6e61 626c 655f 696d 6d65  aser_enable_imme
-0001c9d0: 6469 6174 6528 292c 2062 7574 2077 6974  diate(), but wit
-0001c9e0: 686f 7574 2073 6964 652d 6566 6665 6374  hout side-effect
-0001c9f0: 730d 0a20 2020 2064 6566 2073 6574 5f73  s..    def set_s
-0001ca00: 7472 6f62 655f 656e 6162 6c65 2873 656c  trobe_enable(sel
-0001ca10: 662c 2066 6c61 673a 2062 6f6f 6c29 3a20  f, flag: bool): 
-0001ca20: 2320 2d3e 2053 7065 6374 726f 6d65 7465  # -> Spectromete
-0001ca30: 7252 6573 706f 6e73 6520 0d0a 2020 2020  rResponse ..    
-0001ca40: 2020 2020 7661 6c75 6520 3d20 3120 6966      value = 1 if
-0001ca50: 2066 6c61 6720 656c 7365 2030 0d0a 2020   flag else 0..  
-0001ca60: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-0001ca70: 662e 5f73 656e 645f 636f 6465 2830 7862  f._send_code(0xb
-0001ca80: 652c 2076 616c 7565 2c20 6c61 6265 6c3d  e, value, label=
-0001ca90: 2253 4554 5f53 5452 4f42 455f 454e 4142  "SET_STROBE_ENAB
-0001caa0: 4c45 2229 0d0a 0d0a 2020 2020 2323 2061  LE")....    ## a
-0001cab0: 206c 6974 6572 616c 2070 6173 732d 7468   literal pass-th
-0001cac0: 726f 7567 6820 746f 2067 6574 5f6c 6173  rough to get_las
-0001cad0: 6572 5f65 6e61 626c 6564 2829 0d0a 2020  er_enabled()..  
-0001cae0: 2020 6465 6620 6765 745f 7374 726f 6265    def get_strobe
-0001caf0: 5f65 6e61 626c 6564 2873 656c 6629 3a20  _enabled(self): 
-0001cb00: 2320 2d3e 2053 7065 6374 726f 6d65 7465  # -> Spectromete
-0001cb10: 7252 6573 706f 6e73 6520 0d0a 2020 2020  rResponse ..    
-0001cb20: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-0001cb30: 6765 745f 6c61 7365 725f 656e 6162 6c65  get_laser_enable
-0001cb40: 6428 290d 0a0d 0a20 2020 2023 2023 2323  d()....    # ###
-0001cb50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001cb60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001cb70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001cb80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001cb90: 2323 2323 2323 230d 0a20 2020 2023 2041  #######..    # A
-0001cba0: 6d62 6965 6e74 2054 656d 7065 7261 7475  mbient Temperatu
-0001cbb0: 7265 0d0a 2020 2020 2320 2323 2323 2323  re..    # ######
-0001cbc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001cbd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001cbe0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001cbf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001cc00: 2323 2323 0d0a 0d0a 2020 2020 2323 2040  ####....    ## @
-0001cc10: 7365 6520 6874 7470 733a 2f2f 7777 772e  see https://www.
-0001cc20: 6e78 702e 636f 6d2f 646f 6373 2f65 6e2f  nxp.com/docs/en/
-0001cc30: 6461 7461 2d73 6865 6574 2f4c 4d37 3542  data-sheet/LM75B
-0001cc40: 2e70 6466 0d0a 2020 2020 6465 6620 6765  .pdf..    def ge
-0001cc50: 745f 616d 6269 656e 745f 7465 6d70 6572  t_ambient_temper
-0001cc60: 6174 7572 655f 6465 6743 2873 656c 6629  ature_degC(self)
-0001cc70: 3a20 2320 2d3e 2053 7065 6374 726f 6d65  : # -> Spectrome
-0001cc80: 7465 7252 6573 706f 6e73 6520 0d0a 2020  terResponse ..  
-0001cc90: 2020 2020 2020 6966 206e 6f74 2073 656c        if not sel
-0001cca0: 662e 7365 7474 696e 6773 2e69 735f 6765  f.settings.is_ge
-0001ccb0: 6e31 3528 293a 0d0a 2020 2020 2020 2020  n15():..        
-0001ccc0: 2020 2020 6c6f 672e 6572 726f 7228 2261      log.error("a
-0001ccd0: 6d62 6965 6e74 2074 656d 7065 7261 7475  mbient temperatu
-0001cce0: 7265 2072 6571 7569 7265 7320 4765 6e20  re requires Gen 
-0001ccf0: 312e 3522 290d 0a20 2020 2020 2020 2020  1.5")..         
-0001cd00: 2020 2072 6574 7572 6e20 5370 6563 7472     return Spectr
-0001cd10: 6f6d 6574 6572 5265 7370 6f6e 7365 2864  ometerResponse(d
-0001cd20: 6174 613d 4661 6c73 652c 6572 726f 725f  ata=False,error_
-0001cd30: 6d73 673d 2261 6d62 6965 6e74 2074 656d  msg="ambient tem
-0001cd40: 7020 7265 7175 6972 6573 2067 656e 312e  p requires gen1.
-0001cd50: 3522 290d 0a0d 0a20 2020 2020 2020 206c  5")....        l
-0001cd60: 6f67 2e64 6562 7567 2822 6174 7465 6d70  og.debug("attemp
-0001cd70: 7469 6e67 2074 6f20 7265 6164 2061 6d62  ting to read amb
-0001cd80: 6965 6e74 2074 656d 7065 7261 7475 7265  ient temperature
-0001cd90: 2229 0d0a 2020 2020 2020 2020 7265 7375  ")..        resu
-0001cda0: 6c74 203d 2073 656c 662e 5f67 6574 5f63  lt = self._get_c
-0001cdb0: 6f64 6528 3078 3334 2c20 6c61 6265 6c3d  ode(0x34, label=
-0001cdc0: 2247 4554 5f41 4d42 4945 4e54 5f54 454d  "GET_AMBIENT_TEM
-0001cdd0: 5045 5241 5455 5245 222c 206d 7362 5f6c  PERATURE", msb_l
-0001cde0: 656e 3d32 290d 0a20 2020 2020 2020 2069  en=2)..        i
-0001cdf0: 6620 7265 7375 6c74 2069 7320 4e6f 6e65  f result is None
-0001ce00: 206f 7220 6c65 6e28 7265 7375 6c74 2920   or len(result) 
-0001ce10: 213d 2032 3a0d 0a20 2020 2020 2020 2020  != 2:..         
-0001ce20: 2020 206c 6f67 2e65 7272 6f72 2822 6661     log.error("fa
-0001ce30: 696c 6564 2074 6f20 7265 6164 2061 6d62  iled to read amb
-0001ce40: 6965 6e74 2074 656d 7065 7261 7475 7265  ient temperature
-0001ce50: 2229 0d0a 2020 2020 2020 2020 2020 2020  ")..            
-0001ce60: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
-0001ce70: 7465 7252 6573 706f 6e73 6528 6461 7461  terResponse(data
-0001ce80: 3d46 616c 7365 2c65 7272 6f72 5f6d 7367  =False,error_msg
-0001ce90: 3d22 616d 6269 656e 7420 7465 6d70 2072  ="ambient temp r
-0001cea0: 6561 6420 6661 696c 6564 2229 0d0a 2020  ead failed")..  
-0001ceb0: 2020 2020 2020 6c6f 672e 6465 6275 6728        log.debug(
-0001cec0: 2261 6d62 6965 6e74 2074 656d 7065 7261  "ambient tempera
-0001ced0: 7475 7265 2072 6177 3a20 2573 222c 2072  ture raw: %s", r
-0001cee0: 6573 756c 7429 0d0a 0d0a 2020 2020 2020  esult)....      
-0001cef0: 2020 7261 7720 3d20 7265 7375 6c74 2e64    raw = result.d
-0001cf00: 6174 610d 0a20 2020 2020 2020 2072 6177  ata..        raw
-0001cf10: 203d 2072 6177 203e 3e20 350d 0a20 2020   = raw >> 5..   
-0001cf20: 2020 2020 2064 6567 4320 3d20 302e 3132       degC = 0.12
-0001cf30: 3520 2a20 7574 696c 732e 7477 6f73 5f63  5 * utils.twos_c
-0001cf40: 6f6d 7028 7261 772c 2031 3129 0d0a 0d0a  omp(raw, 11)....
-0001cf50: 2020 2020 2020 2020 6c6f 672e 6465 6275          log.debu
-0001cf60: 6728 2270 6172 7365 6420 616d 6269 656e  g("parsed ambien
-0001cf70: 7420 7465 6d70 6572 6174 7572 6520 6672  t temperature fr
-0001cf80: 6f6d 2072 6177 2025 7320 746f 2025 2e33  om raw %s to %.3
-0001cf90: 6620 6465 6743 222c 2072 6573 756c 742c  f degC", result,
-0001cfa0: 2064 6567 4329 0d0a 2020 2020 2020 2020   degC)..        
-0001cfb0: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
-0001cfc0: 7465 7252 6573 706f 6e73 6528 6461 7461  terResponse(data
-0001cfd0: 3d64 6567 4329 0d0a 0d0a 2020 2020 2320  =degC)....    # 
-0001cfe0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001cff0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d000: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d010: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d020: 2323 2323 2323 2323 2323 0d0a 2020 2020  ##########..    
-0001d030: 2320 6164 6465 6420 666f 7220 7761 7361  # added for wasa
-0001d040: 7463 682d 7368 656c 6c0d 0a20 2020 2023  tch-shell..    #
-0001d050: 2023 2323 2323 2323 2323 2323 2323 2323   ###############
-0001d060: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d070: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d080: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d090: 2323 2323 2323 2323 2323 230d 0a0d 0a20  ###########.... 
-0001d0a0: 2020 2064 6566 2067 6574 5f74 6563 5f65     def get_tec_e
-0001d0b0: 6e61 626c 6564 2873 656c 6629 3a20 2320  nabled(self): # 
-0001d0c0: 2d3e 2053 7065 6374 726f 6d65 7465 7252  -> SpectrometerR
-0001d0d0: 6573 706f 6e73 6520 0d0a 2020 2020 2020  esponse ..      
-0001d0e0: 2020 6966 206e 6f74 2073 656c 662e 7365    if not self.se
-0001d0f0: 7474 696e 6773 2e65 6570 726f 6d2e 6861  ttings.eeprom.ha
-0001d100: 735f 636f 6f6c 696e 673a 0d0a 2020 2020  s_cooling:..    
-0001d110: 2020 2020 2020 2020 6c6f 672e 6572 726f          log.erro
-0001d120: 7228 2275 6e61 626c 6520 746f 2063 6f6e  r("unable to con
-0001d130: 7472 6f6c 2054 4543 3a20 4545 5052 4f4d  trol TEC: EEPROM
-0001d140: 2072 6570 6f72 7473 206e 6f20 636f 6f6c   reports no cool
-0001d150: 696e 6722 290d 0a20 2020 2020 2020 2020  ing")..         
-0001d160: 2020 2072 6574 7572 6e20 5370 6563 7472     return Spectr
-0001d170: 6f6d 6574 6572 5265 7370 6f6e 7365 2864  ometerResponse(d
-0001d180: 6174 613d 4661 6c73 652c 6572 726f 725f  ata=False,error_
-0001d190: 6d73 673d 226e 6f20 636f 6f6c 696e 6720  msg="no cooling 
-0001d1a0: 7265 706f 7274 6564 2229 0d0a 2020 2020  reported")..    
-0001d1b0: 2020 2020 7265 7320 3d20 7365 6c66 2e5f      res = self._
-0001d1c0: 6765 745f 636f 6465 2830 7864 612c 206c  get_code(0xda, l
-0001d1d0: 6162 656c 3d22 4745 545f 4343 445f 5445  abel="GET_CCD_TE
-0001d1e0: 435f 454e 4142 4c45 4422 2c20 6d73 625f  C_ENABLED", msb_
-0001d1f0: 6c65 6e3d 3129 0d0a 2020 2020 2020 2020  len=1)..        
-0001d200: 7265 732e 6461 7461 203d 2030 2021 3d20  res.data = 0 != 
-0001d210: 7265 732e 6461 7461 0d0a 2020 2020 2020  res.data..      
-0001d220: 2020 6966 2072 6573 2e65 7272 6f72 5f6d    if res.error_m
-0001d230: 7367 2021 3d20 2727 3a0d 0a20 2020 2020  sg != '':..     
-0001d240: 2020 2020 2020 2072 6574 7572 6e20 7265         return re
-0001d250: 730d 0a20 2020 2020 2020 2072 6574 7572  s..        retur
-0001d260: 6e20 7265 730d 0a0d 0a20 2020 2064 6566  n res....    def
-0001d270: 2067 6574 5f61 6374 7561 6c5f 6672 616d   get_actual_fram
-0001d280: 6573 2873 656c 6629 3a20 2320 2d3e 2053  es(self): # -> S
-0001d290: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
-0001d2a0: 6e73 6520 0d0a 2020 2020 2020 2020 7265  nse ..        re
-0001d2b0: 7475 726e 2073 656c 662e 5f67 6574 5f63  turn self._get_c
-0001d2c0: 6f64 6528 3078 6534 2c20 6c61 6265 6c3d  ode(0xe4, label=
-0001d2d0: 2247 4554 5f41 4354 5541 4c5f 4652 414d  "GET_ACTUAL_FRAM
-0001d2e0: 4553 222c 206c 7362 5f6c 656e 3d32 290d  ES", lsb_len=2).
-0001d2f0: 0a0d 0a20 2020 2064 6566 2067 6574 5f61  ...    def get_a
-0001d300: 6374 7561 6c5f 696e 7465 6772 6174 696f  ctual_integratio
-0001d310: 6e5f 7469 6d65 5f75 7328 7365 6c66 293a  n_time_us(self):
-0001d320: 2023 202d 3e20 5370 6563 7472 6f6d 6574   # -> Spectromet
-0001d330: 6572 5265 7370 6f6e 7365 200d 0a20 2020  erResponse ..   
-0001d340: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-0001d350: 2e5f 6765 745f 636f 6465 2830 7864 662c  ._get_code(0xdf,
-0001d360: 206c 6162 656c 3d22 4745 545f 4143 5455   label="GET_ACTU
-0001d370: 414c 5f49 4e54 4547 5241 5449 4f4e 5f54  AL_INTEGRATION_T
-0001d380: 494d 455f 5553 222c 206c 7362 5f6c 656e  IME_US", lsb_len
-0001d390: 3d33 290d 0a0d 0a20 2020 2064 6566 2067  =3)....    def g
-0001d3a0: 6574 5f64 6574 6563 746f 725f 6f66 6673  et_detector_offs
-0001d3b0: 6574 2873 656c 6629 3a20 2320 2d3e 2053  et(self): # -> S
-0001d3c0: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
-0001d3d0: 6e73 6520 0d0a 2020 2020 2020 2020 7661  nse ..        va
-0001d3e0: 6c75 6520 3d20 7365 6c66 2e5f 6765 745f  lue = self._get_
-0001d3f0: 636f 6465 2830 7863 342c 206c 6162 656c  code(0xc4, label
-0001d400: 3d22 4745 545f 4445 5445 4354 4f52 5f4f  ="GET_DETECTOR_O
-0001d410: 4646 5345 5422 2c20 6c73 625f 6c65 6e3d  FFSET", lsb_len=
-0001d420: 3229 0d0a 2020 2020 2020 2020 7365 6c66  2)..        self
-0001d430: 2e73 6574 7469 6e67 732e 6565 7072 6f6d  .settings.eeprom
-0001d440: 2e64 6574 6563 746f 725f 6f66 6673 6574  .detector_offset
-0001d450: 203d 2076 616c 7565 2e64 6174 610d 0a20   = value.data.. 
-0001d460: 2020 2020 2020 2072 6574 7572 6e20 5370         return Sp
-0001d470: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-0001d480: 7365 2864 6174 613d 7661 6c75 6529 0d0a  se(data=value)..
-0001d490: 0d0a 2020 2020 6465 6620 6765 745f 6465  ..    def get_de
-0001d4a0: 7465 6374 6f72 5f6f 6666 7365 745f 6f64  tector_offset_od
-0001d4b0: 6428 7365 6c66 293a 2023 202d 3e20 5370  d(self): # -> Sp
-0001d4c0: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-0001d4d0: 7365 200d 0a20 2020 2020 2020 2069 6620  se ..        if 
-0001d4e0: 6e6f 7420 7365 6c66 2e73 6574 7469 6e67  not self.setting
-0001d4f0: 732e 6973 5f69 6e67 6161 7328 293a 0d0a  s.is_ingaas():..
-0001d500: 2020 2020 2020 2020 2020 2020 6c6f 672e              log.
-0001d510: 6465 6275 6728 2247 4554 5f44 4554 4543  debug("GET_DETEC
-0001d520: 544f 525f 4f46 4653 4554 5f4f 4444 206f  TOR_OFFSET_ODD o
-0001d530: 6e6c 7920 7375 7070 6f72 7465 6420 6f6e  nly supported on
-0001d540: 2049 6e47 6141 7322 290d 0a20 2020 2020   InGaAs")..     
-0001d550: 2020 2020 2020 2072 6574 7572 6e20 5370         return Sp
-0001d560: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-0001d570: 7365 2864 6174 613d 7365 6c66 2e73 6574  se(data=self.set
-0001d580: 7469 6e67 732e 6565 7072 6f6d 2e64 6574  tings.eeprom.det
-0001d590: 6563 746f 725f 6f66 6673 6574 5f6f 6464  ector_offset_odd
-0001d5a0: 290d 0a0d 0a20 2020 2020 2020 2076 616c  )....        val
-0001d5b0: 7565 203d 2073 656c 662e 5f67 6574 5f63  ue = self._get_c
-0001d5c0: 6f64 6528 3078 3965 2c20 6c61 6265 6c3d  ode(0x9e, label=
-0001d5d0: 2247 4554 5f44 4554 4543 544f 525f 4f46  "GET_DETECTOR_OF
-0001d5e0: 4653 4554 5f4f 4444 222c 206c 7362 5f6c  FSET_ODD", lsb_l
-0001d5f0: 656e 3d32 290d 0a20 2020 2020 2020 2069  en=2)..        i
-0001d600: 6620 7661 6c75 652e 6572 726f 725f 6d73  f value.error_ms
-0001d610: 6720 213d 2027 273a 0d0a 2020 2020 2020  g != '':..      
-0001d620: 2020 2020 2020 7265 7475 726e 2076 616c        return val
-0001d630: 7565 0d0a 2020 2020 2020 2020 7365 6c66  ue..        self
-0001d640: 2e73 6574 7469 6e67 732e 6565 7072 6f6d  .settings.eeprom
-0001d650: 2e64 6574 6563 746f 725f 6f66 6673 6574  .detector_offset
-0001d660: 5f6f 6464 203d 2076 616c 7565 2e64 6174  _odd = value.dat
-0001d670: 610d 0a20 2020 2020 2020 2072 6574 7572  a..        retur
-0001d680: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
-0001d690: 7370 6f6e 7365 2864 6174 613d 7661 6c75  sponse(data=valu
-0001d6a0: 6529 0d0a 0d0a 2020 2020 6465 6620 6765  e)....    def ge
-0001d6b0: 745f 6363 645f 7365 6e73 696e 675f 7468  t_ccd_sensing_th
-0001d6c0: 7265 7368 6f6c 6428 7365 6c66 293a 2023  reshold(self): #
-0001d6d0: 202d 3e20 5370 6563 7472 6f6d 6574 6572   -> Spectrometer
-0001d6e0: 5265 7370 6f6e 7365 200d 0a20 2020 2020  Response ..     
-0001d6f0: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
-0001d700: 6765 745f 636f 6465 2830 7864 312c 206c  get_code(0xd1, l
-0001d710: 6162 656c 3d22 4745 545f 4343 445f 5345  abel="GET_CCD_SE
-0001d720: 4e53 494e 475f 5448 5245 5348 4f4c 4422  NSING_THRESHOLD"
-0001d730: 2c20 6c73 625f 6c65 6e3d 3229 0d0a 0d0a  , lsb_len=2)....
-0001d740: 2020 2020 6465 6620 6765 745f 6363 645f      def get_ccd_
-0001d750: 7468 7265 7368 6f6c 645f 7365 6e73 696e  threshold_sensin
-0001d760: 675f 6d6f 6465 2873 656c 6629 3a20 2320  g_mode(self): # 
-0001d770: 2d3e 2053 7065 6374 726f 6d65 7465 7252  -> SpectrometerR
-0001d780: 6573 706f 6e73 6520 0d0a 2020 2020 2020  esponse ..      
-0001d790: 2020 7265 7475 726e 2073 656c 662e 5f67    return self._g
-0001d7a0: 6574 5f63 6f64 6528 3078 6366 2c20 6c61  et_code(0xcf, la
-0001d7b0: 6265 6c3d 2247 4554 5f43 4344 5f54 4852  bel="GET_CCD_THR
-0001d7c0: 4553 484f 4c44 5f53 454e 5349 4e47 5f4d  ESHOLD_SENSING_M
-0001d7d0: 4f44 4522 2c20 6d73 625f 6c65 6e3d 3129  ODE", msb_len=1)
-0001d7e0: 0d0a 0d0a 2020 2020 6465 6620 6765 745f  ....    def get_
-0001d7f0: 6578 7465 726e 616c 5f74 7269 6767 6572  external_trigger
-0001d800: 5f6f 7574 7075 7428 7365 6c66 293a 2023  _output(self): #
-0001d810: 202d 3e20 5370 6563 7472 6f6d 6574 6572   -> Spectrometer
-0001d820: 5265 7370 6f6e 7365 200d 0a20 2020 2020  Response ..     
-0001d830: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
-0001d840: 6765 745f 636f 6465 2830 7865 312c 206c  get_code(0xe1, l
-0001d850: 6162 656c 3d22 4745 545f 4558 5445 524e  abel="GET_EXTERN
-0001d860: 414c 5f54 5249 4747 4552 5f4f 5554 5055  AL_TRIGGER_OUTPU
-0001d870: 5422 2c20 6d73 625f 6c65 6e3d 3129 0d0a  T", msb_len=1)..
-0001d880: 0d0a 2020 2020 6465 6620 6765 745f 6c61  ..    def get_la
-0001d890: 7365 725f 696e 7465 726c 6f63 6b28 7365  ser_interlock(se
-0001d8a0: 6c66 293a 2023 202d 3e20 5370 6563 7472  lf): # -> Spectr
-0001d8b0: 6f6d 6574 6572 5265 7370 6f6e 7365 200d  ometerResponse .
-0001d8c0: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-0001d8d0: 2e73 6574 7469 6e67 732e 6973 5f61 726d  .settings.is_arm
-0001d8e0: 2829 3a0d 0a20 2020 2020 2020 2020 2020  ():..           
-0001d8f0: 206c 6f67 2e65 7272 6f72 2822 4745 545f   log.error("GET_
-0001d900: 4c41 5345 525f 494e 5445 524c 4f43 4b20  LASER_INTERLOCK 
-0001d910: 6e6f 7420 7375 7070 6f72 7465 6420 6f6e  not supported on
-0001d920: 2041 524d 2229 0d0a 2020 2020 2020 2020   ARM")..        
-0001d930: 2020 2020 7265 7475 726e 2053 7065 6374      return Spect
-0001d940: 726f 6d65 7465 7252 6573 706f 6e73 6528  rometerResponse(
-0001d950: 6461 7461 3d46 616c 7365 2c65 7272 6f72  data=False,error
-0001d960: 5f6d 7367 3d22 6c61 7365 7220 696e 7465  _msg="laser inte
-0001d970: 726c 6f63 6b20 6e6f 7420 7375 7070 6f72  rlock not suppor
-0001d980: 7465 6422 290d 0a20 2020 2020 2020 2072  ted")..        r
-0001d990: 6574 7572 6e20 7365 6c66 2e5f 6765 745f  eturn self._get_
-0001d9a0: 636f 6465 2830 7865 662c 206c 6162 656c  code(0xef, label
-0001d9b0: 3d22 4745 545f 4c41 5345 525f 494e 5445  ="GET_LASER_INTE
-0001d9c0: 524c 4f43 4b22 2c20 6d73 625f 6c65 6e3d  RLOCK", msb_len=
-0001d9d0: 3129 0d0a 0d0a 2020 2020 6465 6620 6765  1)....    def ge
-0001d9e0: 745f 6c61 7365 725f 656e 6162 6c65 6428  t_laser_enabled(
-0001d9f0: 7365 6c66 293a 2023 202d 3e20 5370 6563  self): # -> Spec
-0001da00: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
-0001da10: 200d 0a20 2020 2020 2020 2072 6573 203d   ..        res =
-0001da20: 2073 656c 662e 5f67 6574 5f63 6f64 6528   self._get_code(
-0001da30: 3078 6532 2c20 6c61 6265 6c3d 2247 4554  0xe2, label="GET
-0001da40: 5f4c 4153 4552 5f45 4e41 424c 4544 222c  _LASER_ENABLED",
-0001da50: 206d 7362 5f6c 656e 3d31 290d 0a20 2020   msb_len=1)..   
-0001da60: 2020 2020 2066 6c61 6720 3d20 3020 213d       flag = 0 !=
-0001da70: 2072 6573 2e64 6174 610d 0a20 2020 2020   res.data..     
-0001da80: 2020 206c 6f67 2e64 6562 7567 2822 6765     log.debug("ge
-0001da90: 745f 6c61 7365 725f 656e 6162 6c65 643a  t_laser_enabled:
-0001daa0: 2025 7322 2c20 666c 6167 290d 0a20 2020   %s", flag)..   
-0001dab0: 2020 2020 2073 656c 662e 7365 7474 696e       self.settin
-0001dac0: 6773 2e73 7461 7465 2e6c 6173 6572 5f65  gs.state.laser_e
-0001dad0: 6e61 626c 6564 203d 2066 6c61 670d 0a20  nabled = flag.. 
-0001dae0: 2020 2020 2020 2072 6574 7572 6e20 5370         return Sp
-0001daf0: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
-0001db00: 7365 2864 6174 613d 666c 6167 290d 0a0d  se(data=flag)...
-0001db10: 0a20 2020 2064 6566 2073 6574 5f6d 6f64  .    def set_mod
-0001db20: 5f6c 696e 6b65 645f 746f 5f69 6e74 6567  _linked_to_integ
-0001db30: 7261 7469 6f6e 2873 656c 662c 2066 6c61  ration(self, fla
-0001db40: 673a 2062 6f6f 6c29 3a20 2320 2d3e 2053  g: bool): # -> S
-0001db50: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
-0001db60: 6e73 6520 0d0a 2020 2020 2020 2020 7661  nse ..        va
-0001db70: 6c75 6520 3d20 3120 6966 2066 6c61 6720  lue = 1 if flag 
-0001db80: 656c 7365 2030 0d0a 2020 2020 2020 2020  else 0..        
-0001db90: 7265 7475 726e 2073 656c 662e 5f73 656e  return self._sen
-0001dba0: 645f 636f 6465 2830 7864 642c 2076 616c  d_code(0xdd, val
-0001dbb0: 7565 2c20 6c61 6265 6c3d 2253 4554 5f4d  ue, label="SET_M
-0001dbc0: 4f44 5f4c 494e 4b45 445f 544f 5f49 4e54  OD_LINKED_TO_INT
-0001dbd0: 4547 5241 5449 4f4e 2229 0d0a 0d0a 2020  EGRATION")....  
-0001dbe0: 2020 6465 6620 6765 745f 6d6f 645f 6c69    def get_mod_li
-0001dbf0: 6e6b 6564 5f74 6f5f 696e 7465 6772 6174  nked_to_integrat
-0001dc00: 696f 6e28 7365 6c66 293a 2023 202d 3e20  ion(self): # -> 
-0001dc10: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
-0001dc20: 6f6e 7365 200d 0a20 2020 2020 2020 2072  onse ..        r
-0001dc30: 6573 203d 2073 656c 662e 5f67 6574 5f63  es = self._get_c
-0001dc40: 6f64 6528 3078 6465 2c20 6c61 6265 6c3d  ode(0xde, label=
-0001dc50: 2247 4554 5f4d 4f44 5f4c 494e 4b45 445f  "GET_MOD_LINKED_
-0001dc60: 544f 5f49 4e54 4547 5241 5449 4f4e 222c  TO_INTEGRATION",
-0001dc70: 206d 7362 5f6c 656e 3d31 290d 0a20 2020   msb_len=1)..   
-0001dc80: 2020 2020 2069 6620 7265 732e 6572 726f       if res.erro
-0001dc90: 725f 6d73 6720 213d 2027 273a 0d0a 2020  r_msg != '':..  
-0001dca0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0001dcb0: 2072 6573 0d0a 2020 2020 2020 2020 7265   res..        re
-0001dcc0: 732e 6461 7461 203d 2030 2021 3d20 7265  s.data = 0 != re
-0001dcd0: 732e 6461 7461 0d0a 2020 2020 2020 2020  s.data..        
-0001dce0: 7265 7475 726e 2072 6573 0d0a 0d0a 2020  return res....  
-0001dcf0: 2020 6465 6620 6765 745f 7365 6c65 6374    def get_select
-0001dd00: 6564 5f61 6463 2873 656c 6629 3a0d 0a20  ed_adc(self):.. 
-0001dd10: 2020 2020 2020 2076 616c 7565 203d 2073         value = s
-0001dd20: 656c 662e 5f67 6574 5f63 6f64 6528 3078  elf._get_code(0x
-0001dd30: 6565 2c20 6c61 6265 6c3d 2247 4554 5f53  ee, label="GET_S
-0001dd40: 454c 4543 5445 445f 4144 4322 2c20 6d73  ELECTED_ADC", ms
-0001dd50: 625f 6c65 6e3d 3129 0d0a 2020 2020 2020  b_len=1)..      
-0001dd60: 2020 6966 2076 616c 7565 2e65 7272 6f72    if value.error
-0001dd70: 5f6d 7367 2021 3d20 2727 3a0d 0a20 2020  _msg != '':..   
-0001dd80: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0001dd90: 7661 6c75 650d 0a20 2020 2020 2020 2069  value..        i
-0001dda0: 6620 7365 6c66 2e73 6574 7469 6e67 732e  f self.settings.
-0001ddb0: 7374 6174 652e 7365 6c65 6374 6564 5f61  state.selected_a
-0001ddc0: 6463 2021 3d20 7661 6c75 652e 6461 7461  dc != value.data
-0001ddd0: 3a0d 0a20 2020 2020 2020 2020 2020 206c  :..            l
-0001dde0: 6f67 2e65 7272 6f72 2822 4745 545f 5345  og.error("GET_SE
-0001ddf0: 4c45 4354 4544 5f41 4443 2025 6420 213d  LECTED_ADC %d !=
-0001de00: 2073 7461 7465 2e73 656c 6563 7465 645f   state.selected_
-0001de10: 6164 6320 2564 222c 2076 616c 7565 2c20  adc %d", value, 
-0001de20: 7365 6c66 2e73 6574 7469 6e67 732e 7374  self.settings.st
-0001de30: 6174 652e 7365 6c65 6374 6564 5f61 6463  ate.selected_adc
-0001de40: 290d 0a20 2020 2020 2020 2020 2020 2073  )..            s
-0001de50: 656c 662e 7365 7474 696e 6773 2e73 7461  elf.settings.sta
-0001de60: 7465 2e73 656c 6563 7465 645f 6164 6320  te.selected_adc 
-0001de70: 3d20 7661 6c75 652e 6461 7461 0d0a 2020  = value.data..  
-0001de80: 2020 2020 2020 7265 7475 726e 2076 616c        return val
-0001de90: 7565 0d0a 0d0a 2020 2020 6465 6620 7365  ue....    def se
-0001dea0: 745f 7472 6967 6765 725f 6465 6c61 7928  t_trigger_delay(
-0001deb0: 7365 6c66 2c20 6861 6c66 5f75 733a 2066  self, half_us: f
-0001dec0: 6c6f 6174 293a 2023 202d 3e20 5370 6563  loat): # -> Spec
+0001b860: 2020 2020 2020 2020 2020 6c61 6265 6c20            label 
+0001b870: 2020 203d 2022 5345 545f 5049 5845 4c5f     = "SET_PIXEL_
+0001b880: 4d4f 4445 2229 0a0a 2020 2020 2020 2020  MODE")..        
+0001b890: 6c6f 672e 6465 6275 6728 2277 6169 7469  log.debug("waiti
+0001b8a0: 6e67 2031 7365 632e 2e2e 2229 0a20 2020  ng 1sec...").   
+0001b8b0: 2020 2020 2073 6c65 6570 2831 290a 0a20       sleep(1).. 
+0001b8c0: 2020 2020 2020 2072 6574 7572 6e20 7265         return re
+0001b8d0: 7375 6c74 0a0a 2020 2020 6465 6620 636c  sult..    def cl
+0001b8e0: 6561 725f 7265 6769 6f6e 7328 7365 6c66  ear_regions(self
+0001b8f0: 293a 0a20 2020 2020 2020 2078 3120 3d20  ):.        x1 = 
+0001b900: 7365 6c66 2e73 6574 7469 6e67 732e 6565  self.settings.ee
+0001b910: 7072 6f6d 2e61 6374 6976 655f 7069 7865  prom.active_pixe
+0001b920: 6c73 5f68 6f72 697a 6f6e 7461 6c0a 2020  ls_horizontal.  
+0001b930: 2020 2020 2020 7931 203d 2073 656c 662e        y1 = self.
+0001b940: 7365 7474 696e 6773 2e65 6570 726f 6d2e  settings.eeprom.
+0001b950: 6163 7469 7665 5f70 6978 656c 735f 7665  active_pixels_ve
+0001b960: 7274 6963 616c 0a20 2020 2020 2020 206c  rtical.        l
+0001b970: 6f67 2e64 6562 7567 2866 2272 6573 6574  og.debug(f"reset
+0001b980: 7469 6e67 7320 6465 7465 6374 6f72 2074  tings detector t
+0001b990: 6f20 6675 6c6c 2028 7b78 317d 2c20 7b79  o full ({x1}, {y
+0001b9a0: 317d 2920 6578 7465 6e74 2229 0a0a 2020  1}) extent")..  
+0001b9b0: 2020 2020 2020 7365 6c66 2e73 6574 7469        self.setti
+0001b9c0: 6e67 732e 7374 6174 652e 7265 6769 6f6e  ngs.state.region
+0001b9d0: 203d 204e 6f6e 650a 2020 2020 2020 2020   = None.        
+0001b9e0: 7365 6c66 2e73 6574 7469 6e67 732e 7570  self.settings.up
+0001b9f0: 6461 7465 5f77 6176 6563 616c 2829 0a0a  date_wavecal()..
+0001ba00: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+0001ba10: 656c 662e 7365 745f 6465 7465 6374 6f72  elf.set_detector
+0001ba20: 5f72 6f69 285b 302c 2030 2c20 7931 2c20  _roi([0, 0, y1, 
+0001ba30: 302c 2078 315d 2c20 7374 6f72 653d 4661  0, x1], store=Fa
+0001ba40: 6c73 6529 0a0a 2020 2020 6465 6620 7365  lse)..    def se
+0001ba50: 745f 7369 6e67 6c65 5f72 6567 696f 6e28  t_single_region(
+0001ba60: 7365 6c66 2c20 6e3a 2069 6e74 293a 0a20  self, n: int):. 
+0001ba70: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+0001ba80: 2020 2054 6869 7320 6675 6e63 7469 6f6e     This function
+0001ba90: 2075 7365 7320 7468 6520 7468 6520 6d75   uses the the mu
+0001baa0: 6c74 692d 7265 6769 6f6e 2066 6561 7475  lti-region featu
+0001bab0: 7265 2074 6f20 7365 6c65 6374 206a 7573  re to select jus
+0001bac0: 7420 6120 7369 6e67 6c65 200a 2020 2020  t a single .    
+0001bad0: 2020 2020 7072 652d 636f 6e66 6967 7572      pre-configur
+0001bae0: 6564 2072 6567 696f 6e20 6174 2061 2074  ed region at a t
+0001baf0: 696d 652e 2020 5768 6963 6865 7665 7220  ime.  Whichever 
+0001bb00: 7265 6769 6f6e 2069 7320 7365 6c65 6374  region is select
+0001bb10: 6564 2c20 7468 6174 200a 2020 2020 2020  ed, that .      
+0001bb20: 2020 7265 6769 6f6e 2773 2070 6172 616d    region's param
+0001bb30: 6574 6572 7320 6172 6520 7772 6974 7465  eters are writte
+0001bb40: 6e20 746f 2022 7265 6769 6f6e 2030 2220  n to "region 0" 
+0001bb50: 6f66 2074 6865 2073 7065 6374 726f 6d65  of the spectrome
+0001bb60: 7465 722c 2061 6e64 0a20 2020 2020 2020  ter, and.       
+0001bb70: 2074 6865 2067 6c6f 6261 6c20 7761 7665   the global wave
+0001bb80: 6361 6c20 6973 2075 7064 6174 6564 2074  cal is updated t
+0001bb90: 6f20 7573 6520 7468 6174 2072 6567 696f  o use that regio
+0001bba0: 6e27 7320 6361 6c69 6272 6174 696f 6e2e  n's calibration.
+0001bbb0: 0a20 2020 2020 2020 0a20 2020 2020 2020  .       .       
+0001bbc0: 2040 746f 646f 2063 6f6e 7369 6465 7220   @todo consider 
+0001bbd0: 636c 6561 725f 7265 6769 6f6e 2829 2066  clear_region() f
+0001bbe0: 756e 6374 696f 6e20 746f 2072 6573 746f  unction to resto
+0001bbf0: 7265 2070 6879 7369 6361 6c20 524f 4920  re physical ROI 
+0001bc00: 746f 200a 2020 2020 2020 2020 2020 2020  to .            
+0001bc10: 2830 2c20 6163 7469 7665 5f76 6572 7469  (0, active_verti
+0001bc20: 6361 6c5f 7069 7865 6c73 2c20 302c 2061  cal_pixels, 0, a
+0001bc30: 6374 6976 655f 686f 7269 7a6f 6e74 616c  ctive_horizontal
+0001bc40: 5f70 6978 656c 7329 0a20 2020 2020 2020  _pixels).       
+0001bc50: 2020 2020 2028 6c65 6176 6520 7761 7665       (leave wave
+0001bc60: 6361 6c20 616c 6f6e 653f 290a 2020 2020  cal alone?).    
+0001bc70: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+0001bc80: 6966 2073 656c 662e 7365 7474 696e 6773  if self.settings
+0001bc90: 2e73 7461 7465 2e64 6574 6563 746f 725f  .state.detector_
+0001bca0: 7265 6769 6f6e 7320 6973 204e 6f6e 653a  regions is None:
+0001bcb0: 0a20 2020 2020 2020 2020 2020 206c 6f67  .            log
+0001bcc0: 2e64 6562 7567 2866 226e 6f20 6465 7465  .debug(f"no dete
+0001bcd0: 6374 6f72 2072 6567 696f 6e73 2063 6f6e  ctor regions con
+0001bce0: 6669 6775 7265 6422 290a 2020 2020 2020  figured").      
+0001bcf0: 2020 2020 2020 7265 7475 726e 2053 7065        return Spe
+0001bd00: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
+0001bd10: 6528 6461 7461 3d46 616c 7365 2c65 7272  e(data=False,err
+0001bd20: 6f72 5f6d 7367 3d22 6e6f 2072 6567 696f  or_msg="no regio
+0001bd30: 6e73 2063 6f6e 6669 6775 7265 6422 290a  ns configured").
+0001bd40: 0a20 2020 2020 2020 2072 6f69 203d 2073  .        roi = s
+0001bd50: 656c 662e 7365 7474 696e 6773 2e73 7461  elf.settings.sta
+0001bd60: 7465 2e64 6574 6563 746f 725f 7265 6769  te.detector_regi
+0001bd70: 6f6e 732e 6765 745f 726f 6928 6e29 0a20  ons.get_roi(n). 
+0001bd80: 2020 2020 2020 2069 6620 726f 6920 6973         if roi is
+0001bd90: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+0001bda0: 2020 206c 6f67 2e64 6562 7567 2866 2275     log.debug(f"u
+0001bdb0: 6e63 6f6e 6669 6775 7265 6420 7265 6769  nconfigured regi
+0001bdc0: 6f6e 207b 6e7d 2028 6d61 7820 7b73 656c  on {n} (max {sel
+0001bdd0: 662e 7365 7474 696e 6773 2e65 6570 726f  f.settings.eepro
+0001bde0: 6d2e 7265 6769 6f6e 5f63 6f75 6e74 7d22  m.region_count}"
+0001bdf0: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+0001be00: 7475 726e 2053 7065 6374 726f 6d65 7465  turn Spectromete
+0001be10: 7252 6573 706f 6e73 6528 6461 7461 3d46  rResponse(data=F
+0001be20: 616c 7365 2c65 7272 6f72 5f6d 7367 3d22  alse,error_msg="
+0001be30: 756e 636f 6e66 6967 7572 6564 2072 6567  unconfigured reg
+0001be40: 696f 6e22 290a 0a20 2020 2020 2020 206c  ion")..        l
+0001be50: 6f67 2e64 6562 7567 2866 2273 6574 5f73  og.debug(f"set_s
+0001be60: 696e 676c 655f 7265 6769 6f6e 3a20 6170  ingle_region: ap
+0001be70: 706c 7969 6e67 2072 6567 696f 6e20 7b6e  plying region {n
+0001be80: 7d3a 207b 726f 697d 2229 0a20 2020 2020  }: {roi}").     
+0001be90: 2020 2073 656c 662e 7365 7474 696e 6773     self.settings
+0001bea0: 2e73 6574 5f73 696e 676c 655f 7265 6769  .set_single_regi
+0001beb0: 6f6e 286e 290a 0a20 2020 2020 2020 2023  on(n)..        #
+0001bec0: 2073 656e 6420 6120 2266 616b 6522 2052   send a "fake" R
+0001bed0: 4f49 2064 6f77 6e73 7472 6561 6d2c 206f  OI downstream, o
+0001bee0: 7665 7272 6964 696e 6720 746f 2070 6f73  verriding to pos
+0001bef0: 6974 696f 6e20 300a 2020 2020 2020 2020  ition 0.        
+0001bf00: 7365 6c66 2e73 6574 5f64 6574 6563 746f  self.set_detecto
+0001bf10: 725f 726f 6928 5b30 2c20 726f 692e 7930  r_roi([0, roi.y0
+0001bf20: 2c20 726f 692e 7931 2c20 726f 692e 7830  , roi.y1, roi.x0
+0001bf30: 2c20 726f 692e 7831 5d2c 2073 746f 7265  , roi.x1], store
+0001bf40: 3d46 616c 7365 290a 2020 2020 2020 2020  =False).        
+0001bf50: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
+0001bf60: 7465 7252 6573 706f 6e73 6528 290a 0a20  terResponse().. 
+0001bf70: 2020 2064 6566 2073 6574 5f64 6574 6563     def set_detec
+0001bf80: 746f 725f 726f 6928 7365 6c66 2c20 6172  tor_roi(self, ar
+0001bf90: 6773 3a20 6c69 7374 5b66 6c6f 6174 5d2c  gs: list[float],
+0001bfa0: 2073 746f 7265 3a20 626f 6f6c 203d 2054   store: bool = T
+0001bfb0: 7275 6529 3a0a 2020 2020 2020 2020 2222  rue):.        ""
+0001bfc0: 220a 2020 2020 2020 2020 4e6f 7465 2074  ".        Note t
+0001bfd0: 6869 7320 6f6e 6c79 2073 656e 6473 2074  his only sends t
+0001bfe0: 6865 2052 4f49 2064 6f77 6e73 7472 6561  he ROI downstrea
+0001bff0: 6d20 746f 2074 6865 2073 7065 6374 726f  m to the spectro
+0001c000: 6d65 7465 7220 2861 6e64 2073 746f 7265  meter (and store
+0001c010: 730a 2020 2020 2020 2020 6974 2069 6e20  s.        it in 
+0001c020: 4465 7465 6374 6f72 5265 6769 6f6e 7329  DetectorRegions)
+0001c030: 2e20 2049 6620 796f 7520 7761 6e74 2074  .  If you want t
+0001c040: 6f20 7570 6461 7465 2074 6865 2077 6176  o update the wav
+0001c050: 6563 616c 2061 6e64 2073 746f 7265 0a20  ecal and store. 
+0001c060: 2020 2020 2020 2074 6865 2022 7365 6c65         the "sele
+0001c070: 6374 6564 2220 7265 6769 6f6e 2069 6e64  cted" region ind
+0001c080: 6578 2c20 7573 6520 7365 745f 7265 6769  ex, use set_regi
+0001c090: 6f6e 2829 2069 6e73 7465 6164 2028 7768  on() instead (wh
+0001c0a0: 6963 6820 6361 6c6c 7320 7468 6973 292e  ich calls this).
+0001c0b0: 0a20 2020 2020 2020 200a 2020 2020 2020  .        .      
+0001c0c0: 2020 596f 7520 7368 6f75 6c64 2075 7365    You should use
+0001c0d0: 2073 6574 5f72 6567 696f 6e28 2920 6966   set_region() if
+0001c0e0: 2079 6f75 2061 7265 2073 656c 6563 7469   you are selecti
+0001c0f0: 6e67 206f 6e65 206f 6620 7468 6520 7374  ng one of the st
+0001c100: 616e 6461 7264 0a20 2020 2020 2020 2072  andard.        r
+0001c110: 6567 696f 6e73 2061 6c72 6561 6479 2063  egions already c
+0001c120: 6f6e 6669 6775 7265 6420 6f6e 2074 6865  onfigured on the
+0001c130: 2045 4550 524f 4d2e 2020 596f 7520 7368   EEPROM.  You sh
+0001c140: 6f75 6c64 2075 7365 2073 6574 5f64 6574  ould use set_det
+0001c150: 6563 746f 725f 726f 6928 290a 2020 2020  ector_roi().    
+0001c160: 2020 2020 6966 2079 6f75 2772 6520 6d61      if you're ma
+0001c170: 6b69 6e67 2061 642d 686f 6320 524f 4973  king ad-hoc ROIs
+0001c180: 2077 6869 6368 2061 7265 6e27 7420 636f   which aren't co
+0001c190: 6e66 6967 7572 6564 206f 6e20 7468 6520  nfigured on the 
+0001c1a0: 4545 5052 4f4d 2e0a 2020 2020 2020 2020  EEPROM..        
+0001c1b0: 0a20 2020 2020 2020 2040 7061 7261 6d20  .        @param 
+0001c1c0: 6172 6773 3a20 6569 7468 6572 2061 2044  args: either a D
+0001c1d0: 6574 6563 746f 7252 4f49 206f 7220 6120  etectorROI or a 
+0001c1e0: 7475 706c 6520 6f66 2028 7265 6769 6f6e  tuple of (region
+0001c1f0: 2c20 7930 2c20 7931 2c20 7830 2c20 7831  , y0, y1, x0, x1
+0001c200: 290a 2020 2020 2020 2020 2222 220a 2020  ).        """.  
+0001c210: 2020 2020 2020 6966 206e 6f74 2073 656c        if not sel
+0001c220: 662e 7365 7474 696e 6773 2e69 735f 6d69  f.settings.is_mi
+0001c230: 6372 6f28 293a 0a20 2020 2020 2020 2020  cro():.         
+0001c240: 2020 206c 6f67 2e64 6562 7567 2822 4465     log.debug("De
+0001c250: 7465 6374 6f72 2052 4f49 206f 6e6c 7920  tector ROI only 
+0001c260: 636f 6e66 6967 7572 6162 6c65 206f 6e20  configurable on 
+0001c270: 5365 7269 6573 2d58 5322 290a 2020 2020  Series-XS").    
+0001c280: 2020 2020 2020 2020 7265 7475 726e 2053          return S
+0001c290: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
+0001c2a0: 6e73 6528 6461 7461 3d46 616c 7365 2c65  nse(data=False,e
+0001c2b0: 7272 6f72 5f6d 7367 3d22 4465 7465 6374  rror_msg="Detect
+0001c2c0: 6f72 2052 4f49 206e 6f74 2063 6f6e 6669  or ROI not confi
+0001c2d0: 6775 7261 626c 6522 290a 0a20 2020 2020  gurable")..     
+0001c2e0: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
+0001c2f0: 2861 7267 732c 2044 6574 6563 746f 7252  (args, DetectorR
+0001c300: 4f49 293a 0a20 2020 2020 2020 2020 2020  OI):.           
+0001c310: 2072 6f69 203d 2061 7267 730a 2020 2020   roi = args.    
+0001c320: 2020 2020 2020 2020 6c6f 672e 6465 6275          log.debu
+0001c330: 6728 6622 7061 7373 6564 2044 6574 6563  g(f"passed Detec
+0001c340: 746f 7252 4f49 3a20 7b72 6f69 7d22 290a  torROI: {roi}").
+0001c350: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+0001c360: 2020 2020 2020 2020 2020 2320 636f 6e76            # conv
+0001c370: 6572 7420 6172 6773 2074 6f20 524f 490a  ert args to ROI.
+0001c380: 2020 2020 2020 2020 2020 2020 6c6f 672e              log.
+0001c390: 6465 6275 6728 6622 6372 6561 7469 6e67  debug(f"creating
+0001c3a0: 2044 6574 6563 746f 7252 4f49 2066 726f   DetectorROI fro
+0001c3b0: 6d20 6172 6773 3a20 7b61 7267 737d 2229  m args: {args}")
+0001c3c0: 0a0a 2020 2020 2020 2020 2020 2020 6966  ..            if
+0001c3d0: 206c 656e 2861 7267 7329 2021 3d20 353a   len(args) != 5:
+0001c3e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001c3f0: 206c 6f67 2e65 7272 6f72 2866 2269 6e76   log.error(f"inv
+0001c400: 616c 6964 2064 6574 6563 746f 7220 726f  alid detector ro
+0001c410: 6920 6172 6773 3a20 7b61 7267 737d 2229  i args: {args}")
+0001c420: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001c430: 2072 6574 7572 6e20 5370 6563 7472 6f6d   return Spectrom
+0001c440: 6574 6572 5265 7370 6f6e 7365 2864 6174  eterResponse(dat
+0001c450: 613d 4661 6c73 652c 6572 726f 725f 6d73  a=False,error_ms
+0001c460: 673d 2269 6e76 616c 6964 2072 6f69 2061  g="invalid roi a
+0001c470: 7267 7322 290a 0a20 2020 2020 2020 2020  rgs")..         
+0001c480: 2020 2072 6567 696f 6e20 3d20 696e 7428     region = int(
+0001c490: 726f 756e 6428 6172 6773 5b30 5d29 290a  round(args[0])).
+0001c4a0: 2020 2020 2020 2020 2020 2020 7930 2020              y0  
+0001c4b0: 2020 203d 2069 6e74 2872 6f75 6e64 2861     = int(round(a
+0001c4c0: 7267 735b 315d 2929 0a20 2020 2020 2020  rgs[1])).       
+0001c4d0: 2020 2020 2079 3120 2020 2020 3d20 696e       y1     = in
+0001c4e0: 7428 726f 756e 6428 6172 6773 5b32 5d29  t(round(args[2])
+0001c4f0: 290a 2020 2020 2020 2020 2020 2020 7830  ).            x0
+0001c500: 2020 2020 203d 2069 6e74 2872 6f75 6e64       = int(round
+0001c510: 2861 7267 735b 335d 2929 0a20 2020 2020  (args[3])).     
+0001c520: 2020 2020 2020 2078 3120 2020 2020 3d20         x1     = 
+0001c530: 696e 7428 726f 756e 6428 6172 6773 5b34  int(round(args[4
+0001c540: 5d29 290a 0a20 2020 2020 2020 2020 2020  ]))..           
+0001c550: 2069 6620 6e6f 7420 2830 203c 3d20 7265   if not (0 <= re
+0001c560: 6769 6f6e 203c 3d20 3320 616e 640a 2020  gion <= 3 and.  
+0001c570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c580: 2020 7930 203c 2079 3120 616e 640a 2020    y0 < y1 and.  
+0001c590: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c5a0: 2020 7830 203c 2078 3120 616e 640a 2020    x0 < x1 and.  
+0001c5b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c5c0: 2020 7930 203e 3d20 3020 616e 640a 2020    y0 >= 0 and.  
+0001c5d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c5e0: 2020 7830 203e 3d20 3020 616e 640a 2020    x0 >= 0 and.  
+0001c5f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c600: 2020 7931 203c 3d20 7365 6c66 2e73 6574    y1 <= self.set
+0001c610: 7469 6e67 732e 6565 7072 6f6d 2e61 6374  tings.eeprom.act
+0001c620: 6976 655f 7069 7865 6c73 5f68 6f72 697a  ive_pixels_horiz
+0001c630: 6f6e 7461 6c20 616e 640a 2020 2020 2020  ontal and.      
+0001c640: 2020 2020 2020 2020 2020 2020 2020 7831                x1
+0001c650: 203c 3d20 7365 6c66 2e73 6574 7469 6e67   <= self.setting
+0001c660: 732e 6565 7072 6f6d 2e61 6374 6976 655f  s.eeprom.active_
+0001c670: 7069 7865 6c73 5f68 6f72 697a 6f6e 7461  pixels_horizonta
+0001c680: 6c29 3a0a 2020 2020 2020 2020 2020 2020  l):.            
+0001c690: 2020 2020 6c6f 672e 6572 726f 7228 6622      log.error(f"
+0001c6a0: 696e 7661 6c69 6420 6465 7465 6374 6f72  invalid detector
+0001c6b0: 2072 6f69 3a20 7b61 7267 737d 2229 0a20   roi: {args}"). 
+0001c6c0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+0001c6d0: 6574 7572 6e20 5370 6563 7472 6f6d 6574  eturn Spectromet
+0001c6e0: 6572 5265 7370 6f6e 7365 2864 6174 613d  erResponse(data=
+0001c6f0: 4661 6c73 652c 6572 726f 725f 6d73 673d  False,error_msg=
+0001c700: 2269 6e76 616c 6964 2072 6f69 2061 7267  "invalid roi arg
+0001c710: 7322 290a 2020 2020 2020 2020 2020 2020  s").            
+0001c720: 726f 6920 3d20 4465 7465 6374 6f72 524f  roi = DetectorRO
+0001c730: 4928 7265 6769 6f6e 2c20 7930 2c20 7931  I(region, y0, y1
+0001c740: 2c20 7830 2c20 7831 290a 2020 2020 2020  , x0, x1).      
+0001c750: 2020 2020 2020 6c6f 672e 6465 6275 6728        log.debug(
+0001c760: 6622 6372 6561 7465 6420 4465 7465 6374  f"created Detect
+0001c770: 6f72 524f 493a 207b 726f 697d 2229 0a0a  orROI: {roi}")..
+0001c780: 2020 2020 2020 2020 2320 6465 7465 726d          # determ
+0001c790: 696e 6520 7072 6576 696f 7573 2074 6f74  ine previous tot
+0001c7a0: 616c 2070 6978 656c 730a 2020 2020 2020  al pixels.      
+0001c7b0: 2020 7365 6c66 2e70 7265 765f 7069 7865    self.prev_pixe
+0001c7c0: 6c73 203d 2073 656c 662e 7365 7474 696e  ls = self.settin
+0001c7d0: 6773 2e70 6978 656c 7328 290a 2020 2020  gs.pixels().    
+0001c7e0: 2020 2020 6c6f 672e 6465 6275 6728 6622      log.debug(f"
+0001c7f0: 7072 6576 5f70 6978 656c 7320 3d20 7b73  prev_pixels = {s
+0001c800: 656c 662e 7072 6576 5f70 6978 656c 737d  elf.prev_pixels}
+0001c810: 2229 0a0a 2020 2020 2020 2020 6966 2073  ")..        if s
+0001c820: 746f 7265 3a0a 2020 2020 2020 2020 2020  tore:.          
+0001c830: 2020 6966 2073 656c 662e 7365 7474 696e    if self.settin
+0001c840: 6773 2e73 7461 7465 2e64 6574 6563 746f  gs.state.detecto
+0001c850: 725f 7265 6769 6f6e 7320 6973 204e 6f6e  r_regions is Non
+0001c860: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0001c870: 2020 206c 6f67 2e64 6562 7567 2822 6372     log.debug("cr
+0001c880: 6561 7469 6e67 2044 6574 6563 746f 7252  eating DetectorR
+0001c890: 6567 696f 6e73 2229 0a20 2020 2020 2020  egions").       
+0001c8a0: 2020 2020 2020 2020 2073 656c 662e 7365           self.se
+0001c8b0: 7474 696e 6773 2e73 7461 7465 2e64 6574  ttings.state.det
+0001c8c0: 6563 746f 725f 7265 6769 6f6e 7320 3d20  ector_regions = 
+0001c8d0: 4465 7465 6374 6f72 5265 6769 6f6e 7328  DetectorRegions(
+0001c8e0: 290a 0a20 2020 2020 2020 2020 2020 2023  )..            #
+0001c8f0: 2074 6869 7320 6973 2061 206e 6f2d 6f70   this is a no-op
+0001c900: 2069 6620 6974 2773 2061 6c72 6561 6479   if it's already
+0001c910: 2070 7265 7365 6e74 2061 6e64 2075 6e63   present and unc
+0001c920: 6861 6e67 6564 0a20 2020 2020 2020 2020  hanged.         
+0001c930: 2020 206c 6f67 2e64 6562 7567 2822 7361     log.debug("sa
+0001c940: 7669 6e67 2044 6574 6563 746f 7252 4f49  ving DetectorROI
+0001c950: 2069 6e20 4465 7465 6374 6f72 5265 6769   in DetectorRegi
+0001c960: 6f6e 7322 290a 2020 2020 2020 2020 2020  ons").          
+0001c970: 2020 7365 6c66 2e73 6574 7469 6e67 732e    self.settings.
+0001c980: 7374 6174 652e 6465 7465 6374 6f72 5f72  state.detector_r
+0001c990: 6567 696f 6e73 2e61 6464 2872 6f69 290a  egions.add(roi).
+0001c9a0: 0a20 2020 2020 2020 206c 6f67 2e64 6562  .        log.deb
+0001c9b0: 7567 2866 2274 6f74 616c 5f70 6978 656c  ug(f"total_pixel
+0001c9c0: 7320 6e6f 7720 7b73 656c 662e 7365 7474  s now {self.sett
+0001c9d0: 696e 6773 2e70 6978 656c 7328 297d 2229  ings.pixels()}")
+0001c9e0: 0a0a 2020 2020 2020 2020 6275 6620 3d20  ..        buf = 
+0001c9f0: 7574 696c 732e 7569 6e74 3136 5f74 6f5f  utils.uint16_to_
+0001ca00: 6c69 7474 6c65 5f65 6e64 6961 6e28 5b20  little_endian([ 
+0001ca10: 726f 692e 7930 2c20 726f 692e 7931 2c20  roi.y0, roi.y1, 
+0001ca20: 726f 692e 7830 2c20 726f 692e 7831 205d  roi.x0, roi.x1 ]
+0001ca30: 290a 2020 2020 2020 2020 6c6f 672e 6465  ).        log.de
+0001ca40: 6275 6728 2277 6f75 6c64 2073 656e 6420  bug("would send 
+0001ca50: 6275 663a 2025 7322 2c20 6275 6629 0a0a  buf: %s", buf)..
+0001ca60: 2020 2020 2020 2020 7265 7375 6c74 203d          result =
+0001ca70: 2073 656c 662e 5f73 656e 645f 636f 6465   self._send_code
+0001ca80: 2862 5265 7175 6573 7420 2020 2020 2020  (bRequest       
+0001ca90: 203d 2030 7866 662c 0a20 2020 2020 2020   = 0xff,.       
+0001caa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cab0: 2020 2020 2020 2020 2077 5661 6c75 6520           wValue 
+0001cac0: 2020 2020 2020 2020 203d 2030 7832 352c           = 0x25,
+0001cad0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001cae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001caf0: 2077 496e 6465 7820 2020 2020 2020 2020   wIndex         
+0001cb00: 203d 2072 6f69 2e72 6567 696f 6e2c 0a20   = roi.region,. 
+0001cb10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cb20: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+0001cb30: 6174 615f 6f72 5f77 4c65 6e67 7468 203d  ata_or_wLength =
+0001cb40: 2062 7566 2c0a 2020 2020 2020 2020 2020   buf,.          
+0001cb50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cb60: 2020 2020 2020 6c61 6265 6c20 2020 2020        label     
+0001cb70: 2020 2020 2020 3d20 2253 4554 5f44 4554        = "SET_DET
+0001cb80: 4543 544f 525f 524f 4922 290a 0a20 2020  ECTOR_ROI")..   
+0001cb90: 2020 2020 206c 6f67 2e64 6562 7567 2822       log.debug("
+0001cba0: 7761 6974 696e 6720 3173 6563 2e2e 2e22  waiting 1sec..."
+0001cbb0: 290a 2020 2020 2020 2020 736c 6565 7028  ).        sleep(
+0001cbc0: 3129 0a0a 2020 2020 2020 2020 2320 4a75  1)..        # Ju
+0001cbd0: 7374 2069 6e20 6361 7365 2c20 666c 6f77  st in case, flow
+0001cbe0: 7320 7468 6520 7570 6461 7465 6420 4465  s the updated De
+0001cbf0: 7465 6374 6f72 5265 6769 6f6e 7320 6f62  tectorRegions ob
+0001cc00: 6a65 6374 2075 7073 7472 6561 6d0a 2020  ject upstream.  
+0001cc10: 2020 2020 2020 2320 736f 2063 616c 6c65        # so calle
+0001cc20: 7220 6861 7320 6163 6365 7373 2074 6f20  r has access to 
+0001cc30: 6974 2e0a 2020 2020 2020 2020 6966 2073  it..        if s
+0001cc40: 746f 7265 3a0a 2020 2020 2020 2020 2020  tore:.          
+0001cc50: 2020 7365 6c66 2e71 7565 7565 5f6d 6573    self.queue_mes
+0001cc60: 7361 6765 2822 6465 7465 6374 6f72 5f72  sage("detector_r
+0001cc70: 6567 696f 6e73 222c 2073 656c 662e 7365  egions", self.se
+0001cc80: 7474 696e 6773 2e73 7461 7465 2e64 6574  ttings.state.det
+0001cc90: 6563 746f 725f 7265 6769 6f6e 7329 0a0a  ector_regions)..
+0001cca0: 2020 2020 2020 2020 7265 7475 726e 2072          return r
+0001ccb0: 6573 756c 740a 0a20 2020 2064 6566 2067  esult..    def g
+0001ccc0: 6574 5f66 7067 615f 636f 6e66 6967 7572  et_fpga_configur
+0001ccd0: 6174 696f 6e5f 7265 6769 7374 6572 2873  ation_register(s
+0001cce0: 656c 662c 206c 6162 656c 3a20 7374 7220  elf, label: str 
+0001ccf0: 3d20 2222 293a 0a20 2020 2020 2020 2072  = ""):.        r
+0001cd00: 6177 203d 2073 656c 662e 5f67 6574 5f63  aw = self._get_c
+0001cd10: 6f64 6528 3078 6233 2c20 6c73 625f 6c65  ode(0xb3, lsb_le
+0001cd20: 6e3d 322c 206c 6162 656c 3d22 4745 545f  n=2, label="GET_
+0001cd30: 4650 4741 5f43 4f4e 4649 4755 5241 5449  FPGA_CONFIGURATI
+0001cd40: 4f4e 5f52 4547 4953 5445 5222 290a 2020  ON_REGISTER").  
+0001cd50: 2020 2020 2020 6c6f 672e 6465 6275 6728        log.debug(
+0001cd60: 6622 4650 4741 2043 6f6e 6669 6775 7261  f"FPGA Configura
+0001cd70: 7469 6f6e 2052 6567 6973 7465 723a 2030  tion Register: 0
+0001cd80: 787b 7261 773a 3034 787d 2028 7b6c 6162  x{raw:04x} ({lab
+0001cd90: 656c 7d29 2229 0a20 2020 2020 2020 2072  el})").        r
+0001cda0: 6574 7572 6e20 7261 770a 0a20 2020 2023  eturn raw..    #
+0001cdb0: 2023 2323 2323 2323 2323 2323 2323 2323   ###############
+0001cdc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001cdd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001cde0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001cdf0: 2323 2323 2323 2323 2323 230a 2020 2020  ###########.    
+0001ce00: 230a 2020 2020 2320 2020 2020 2020 2020  #.    #         
+0001ce10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ce20: 2020 4163 6365 7373 6f72 7920 436f 6e6e    Accessory Conn
+0001ce30: 6563 746f 720a 2020 2020 230a 2020 2020  ector.    #.    
+0001ce40: 2320 2323 2323 2323 2323 2323 2323 2323  # ##############
+0001ce50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ce60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ce70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ce80: 2323 2323 2323 2323 2323 2323 0a0a 2020  ############..  
+0001ce90: 2020 2320 2323 2323 2323 2323 2323 2323    # ############
+0001cea0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ceb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001cec0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ced0: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
+0001cee0: 2020 2023 2041 6363 6573 736f 7279 2045     # Accessory E
+0001cef0: 6e61 626c 650a 2020 2020 2320 2323 2323  nable.    # ####
+0001cf00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001cf10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001cf20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001cf30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001cf40: 2323 2323 2323 0a0a 2020 2020 2323 2040  ######..    ## @
+0001cf50: 746f 646f 2063 6861 6e67 6520 6f70 636f  todo change opco
+0001cf60: 6465 2028 636f 6e66 6c69 6374 7320 7769  de (conflicts wi
+0001cf70: 7468 2047 4554 5f44 4554 4543 544f 525f  th GET_DETECTOR_
+0001cf80: 5354 4152 545f 4c49 4e45 290a 2020 2020  START_LINE).    
+0001cf90: 6465 6620 7365 745f 6163 6365 7373 6f72  def set_accessor
+0001cfa0: 795f 656e 6162 6c65 2873 656c 662c 2066  y_enable(self, f
+0001cfb0: 6c61 673a 2062 6f6f 6c29 3a0a 2020 2020  lag: bool):.    
+0001cfc0: 2020 2020 6966 206e 6f74 2073 656c 662e      if not self.
+0001cfd0: 7365 7474 696e 6773 2e69 735f 6765 6e31  settings.is_gen1
+0001cfe0: 3528 293a 0a20 2020 2020 2020 2020 2020  5():.           
+0001cff0: 206c 6f67 2e64 6562 7567 2822 6163 6365   log.debug("acce
+0001d000: 7373 6f72 7920 7265 7175 6972 6573 2047  ssory requires G
+0001d010: 656e 2031 2e35 2229 0a20 2020 2020 2020  en 1.5").       
+0001d020: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
+0001d030: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
+0001d040: 2864 6174 613d 4661 6c73 652c 6572 726f  (data=False,erro
+0001d050: 725f 6d73 673d 2272 6571 7569 7265 7320  r_msg="requires 
+0001d060: 6765 6e31 2e35 2229 0a20 2020 2020 2020  gen1.5").       
+0001d070: 2076 616c 7565 203d 2031 2069 6620 666c   value = 1 if fl
+0001d080: 6167 2065 6c73 6520 300a 2020 2020 2020  ag else 0.      
+0001d090: 2020 7265 7475 726e 2073 656c 662e 5f73    return self._s
+0001d0a0: 656e 645f 636f 6465 2862 5265 7175 6573  end_code(bReques
+0001d0b0: 7420 2020 2020 2020 203d 2030 7832 322c  t        = 0x22,
+0001d0c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001d0d0: 2020 2020 2020 2020 2020 2020 2020 2077                 w
+0001d0e0: 5661 6c75 6520 2020 2020 2020 2020 203d  Value          =
+0001d0f0: 2076 616c 7565 2c0a 2020 2020 2020 2020   value,.        
+0001d100: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d110: 2020 2020 2020 7749 6e64 6578 2020 2020        wIndex    
+0001d120: 2020 2020 2020 3d20 302c 0a20 2020 2020        = 0,.     
+0001d130: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d140: 2020 2020 2020 2020 2064 6174 615f 6f72           data_or
+0001d150: 5f77 4c65 6e67 7468 203d 205b 305d 202a  _wLength = [0] *
+0001d160: 2038 2c0a 2020 2020 2020 2020 2020 2020   8,.            
+0001d170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d180: 2020 6c61 6265 6c20 2020 2020 2020 2020    label         
+0001d190: 2020 3d20 2253 4554 5f41 4343 4553 534f    = "SET_ACCESSO
+0001d1a0: 5259 5f45 4e41 424c 4522 290a 0a20 2020  RY_ENABLE")..   
+0001d1b0: 2023 2320 4074 6f64 6f20 6669 6e64 206f   ## @todo find o
+0001d1c0: 7574 206f 7063 6f64 650a 2020 2020 6465  ut opcode.    de
+0001d1d0: 6620 6765 745f 6469 7363 7265 7465 735f  f get_discretes_
+0001d1e0: 656e 6162 6c65 6428 7365 6c66 293a 0a20  enabled(self):. 
+0001d1f0: 2020 2020 2020 2069 6620 6e6f 7420 7365         if not se
+0001d200: 6c66 2e73 6574 7469 6e67 732e 6973 5f67  lf.settings.is_g
+0001d210: 656e 3135 2829 3a0a 2020 2020 2020 2020  en15():.        
+0001d220: 2020 2020 6c6f 672e 6572 726f 7228 2261      log.error("a
+0001d230: 6363 6573 736f 7279 2072 6571 7569 7265  ccessory require
+0001d240: 7320 4765 6e20 312e 3522 290a 2020 2020  s Gen 1.5").    
+0001d250: 2020 2020 2020 2020 7265 7475 726e 2053          return S
+0001d260: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
+0001d270: 6e73 6528 6461 7461 3d46 616c 7365 2c65  nse(data=False,e
+0001d280: 7272 6f72 5f6d 7367 3d22 7265 7175 6972  rror_msg="requir
+0001d290: 6573 2067 656e 312e 3522 290a 2020 2020  es gen1.5").    
+0001d2a0: 2020 2020 2320 7265 7475 726e 2073 656c      # return sel
+0001d2b0: 662e 5f67 6574 5f63 6f64 6528 3078 3337  f._get_code(0x37
+0001d2c0: 2c20 6c61 6265 6c3d 2247 4554 5f41 4343  , label="GET_ACC
+0001d2d0: 4553 534f 5259 5f45 4e41 424c 4544 222c  ESSORY_ENABLED",
+0001d2e0: 206d 7362 5f6c 656e 3d31 290a 0a20 2020   msb_len=1)..   
+0001d2f0: 2023 2023 2323 2323 2323 2323 2323 2323   # #############
+0001d300: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001d310: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001d320: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001d330: 2323 2323 2323 2323 2323 2323 230a 2020  #############.  
+0001d340: 2020 2320 4661 6e0a 2020 2020 2320 2323    # Fan.    # ##
+0001d350: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001d360: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001d370: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001d380: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001d390: 2323 2323 2323 2323 0a0a 2020 2020 6465  ########..    de
+0001d3a0: 6620 7365 745f 6661 6e5f 656e 6162 6c65  f set_fan_enable
+0001d3b0: 2873 656c 662c 2066 6c61 673a 2062 6f6f  (self, flag: boo
+0001d3c0: 6c29 3a0a 2020 2020 2020 2020 6966 206e  l):.        if n
+0001d3d0: 6f74 2073 656c 662e 7365 7474 696e 6773  ot self.settings
+0001d3e0: 2e69 735f 6765 6e31 3528 293a 0a20 2020  .is_gen15():.   
+0001d3f0: 2020 2020 2020 2020 206c 6f67 2e64 6562           log.deb
+0001d400: 7567 2822 6661 6e20 7265 7175 6972 6573  ug("fan requires
+0001d410: 2047 656e 2031 2e35 2229 0a20 2020 2020   Gen 1.5").     
+0001d420: 2020 2020 2020 2072 6574 7572 6e20 5370         return Sp
+0001d430: 6563 7472 6f6d 6574 6572 5265 7370 6f6e  ectrometerRespon
+0001d440: 7365 2864 6174 613d 4661 6c73 652c 6572  se(data=False,er
+0001d450: 726f 725f 6d73 673d 2266 616e 2072 6571  ror_msg="fan req
+0001d460: 7569 7265 7320 6765 6e31 352e 2229 0a20  uires gen15."). 
+0001d470: 2020 2020 2020 2076 616c 7565 203d 2031         value = 1
+0001d480: 2069 6620 666c 6167 2065 6c73 6520 300a   if flag else 0.
+0001d490: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+0001d4a0: 656c 662e 5f73 656e 645f 636f 6465 2862  elf._send_code(b
+0001d4b0: 5265 7175 6573 7420 2020 2020 2020 203d  Request        =
+0001d4c0: 2030 7833 362c 0a20 2020 2020 2020 2020   0x36,.         
+0001d4d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d4e0: 2020 2020 2077 5661 6c75 6520 2020 2020       wValue     
+0001d4f0: 2020 2020 203d 2076 616c 7565 2c0a 2020       = value,.  
+0001d500: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d510: 2020 2020 2020 2020 2020 2020 7749 6e64              wInd
+0001d520: 6578 2020 2020 2020 2020 2020 3d20 302c  ex          = 0,
+0001d530: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001d540: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+0001d550: 6174 615f 6f72 5f77 4c65 6e67 7468 203d  ata_or_wLength =
+0001d560: 205b 305d 202a 2038 2c0a 2020 2020 2020   [0] * 8,.      
+0001d570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d580: 2020 2020 2020 2020 6c61 6265 6c20 2020          label   
+0001d590: 2020 2020 2020 2020 3d20 2253 4554 5f46          = "SET_F
+0001d5a0: 414e 5f45 4e41 424c 4522 290a 0a20 2020  AN_ENABLE")..   
+0001d5b0: 2064 6566 2067 6574 5f66 616e 5f65 6e61   def get_fan_ena
+0001d5c0: 626c 6564 2873 656c 6629 3a0a 2020 2020  bled(self):.    
+0001d5d0: 2020 2020 6966 206e 6f74 2073 656c 662e      if not self.
+0001d5e0: 7365 7474 696e 6773 2e69 735f 6765 6e31  settings.is_gen1
+0001d5f0: 3528 293a 0a20 2020 2020 2020 2020 2020  5():.           
+0001d600: 206c 6f67 2e65 7272 6f72 2822 6661 6e20   log.error("fan 
+0001d610: 7265 7175 6972 6573 2047 656e 2031 2e35  requires Gen 1.5
+0001d620: 2229 0a20 2020 2020 2020 2020 2020 2072  ").            r
+0001d630: 6574 7572 6e20 5370 6563 7472 6f6d 6574  eturn Spectromet
+0001d640: 6572 5265 7370 6f6e 7365 2864 6174 613d  erResponse(data=
+0001d650: 4661 6c73 652c 6572 726f 725f 6d73 673d  False,error_msg=
+0001d660: 2266 616e 2072 6571 7569 7265 7320 6765  "fan requires ge
+0001d670: 6e31 2e35 2229 0a20 2020 2020 2020 2072  n1.5").        r
+0001d680: 6574 7572 6e20 5370 6563 7472 6f6d 6574  eturn Spectromet
+0001d690: 6572 5265 7370 6f6e 7365 2864 6174 613d  erResponse(data=
+0001d6a0: 3020 213d 2073 656c 662e 5f67 6574 5f63  0 != self._get_c
+0001d6b0: 6f64 6528 3078 3337 2c20 6c61 6265 6c3d  ode(0x37, label=
+0001d6c0: 2247 4554 5f46 414e 5f45 4e41 424c 4544  "GET_FAN_ENABLED
+0001d6d0: 222c 206d 7362 5f6c 656e 3d31 2929 0a0a  ", msb_len=1))..
+0001d6e0: 2020 2020 2320 2323 2323 2323 2323 2323      # ##########
+0001d6f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001d700: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001d710: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001d720: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001d730: 0a20 2020 2023 204c 616d 700a 2020 2020  .    # Lamp.    
+0001d740: 2320 2323 2323 2323 2323 2323 2323 2323  # ##############
+0001d750: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001d760: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001d770: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001d780: 2323 2323 2323 2323 2323 2323 0a0a 2020  ############..  
+0001d790: 2020 6465 6620 7365 745f 6c61 6d70 5f65    def set_lamp_e
+0001d7a0: 6e61 626c 6528 7365 6c66 2c20 666c 6167  nable(self, flag
+0001d7b0: 3a20 626f 6f6c 293a 0a20 2020 2020 2020  : bool):.       
+0001d7c0: 2069 6620 6e6f 7420 7365 6c66 2e73 6574   if not self.set
+0001d7d0: 7469 6e67 732e 6973 5f67 656e 3135 2829  tings.is_gen15()
+0001d7e0: 3a0a 2020 2020 2020 2020 2020 2020 6c6f  :.            lo
+0001d7f0: 672e 6465 6275 6728 226c 616d 7020 7265  g.debug("lamp re
+0001d800: 7175 6972 6573 2047 656e 2031 2e35 2229  quires Gen 1.5")
+0001d810: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0001d820: 7572 6e20 5370 6563 7472 6f6d 6574 6572  urn Spectrometer
+0001d830: 5265 7370 6f6e 7365 2864 6174 613d 4661  Response(data=Fa
+0001d840: 6c73 652c 6572 726f 725f 6d73 673d 226c  lse,error_msg="l
+0001d850: 616d 7020 7265 7175 6972 6573 2067 656e  amp requires gen
+0001d860: 312e 3522 290a 2020 2020 2020 2020 7661  1.5").        va
+0001d870: 6c75 6520 3d20 3120 6966 2066 6c61 6720  lue = 1 if flag 
+0001d880: 656c 7365 2030 0a20 2020 2020 2020 2072  else 0.        r
+0001d890: 6574 7572 6e20 7365 6c66 2e5f 7365 6e64  eturn self._send
+0001d8a0: 5f63 6f64 6528 6252 6571 7565 7374 2020  _code(bRequest  
+0001d8b0: 2020 2020 2020 3d20 3078 3332 2c0a 2020        = 0x32,.  
+0001d8c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d8d0: 2020 2020 2020 2020 2020 2020 7756 616c              wVal
+0001d8e0: 7565 2020 2020 2020 2020 2020 3d20 7661  ue          = va
+0001d8f0: 6c75 652c 0a20 2020 2020 2020 2020 2020  lue,.           
+0001d900: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d910: 2020 2077 496e 6465 7820 2020 2020 2020     wIndex       
+0001d920: 2020 203d 2030 2c0a 2020 2020 2020 2020     = 0,.        
+0001d930: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d940: 2020 2020 2020 6461 7461 5f6f 725f 774c        data_or_wL
+0001d950: 656e 6774 6820 3d20 5b30 5d20 2a20 382c  ength = [0] * 8,
+0001d960: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001d970: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+0001d980: 6162 656c 2020 2020 2020 2020 2020 203d  abel           =
+0001d990: 2022 5345 545f 4c41 4d50 5f45 4e41 424c   "SET_LAMP_ENABL
+0001d9a0: 4522 290a 0a20 2020 2064 6566 2067 6574  E")..    def get
+0001d9b0: 5f6c 616d 705f 656e 6162 6c65 6428 7365  _lamp_enabled(se
+0001d9c0: 6c66 293a 0a20 2020 2020 2020 2069 6620  lf):.        if 
+0001d9d0: 6e6f 7420 7365 6c66 2e73 6574 7469 6e67  not self.setting
+0001d9e0: 732e 6973 5f67 656e 3135 2829 3a0a 2020  s.is_gen15():.  
+0001d9f0: 2020 2020 2020 2020 2020 6c6f 672e 6572            log.er
+0001da00: 726f 7228 226c 616d 7020 7265 7175 6972  ror("lamp requir
+0001da10: 6573 2047 656e 2031 2e35 2229 0a20 2020  es Gen 1.5").   
+0001da20: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0001da30: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
+0001da40: 6f6e 7365 2864 6174 613d 4661 6c73 652c  onse(data=False,
+0001da50: 6572 726f 725f 6d73 673d 226c 616d 7020  error_msg="lamp 
+0001da60: 7265 7175 6972 6573 2067 656e 312e 3522  requires gen1.5"
+0001da70: 290a 2020 2020 2020 2020 7265 7320 3d20  ).        res = 
+0001da80: 7365 6c66 2e5f 6765 745f 636f 6465 2830  self._get_code(0
+0001da90: 7833 332c 206c 6162 656c 3d22 4745 545f  x33, label="GET_
+0001daa0: 4c41 4d50 5f45 4e41 424c 4544 222c 206d  LAMP_ENABLED", m
+0001dab0: 7362 5f6c 656e 3d31 290a 2020 2020 2020  sb_len=1).      
+0001dac0: 2020 7265 732e 6461 7461 203d 2030 2021    res.data = 0 !
+0001dad0: 3d20 7265 732e 6461 7461 0a20 2020 2020  = res.data.     
+0001dae0: 2020 2072 6574 7572 6e20 7265 730a 0a20     return res.. 
+0001daf0: 2020 2023 2023 2323 2323 2323 2323 2323     # ###########
+0001db00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001db10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001db20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001db30: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
+0001db40: 2020 2020 2320 5368 7574 7465 720a 2020      # Shutter.  
+0001db50: 2020 2320 2323 2323 2323 2323 2323 2323    # ############
+0001db60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001db70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001db80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001db90: 2323 2323 2323 2323 2323 2323 2323 0a0a  ##############..
+0001dba0: 2020 2020 6465 6620 7365 745f 7368 7574      def set_shut
+0001dbb0: 7465 725f 656e 6162 6c65 2873 656c 662c  ter_enable(self,
+0001dbc0: 2066 6c61 673a 2062 6f6f 6c29 3a0a 2020   flag: bool):.  
+0001dbd0: 2020 2020 2020 6966 206e 6f74 2028 7365        if not (se
+0001dbe0: 6c66 2e73 6574 7469 6e67 732e 6973 5f67  lf.settings.is_g
+0001dbf0: 656e 3135 2829 2061 6e64 2073 656c 662e  en15() and self.
+0001dc00: 7365 7474 696e 6773 2e65 6570 726f 6d2e  settings.eeprom.
+0001dc10: 6861 735f 7368 7574 7465 7229 3a0a 2020  has_shutter):.  
+0001dc20: 2020 2020 2020 2020 2020 6c6f 672e 6465            log.de
+0001dc30: 6275 6728 2273 6875 7474 6572 2072 6571  bug("shutter req
+0001dc40: 7569 7265 7320 4765 6e20 312e 3520 616e  uires Gen 1.5 an
+0001dc50: 6420 6861 735f 7368 7574 7465 7220 666c  d has_shutter fl
+0001dc60: 6167 2229 0a20 2020 2020 2020 2020 2020  ag").           
+0001dc70: 2072 6574 7572 6e20 5370 6563 7472 6f6d   return Spectrom
+0001dc80: 6574 6572 5265 7370 6f6e 7365 2864 6174  eterResponse(dat
+0001dc90: 613d 4661 6c73 652c 6572 726f 725f 6d73  a=False,error_ms
+0001dca0: 673d 2273 6875 7474 6572 2072 6571 7569  g="shutter requi
+0001dcb0: 7265 7320 6765 6e31 2e35 2229 0a20 2020  res gen1.5").   
+0001dcc0: 2020 2020 2076 616c 7565 203d 2031 2069       value = 1 i
+0001dcd0: 6620 666c 6167 2065 6c73 6520 300a 2020  f flag else 0.  
+0001dce0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+0001dcf0: 662e 5f73 656e 645f 636f 6465 2862 5265  f._send_code(bRe
+0001dd00: 7175 6573 7420 2020 2020 2020 203d 2030  quest        = 0
+0001dd10: 7833 302c 0a20 2020 2020 2020 2020 2020  x30,.           
+0001dd20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001dd30: 2020 2077 5661 6c75 6520 2020 2020 2020     wValue       
+0001dd40: 2020 203d 2076 616c 7565 2c0a 2020 2020     = value,.    
+0001dd50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001dd60: 2020 2020 2020 2020 2020 7749 6e64 6578            wIndex
+0001dd70: 2020 2020 2020 2020 2020 3d20 302c 0a20            = 0,. 
+0001dd80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001dd90: 2020 2020 2020 2020 2020 2020 2064 6174               dat
+0001dda0: 615f 6f72 5f77 4c65 6e67 7468 203d 205b  a_or_wLength = [
+0001ddb0: 305d 202a 2038 2c0a 2020 2020 2020 2020  0] * 8,.        
+0001ddc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ddd0: 2020 2020 2020 6c61 6265 6c20 2020 2020        label     
+0001dde0: 2020 2020 2020 3d20 2253 4554 5f53 4855        = "SET_SHU
+0001ddf0: 5454 4552 5f45 4e41 424c 4522 290a 0a20  TTER_ENABLE").. 
+0001de00: 2020 2064 6566 2067 6574 5f73 6875 7474     def get_shutt
+0001de10: 6572 5f65 6e61 626c 6564 2873 656c 6629  er_enabled(self)
+0001de20: 3a0a 2020 2020 2020 2020 6966 206e 6f74  :.        if not
+0001de30: 2028 7365 6c66 2e73 6574 7469 6e67 732e   (self.settings.
+0001de40: 6973 5f67 656e 3135 2829 2061 6e64 2073  is_gen15() and s
+0001de50: 656c 662e 7365 7474 696e 6773 2e65 6570  elf.settings.eep
+0001de60: 726f 6d2e 6861 735f 7368 7574 7465 7229  rom.has_shutter)
+0001de70: 3a0a 2020 2020 2020 2020 2020 2020 6c6f  :.            lo
+0001de80: 672e 6465 6275 6728 2273 6875 7474 6572  g.debug("shutter
+0001de90: 2072 6571 7569 7265 7320 4765 6e20 312e   requires Gen 1.
+0001dea0: 3520 616e 6420 6861 735f 7368 7574 7465  5 and has_shutte
+0001deb0: 7220 666c 6167 2229 0a20 2020 2020 2020  r flag").       
+0001dec0: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
 0001ded0: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
-0001dee0: 200d 0a20 2020 2020 2020 2022 2222 0d0a   ..        """..
-0001def0: 2020 2020 2020 2020 4120 636f 6e66 656e          A confen
-0001df00: 7572 6162 6c65 2064 656c 6179 2066 726f  urable delay fro
-0001df10: 6d20 7768 656e 2061 6e20 696e 626f 756e  m when an inboun
-0001df20: 6420 7472 6967 6765 7220 7369 676e 616c  d trigger signal
-0001df30: 2069 730d 0a20 2020 2020 2020 2072 6563   is..        rec
-0001df40: 6569 7665 6420 6279 2074 6865 2073 7065  eived by the spe
-0001df50: 6374 726f 6d65 7465 722c 2075 6e74 696c  ctrometer, until
-0001df60: 2074 6865 2074 7269 6767 6572 6564 2061   the triggered a
-0001df70: 6371 7569 7369 7469 6f6e 2061 6374 7561  cquisition actua
-0001df80: 6c6c 7920 7374 6172 7473 2e0d 0a20 2020  lly starts...   
-0001df90: 2020 2020 200d 0a20 2020 2020 2020 2044       ..        D
-0001dfa0: 6566 6175 6c74 2076 616c 7565 2069 7320  efault value is 
-0001dfb0: 3075 732e 0d0a 2020 2020 2020 2020 0d0a  0us...        ..
-0001dfc0: 2020 2020 2020 2020 556e 6974 2069 7320          Unit is 
-0001dfd0: 696e 2030 2e35 206d 6963 726f 7365 636f  in 0.5 microseco
-0001dfe0: 6e64 7320 2835 3030 6e73 292c 2073 6f20  nds (500ns), so 
-0001dff0: 7661 6c75 6520 6f66 2032 3520 776f 756c  value of 25 woul
-0001e000: 6420 7265 7072 6573 656e 7420 3132 2e35  d represent 12.5
-0001e010: 7573 2e0d 0a20 2020 2020 2020 200d 0a20  us...        .. 
-0001e020: 2020 2020 2020 2056 616c 7565 2069 7320         Value is 
-0001e030: 3234 6269 742c 2073 6f20 6d61 7820 7661  24bit, so max va
-0001e040: 6c75 6520 6973 2031 3637 3737 3231 3620  lue is 16777216 
-0001e050: 2838 2e33 3838 3630 3820 7365 6329 2e0d  (8.388608 sec)..
-0001e060: 0a20 2020 2020 2020 200d 0a20 2020 2020  .        ..     
-0001e070: 2020 204c 696b 6520 7472 6967 6765 7269     Like triggeri
-0001e080: 6e67 2c20 6f6e 6c79 2063 7572 7265 6e74  ng, only current
-0001e090: 6c79 2073 7570 706f 7274 6564 206f 6e20  ly supported on 
-0001e0a0: 4152 4d2e 0d0a 2020 2020 2020 2020 2222  ARM...        ""
-0001e0b0: 220d 0a20 2020 2020 2020 2069 6620 6e6f  "..        if no
-0001e0c0: 7420 7365 6c66 2e73 6574 7469 6e67 732e  t self.settings.
-0001e0d0: 6973 5f61 726d 2829 3a0d 0a20 2020 2020  is_arm():..     
-0001e0e0: 2020 2020 2020 206c 6f67 2e65 7272 6f72         log.error
-0001e0f0: 2822 5345 545f 5452 4947 4745 525f 4445  ("SET_TRIGGER_DE
-0001e100: 4c41 5920 6f6e 6c79 2073 7570 706f 7274  LAY only support
-0001e110: 6564 206f 6e20 4152 4d22 290d 0a20 2020  ed on ARM")..   
-0001e120: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0001e130: 4661 6c73 650d 0a20 2020 2020 2020 206c  False..        l
-0001e140: 7377 203d 2068 616c 665f 7573 2026 2030  sw = half_us & 0
-0001e150: 7866 6666 660d 0a20 2020 2020 2020 206d  xffff..        m
-0001e160: 7362 203d 2028 6861 6c66 5f75 7320 3e3e  sb = (half_us >>
-0001e170: 2031 3629 2026 2030 7866 660d 0a20 2020   16) & 0xff..   
-0001e180: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-0001e190: 2e5f 7365 6e64 5f63 6f64 6528 3078 6161  ._send_code(0xaa
-0001e1a0: 2c20 7756 616c 7565 3d6c 7377 2c20 7749  , wValue=lsw, wI
-0001e1b0: 6e64 6578 3d6d 7362 2c20 6c61 6265 6c3d  ndex=msb, label=
-0001e1c0: 2253 4554 5f54 5249 4747 4552 5f44 454c  "SET_TRIGGER_DEL
-0001e1d0: 4159 2229 0d0a 0d0a 2020 2020 2320 6e6f  AY")....    # no
-0001e1e0: 7420 7465 7374 6564 0d0a 2020 2020 6465  t tested..    de
-0001e1f0: 6620 6765 745f 7472 6967 6765 725f 6465  f get_trigger_de
-0001e200: 6c61 7928 7365 6c66 293a 2023 202d 3e20  lay(self): # -> 
-0001e210: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
-0001e220: 6f6e 7365 200d 0a20 2020 2020 2020 2069  onse ..        i
-0001e230: 6620 6e6f 7420 7365 6c66 2e73 6574 7469  f not self.setti
-0001e240: 6e67 732e 6973 5f61 726d 2829 3a0d 0a20  ngs.is_arm():.. 
-0001e250: 2020 2020 2020 2020 2020 206d 7367 203d             msg =
-0001e260: 2022 4745 545f 5452 4947 4745 525f 4445   "GET_TRIGGER_DE
-0001e270: 4c41 5920 6f6e 6c79 2073 7570 706f 7274  LAY only support
-0001e280: 6564 206f 6e20 4152 4d22 0d0a 2020 2020  ed on ARM"..    
-0001e290: 2020 2020 2020 2020 6c6f 672e 6572 726f          log.erro
-0001e2a0: 7228 6d73 6729 0d0a 2020 2020 2020 2020  r(msg)..        
-0001e2b0: 2020 2020 7265 7475 726e 2053 7065 6374      return Spect
-0001e2c0: 726f 6d65 7465 7252 6573 706f 6e73 6528  rometerResponse(
-0001e2d0: 6572 726f 725f 6c76 6c3d 4572 726f 724c  error_lvl=ErrorL
-0001e2e0: 6576 656c 2e6c 6f77 2c20 6572 726f 725f  evel.low, error_
-0001e2f0: 6d73 673d 6d73 6729 0d0a 2020 2020 2020  msg=msg)..      
-0001e300: 2020 7265 7475 726e 2073 656c 662e 5f67    return self._g
-0001e310: 6574 5f63 6f64 6528 3078 6534 2c20 6c61  et_code(0xe4, la
-0001e320: 6265 6c3d 2247 4554 5f54 5249 4747 4552  bel="GET_TRIGGER
-0001e330: 5f44 454c 4159 222c 206c 7362 5f6c 656e  _DELAY", lsb_len
-0001e340: 3d33 2920 2320 6e6f 7420 7375 7265 2061  =3) # not sure a
-0001e350: 626f 7574 204c 5342 0d0a 0d0a 2020 2020  bout LSB....    
-0001e360: 6465 6620 6765 745f 7672 5f63 6f6e 7469  def get_vr_conti
-0001e370: 6e75 6f75 735f 6363 6428 7365 6c66 293a  nuous_ccd(self):
-0001e380: 2023 202d 3e20 5370 6563 7472 6f6d 6574   # -> Spectromet
-0001e390: 6572 5265 7370 6f6e 7365 200d 0a20 2020  erResponse ..   
-0001e3a0: 2020 2020 2072 6573 203d 2073 656c 662e       res = self.
-0001e3b0: 5f67 6574 5f63 6f64 6528 3078 6363 2c20  _get_code(0xcc, 
-0001e3c0: 6c61 6265 6c3d 2247 4554 5f56 525f 434f  label="GET_VR_CO
-0001e3d0: 4e54 494e 554f 5553 5f43 4344 222c 206d  NTINUOUS_CCD", m
-0001e3e0: 7362 5f6c 656e 3d31 290d 0a20 2020 2020  sb_len=1)..     
-0001e3f0: 2020 2069 6620 7265 732e 6572 726f 725f     if res.error_
-0001e400: 6d73 6720 213d 2027 273a 0d0a 2020 2020  msg != '':..    
-0001e410: 2020 2020 2020 2020 7265 7475 726e 2072          return r
-0001e420: 6573 0d0a 2020 2020 2020 2020 7265 732e  es..        res.
-0001e430: 6461 7461 203d 2030 2021 3d20 7265 732e  data = 0 != res.
-0001e440: 6461 7461 0d0a 2020 2020 2020 2020 7265  data..        re
-0001e450: 7475 726e 2072 6573 0d0a 0d0a 2020 2020  turn res....    
-0001e460: 6465 6620 6765 745f 7672 5f6e 756d 5f66  def get_vr_num_f
-0001e470: 7261 6d65 7328 7365 6c66 293a 2023 202d  rames(self): # -
-0001e480: 3e20 5370 6563 7472 6f6d 6574 6572 5265  > SpectrometerRe
-0001e490: 7370 6f6e 7365 200d 0a20 2020 2020 2020  sponse ..       
-0001e4a0: 2072 6574 7572 6e20 7365 6c66 2e5f 6765   return self._ge
-0001e4b0: 745f 636f 6465 2830 7863 642c 206c 6162  t_code(0xcd, lab
-0001e4c0: 656c 3d22 4745 545f 5652 5f4e 554d 5f46  el="GET_VR_NUM_F
-0001e4d0: 5241 4d45 5322 2c20 6d73 625f 6c65 6e3d  RAMES", msb_len=
-0001e4e0: 3129 0d0a 0d0a 2020 2020 6465 6620 6765  1)....    def ge
-0001e4f0: 745f 6f70 745f 6163 7475 616c 5f69 6e74  t_opt_actual_int
-0001e500: 6567 7261 7469 6f6e 5f74 696d 6528 7365  egration_time(se
-0001e510: 6c66 293a 2023 202d 3e20 5370 6563 7472  lf): # -> Spectr
-0001e520: 6f6d 6574 6572 5265 7370 6f6e 7365 200d  ometerResponse .
-0001e530: 0a20 2020 2020 2020 2072 6573 203d 2073  .        res = s
-0001e540: 656c 662e 6765 745f 7570 7065 725f 636f  elf.get_upper_co
-0001e550: 6465 2830 7830 622c 206c 6162 656c 3d22  de(0x0b, label="
-0001e560: 4745 545f 4f50 545f 4143 545f 494e 545f  GET_OPT_ACT_INT_
-0001e570: 5449 4d45 222c 206d 7362 5f6c 656e 3d31  TIME", msb_len=1
-0001e580: 2920 0d0a 2020 2020 2020 2020 6966 2072  ) ..        if r
-0001e590: 6573 2e65 7272 6f72 5f6d 7367 2021 3d20  es.error_msg != 
-0001e5a0: 2727 3a0d 0a20 2020 2020 2020 2020 2020  '':..           
-0001e5b0: 2072 6574 7572 6e20 7265 730d 0a20 2020   return res..   
-0001e5c0: 2020 2020 2072 6573 2e64 6174 6120 3d20       res.data = 
-0001e5d0: 3020 213d 2072 6573 2e64 6174 610d 0a20  0 != res.data.. 
-0001e5e0: 2020 2020 2020 2072 6574 7572 6e20 7265         return re
-0001e5f0: 730d 0a0d 0a20 2020 2064 6566 2067 6574  s....    def get
-0001e600: 5f6f 7074 5f61 7265 615f 7363 616e 2873  _opt_area_scan(s
-0001e610: 656c 6629 3a20 2320 2d3e 2053 7065 6374  elf): # -> Spect
-0001e620: 726f 6d65 7465 7252 6573 706f 6e73 6520  rometerResponse 
-0001e630: 0d0a 2020 2020 2020 2020 7265 7320 3d20  ..        res = 
-0001e640: 7365 6c66 2e67 6574 5f75 7070 6572 5f63  self.get_upper_c
-0001e650: 6f64 6528 3078 3061 2c20 6c61 6265 6c3d  ode(0x0a, label=
-0001e660: 2247 4554 5f4f 5054 5f41 5245 415f 5343  "GET_OPT_AREA_SC
-0001e670: 414e 222c 206d 7362 5f6c 656e 3d31 290d  AN", msb_len=1).
-0001e680: 0a20 2020 2020 2020 2069 6620 7265 732e  .        if res.
-0001e690: 6572 726f 725f 6d73 6720 213d 2027 273a  error_msg != '':
-0001e6a0: 0d0a 2020 2020 2020 2020 2020 2020 7265  ..            re
-0001e6b0: 7475 726e 2072 6573 0d0a 2020 2020 2020  turn res..      
-0001e6c0: 2020 7265 732e 6461 7461 203d 2030 2021    res.data = 0 !
-0001e6d0: 3d20 7265 732e 6461 7461 0d0a 2020 2020  = res.data..    
-0001e6e0: 2020 2020 7265 7475 726e 2072 6573 0d0a      return res..
-0001e6f0: 0d0a 2020 2020 6465 6620 6765 745f 6f70  ..    def get_op
-0001e700: 745f 6366 5f73 656c 6563 7428 7365 6c66  t_cf_select(self
-0001e710: 293a 2023 202d 3e20 5370 6563 7472 6f6d  ): # -> Spectrom
-0001e720: 6574 6572 5265 7370 6f6e 7365 200d 0a20  eterResponse .. 
-0001e730: 2020 2020 2020 2072 6573 203d 2073 656c         res = sel
-0001e740: 662e 6765 745f 7570 7065 725f 636f 6465  f.get_upper_code
-0001e750: 2830 7830 372c 206c 6162 656c 3d22 4745  (0x07, label="GE
-0001e760: 545f 4f50 545f 4346 5f53 454c 4543 5422  T_OPT_CF_SELECT"
-0001e770: 2c20 6d73 625f 6c65 6e3d 3129 0d0a 2020  , msb_len=1)..  
-0001e780: 2020 2020 2020 6966 2072 6573 2e65 7272        if res.err
-0001e790: 6f72 5f6d 7367 2021 3d20 2727 3a0d 0a20  or_msg != '':.. 
-0001e7a0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-0001e7b0: 6e20 7265 730d 0a20 2020 2020 2020 2072  n res..        r
-0001e7c0: 6573 2e64 6174 6120 3d20 3020 213d 2072  es.data = 0 != r
-0001e7d0: 6573 2e64 6174 610d 0a20 2020 2020 2020  es.data..       
-0001e7e0: 2072 6574 7572 6e20 7265 730d 0a0d 0a20   return res.... 
-0001e7f0: 2020 2064 6566 2067 6574 5f6f 7074 5f64     def get_opt_d
-0001e800: 6174 615f 6865 6164 6572 5f74 6162 2873  ata_header_tab(s
-0001e810: 656c 6629 3a20 2320 2d3e 2053 7065 6374  elf): # -> Spect
-0001e820: 726f 6d65 7465 7252 6573 706f 6e73 6520  rometerResponse 
-0001e830: 0d0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-0001e840: 2073 656c 662e 6765 745f 7570 7065 725f   self.get_upper_
-0001e850: 636f 6465 2830 7830 362c 206c 6162 656c  code(0x06, label
-0001e860: 3d22 4745 545f 4f50 545f 4441 5441 5f48  ="GET_OPT_DATA_H
-0001e870: 4541 4445 525f 5441 4222 2c20 6d73 625f  EADER_TAB", msb_
-0001e880: 6c65 6e3d 3129 0d0a 0d0a 2020 2020 6465  len=1)....    de
-0001e890: 6620 6765 745f 6f70 745f 686f 7269 7a6f  f get_opt_horizo
-0001e8a0: 6e74 616c 5f62 696e 6e69 6e67 2873 656c  ntal_binning(sel
-0001e8b0: 6629 3a20 2320 2d3e 2053 7065 6374 726f  f): # -> Spectro
-0001e8c0: 6d65 7465 7252 6573 706f 6e73 6520 0d0a  meterResponse ..
-0001e8d0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-0001e8e0: 656c 662e 6765 745f 7570 7065 725f 636f  elf.get_upper_co
-0001e8f0: 6465 2830 7830 632c 206c 6162 656c 3d22  de(0x0c, label="
-0001e900: 4745 545f 4f50 545f 484f 5249 5a4f 4e54  GET_OPT_HORIZONT
-0001e910: 414c 5f42 494e 4e49 4e47 222c 206d 7362  AL_BINNING", msb
-0001e920: 5f6c 656e 3d31 290d 0a0d 0a20 2020 2064  _len=1)....    d
-0001e930: 6566 2067 6574 5f6f 7074 5f69 6e74 6567  ef get_opt_integ
-0001e940: 7261 7469 6f6e 5f74 696d 655f 7265 736f  ration_time_reso
-0001e950: 6c75 7469 6f6e 2873 656c 6629 3a20 2320  lution(self): # 
-0001e960: 2d3e 2053 7065 6374 726f 6d65 7465 7252  -> SpectrometerR
-0001e970: 6573 706f 6e73 6520 0d0a 2020 2020 2020  esponse ..      
-0001e980: 2020 7265 7475 726e 2073 656c 662e 6765    return self.ge
-0001e990: 745f 7570 7065 725f 636f 6465 2830 7830  t_upper_code(0x0
-0001e9a0: 352c 206c 6162 656c 3d22 4745 545f 4f50  5, label="GET_OP
-0001e9b0: 545f 494e 5445 4752 4154 494f 4e5f 5449  T_INTEGRATION_TI
-0001e9c0: 4d45 5f52 4553 4f4c 5554 494f 4e22 2c20  ME_RESOLUTION", 
-0001e9d0: 6d73 625f 6c65 6e3d 3129 0d0a 0d0a 2020  msb_len=1)....  
-0001e9e0: 2020 2320 2323 2323 2323 2323 2323 2323    # ############
-0001e9f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ea00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001dee0: 2864 6174 613d 4661 6c73 652c 6572 726f  (data=False,erro
+0001def0: 725f 6d73 673d 2273 6875 7474 6572 2072  r_msg="shutter r
+0001df00: 6571 7569 7265 7320 6765 6e31 2e35 2229  equires gen1.5")
+0001df10: 0a20 2020 2020 2020 2072 6573 203d 2053  .        res = S
+0001df20: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
+0001df30: 6e73 6528 6461 7461 3d30 2021 3d20 7365  nse(data=0 != se
+0001df40: 6c66 2e5f 6765 745f 636f 6465 2830 7833  lf._get_code(0x3
+0001df50: 312c 206c 6162 656c 3d22 4745 545f 5348  1, label="GET_SH
+0001df60: 5554 5445 525f 454e 4142 4c45 4422 2c20  UTTER_ENABLED", 
+0001df70: 6d73 625f 6c65 6e3d 3129 290a 2020 2020  msb_len=1)).    
+0001df80: 2020 2020 7265 732e 6461 7461 203d 2030      res.data = 0
+0001df90: 2021 3d20 7265 732e 6461 7461 0a20 2020   != res.data.   
+0001dfa0: 2020 2020 2072 6574 7572 6e20 7265 7320       return res 
+0001dfb0: 0a0a 2020 2020 2320 2323 2323 2323 2323  ..    # ########
+0001dfc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001dfd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001dfe0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001dff0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e000: 2323 0a20 2020 2023 204c 6173 6572 204d  ##.    # Laser M
+0001e010: 6f64 756c 6174 696f 6e20 616e 6420 436f  odulation and Co
+0001e020: 6e74 696e 756f 7573 2053 7472 6f62 650a  ntinuous Strobe.
+0001e030: 2020 2020 2320 2323 2323 2323 2323 2323      # ##########
+0001e040: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e050: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e060: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e070: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e080: 0a0a 2020 2020 6465 6620 7365 745f 6d6f  ..    def set_mo
+0001e090: 645f 656e 6162 6c65 2873 656c 662c 2066  d_enable(self, f
+0001e0a0: 6c61 673a 2062 6f6f 6c29 3a0a 2020 2020  lag: bool):.    
+0001e0b0: 2020 2020 7365 6c66 2e73 6574 7469 6e67      self.setting
+0001e0c0: 732e 7374 6174 652e 6d6f 645f 656e 6162  s.state.mod_enab
+0001e0d0: 6c65 6420 3d20 666c 6167 0a20 2020 2020  led = flag.     
+0001e0e0: 2020 2076 616c 7565 203d 2031 2069 6620     value = 1 if 
+0001e0f0: 666c 6167 2065 6c73 6520 300a 2020 2020  flag else 0.    
+0001e100: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+0001e110: 5f73 656e 645f 636f 6465 2830 7862 642c  _send_code(0xbd,
+0001e120: 2076 616c 7565 2c20 6c61 6265 6c3d 2253   value, label="S
+0001e130: 4554 5f4d 4f44 5f45 4e41 424c 4522 290a  ET_MOD_ENABLE").
+0001e140: 0a20 2020 2064 6566 2067 6574 5f6d 6f64  .    def get_mod
+0001e150: 5f65 6e61 626c 6564 2873 656c 6629 3a0a  _enabled(self):.
+0001e160: 2020 2020 2020 2020 7265 7320 3d20 7365          res = se
+0001e170: 6c66 2e5f 6765 745f 636f 6465 2830 7865  lf._get_code(0xe
+0001e180: 332c 206c 6162 656c 3d22 4745 545f 4d4f  3, label="GET_MO
+0001e190: 445f 454e 4142 4c45 4422 2c20 6d73 625f  D_ENABLED", msb_
+0001e1a0: 6c65 6e3d 3129 0a20 2020 2020 2020 2069  len=1).        i
+0001e1b0: 6620 7265 732e 6572 726f 725f 6d73 6720  f res.error_msg 
+0001e1c0: 213d 2027 273a 0a20 2020 2020 2020 2020  != '':.         
+0001e1d0: 2020 2072 6574 7572 6e20 7265 730a 2020     return res.  
+0001e1e0: 2020 2020 2020 666c 6167 203d 2030 2021        flag = 0 !
+0001e1f0: 3d20 7265 732e 6461 7461 0a20 2020 2020  = res.data.     
+0001e200: 2020 2073 656c 662e 7365 7474 696e 6773     self.settings
+0001e210: 2e73 7461 7465 2e6d 6f64 5f65 6e61 626c  .state.mod_enabl
+0001e220: 6564 203d 2066 6c61 670a 2020 2020 2020  ed = flag.      
+0001e230: 2020 7265 7475 726e 2053 7065 6374 726f    return Spectro
+0001e240: 6d65 7465 7252 6573 706f 6e73 6528 6461  meterResponse(da
+0001e250: 7461 3d66 6c61 6729 0a0a 2020 2020 6465  ta=flag)..    de
+0001e260: 6620 7365 745f 6d6f 645f 7065 7269 6f64  f set_mod_period
+0001e270: 5f75 7328 7365 6c66 2c20 7573 3a20 666c  _us(self, us: fl
+0001e280: 6f61 7429 3a0a 2020 2020 2020 2020 7365  oat):.        se
+0001e290: 6c66 2e73 6574 7469 6e67 732e 7374 6174  lf.settings.stat
+0001e2a0: 652e 6d6f 645f 7065 7269 6f64 5f75 7320  e.mod_period_us 
+0001e2b0: 3d20 7573 0a20 2020 2020 2020 2028 6c73  = us.        (ls
+0001e2c0: 772c 206d 7377 2c20 6275 6629 203d 2073  w, msw, buf) = s
+0001e2d0: 656c 662e 5f74 6f34 3062 6974 2875 7329  elf._to40bit(us)
+0001e2e0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0001e2f0: 7365 6c66 2e5f 7365 6e64 5f63 6f64 6528  self._send_code(
+0001e300: 3078 6337 2c20 6c73 772c 206d 7377 2c20  0xc7, lsw, msw, 
+0001e310: 6275 662c 206c 6162 656c 3d22 5345 545f  buf, label="SET_
+0001e320: 4d4f 445f 5045 5249 4f44 2229 0a0a 2020  MOD_PERIOD")..  
+0001e330: 2020 6465 6620 6765 745f 6d6f 645f 7065    def get_mod_pe
+0001e340: 7269 6f64 5f75 7328 7365 6c66 293a 0a20  riod_us(self):. 
+0001e350: 2020 2020 2020 2072 6573 756c 7420 3d20         result = 
+0001e360: 7365 6c66 2e5f 6765 745f 636f 6465 2830  self._get_code(0
+0001e370: 7863 622c 206c 6162 656c 3d22 4745 545f  xcb, label="GET_
+0001e380: 4d4f 445f 5045 5249 4f44 222c 206c 7362  MOD_PERIOD", lsb
+0001e390: 5f6c 656e 3d35 290a 2020 2020 2020 2020  _len=5).        
+0001e3a0: 7365 6c66 2e73 6574 7469 6e67 732e 7374  self.settings.st
+0001e3b0: 6174 652e 6d6f 645f 7065 7269 6f64 5f75  ate.mod_period_u
+0001e3c0: 7320 3d20 7265 7375 6c74 0a20 2020 2020  s = result.     
+0001e3d0: 2020 2072 6574 7572 6e20 7265 7375 6c74     return result
+0001e3e0: 0a0a 2020 2020 6465 6620 7365 745f 6d6f  ..    def set_mo
+0001e3f0: 645f 7769 6474 685f 7573 2873 656c 662c  d_width_us(self,
+0001e400: 2075 733a 2066 6c6f 6174 293a 0a20 2020   us: float):.   
+0001e410: 2020 2020 2073 656c 662e 7365 7474 696e       self.settin
+0001e420: 6773 2e73 7461 7465 2e6d 6f64 5f77 6964  gs.state.mod_wid
+0001e430: 7468 5f75 7320 3d20 7573 0a20 2020 2020  th_us = us.     
+0001e440: 2020 2028 6c73 772c 206d 7377 2c20 6275     (lsw, msw, bu
+0001e450: 6629 203d 2073 656c 662e 5f74 6f34 3062  f) = self._to40b
+0001e460: 6974 2875 7329 0a20 2020 2020 2020 2072  it(us).        r
+0001e470: 6574 7572 6e20 7365 6c66 2e5f 7365 6e64  eturn self._send
+0001e480: 5f63 6f64 6528 3078 6462 2c20 6c73 772c  _code(0xdb, lsw,
+0001e490: 206d 7377 2c20 6275 662c 206c 6162 656c   msw, buf, label
+0001e4a0: 3d22 5345 545f 4d4f 445f 5749 4454 4822  ="SET_MOD_WIDTH"
+0001e4b0: 290a 0a20 2020 2064 6566 2067 6574 5f6d  )..    def get_m
+0001e4c0: 6f64 5f77 6964 7468 5f75 7328 7365 6c66  od_width_us(self
+0001e4d0: 293a 0a20 2020 2020 2020 2072 6573 756c  ):.        resul
+0001e4e0: 7420 3d20 7365 6c66 2e5f 6765 745f 636f  t = self._get_co
+0001e4f0: 6465 2830 7864 632c 206c 6162 656c 3d22  de(0xdc, label="
+0001e500: 4745 545f 4d4f 445f 5749 4454 4822 2c20  GET_MOD_WIDTH", 
+0001e510: 6c73 625f 6c65 6e3d 3529 0a20 2020 2020  lsb_len=5).     
+0001e520: 2020 2073 656c 662e 7365 7474 696e 6773     self.settings
+0001e530: 2e73 7461 7465 2e6d 6f64 5f77 6964 7468  .state.mod_width
+0001e540: 5f75 7320 3d20 7265 7375 6c74 2e64 6174  _us = result.dat
+0001e550: 610a 2020 2020 2020 2020 7265 7475 726e  a.        return
+0001e560: 2072 6573 756c 740a 0a20 2020 2064 6566   result..    def
+0001e570: 2073 6574 5f6d 6f64 5f64 656c 6179 5f75   set_mod_delay_u
+0001e580: 7328 7365 6c66 2c20 7573 3a20 666c 6f61  s(self, us: floa
+0001e590: 7429 3a0a 2020 2020 2020 2020 7365 6c66  t):.        self
+0001e5a0: 2e73 6574 7469 6e67 732e 7374 6174 652e  .settings.state.
+0001e5b0: 6d6f 645f 6465 6c61 795f 7573 203d 2075  mod_delay_us = u
+0001e5c0: 730a 2020 2020 2020 2020 286c 7377 2c20  s.        (lsw, 
+0001e5d0: 6d73 772c 2062 7566 2920 3d20 7365 6c66  msw, buf) = self
+0001e5e0: 2e5f 746f 3430 6269 7428 7573 290a 2020  ._to40bit(us).  
+0001e5f0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+0001e600: 662e 5f73 656e 645f 636f 6465 2830 7863  f._send_code(0xc
+0001e610: 362c 206c 7377 2c20 6d73 772c 2062 7566  6, lsw, msw, buf
+0001e620: 2c20 6c61 6265 6c3d 2253 4554 5f4d 4f44  , label="SET_MOD
+0001e630: 5f44 454c 4159 2229 0a0a 2020 2020 6465  _DELAY")..    de
+0001e640: 6620 6765 745f 6d6f 645f 6465 6c61 795f  f get_mod_delay_
+0001e650: 7573 2873 656c 6629 3a0a 2020 2020 2020  us(self):.      
+0001e660: 2020 7265 7375 6c74 203d 2073 656c 662e    result = self.
+0001e670: 5f67 6574 5f63 6f64 6528 3078 6361 2c20  _get_code(0xca, 
+0001e680: 6c61 6265 6c3d 2247 4554 5f4d 4f44 5f44  label="GET_MOD_D
+0001e690: 454c 4159 222c 206c 7362 5f6c 656e 3d35  ELAY", lsb_len=5
+0001e6a0: 290a 2020 2020 2020 2020 7365 6c66 2e73  ).        self.s
+0001e6b0: 6574 7469 6e67 732e 7374 6174 652e 6d6f  ettings.state.mo
+0001e6c0: 645f 6465 6c61 795f 7573 203d 2072 6573  d_delay_us = res
+0001e6d0: 756c 742e 6461 7461 0a20 2020 2020 2020  ult.data.       
+0001e6e0: 2072 6574 7572 6e20 7265 7375 6c74 0a0a   return result..
+0001e6f0: 2020 2020 6465 6620 7365 745f 6d6f 645f      def set_mod_
+0001e700: 6475 7261 7469 6f6e 5f75 735f 4e4f 545f  duration_us_NOT_
+0001e710: 5553 4544 2873 656c 662c 2075 733a 2066  USED(self, us: f
+0001e720: 6c6f 6174 293a 0a20 2020 2020 2020 2073  loat):.        s
+0001e730: 656c 662e 7365 7474 696e 6773 2e73 7461  elf.settings.sta
+0001e740: 7465 2e6d 6f64 5f64 7572 6174 696f 6e5f  te.mod_duration_
+0001e750: 7573 203d 2075 730a 2020 2020 2020 2020  us = us.        
+0001e760: 286c 7377 2c20 6d73 772c 2062 7566 2920  (lsw, msw, buf) 
+0001e770: 3d20 7365 6c66 2e5f 746f 3430 6269 7428  = self._to40bit(
+0001e780: 7573 290a 2020 2020 2020 2020 7265 7475  us).        retu
+0001e790: 726e 2073 656c 662e 5f73 656e 645f 636f  rn self._send_co
+0001e7a0: 6465 2830 7862 392c 206c 7377 2c20 6d73  de(0xb9, lsw, ms
+0001e7b0: 772c 2062 7566 2c20 6c61 6265 6c3d 2253  w, buf, label="S
+0001e7c0: 4554 5f4d 4f44 5f44 5552 4154 494f 4e22  ET_MOD_DURATION"
+0001e7d0: 290a 0a20 2020 2064 6566 2067 6574 5f6d  )..    def get_m
+0001e7e0: 6f64 5f64 7572 6174 696f 6e5f 7573 2873  od_duration_us(s
+0001e7f0: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+0001e800: 7375 6c74 203d 2073 656c 662e 5f67 6574  sult = self._get
+0001e810: 5f63 6f64 6528 3078 6333 2c20 6c61 6265  _code(0xc3, labe
+0001e820: 6c3d 2247 4554 5f4d 4f44 5f44 5552 4154  l="GET_MOD_DURAT
+0001e830: 494f 4e22 2c20 6c73 625f 6c65 6e3d 3529  ION", lsb_len=5)
+0001e840: 0a20 2020 2020 2020 2073 656c 662e 7365  .        self.se
+0001e850: 7474 696e 6773 2e73 7461 7465 2e6d 6f64  ttings.state.mod
+0001e860: 5f64 7572 6174 696f 6e5f 7573 203d 2072  _duration_us = r
+0001e870: 6573 756c 742e 6461 7461 0a20 2020 2020  esult.data.     
+0001e880: 2020 2072 6574 7572 6e20 7265 7375 6c74     return result
+0001e890: 0a0a 2020 2020 2323 2074 6869 7320 6973  ..    ## this is
+0001e8a0: 2061 2073 796e 6f6e 796d 2066 6f72 205f   a synonym for _
+0001e8b0: 7365 745f 6c61 7365 725f 656e 6162 6c65  set_laser_enable
+0001e8c0: 5f69 6d6d 6564 6961 7465 2829 2c20 6275  _immediate(), bu
+0001e8d0: 7420 7769 7468 6f75 7420 7369 6465 2d65  t without side-e
+0001e8e0: 6666 6563 7473 0a20 2020 2064 6566 2073  ffects.    def s
+0001e8f0: 6574 5f73 7472 6f62 655f 656e 6162 6c65  et_strobe_enable
+0001e900: 2873 656c 662c 2066 6c61 673a 2062 6f6f  (self, flag: boo
+0001e910: 6c29 3a0a 2020 2020 2020 2020 7661 6c75  l):.        valu
+0001e920: 6520 3d20 3120 6966 2066 6c61 6720 656c  e = 1 if flag el
+0001e930: 7365 2030 0a20 2020 2020 2020 2072 6574  se 0.        ret
+0001e940: 7572 6e20 7365 6c66 2e5f 7365 6e64 5f63  urn self._send_c
+0001e950: 6f64 6528 3078 6265 2c20 7661 6c75 652c  ode(0xbe, value,
+0001e960: 206c 6162 656c 3d22 5345 545f 5354 524f   label="SET_STRO
+0001e970: 4245 5f45 4e41 424c 4522 290a 0a20 2020  BE_ENABLE")..   
+0001e980: 2023 2320 6120 6c69 7465 7261 6c20 7061   ## a literal pa
+0001e990: 7373 2d74 6872 6f75 6768 2074 6f20 6765  ss-through to ge
+0001e9a0: 745f 6c61 7365 725f 656e 6162 6c65 6428  t_laser_enabled(
+0001e9b0: 290a 2020 2020 6465 6620 6765 745f 7374  ).    def get_st
+0001e9c0: 726f 6265 5f65 6e61 626c 6564 2873 656c  robe_enabled(sel
+0001e9d0: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
+0001e9e0: 726e 2073 656c 662e 6765 745f 6c61 7365  rn self.get_lase
+0001e9f0: 725f 656e 6162 6c65 6428 290a 0a20 2020  r_enabled()..   
+0001ea00: 2023 2023 2323 2323 2323 2323 2323 2323   # #############
 0001ea10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ea20: 2323 2323 2323 2323 2323 2323 2323 0d0a  ##############..
-0001ea30: 2020 2020 2320 416e 616c 6f67 206f 7574      # Analog out
-0001ea40: 7075 740d 0a20 2020 2023 2023 2323 2323  put..    # #####
-0001ea50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ea60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ea20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ea30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ea40: 2323 2323 2323 2323 2323 2323 230a 2020  #############.  
+0001ea50: 2020 2320 416d 6269 656e 7420 5465 6d70    # Ambient Temp
+0001ea60: 6572 6174 7572 650a 2020 2020 2320 2323  erature.    # ##
 0001ea70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0001ea80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ea90: 2323 2323 230d 0a0d 0a20 2020 2023 2320  #####....    ## 
-0001eaa0: 4070 6172 616d 2076 616c 7565 2028 496e  @param value (In
-0001eab0: 7075 7429 2074 7570 6c65 206f 6620 2862  put) tuple of (b
-0001eac0: 6f6f 6c20 656e 6162 6c65 2c20 696e 7420  ool enable, int 
-0001ead0: 6d6f 6465 290d 0a20 2020 2064 6566 2073  mode)..    def s
-0001eae0: 6574 5f61 6e61 6c6f 675f 6f75 7470 7574  et_analog_output
-0001eaf0: 5f6d 6f64 6528 7365 6c66 2c20 7661 6c75  _mode(self, valu
-0001eb00: 653a 2074 7570 6c65 5b62 6f6f 6c2c 2069  e: tuple[bool, i
-0001eb10: 6e74 5d29 3a20 2320 2d3e 2053 7065 6374  nt]): # -> Spect
-0001eb20: 726f 6d65 7465 7252 6573 706f 6e73 6520  rometerResponse 
-0001eb30: 0d0a 2020 2020 2020 2020 6966 206e 6f74  ..        if not
-0001eb40: 2073 656c 662e 7365 7474 696e 6773 2e69   self.settings.i
-0001eb50: 735f 6765 6e32 2829 3a0d 0a20 2020 2020  s_gen2():..     
-0001eb60: 2020 2020 2020 206c 6f67 6765 722e 6572         logger.er
-0001eb70: 726f 7228 2261 6e61 6c6f 6720 6f75 7470  ror("analog outp
-0001eb80: 7574 206f 6e6c 7920 6176 6169 6c61 626c  ut only availabl
-0001eb90: 6520 6f6e 2047 656e 3222 290d 0a20 2020  e on Gen2")..   
-0001eba0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0001ebb0: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
-0001ebc0: 6f6e 7365 2864 6174 613d 4661 6c73 652c  onse(data=False,
-0001ebd0: 6572 726f 725f 6d73 673d 2261 6e61 6c6f  error_msg="analo
-0001ebe0: 6720 6f75 7470 7574 2075 6e73 7570 706f  g output unsuppo
-0001ebf0: 7274 6564 2229 0d0a 0d0a 2020 2020 2020  rted")....      
-0001ec00: 2020 7749 6e64 6578 203d 2030 0d0a 0d0a    wIndex = 0....
-0001ec10: 2020 2020 2020 2020 2320 7061 7273 6520          # parse 
-0001ec20: 656e 6162 6c65 2061 6e64 206d 6f64 6520  enable and mode 
-0001ec30: 6672 6f6d 2076 616c 7565 2074 7570 6c65  from value tuple
-0001ec40: 0d0a 2020 2020 2020 2020 7472 793a 0d0a  ..        try:..
-0001ec50: 2020 2020 2020 2020 2020 2020 6966 2069              if i
-0001ec60: 7369 6e73 7461 6e63 6528 7661 6c75 655b  sinstance(value[
-0001ec70: 305d 2c20 626f 6f6c 293a 0d0a 2020 2020  0], bool):..    
-0001ec80: 2020 2020 2020 2020 2020 2020 656e 6162              enab
-0001ec90: 6c65 203d 2076 616c 7565 5b30 5d0d 0a20  le = value[0].. 
-0001eca0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-0001ecb0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0001ecc0: 2020 656e 6162 6c65 203d 2076 616c 7565    enable = value
-0001ecd0: 5b30 5d20 213d 2030 0d0a 0d0a 2020 2020  [0] != 0....    
-0001ece0: 2020 2020 2020 2020 6d6f 6465 203d 2069          mode = i
-0001ecf0: 6e74 2876 616c 7565 5b31 5d29 0d0a 2020  nt(value[1])..  
-0001ed00: 2020 2020 2020 2020 2020 6966 2028 6d6f            if (mo
-0001ed10: 6465 2021 3d20 3020 616e 6420 6d6f 6465  de != 0 and mode
-0001ed20: 2021 3d20 3129 3a0d 0a20 2020 2020 2020   != 1):..       
-0001ed30: 2020 2020 2020 2020 206c 6f67 6765 722e           logger.
-0001ed40: 6572 726f 7228 2269 6e76 616c 6964 2061  error("invalid a
-0001ed50: 6e61 6c6f 6720 6f75 7470 7574 206d 6f64  nalog output mod
-0001ed60: 6520 3078 2530 3278 2c20 6469 7361 626c  e 0x%02x, disabl
-0001ed70: 696e 6722 2c20 6d6f 6465 290d 0a20 2020  ing", mode)..   
-0001ed80: 2020 2020 2020 2020 2020 2020 2065 6e61               ena
-0001ed90: 626c 6520 3d20 4661 6c73 650d 0a20 2020  ble = False..   
-0001eda0: 2020 2020 2020 2020 2020 2020 206d 6f64               mod
-0001edb0: 6520 3d20 300d 0a0d 0a20 2020 2020 2020  e = 0....       
-0001edc0: 2020 2020 2069 6620 656e 6162 6c65 3a0d       if enable:.
-0001edd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001ede0: 2077 496e 6465 7820 3d20 3078 3032 207c   wIndex = 0x02 |
-0001edf0: 206d 6f64 6520 2320 3078 3032 2073 6574   mode # 0x02 set
-0001ee00: 7320 7468 6520 2265 6e61 626c 6522 2062  s the "enable" b
-0001ee10: 6974 0d0a 2020 2020 2020 2020 2020 2020  it..            
-0001ee20: 2020 2020 7365 6c66 2e73 7461 7465 2e61      self.state.a
-0001ee30: 6e61 6c6f 675f 6f75 745f 656e 6162 6c65  nalog_out_enable
-0001ee40: 203d 2054 7275 650d 0a20 2020 2020 2020   = True..       
-0001ee50: 2020 2020 2020 2020 2073 656c 662e 7374           self.st
-0001ee60: 6174 652e 616e 616c 6f67 5f6f 7574 5f6d  ate.analog_out_m
-0001ee70: 6f64 6520 3d20 6d6f 6465 0d0a 2020 2020  ode = mode..    
-0001ee80: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0001ee90: 2e73 7461 7465 2e61 6e61 6c6f 675f 6f75  .state.analog_ou
-0001eea0: 745f 7661 6c75 6520 3d20 3020 6966 206d  t_value = 0 if m
-0001eeb0: 6f64 6520 3d3d 2030 2065 6c73 6520 3430  ode == 0 else 40
-0001eec0: 2023 2034 6d41 2064 6566 6175 6c74 2063   # 4mA default c
-0001eed0: 7572 7265 6e74 2069 6e20 6465 6369 2d6d  urrent in deci-m
-0001eee0: 410d 0a20 2020 2020 2020 2020 2020 2065  A..            e
-0001eef0: 6c73 653a 0d0a 2020 2020 2020 2020 2020  lse:..          
-0001ef00: 2020 2020 2020 7749 6e64 6578 203d 2030        wIndex = 0
-0001ef10: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0001ef20: 2020 7365 6c66 2e73 7461 7465 2e61 6e61    self.state.ana
-0001ef30: 6c6f 675f 6f75 745f 656e 6162 6c65 203d  log_out_enable =
-0001ef40: 2046 616c 7365 0d0a 2020 2020 2020 2020   False..        
-0001ef50: 2020 2020 2020 2020 7365 6c66 2e73 7461          self.sta
-0001ef60: 7465 2e61 6e61 6c6f 675f 6f75 745f 6d6f  te.analog_out_mo
-0001ef70: 6465 203d 2030 0d0a 2020 2020 2020 2020  de = 0..        
-0001ef80: 2020 2020 2020 2020 7365 6c66 2e73 7461          self.sta
-0001ef90: 7465 2e61 6e61 6c6f 675f 6f75 745f 7661  te.analog_out_va
-0001efa0: 6c75 6520 3d20 300d 0a0d 0a20 2020 2020  lue = 0....     
-0001efb0: 2020 2065 7863 6570 743a 0d0a 2020 2020     except:..    
-0001efc0: 2020 2020 2020 2020 6c6f 6767 6572 2e65          logger.e
-0001efd0: 7272 6f72 2822 7365 745f 616e 616c 6f67  rror("set_analog
-0001efe0: 5f6f 7574 7075 745f 6d6f 6465 2074 616b  _output_mode tak
-0001eff0: 6573 2074 7570 6c65 206f 6620 2862 6f6f  es tuple of (boo
-0001f000: 6c2c 2069 6e74 292c 2064 6973 6162 6c69  l, int), disabli
-0001f010: 6e67 2229 0d0a 2020 2020 2020 2020 2020  ng")..          
-0001f020: 2020 7749 6e64 6578 203d 2030 0d0a 0d0a    wIndex = 0....
-0001f030: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-0001f040: 656c 662e 5f73 656e 645f 636f 6465 2862  elf._send_code(b
-0001f050: 5265 7175 6573 7420 203d 2030 7866 662c  Request  = 0xff,
-0001f060: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0001f070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f080: 7756 616c 7565 2020 2020 3d20 3078 3131  wValue    = 0x11
-0001f090: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-0001f0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f0b0: 2077 496e 6465 7820 2020 203d 2077 496e   wIndex    = wIn
-0001f0c0: 6465 782c 0d0a 2020 2020 2020 2020 2020  dex,..          
-0001f0d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f0e0: 2020 2020 6c61 6265 6c20 2020 2020 3d20      label     = 
-0001f0f0: 2253 4554 5f41 4e41 4c4f 475f 4f55 545f  "SET_ANALOG_OUT_
-0001f100: 4d4f 4445 2229 0d0a 0d0a 2020 2020 6465  MODE")....    de
-0001f110: 6620 7365 745f 616e 616c 6f67 5f6f 7574  f set_analog_out
-0001f120: 7075 745f 7661 6c75 6528 7365 6c66 2c20  put_value(self, 
-0001f130: 7661 6c75 653a 2069 6e74 293a 2023 202d  value: int): # -
-0001f140: 3e20 5370 6563 7472 6f6d 6574 6572 5265  > SpectrometerRe
-0001f150: 7370 6f6e 7365 200d 0a20 2020 2020 2020  sponse ..       
-0001f160: 2069 6620 6e6f 7420 7365 6c66 2e73 6574   if not self.set
-0001f170: 7469 6e67 732e 6973 5f67 656e 3228 293a  tings.is_gen2():
-0001f180: 0d0a 2020 2020 2020 2020 2020 2020 6c6f  ..            lo
-0001f190: 6767 6572 2e65 7272 6f72 2822 616e 616c  gger.error("anal
-0001f1a0: 6f67 206f 7574 7075 7420 6f6e 6c79 2061  og output only a
-0001f1b0: 7661 696c 6162 6c65 206f 6e20 4765 6e32  vailable on Gen2
-0001f1c0: 2229 0d0a 2020 2020 2020 2020 2020 2020  ")..            
-0001f1d0: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
-0001f1e0: 7465 7252 6573 706f 6e73 6528 6461 7461  terResponse(data
-0001f1f0: 3d46 616c 7365 2c65 7272 6f72 5f6d 7367  =False,error_msg
-0001f200: 3d22 616e 616c 6f67 206f 7574 7075 7420  ="analog output 
-0001f210: 756e 7375 7070 6f72 7465 6422 290d 0a0d  unsupported")...
-0001f220: 0a20 2020 2020 2020 2023 2073 7065 6374  .        # spect
-0001f230: 726f 6d65 7465 7220 7368 6f75 6c64 2072  rometer should r
-0001f240: 616e 6765 2d6c 696d 6974 2c20 6275 7420  ange-limit, but 
-0001f250: 6a75 7374 2074 6f20 636f 6469 6679 3a0d  just to codify:.
-0001f260: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-0001f270: 2e73 7461 7465 2e61 6e61 6c6f 675f 6f75  .state.analog_ou
-0001f280: 745f 6d6f 6465 203d 3d20 303a 0d0a 2020  t_mode == 0:..  
-0001f290: 2020 2020 2020 2020 2020 2320 766f 6c74            # volt
-0001f2a0: 6167 6520 2864 6563 6976 6f6c 7473 2c20  age (decivolts, 
-0001f2b0: 7261 6e67 6520 302d 3530 2028 302d 3556  range 0-50 (0-5V
-0001f2c0: 2929 0d0a 2020 2020 2020 2020 2020 2020  ))..            
-0001f2d0: 6966 2076 616c 7565 203c 2030 3a0d 0a20  if value < 0:.. 
-0001f2e0: 2020 2020 2020 2020 2020 2020 2020 2076                 v
-0001f2f0: 616c 7565 203d 2030 0d0a 2020 2020 2020  alue = 0..      
-0001f300: 2020 2020 2020 6966 2076 616c 7565 203e        if value >
-0001f310: 2035 303a 0d0a 2020 2020 2020 2020 2020   50:..          
-0001f320: 2020 2020 2020 7661 6c75 6520 3d20 3530        value = 50
-0001f330: 0d0a 2020 2020 2020 2020 656c 6966 2073  ..        elif s
-0001f340: 656c 662e 7374 6174 652e 616e 616c 6f67  elf.state.analog
-0001f350: 5f6f 7574 5f6d 6f64 6520 3d3d 2031 3a0d  _out_mode == 1:.
-0001f360: 0a20 2020 2020 2020 2020 2020 2023 2063  .            # c
-0001f370: 7572 7265 6e74 2028 6465 6369 2d6d 412c  urrent (deci-mA,
-0001f380: 2072 616e 6765 2034 302d 3230 3020 2834   range 40-200 (4
-0001f390: 2d32 306d 4129 290d 0a20 2020 2020 2020  -20mA))..       
-0001f3a0: 2020 2020 2069 6620 7661 6c75 6520 3c20       if value < 
-0001f3b0: 3430 3a0d 0a20 2020 2020 2020 2020 2020  40:..           
-0001f3c0: 2020 2020 2076 616c 7565 203d 2034 300d       value = 40.
-0001f3d0: 0a20 2020 2020 2020 2020 2020 2065 6c69  .            eli
-0001f3e0: 6620 7661 6c75 6520 3e20 3230 303a 0d0a  f value > 200:..
-0001f3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f400: 7661 6c75 6520 3d20 3230 300d 0a20 2020  value = 200..   
-0001f410: 2020 2020 2065 6c73 653a 0d0a 2020 2020       else:..    
-0001f420: 2020 2020 2020 2020 6c6f 672e 6572 726f          log.erro
-0001f430: 7228 2269 6e76 616c 6964 2061 6e61 6c6f  r("invalid analo
-0001f440: 6720 6f75 7420 6d6f 6465 2025 642c 2069  g out mode %d, i
-0001f450: 676e 6f72 696e 6720 7661 6c75 6522 2c20  gnoring value", 
-0001f460: 7365 6c66 2e73 7461 7465 2e61 6e61 6c6f  self.state.analo
-0001f470: 675f 6f75 745f 6d6f 6465 290d 0a20 2020  g_out_mode)..   
-0001f480: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0001f490: 5370 6563 7472 6f6d 6574 6572 5265 7370  SpectrometerResp
-0001f4a0: 6f6e 7365 2864 6174 613d 4661 6c73 652c  onse(data=False,
-0001f4b0: 6572 726f 725f 6d73 673d 2269 6e76 616c  error_msg="inval
-0001f4c0: 6964 206d 6f64 6522 290d 0a0d 0a20 2020  id mode")....   
-0001f4d0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-0001f4e0: 2e5f 7365 6e64 5f63 6f64 6528 6252 6571  ._send_code(bReq
-0001f4f0: 7565 7374 2020 3d20 3078 6666 2c0d 0a20  uest  = 0xff,.. 
-0001f500: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f510: 2020 2020 2020 2020 2020 2020 2077 5661               wVa
-0001f520: 6c75 6520 2020 203d 2030 7831 322c 0d0a  lue    = 0x12,..
-0001f530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f540: 2020 2020 2020 2020 2020 2020 2020 7749                wI
-0001f550: 6e64 6578 2020 2020 3d20 7661 6c75 652c  ndex    = value,
-0001f560: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0001f570: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f580: 6c61 6265 6c20 2020 2020 3d20 2253 4554  label     = "SET
-0001f590: 5f41 4e41 4c4f 475f 4f55 545f 5641 4c55  _ANALOG_OUT_VALU
-0001f5a0: 4522 290d 0a0d 0a20 2020 2064 6566 2067  E")....    def g
-0001f5b0: 6574 5f61 6e61 6c6f 675f 6f75 7470 7574  et_analog_output
-0001f5c0: 5f73 7461 7465 2873 656c 6629 3a20 2320  _state(self): # 
-0001f5d0: 2d3e 2053 7065 6374 726f 6d65 7465 7252  -> SpectrometerR
-0001f5e0: 6573 706f 6e73 6520 0d0a 2020 2020 2020  esponse ..      
-0001f5f0: 2020 6966 206e 6f74 2073 656c 662e 7365    if not self.se
-0001f600: 7474 696e 6773 2e69 735f 6765 6e32 2829  ttings.is_gen2()
-0001f610: 3a0d 0a20 2020 2020 2020 2020 2020 206c  :..            l
-0001f620: 6f67 6765 722e 6572 726f 7228 2261 6e61  ogger.error("ana
-0001f630: 6c6f 6720 6f75 7470 7574 206f 6e6c 7920  log output only 
-0001f640: 6176 6169 6c61 626c 6520 6f6e 2047 656e  available on Gen
-0001f650: 3222 290d 0a20 2020 2020 2020 2020 2020  2")..           
-0001f660: 2072 6574 7572 6e20 5370 6563 7472 6f6d   return Spectrom
-0001f670: 6574 6572 5265 7370 6f6e 7365 2864 6174  eterResponse(dat
-0001f680: 613d 4661 6c73 652c 6572 726f 725f 6d73  a=False,error_ms
-0001f690: 673d 2261 6e61 6c6f 6720 6f75 7470 7574  g="analog output
-0001f6a0: 2075 6e73 7570 706f 7274 6564 2229 0d0a   unsupported")..
-0001f6b0: 0d0a 2020 2020 2020 2020 7265 7320 3d20  ..        res = 
-0001f6c0: 7365 6c66 2e67 6574 5f75 7070 6572 5f63  self.get_upper_c
-0001f6d0: 6f64 6528 3078 3161 2c20 774c 656e 6774  ode(0x1a, wLengt
-0001f6e0: 683d 332c 206c 6162 656c 3d22 4745 545f  h=3, label="GET_
-0001f6f0: 414e 414c 4f47 5f4f 5554 5f53 5441 5445  ANALOG_OUT_STATE
-0001f700: 2229 0d0a 2020 2020 2020 2020 6966 2072  ")..        if r
-0001f710: 6573 2e65 7272 6f72 5f6d 7367 2021 3d20  es.error_msg != 
-0001f720: 2727 3a0d 0a20 2020 2020 2020 2020 2020  '':..           
-0001f730: 2072 6574 7572 6e20 7265 730d 0a20 2020   return res..   
-0001f740: 2020 2020 2064 6174 6120 3d20 7265 732e       data = res.
-0001f750: 6461 7461 0d0a 2020 2020 2020 2020 6966  data..        if
-0001f760: 2028 6461 7461 2069 7320 4e6f 6e65 206f   (data is None o
-0001f770: 7220 6c65 6e28 6461 7461 2920 213d 2033  r len(data) != 3
-0001f780: 293a 0d0a 2020 2020 2020 2020 2020 2020  ):..            
-0001f790: 6c6f 6767 6572 2e65 7272 6f72 2822 696e  logger.error("in
-0001f7a0: 7661 6c69 6420 616e 616c 6f67 206f 7574  valid analog out
-0001f7b0: 2073 7461 7465 2072 6561 643a 2025 7322   state read: %s"
-0001f7c0: 2c20 6461 7461 290d 0a20 2020 2020 2020  , data)..       
-0001f7d0: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
-0001f7e0: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
-0001f7f0: 2864 6174 613d 4661 6c73 652c 6572 726f  (data=False,erro
-0001f800: 725f 6d73 673d 2269 6e76 616c 6964 2061  r_msg="invalid a
-0001f810: 6e61 6c6f 6720 6f75 7420 7374 6174 6520  nalog out state 
-0001f820: 7265 6164 2229 0d0a 0d0a 2020 2020 2020  read")....      
-0001f830: 2020 6966 2064 6174 615b 305d 2021 3d20    if data[0] != 
-0001f840: 3020 616e 6420 6461 7461 5b30 5d20 213d  0 and data[0] !=
-0001f850: 2031 3a0d 0a20 2020 2020 2020 2020 2020   1:..           
-0001f860: 206c 6f67 6765 722e 6572 726f 7228 2272   logger.error("r
-0001f870: 6563 6569 7665 6420 696e 7661 6c69 6420  eceived invalid 
-0001f880: 616e 616c 6f67 206f 7574 2065 6e61 626c  analog out enabl
-0001f890: 653a 2025 6422 2c20 6461 7461 5b30 5d29  e: %d", data[0])
-0001f8a0: 0d0a 2020 2020 2020 2020 6966 2064 6174  ..        if dat
-0001f8b0: 615b 315d 2021 3d20 3020 616e 6420 6461  a[1] != 0 and da
-0001f8c0: 7461 5b31 5d20 213d 2031 3a0d 0a20 2020  ta[1] != 1:..   
-0001f8d0: 2020 2020 2020 2020 206c 6f67 6765 722e           logger.
-0001f8e0: 6572 726f 7228 2272 6563 6569 7665 6420  error("received 
-0001f8f0: 696e 7661 6c69 6420 616e 616c 6f67 206f  invalid analog o
-0001f900: 7574 206d 6f64 653a 2025 6422 2c20 6461  ut mode: %d", da
-0001f910: 7461 5b31 5d29 0d0a 0d0a 2020 2020 2020  ta[1])....      
-0001f920: 2020 7365 6c66 2e73 7461 7465 2e61 6e61    self.state.ana
-0001f930: 6c6f 675f 6f75 745f 656e 6162 6c65 203d  log_out_enable =
-0001f940: 2064 6174 615b 305d 2021 3d20 300d 0a20   data[0] != 0.. 
-0001f950: 2020 2020 2020 2073 656c 662e 7374 6174         self.stat
-0001f960: 652e 616e 616c 6f67 5f6f 7574 5f6d 6f64  e.analog_out_mod
-0001f970: 6520 3d20 6461 7461 5b31 5d0d 0a20 2020  e = data[1]..   
-0001f980: 2020 2020 2073 656c 662e 7374 6174 652e       self.state.
-0001f990: 616e 616c 6f67 5f6f 7574 5f76 616c 7565  analog_out_value
-0001f9a0: 203d 2064 6174 615b 325d 2023 206e 6f20   = data[2] # no 
-0001f9b0: 7261 6e67 652d 6368 6563 6b69 6e67 2061  range-checking a
-0001f9c0: 7070 6c69 6564 0d0a 2020 2020 2020 2020  pplied..        
-0001f9d0: 6461 7461 203d 2028 7365 6c66 2e73 7461  data = (self.sta
-0001f9e0: 7465 2e61 6e61 6c6f 675f 6f75 745f 656e  te.analog_out_en
-0001f9f0: 6162 6c65 2c0d 0a20 2020 2020 2020 2020  able,..         
-0001fa00: 2020 2020 2020 2073 656c 662e 7374 6174         self.stat
-0001fa10: 652e 616e 616c 6f67 5f6f 7574 5f6d 6f64  e.analog_out_mod
-0001fa20: 652c 0d0a 2020 2020 2020 2020 2020 2020  e,..            
-0001fa30: 2020 2020 7365 6c66 2e73 7461 7465 2e61      self.state.a
-0001fa40: 6e61 6c6f 675f 6f75 745f 7661 6c75 6529  nalog_out_value)
-0001fa50: 0d0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-0001fa60: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
-0001fa70: 706f 6e73 6528 6461 7461 3d64 6174 6129  ponse(data=data)
-0001fa80: 0d0a 0d0a 2020 2020 2320 4072 6574 7572  ....    # @retur
-0001fa90: 6e73 2064 6563 6976 6f6c 7473 0d0a 2020  ns decivolts..  
-0001faa0: 2020 6465 6620 6765 745f 616e 616c 6f67    def get_analog
-0001fab0: 5f69 6e70 7574 5f76 616c 7565 2873 656c  _input_value(sel
-0001fac0: 6629 3a20 2320 2d3e 2053 7065 6374 726f  f): # -> Spectro
-0001fad0: 6d65 7465 7252 6573 706f 6e73 6520 0d0a  meterResponse ..
-0001fae0: 2020 2020 2020 2020 6966 206e 6f74 2073          if not s
-0001faf0: 656c 662e 7365 7474 696e 6773 2e69 735f  elf.settings.is_
-0001fb00: 6765 6e32 2829 3a0d 0a20 2020 2020 2020  gen2():..       
-0001fb10: 2020 2020 206c 6f67 6765 722e 6572 726f       logger.erro
-0001fb20: 7228 2261 6e61 6c6f 6720 696e 7075 7420  r("analog input 
-0001fb30: 6f6e 6c79 2061 7661 696c 6162 6c65 206f  only available o
-0001fb40: 6e20 4765 6e32 2229 0d0a 2020 2020 2020  n Gen2")..      
-0001fb50: 2020 2020 2020 7265 7475 726e 2053 7065        return Spe
-0001fb60: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
-0001fb70: 6528 6461 7461 3d46 616c 7365 2c65 7272  e(data=False,err
-0001fb80: 6f72 5f6d 7367 3d22 616e 616c 6f67 2069  or_msg="analog i
-0001fb90: 6e70 7574 2075 6e73 7570 706f 7274 6564  nput unsupported
-0001fba0: 2229 0d0a 2020 2020 2020 2020 7265 7475  ")..        retu
-0001fbb0: 726e 2073 656c 662e 6765 745f 7570 7065  rn self.get_uppe
-0001fbc0: 725f 636f 6465 2830 7831 622c 206c 7362  r_code(0x1b, lsb
-0001fbd0: 5f6c 656e 3d31 2c20 6c61 6265 6c3d 2247  _len=1, label="G
-0001fbe0: 4554 5f41 4e41 4c4f 475f 494e 5f56 414c  ET_ANALOG_IN_VAL
-0001fbf0: 5545 2229 0d0a 0d0a 2020 2020 2320 2323  UE")....    # ##
-0001fc00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001fc10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001fc20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001fc30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001fc40: 2323 2323 2323 2323 0d0a 2020 2020 2320  ########..    # 
-0001fc50: 4545 5052 4f4d 2043 7275 6674 0d0a 2020  EEPROM Cruft..  
-0001fc60: 2020 2320 2323 2323 2323 2323 2323 2323    # ############
-0001fc70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001fc80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001fc90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001fca0: 2323 2323 2323 2323 2323 2323 2323 0d0a  ##############..
-0001fcb0: 0d0a 2020 2020 6465 6620 7570 6461 7465  ..    def update
-0001fcc0: 5f73 6573 7369 6f6e 5f65 6570 726f 6d28  _session_eeprom(
-0001fcd0: 7365 6c66 2c20 7061 6972 3a20 7475 706c  self, pair: tupl
-0001fce0: 655b 7374 722c 2045 4550 524f 4d5d 293a  e[str, EEPROM]):
-0001fcf0: 2023 202d 3e20 5370 6563 7472 6f6d 6574   # -> Spectromet
-0001fd00: 6572 5265 7370 6f6e 7365 200d 0a20 2020  erResponse ..   
-0001fd10: 2020 2020 2022 2222 0d0a 2020 2020 2020       """..      
-0001fd20: 2020 4769 7665 6e20 6120 2873 6572 6961    Given a (seria
-0001fd30: 6c5f 6e75 6d62 6572 2c20 4545 5052 4f4d  l_number, EEPROM
-0001fd40: 2920 7061 6972 2c20 7570 6461 7465 2074  ) pair, update t
-0001fd50: 6869 7320 7072 6f63 6573 7327 7320 2273  his process's "s
-0001fd60: 6573 7369 6f6e 220d 0a20 2020 2020 2020  ession"..       
-0001fd70: 2045 4550 524f 4d20 7769 7468 206a 7573   EEPROM with jus
-0001fd80: 7420 7468 6520 4544 4954 4142 4c45 2066  t the EDITABLE f
-0001fd90: 6965 6c64 7320 6f66 2074 6865 2070 6173  ields of the pas
-0001fda0: 7365 6420 4545 5052 4f4d 2e0d 0a20 2020  sed EEPROM...   
-0001fdb0: 2020 2020 2022 2222 0d0a 2020 2020 2020       """..      
-0001fdc0: 2020 6c6f 672e 6465 6275 6728 2266 6964    log.debug("fid
-0001fdd0: 2e75 7064 6174 655f 7365 7373 696f 6e5f  .update_session_
-0001fde0: 6565 7072 6f6d 3a20 2573 2075 7064 6174  eeprom: %s updat
-0001fdf0: 696e 6720 4545 5052 4f4d 2069 6e73 7461  ing EEPROM insta
-0001fe00: 6e63 6522 2c20 7365 6c66 2e73 6574 7469  nce", self.setti
-0001fe10: 6e67 732e 6565 7072 6f6d 2e73 6572 6961  ngs.eeprom.seria
-0001fe20: 6c5f 6e75 6d62 6572 290d 0a0d 0a20 2020  l_number)....   
-0001fe30: 2020 2020 2069 6620 6e6f 7420 7365 6c66       if not self
-0001fe40: 2e65 6570 726f 6d5f 6261 636b 7570 3a0d  .eeprom_backup:.
-0001fe50: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-0001fe60: 662e 6565 7072 6f6d 5f62 6163 6b75 7020  f.eeprom_backup 
-0001fe70: 3d20 636f 7079 2e64 6565 7063 6f70 7928  = copy.deepcopy(
-0001fe80: 7365 6c66 2e73 6574 7469 6e67 732e 6565  self.settings.ee
-0001fe90: 7072 6f6d 290d 0a0d 0a20 2020 2020 2020  prom)....       
-0001fea0: 2073 656c 662e 7365 7474 696e 6773 2e65   self.settings.e
-0001feb0: 6570 726f 6d2e 7570 6461 7465 5f65 6469  eprom.update_edi
-0001fec0: 7461 626c 6528 7061 6972 5b31 5d29 0d0a  table(pair[1])..
-0001fed0: 2020 2020 2020 2020 7265 7475 726e 2053          return S
-0001fee0: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
-0001fef0: 6e73 6528 6461 7461 3d54 7275 6529 0d0a  nse(data=True)..
-0001ff00: 0d0a 2020 2020 6465 6620 7265 706c 6163  ..    def replac
-0001ff10: 655f 7365 7373 696f 6e5f 6565 7072 6f6d  e_session_eeprom
-0001ff20: 2873 656c 662c 2070 6169 723a 2074 7570  (self, pair: tup
-0001ff30: 6c65 5b73 7472 2c20 4545 5052 4f4d 5d29  le[str, EEPROM])
-0001ff40: 3a20 2320 2d3e 2053 7065 6374 726f 6d65  : # -> Spectrome
-0001ff50: 7465 7252 6573 706f 6e73 6520 0d0a 2020  terResponse ..  
-0001ff60: 2020 2020 2020 2222 220d 0a20 2020 2020        """..     
-0001ff70: 2020 2047 6976 656e 2061 2028 7365 7269     Given a (seri
-0001ff80: 616c 5f6e 756d 6265 722c 2045 4550 524f  al_number, EEPRO
-0001ff90: 4d29 2070 6169 722c 2072 6570 6c61 6365  M) pair, replace
-0001ffa0: 2074 6869 7320 7072 6f63 6573 7327 7320   this process's 
-0001ffb0: 2273 6573 7369 6f6e 220d 0a20 2020 2020  "session"..     
-0001ffc0: 2020 2045 4550 524f 4d20 7769 7468 2074     EEPROM with t
-0001ffd0: 6865 2070 6173 7365 6420 4545 5052 4f4d  he passed EEPROM
-0001ffe0: 2e0d 0a20 2020 2020 2020 2022 2222 0d0a  ...        """..
-0001fff0: 2020 2020 2020 2020 6c6f 672e 6465 6275          log.debu
-00020000: 6728 2266 6964 2e72 6570 6c61 6365 5f73  g("fid.replace_s
-00020010: 6573 7369 6f6e 5f65 6570 726f 6d3a 2025  ession_eeprom: %
-00020020: 7320 7265 706c 6163 696e 6720 4545 5052  s replacing EEPR
-00020030: 4f4d 2069 6e73 7461 6e63 6522 2c20 7365  OM instance", se
-00020040: 6c66 2e73 6574 7469 6e67 732e 6565 7072  lf.settings.eepr
-00020050: 6f6d 2e73 6572 6961 6c5f 6e75 6d62 6572  om.serial_number
-00020060: 290d 0a0d 0a20 2020 2020 2020 2069 6620  )....        if 
-00020070: 6e6f 7420 7365 6c66 2e65 6570 726f 6d5f  not self.eeprom_
-00020080: 6261 636b 7570 3a0d 0a20 2020 2020 2020  backup:..       
-00020090: 2020 2020 2073 656c 662e 6565 7072 6f6d       self.eeprom
-000200a0: 5f62 6163 6b75 7020 3d20 636f 7079 2e64  _backup = copy.d
-000200b0: 6565 7063 6f70 7928 7365 6c66 2e73 6574  eepcopy(self.set
-000200c0: 7469 6e67 732e 6565 7072 6f6d 290d 0a0d  tings.eeprom)...
-000200d0: 0a20 2020 2020 2020 2073 656c 662e 7365  .        self.se
-000200e0: 7474 696e 6773 2e65 6570 726f 6d20 3d20  ttings.eeprom = 
-000200f0: 7061 6972 5b31 5d0d 0a20 2020 2020 2020  pair[1]..       
-00020100: 2073 656c 662e 7365 7474 696e 6773 2e65   self.settings.e
-00020110: 6570 726f 6d2e 6475 6d70 2829 0d0a 2020  eprom.dump()..  
-00020120: 2020 2020 2020 7265 7475 726e 2053 7065        return Spe
-00020130: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
-00020140: 6528 290d 0a0d 0a20 2020 2023 2320 4163  e()....    ## Ac
-00020150: 7475 616c 6c79 2073 746f 7265 2074 6865  tually store the
-00020160: 2063 7572 7265 6e74 2073 6573 7369 6f6e   current session
-00020170: 2045 4550 524f 4d20 6669 656c 6473 2074   EEPROM fields t
-00020180: 6f20 7468 6520 7370 6563 7472 6f6d 6574  o the spectromet
-00020190: 6572 2e0d 0a20 2020 2064 6566 2077 7269  er...    def wri
-000201a0: 7465 5f65 6570 726f 6d28 7365 6c66 293a  te_eeprom(self):
-000201b0: 2023 202d 3e20 5370 6563 7472 6f6d 6574   # -> Spectromet
-000201c0: 6572 5265 7370 6f6e 7365 200d 0a20 2020  erResponse ..   
-000201d0: 2020 2020 2069 6620 6e6f 7420 7365 6c66       if not self
-000201e0: 2e65 6570 726f 6d5f 6261 636b 7570 3a0d  .eeprom_backup:.
-000201f0: 0a20 2020 2020 2020 2020 2020 206c 6f67  .            log
-00020200: 2e63 7269 7469 6361 6c28 2265 7870 6563  .critical("expec
-00020210: 7465 6420 746f 2075 7064 6174 6520 6f72  ted to update or
-00020220: 2072 6570 6c61 6365 2045 4550 524f 4d20   replace EEPROM 
-00020230: 6f62 6a65 6374 2062 6566 6f72 6520 7772  object before wr
-00020240: 6974 6520 636f 6d6d 616e 6422 290d 0a20  ite command").. 
-00020250: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00020260: 7175 6575 655f 6d65 7373 6167 6528 226d  queue_message("m
-00020270: 6172 7175 6565 5f65 7272 6f72 222c 2022  arquee_error", "
-00020280: 4661 696c 6564 2074 6f20 7772 6974 6520  Failed to write 
-00020290: 4545 5052 4f4d 2229 0d0a 2020 2020 2020  EEPROM")..      
-000202a0: 2020 2020 2020 7265 7475 726e 2053 7065        return Spe
-000202b0: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
-000202c0: 6528 6461 7461 3d46 616c 7365 2c65 7272  e(data=False,err
-000202d0: 6f72 5f6d 7367 3d22 6661 696c 6564 2074  or_msg="failed t
-000202e0: 6f20 7772 6974 6520 6565 7072 6f6d 2229  o write eeprom")
-000202f0: 0d0a 0d0a 2020 2020 2020 2020 2320 6261  ....        # ba
-00020300: 636b 7570 2063 6f6e 7465 6e74 7320 6f66  ckup contents of
-00020310: 2070 7265 7669 6f75 7320 4545 5052 4f4d   previous EEPROM
-00020320: 2069 6e20 6c6f 670d 0a20 2020 2020 2020   in log..       
-00020330: 206c 6f67 2e64 6562 7567 2822 4f72 6967   log.debug("Orig
-00020340: 696e 616c 2045 4550 524f 4d20 636f 6e74  inal EEPROM cont
-00020350: 656e 7473 2229 0d0a 2020 2020 2020 2020  ents")..        
-00020360: 7365 6c66 2e65 6570 726f 6d5f 6261 636b  self.eeprom_back
-00020370: 7570 2e64 756d 7028 290d 0a20 2020 2020  up.dump()..     
-00020380: 2020 206c 6f67 2e64 6562 7567 2822 4f72     log.debug("Or
-00020390: 6967 696e 616c 2045 4550 524f 4d20 6275  iginal EEPROM bu
-000203a0: 6666 6572 733a 2025 7322 2c20 7365 6c66  ffers: %s", self
-000203b0: 2e65 6570 726f 6d5f 6261 636b 7570 2e62  .eeprom_backup.b
-000203c0: 7566 6665 7273 290d 0a0d 0a20 2020 2020  uffers)....     
-000203d0: 2020 2074 7279 3a0d 0a20 2020 2020 2020     try:..       
-000203e0: 2020 2020 2073 656c 662e 7365 7474 696e       self.settin
-000203f0: 6773 2e65 6570 726f 6d2e 6765 6e65 7261  gs.eeprom.genera
-00020400: 7465 5f77 7269 7465 5f62 7566 6665 7273  te_write_buffers
-00020410: 2829 0d0a 2020 2020 2020 2020 6578 6365  ()..        exce
-00020420: 7074 3a0d 0a20 2020 2020 2020 2020 2020  pt:..           
-00020430: 206c 6f67 2e63 7269 7469 6361 6c28 2266   log.critical("f
-00020440: 6169 6c65 6420 746f 2072 656e 6465 7220  ailed to render 
-00020450: 4545 5052 4f4d 2077 7269 7465 2062 7566  EEPROM write buf
-00020460: 6665 7273 222c 2065 7863 5f69 6e66 6f3d  fers", exc_info=
-00020470: 3129 0d0a 2020 2020 2020 2020 2020 2020  1)..            
-00020480: 7365 6c66 2e71 7565 7565 5f6d 6573 7361  self.queue_messa
-00020490: 6765 2822 6d61 7271 7565 655f 6572 726f  ge("marquee_erro
-000204a0: 7222 2c20 2246 6169 6c65 6420 746f 2077  r", "Failed to w
-000204b0: 7269 7465 2045 4550 524f 4d22 290d 0a20  rite EEPROM").. 
-000204c0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-000204d0: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
-000204e0: 7370 6f6e 7365 2864 6174 613d 4661 6c73  sponse(data=Fals
-000204f0: 652c 6572 726f 725f 6d73 673d 2266 6169  e,error_msg="fai
-00020500: 6c65 6420 746f 2067 656e 6572 6174 6520  led to generate 
-00020510: 6565 7072 6f6d 2229 0d0a 0d0a 2020 2020  eeprom")....    
-00020520: 2020 2020 6c6f 672e 6465 6275 6728 2257      log.debug("W
-00020530: 6f75 6c64 2077 7269 7465 206e 6577 2062  ould write new b
-00020540: 7566 6665 7273 3a20 2573 222c 2073 656c  uffers: %s", sel
-00020550: 662e 7365 7474 696e 6773 2e65 6570 726f  f.settings.eepro
-00020560: 6d2e 7772 6974 655f 6275 6666 6572 7329  m.write_buffers)
-00020570: 0d0a 0d0a 2020 2020 2020 2020 666f 7220  ....        for 
-00020580: 7061 6765 2069 6e20 7261 6e67 6528 4545  page in range(EE
-00020590: 5052 4f4d 2e4d 4158 5f50 4147 4553 293a  PROM.MAX_PAGES):
-000205a0: 0d0a 2020 2020 2020 2020 2020 2020 6966  ..            if
-000205b0: 2073 656c 662e 7365 7474 696e 6773 2e69   self.settings.i
-000205c0: 735f 6172 6d28 293a 0d0a 2020 2020 2020  s_arm():..      
-000205d0: 2020 2020 2020 2020 2020 6c6f 672e 6465            log.de
-000205e0: 6275 6728 2277 7269 7469 6e67 2070 6167  bug("writing pag
-000205f0: 6520 2564 3a20 2573 222c 2070 6167 652c  e %d: %s", page,
-00020600: 2073 656c 662e 7365 7474 696e 6773 2e65   self.settings.e
-00020610: 6570 726f 6d2e 7772 6974 655f 6275 6666  eprom.write_buff
-00020620: 6572 735b 7061 6765 5d29 0d0a 2020 2020  ers[page])..    
-00020630: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00020640: 2e5f 7365 6e64 5f63 6f64 6528 6252 6571  ._send_code(bReq
-00020650: 7565 7374 2020 2020 2020 2020 3d20 3078  uest        = 0x
-00020660: 6666 2c20 2320 7365 636f 6e64 2d74 6965  ff, # second-tie
-00020670: 720d 0a20 2020 2020 2020 2020 2020 2020  r..             
-00020680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020690: 2020 7756 616c 7565 2020 2020 2020 2020    wValue        
-000206a0: 2020 3d20 3078 3032 2c0d 0a20 2020 2020    = 0x02,..     
-000206b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000206c0: 2020 2020 2020 2020 2020 7749 6e64 6578            wIndex
-000206d0: 2020 2020 2020 2020 2020 3d20 7061 6765            = page
-000206e0: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-000206f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020700: 2020 6461 7461 5f6f 725f 774c 656e 6774    data_or_wLengt
-00020710: 6820 3d20 7365 6c66 2e73 6574 7469 6e67  h = self.setting
-00020720: 732e 6565 7072 6f6d 2e77 7269 7465 5f62  s.eeprom.write_b
-00020730: 7566 6665 7273 5b70 6167 655d 2c0d 0a20  uffers[page],.. 
-00020740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020750: 2020 2020 2020 2020 2020 2020 2020 6c61                la
-00020760: 6265 6c20 2020 2020 2020 2020 2020 3d20  bel           = 
-00020770: 2257 5249 5445 5f45 4550 524f 4d22 290d  "WRITE_EEPROM").
-00020780: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
-00020790: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-000207a0: 2020 2020 4441 5441 5f53 5441 5254 203d      DATA_START =
-000207b0: 2030 7833 6330 300d 0a20 2020 2020 2020   0x3c00..       
-000207c0: 2020 2020 2020 2020 206f 6666 7365 7420           offset 
-000207d0: 3d20 4441 5441 5f53 5441 5254 202b 2070  = DATA_START + p
-000207e0: 6167 6520 2a20 3634 0d0a 2020 2020 2020  age * 64..      
-000207f0: 2020 2020 2020 2020 2020 6c6f 672e 6465            log.de
-00020800: 6275 6728 2277 7269 7469 6e67 2070 6167  bug("writing pag
-00020810: 6520 2564 2061 7420 6f66 6673 6574 2030  e %d at offset 0
-00020820: 7825 3034 783a 2025 7322 2c20 7061 6765  x%04x: %s", page
-00020830: 2c20 6f66 6673 6574 2c20 7365 6c66 2e73  , offset, self.s
-00020840: 6574 7469 6e67 732e 6565 7072 6f6d 2e77  ettings.eeprom.w
-00020850: 7269 7465 5f62 7566 6665 7273 5b70 6167  rite_buffers[pag
-00020860: 655d 290d 0a20 2020 2020 2020 2020 2020  e])..           
-00020870: 2020 2020 2073 656c 662e 5f73 656e 645f       self._send_
-00020880: 636f 6465 2862 5265 7175 6573 7420 2020  code(bRequest   
-00020890: 2020 2020 203d 2030 7861 322c 2020 2023       = 0xa2,   #
-000208a0: 2064 616e 6765 726f 7573 0d0a 2020 2020   dangerous..    
-000208b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000208c0: 2020 2020 2020 2020 2020 2077 5661 6c75             wValu
-000208d0: 6520 2020 2020 2020 2020 203d 206f 6666  e          = off
-000208e0: 7365 742c 2023 2061 7267 7561 626c 7920  set, # arguably 
-000208f0: 616e 2069 6e64 6578 2062 7574 2068 6579  an index but hey
-00020900: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00020910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020920: 2077 496e 6465 7820 2020 2020 2020 2020   wIndex         
-00020930: 203d 2030 2c0d 0a20 2020 2020 2020 2020   = 0,..         
-00020940: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020950: 2020 2020 2020 6461 7461 5f6f 725f 774c        data_or_wL
-00020960: 656e 6774 6820 3d20 7365 6c66 2e73 6574  ength = self.set
-00020970: 7469 6e67 732e 6565 7072 6f6d 2e77 7269  tings.eeprom.wri
-00020980: 7465 5f62 7566 6665 7273 5b70 6167 655d  te_buffers[page]
-00020990: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-000209a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000209b0: 2020 6c61 6265 6c20 2020 2020 2020 2020    label         
-000209c0: 2020 3d20 2257 5249 5445 5f45 4550 524f    = "WRITE_EEPRO
-000209d0: 4d22 290d 0a0d 0a20 2020 2020 2020 2073  M")....        s
-000209e0: 656c 662e 7175 6575 655f 6d65 7373 6167  elf.queue_messag
-000209f0: 6528 226d 6172 7175 6565 5f69 6e66 6f22  e("marquee_info"
-00020a00: 2c20 2245 4550 524f 4d20 7375 6363 6573  , "EEPROM succes
-00020a10: 7366 756c 6c79 2075 7064 6174 6564 2229  sfully updated")
-00020a20: 0d0a 0d0a 2020 2020 2020 2020 2320 616e  ....        # an
-00020a30: 7920 7661 6c75 6520 696e 2064 6f69 6e67  y value in doing
-00020a40: 2074 6869 733f 0d0a 2020 2020 2020 2020   this?..        
-00020a50: 7365 6c66 2e73 6574 7469 6e67 732e 6565  self.settings.ee
-00020a60: 7072 6f6d 2e62 7566 6665 7273 203d 2073  prom.buffers = s
-00020a70: 656c 662e 7365 7474 696e 6773 2e65 6570  elf.settings.eep
-00020a80: 726f 6d2e 7772 6974 655f 6275 6666 6572  rom.write_buffer
-00020a90: 730d 0a0d 0a20 2020 2020 2020 2072 6574  s....        ret
-00020aa0: 7572 6e20 5370 6563 7472 6f6d 6574 6572  urn Spectrometer
-00020ab0: 5265 7370 6f6e 7365 2864 6174 613d 5472  Response(data=Tr
-00020ac0: 7565 290d 0a0d 0a20 2020 2023 2023 2323  ue)....    # ###
-00020ad0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00020ae0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00020af0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00020b00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00020b10: 2323 2323 2323 230d 0a20 2020 2023 2049  #######..    # I
-00020b20: 6e74 6572 7072 6f63 6573 7320 436f 6d6d  nterprocess Comm
-00020b30: 756e 6963 6174 696f 6e73 0d0a 2020 2020  unications..    
-00020b40: 2320 2323 2323 2323 2323 2323 2323 2323  # ##############
-00020b50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00020b60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00020b70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00020b80: 2323 2323 2323 2323 2323 2323 0d0a 0d0a  ############....
-00020b90: 2020 2020 2320 4074 6f64 6f20 6d6f 7665      # @todo move
-00020ba0: 2073 7472 696e 672d 746f 2d65 6e75 6d20   string-to-enum 
-00020bb0: 636f 6e76 6572 7465 7220 746f 2041 7070  converter to App
-00020bc0: 4c6f 670d 0a20 2020 2064 6566 2073 6574  Log..    def set
-00020bd0: 5f6c 6f67 5f6c 6576 656c 2873 656c 662c  _log_level(self,
-00020be0: 2073 3a20 7374 7229 3a20 2320 2d3e 2053   s: str): # -> S
-00020bf0: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
-00020c00: 6e73 6520 0d0a 2020 2020 2020 2020 6c76  nse ..        lv
-00020c10: 6c20 3d20 6c6f 6767 696e 672e 4445 4255  l = logging.DEBU
-00020c20: 4720 6966 2073 203d 3d20 2244 4542 5547  G if s == "DEBUG
-00020c30: 2220 656c 7365 206c 6f67 6769 6e67 2e49  " else logging.I
-00020c40: 4e46 4f0d 0a20 2020 2020 2020 206c 6f67  NFO..        log
-00020c50: 2e64 6562 7567 2822 6669 642e 7365 745f  .debug("fid.set_
-00020c60: 6c6f 675f 6c65 7665 6c3a 2073 6574 7469  log_level: setti
-00020c70: 6e67 2074 6f20 2573 222c 206c 766c 290d  ng to %s", lvl).
-00020c80: 0a20 2020 2020 2020 206c 6f67 6769 6e67  .        logging
-00020c90: 2e67 6574 4c6f 6767 6572 2829 2e73 6574  .getLogger().set
-00020ca0: 4c65 7665 6c28 6c76 6c29 0d0a 2020 2020  Level(lvl)..    
-00020cb0: 2020 2020 7265 7475 726e 2053 7065 6374      return Spect
-00020cc0: 726f 6d65 7465 7252 6573 706f 6e73 6528  rometerResponse(
-00020cd0: 290d 0a0d 0a20 2020 2064 6566 2071 7565  )....    def que
-00020ce0: 7565 5f6d 6573 7361 6765 2873 656c 662c  ue_message(self,
-00020cf0: 2073 6574 7469 6e67 2c20 7661 6c75 6529   setting, value)
-00020d00: 3a20 2320 2d3e 2053 7065 6374 726f 6d65  : # -> Spectrome
-00020d10: 7465 7252 6573 706f 6e73 6520 0d0a 2020  terResponse ..  
-00020d20: 2020 2020 2020 2222 220d 0a20 2020 2020        """..     
-00020d30: 2020 2049 6620 616e 2075 7073 7472 6561     If an upstrea
-00020d40: 6d20 7175 6575 6520 6973 2064 6566 696e  m queue is defin
-00020d50: 6564 2c20 7365 6e64 2074 6865 206e 616d  ed, send the nam
-00020d60: 652d 7661 6c75 6520 7061 6972 2e20 2044  e-value pair.  D
-00020d70: 6f65 7320 6e6f 7468 696e 670d 0a20 2020  oes nothing..   
-00020d80: 2020 2020 2069 6620 7468 6520 6361 6c6c       if the call
-00020d90: 6572 2068 6173 6e27 7420 7072 6f76 6964  er hasn't provid
-00020da0: 6564 2061 2071 7565 7565 2e0d 0a20 2020  ed a queue...   
-00020db0: 2020 2020 2022 2222 0d0a 2020 2020 2020       """..      
-00020dc0: 2020 6966 2073 656c 662e 6d65 7373 6167    if self.messag
-00020dd0: 655f 7175 6575 6520 6973 204e 6f6e 653a  e_queue is None:
-00020de0: 0d0a 2020 2020 2020 2020 2020 2020 7265  ..            re
-00020df0: 7475 726e 2053 7065 6374 726f 6d65 7465  turn Spectromete
-00020e00: 7252 6573 706f 6e73 6528 6461 7461 3d46  rResponse(data=F
-00020e10: 616c 7365 290d 0a0d 0a20 2020 2020 2020  alse)....       
-00020e20: 206d 7367 203d 2053 7461 7475 734d 6573   msg = StatusMes
-00020e30: 7361 6765 2873 6574 7469 6e67 2c20 7661  sage(setting, va
-00020e40: 6c75 6529 0d0a 2020 2020 2020 2020 7472  lue)..        tr
-00020e50: 793a 0d0a 2020 2020 2020 2020 2020 2020  y:..            
-00020e60: 7365 6c66 2e6d 6573 7361 6765 5f71 7565  self.message_que
-00020e70: 7565 2e70 7574 286d 7367 2920 2320 7075  ue.put(msg) # pu
-00020e80: 745f 6e6f 7761 6974 286d 7367 290d 0a20  t_nowait(msg).. 
-00020e90: 2020 2020 2020 2065 7863 6570 743a 0d0a         except:..
+0001ea90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001eaa0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001eab0: 2323 2323 2323 2323 0a0a 2020 2020 2323  ########..    ##
+0001eac0: 2040 7365 6520 6874 7470 733a 2f2f 7777   @see https://ww
+0001ead0: 772e 6e78 702e 636f 6d2f 646f 6373 2f65  w.nxp.com/docs/e
+0001eae0: 6e2f 6461 7461 2d73 6865 6574 2f4c 4d37  n/data-sheet/LM7
+0001eaf0: 3542 2e70 6466 0a20 2020 2064 6566 2067  5B.pdf.    def g
+0001eb00: 6574 5f61 6d62 6965 6e74 5f74 656d 7065  et_ambient_tempe
+0001eb10: 7261 7475 7265 5f64 6567 4328 7365 6c66  rature_degC(self
+0001eb20: 293a 0a20 2020 2020 2020 2069 6620 7365  ):.        if se
+0001eb30: 6c66 2e73 6574 7469 6e67 732e 6973 5f67  lf.settings.is_g
+0001eb40: 656e 3135 2829 3a0a 2020 2020 2020 2020  en15():.        
+0001eb50: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+0001eb60: 6765 745f 616d 6269 656e 745f 7465 6d70  get_ambient_temp
+0001eb70: 6572 6174 7572 655f 6465 6743 5f67 656e  erature_degC_gen
+0001eb80: 3135 2829 0a20 2020 2020 2020 2065 6c69  15().        eli
+0001eb90: 6620 7365 6c66 2e73 6574 7469 6e67 732e  f self.settings.
+0001eba0: 6973 5f78 7328 293a 0a20 2020 2020 2020  is_xs():.       
+0001ebb0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+0001ebc0: 2e67 6574 5f61 6d62 6965 6e74 5f74 656d  .get_ambient_tem
+0001ebd0: 7065 7261 7475 7265 5f64 6567 435f 6172  perature_degC_ar
+0001ebe0: 6d28 290a 2020 2020 2020 2020 656c 7365  m().        else
+0001ebf0: 3a0a 2020 2020 2020 2020 2020 2020 6c6f  :.            lo
+0001ec00: 672e 6465 6275 6728 2261 6d62 6965 6e74  g.debug("ambient
+0001ec10: 2074 656d 7065 7261 7475 7265 2072 6571   temperature req
+0001ec20: 7569 7265 7320 5853 206f 7220 4765 6e20  uires XS or Gen 
+0001ec30: 312e 3522 290a 2020 2020 2020 2020 2020  1.5").          
+0001ec40: 2020 7265 7475 726e 200a 0a20 2020 2064    return ..    d
+0001ec50: 6566 2067 6574 5f61 6d62 6965 6e74 5f74  ef get_ambient_t
+0001ec60: 656d 7065 7261 7475 7265 5f64 6567 435f  emperature_degC_
+0001ec70: 6172 6d28 7365 6c66 293a 0a20 2020 2020  arm(self):.     
+0001ec80: 2020 2069 6620 6e6f 7420 7365 6c66 2e73     if not self.s
+0001ec90: 6574 7469 6e67 732e 6973 5f78 7328 293a  ettings.is_xs():
+0001eca0: 0a20 2020 2020 2020 2020 2020 206d 7367  .            msg
+0001ecb0: 203d 2022 616d 6269 656e 7420 7465 6d70   = "ambient temp
+0001ecc0: 6572 6174 7572 6520 4152 4d20 7265 7175  erature ARM requ
+0001ecd0: 6972 6573 2058 5322 0a20 2020 2020 2020  ires XS".       
+0001ece0: 2020 2020 206c 6f67 2e64 6562 7567 286d       log.debug(m
+0001ecf0: 7367 290a 2020 2020 2020 2020 2020 2020  sg).            
+0001ed00: 7265 7475 726e 0a0a 2020 2020 2020 2020  return..        
+0001ed10: 6966 2073 656c 662e 7365 7474 696e 6773  if self.settings
+0001ed20: 2e6d 6963 726f 636f 6e74 726f 6c6c 6572  .microcontroller
+0001ed30: 5f66 6972 6d77 6172 655f 7665 7273 696f  _firmware_versio
+0001ed40: 6e20 3d3d 2022 312e 302e 322e 3922 3a0a  n == "1.0.2.9":.
+0001ed50: 2020 2020 2020 2020 2020 2020 6d73 6720              msg 
+0001ed60: 3d20 2261 6d62 6965 6e74 2074 656d 7065  = "ambient tempe
+0001ed70: 7261 7475 7265 2041 524d 2072 6571 7569  rature ARM requi
+0001ed80: 7265 7320 6e65 7765 7220 6669 726d 7761  res newer firmwa
+0001ed90: 7265 220a 2020 2020 2020 2020 2020 2020  re".            
+0001eda0: 6c6f 672e 6465 6275 6728 6d73 6729 0a20  log.debug(msg). 
+0001edb0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0001edc0: 6e0a 0a20 2020 2020 2020 2072 6573 756c  n..        resul
+0001edd0: 7420 3d20 7365 6c66 2e5f 6765 745f 636f  t = self._get_co
+0001ede0: 6465 2830 7866 662c 2030 7832 612c 206c  de(0xff, 0x2a, l
+0001edf0: 6162 656c 3d22 4745 545f 414d 4249 454e  abel="GET_AMBIEN
+0001ee00: 545f 5445 4d50 4552 4154 5552 455f 4445  T_TEMPERATURE_DE
+0001ee10: 4743 5f41 524d 222c 206d 7362 5f6c 656e  GC_ARM", msb_len
+0001ee20: 3d31 290a 2020 2020 2020 2020 6966 2072  =1).        if r
+0001ee30: 6573 756c 7420 6973 204e 6f6e 6520 6f72  esult is None or
+0001ee40: 2072 6573 756c 742e 6461 7461 2069 7320   result.data is 
+0001ee50: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+0001ee60: 2020 6d73 6720 3d20 6622 6661 696c 6564    msg = f"failed
+0001ee70: 2074 6f20 7265 6164 2061 6d62 6965 6e74   to read ambient
+0001ee80: 2074 656d 7065 7261 7475 7265 220a 2020   temperature".  
+0001ee90: 2020 2020 2020 2020 2020 6c6f 672e 6572            log.er
+0001eea0: 726f 7228 6d73 6729 0a20 2020 2020 2020  ror(msg).       
+0001eeb0: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
+0001eec0: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
+0001eed0: 2865 7272 6f72 5f6d 7367 3d6d 7367 290a  (error_msg=msg).
+0001eee0: 2020 2020 2020 2020 6465 6743 203d 2072          degC = r
+0001eef0: 6573 756c 742e 6461 7461 0a0a 2020 2020  esult.data..    
+0001ef00: 2020 2020 6c6f 672e 6465 6275 6728 2261      log.debug("a
+0001ef10: 6d62 6965 6e74 2074 656d 7065 7261 7475  mbient temperatu
+0001ef20: 7265 2064 6567 4320 4152 4d3a 2025 7322  re degC ARM: %s"
+0001ef30: 2c20 6465 6743 290a 2020 2020 2020 2020  , degC).        
+0001ef40: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
+0001ef50: 7465 7252 6573 706f 6e73 6528 6461 7461  terResponse(data
+0001ef60: 3d64 6567 4329 0a0a 2020 2020 6465 6620  =degC)..    def 
+0001ef70: 6765 745f 616d 6269 656e 745f 7465 6d70  get_ambient_temp
+0001ef80: 6572 6174 7572 655f 6465 6743 5f67 656e  erature_degC_gen
+0001ef90: 3135 2873 656c 6629 3a0a 2020 2020 2020  15(self):.      
+0001efa0: 2020 6966 206e 6f74 2073 656c 662e 7365    if not self.se
+0001efb0: 7474 696e 6773 2e69 735f 6765 6e31 3528  ttings.is_gen15(
+0001efc0: 293a 0a20 2020 2020 2020 2020 2020 206d  ):.            m
+0001efd0: 7367 203d 2022 616d 6269 656e 7420 7465  sg = "ambient te
+0001efe0: 6d70 6572 6174 7572 6520 4765 6e31 2e35  mperature Gen1.5
+0001eff0: 2072 6571 7569 7265 7320 4765 6e20 312e   requires Gen 1.
+0001f000: 3522 0a20 2020 2020 2020 2020 2020 206c  5".            l
+0001f010: 6f67 2e65 7272 6f72 286d 7367 290a 2020  og.error(msg).  
+0001f020: 2020 2020 2020 2020 2020 7265 7475 726e            return
+0001f030: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
+0001f040: 706f 6e73 6528 6572 726f 725f 6d73 673d  ponse(error_msg=
+0001f050: 6d73 6729 0a20 2020 2020 2020 2020 2020  msg).           
+0001f060: 200a 2020 2020 2020 2020 7265 7375 6c74   .        result
+0001f070: 203d 2073 656c 662e 5f67 6574 5f63 6f64   = self._get_cod
+0001f080: 6528 3078 3335 2c20 6c61 6265 6c3d 2247  e(0x35, label="G
+0001f090: 4554 5f41 4d42 4945 4e54 5f54 454d 5045  ET_AMBIENT_TEMPE
+0001f0a0: 5241 5455 5245 5f47 454e 3135 222c 206d  RATURE_GEN15", m
+0001f0b0: 7362 5f6c 656e 3d32 290a 2020 2020 2020  sb_len=2).      
+0001f0c0: 2020 6966 2072 6573 756c 7420 6973 204e    if result is N
+0001f0d0: 6f6e 6520 6f72 206c 656e 2872 6573 756c  one or len(resul
+0001f0e0: 7429 2021 3d20 323a 0a20 2020 2020 2020  t) != 2:.       
+0001f0f0: 2020 2020 206d 7367 203d 2066 2266 6169       msg = f"fai
+0001f100: 6c65 6420 746f 2072 6561 6420 616d 6269  led to read ambi
+0001f110: 656e 7420 7465 6d70 6572 6174 7572 6522  ent temperature"
+0001f120: 0a20 2020 2020 2020 2020 2020 206c 6f67  .            log
+0001f130: 2e65 7272 6f72 286d 7367 290a 2020 2020  .error(msg).    
+0001f140: 2020 2020 2020 2020 7265 7475 726e 2053          return S
+0001f150: 7065 6374 726f 6d65 7465 7252 6573 706f  pectrometerRespo
+0001f160: 6e73 6528 6572 726f 725f 6d73 673d 6d73  nse(error_msg=ms
+0001f170: 6729 0a20 2020 2020 2020 206c 6f67 2e64  g).        log.d
+0001f180: 6562 7567 2822 616d 6269 656e 7420 7465  ebug("ambient te
+0001f190: 6d70 6572 6174 7572 6520 7261 773a 2025  mperature raw: %
+0001f1a0: 7322 2c20 7265 7375 6c74 290a 0a20 2020  s", result)..   
+0001f1b0: 2020 2020 2072 6177 203d 2072 6573 756c       raw = resul
+0001f1c0: 742e 6461 7461 0a20 2020 2020 2020 2072  t.data.        r
+0001f1d0: 6177 203d 2072 6177 203e 3e20 350a 2020  aw = raw >> 5.  
+0001f1e0: 2020 2020 2020 6465 6743 203d 2030 2e31        degC = 0.1
+0001f1f0: 3235 202a 2075 7469 6c73 2e74 776f 735f  25 * utils.twos_
+0001f200: 636f 6d70 2872 6177 2c20 3131 290a 0a20  comp(raw, 11).. 
+0001f210: 2020 2020 2020 206c 6f67 2e64 6562 7567         log.debug
+0001f220: 2822 7061 7273 6564 2061 6d62 6965 6e74  ("parsed ambient
+0001f230: 2074 656d 7065 7261 7475 7265 2066 726f   temperature fro
+0001f240: 6d20 7261 7720 2573 2074 6f20 252e 3366  m raw %s to %.3f
+0001f250: 2064 6567 4322 2c20 7265 7375 6c74 2c20   degC", result, 
+0001f260: 6465 6743 290a 2020 2020 2020 2020 7265  degC).        re
+0001f270: 7475 726e 2053 7065 6374 726f 6d65 7465  turn Spectromete
+0001f280: 7252 6573 706f 6e73 6528 6461 7461 3d64  rResponse(data=d
+0001f290: 6567 4329 0a0a 2020 2020 2320 2323 2323  egC)..    # ####
+0001f2a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001f2b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001f2c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001f2d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001f2e0: 2323 2323 2323 0a20 2020 2023 2061 6464  ######.    # add
+0001f2f0: 6564 2066 6f72 2077 6173 6174 6368 2d73  ed for wasatch-s
+0001f300: 6865 6c6c 0a20 2020 2023 2023 2323 2323  hell.    # #####
+0001f310: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001f320: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001f330: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001f340: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001f350: 2323 2323 230a 0a20 2020 2064 6566 2067  #####..    def g
+0001f360: 6574 5f74 6563 5f65 6e61 626c 6564 2873  et_tec_enabled(s
+0001f370: 656c 6629 3a0a 2020 2020 2020 2020 6966  elf):.        if
+0001f380: 206e 6f74 2073 656c 662e 7365 7474 696e   not self.settin
+0001f390: 6773 2e65 6570 726f 6d2e 6861 735f 636f  gs.eeprom.has_co
+0001f3a0: 6f6c 696e 673a 0a20 2020 2020 2020 2020  oling:.         
+0001f3b0: 2020 206c 6f67 2e65 7272 6f72 2822 756e     log.error("un
+0001f3c0: 6162 6c65 2074 6f20 636f 6e74 726f 6c20  able to control 
+0001f3d0: 5445 433a 2045 4550 524f 4d20 7265 706f  TEC: EEPROM repo
+0001f3e0: 7274 7320 6e6f 2063 6f6f 6c69 6e67 2229  rts no cooling")
+0001f3f0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0001f400: 7572 6e20 5370 6563 7472 6f6d 6574 6572  urn Spectrometer
+0001f410: 5265 7370 6f6e 7365 2864 6174 613d 4661  Response(data=Fa
+0001f420: 6c73 652c 6572 726f 725f 6d73 673d 226e  lse,error_msg="n
+0001f430: 6f20 636f 6f6c 696e 6720 7265 706f 7274  o cooling report
+0001f440: 6564 2229 0a20 2020 2020 2020 2072 6573  ed").        res
+0001f450: 203d 2073 656c 662e 5f67 6574 5f63 6f64   = self._get_cod
+0001f460: 6528 3078 6461 2c20 6c61 6265 6c3d 2247  e(0xda, label="G
+0001f470: 4554 5f43 4344 5f54 4543 5f45 4e41 424c  ET_CCD_TEC_ENABL
+0001f480: 4544 222c 206d 7362 5f6c 656e 3d31 290a  ED", msb_len=1).
+0001f490: 2020 2020 2020 2020 7265 732e 6461 7461          res.data
+0001f4a0: 203d 2030 2021 3d20 7265 732e 6461 7461   = 0 != res.data
+0001f4b0: 0a20 2020 2020 2020 2069 6620 7265 732e  .        if res.
+0001f4c0: 6572 726f 725f 6d73 6720 213d 2027 273a  error_msg != '':
+0001f4d0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0001f4e0: 7572 6e20 7265 730a 2020 2020 2020 2020  urn res.        
+0001f4f0: 7265 7475 726e 2072 6573 0a0a 2020 2020  return res..    
+0001f500: 6465 6620 6765 745f 6163 7475 616c 5f66  def get_actual_f
+0001f510: 7261 6d65 7328 7365 6c66 293a 0a20 2020  rames(self):.   
+0001f520: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+0001f530: 2e5f 6765 745f 636f 6465 2830 7865 342c  ._get_code(0xe4,
+0001f540: 206c 6162 656c 3d22 4745 545f 4143 5455   label="GET_ACTU
+0001f550: 414c 5f46 5241 4d45 5322 2c20 6c73 625f  AL_FRAMES", lsb_
+0001f560: 6c65 6e3d 3229 0a0a 2020 2020 6465 6620  len=2)..    def 
+0001f570: 6765 745f 6163 7475 616c 5f69 6e74 6567  get_actual_integ
+0001f580: 7261 7469 6f6e 5f74 696d 655f 7573 2873  ration_time_us(s
+0001f590: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+0001f5a0: 7475 726e 2073 656c 662e 5f67 6574 5f63  turn self._get_c
+0001f5b0: 6f64 6528 3078 6466 2c20 6c61 6265 6c3d  ode(0xdf, label=
+0001f5c0: 2247 4554 5f41 4354 5541 4c5f 494e 5445  "GET_ACTUAL_INTE
+0001f5d0: 4752 4154 494f 4e5f 5449 4d45 5f55 5322  GRATION_TIME_US"
+0001f5e0: 2c20 6c73 625f 6c65 6e3d 3329 0a0a 2020  , lsb_len=3)..  
+0001f5f0: 2020 6465 6620 6765 745f 6465 7465 6374    def get_detect
+0001f600: 6f72 5f6f 6666 7365 7428 7365 6c66 293a  or_offset(self):
+0001f610: 0a20 2020 2020 2020 2076 616c 7565 203d  .        value =
+0001f620: 2073 656c 662e 5f67 6574 5f63 6f64 6528   self._get_code(
+0001f630: 3078 6334 2c20 6c61 6265 6c3d 2247 4554  0xc4, label="GET
+0001f640: 5f44 4554 4543 544f 525f 4f46 4653 4554  _DETECTOR_OFFSET
+0001f650: 222c 206c 7362 5f6c 656e 3d32 290a 2020  ", lsb_len=2).  
+0001f660: 2020 2020 2020 7365 6c66 2e73 6574 7469        self.setti
+0001f670: 6e67 732e 6565 7072 6f6d 2e64 6574 6563  ngs.eeprom.detec
+0001f680: 746f 725f 6f66 6673 6574 203d 2076 616c  tor_offset = val
+0001f690: 7565 2e64 6174 610a 2020 2020 2020 2020  ue.data.        
+0001f6a0: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
+0001f6b0: 7465 7252 6573 706f 6e73 6528 6461 7461  terResponse(data
+0001f6c0: 3d76 616c 7565 290a 0a20 2020 2064 6566  =value)..    def
+0001f6d0: 2067 6574 5f64 6574 6563 746f 725f 6f66   get_detector_of
+0001f6e0: 6673 6574 5f6f 6464 2873 656c 6629 3a0a  fset_odd(self):.
+0001f6f0: 2020 2020 2020 2020 6966 206e 6f74 2073          if not s
+0001f700: 656c 662e 7365 7474 696e 6773 2e69 735f  elf.settings.is_
+0001f710: 696e 6761 6173 2829 3a0a 2020 2020 2020  ingaas():.      
+0001f720: 2020 2020 2020 6c6f 672e 6465 6275 6728        log.debug(
+0001f730: 2247 4554 5f44 4554 4543 544f 525f 4f46  "GET_DETECTOR_OF
+0001f740: 4653 4554 5f4f 4444 206f 6e6c 7920 7375  FSET_ODD only su
+0001f750: 7070 6f72 7465 6420 6f6e 2049 6e47 6141  pported on InGaA
+0001f760: 7322 290a 2020 2020 2020 2020 2020 2020  s").            
+0001f770: 7265 7475 726e 2053 7065 6374 726f 6d65  return Spectrome
+0001f780: 7465 7252 6573 706f 6e73 6528 6461 7461  terResponse(data
+0001f790: 3d73 656c 662e 7365 7474 696e 6773 2e65  =self.settings.e
+0001f7a0: 6570 726f 6d2e 6465 7465 6374 6f72 5f6f  eprom.detector_o
+0001f7b0: 6666 7365 745f 6f64 6429 0a0a 2020 2020  ffset_odd)..    
+0001f7c0: 2020 2020 7661 6c75 6520 3d20 7365 6c66      value = self
+0001f7d0: 2e5f 6765 745f 636f 6465 2830 7839 652c  ._get_code(0x9e,
+0001f7e0: 206c 6162 656c 3d22 4745 545f 4445 5445   label="GET_DETE
+0001f7f0: 4354 4f52 5f4f 4646 5345 545f 4f44 4422  CTOR_OFFSET_ODD"
+0001f800: 2c20 6c73 625f 6c65 6e3d 3229 0a20 2020  , lsb_len=2).   
+0001f810: 2020 2020 2069 6620 7661 6c75 652e 6572       if value.er
+0001f820: 726f 725f 6d73 6720 213d 2027 273a 0a20  ror_msg != '':. 
+0001f830: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0001f840: 6e20 7661 6c75 650a 2020 2020 2020 2020  n value.        
+0001f850: 7365 6c66 2e73 6574 7469 6e67 732e 6565  self.settings.ee
+0001f860: 7072 6f6d 2e64 6574 6563 746f 725f 6f66  prom.detector_of
+0001f870: 6673 6574 5f6f 6464 203d 2076 616c 7565  fset_odd = value
+0001f880: 2e64 6174 610a 2020 2020 2020 2020 7265  .data.        re
+0001f890: 7475 726e 2053 7065 6374 726f 6d65 7465  turn Spectromete
+0001f8a0: 7252 6573 706f 6e73 6528 6461 7461 3d76  rResponse(data=v
+0001f8b0: 616c 7565 290a 0a20 2020 2064 6566 2067  alue)..    def g
+0001f8c0: 6574 5f63 6364 5f73 656e 7369 6e67 5f74  et_ccd_sensing_t
+0001f8d0: 6872 6573 686f 6c64 2873 656c 6629 3a0a  hreshold(self):.
+0001f8e0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+0001f8f0: 656c 662e 5f67 6574 5f63 6f64 6528 3078  elf._get_code(0x
+0001f900: 6431 2c20 6c61 6265 6c3d 2247 4554 5f43  d1, label="GET_C
+0001f910: 4344 5f53 454e 5349 4e47 5f54 4852 4553  CD_SENSING_THRES
+0001f920: 484f 4c44 222c 206c 7362 5f6c 656e 3d32  HOLD", lsb_len=2
+0001f930: 290a 0a20 2020 2064 6566 2067 6574 5f63  )..    def get_c
+0001f940: 6364 5f74 6872 6573 686f 6c64 5f73 656e  cd_threshold_sen
+0001f950: 7369 6e67 5f6d 6f64 6528 7365 6c66 293a  sing_mode(self):
+0001f960: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0001f970: 7365 6c66 2e5f 6765 745f 636f 6465 2830  self._get_code(0
+0001f980: 7863 662c 206c 6162 656c 3d22 4745 545f  xcf, label="GET_
+0001f990: 4343 445f 5448 5245 5348 4f4c 445f 5345  CCD_THRESHOLD_SE
+0001f9a0: 4e53 494e 475f 4d4f 4445 222c 206d 7362  NSING_MODE", msb
+0001f9b0: 5f6c 656e 3d31 290a 0a20 2020 2064 6566  _len=1)..    def
+0001f9c0: 2067 6574 5f65 7874 6572 6e61 6c5f 7472   get_external_tr
+0001f9d0: 6967 6765 725f 6f75 7470 7574 2873 656c  igger_output(sel
+0001f9e0: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
+0001f9f0: 726e 2073 656c 662e 5f67 6574 5f63 6f64  rn self._get_cod
+0001fa00: 6528 3078 6531 2c20 6c61 6265 6c3d 2247  e(0xe1, label="G
+0001fa10: 4554 5f45 5854 4552 4e41 4c5f 5452 4947  ET_EXTERNAL_TRIG
+0001fa20: 4745 525f 4f55 5450 5554 222c 206d 7362  GER_OUTPUT", msb
+0001fa30: 5f6c 656e 3d31 290a 0a20 2020 2064 6566  _len=1)..    def
+0001fa40: 2073 6574 5f6d 6f64 5f6c 696e 6b65 645f   set_mod_linked_
+0001fa50: 746f 5f69 6e74 6567 7261 7469 6f6e 2873  to_integration(s
+0001fa60: 656c 662c 2066 6c61 673a 2062 6f6f 6c29  elf, flag: bool)
+0001fa70: 3a0a 2020 2020 2020 2020 7661 6c75 6520  :.        value 
+0001fa80: 3d20 3120 6966 2066 6c61 6720 656c 7365  = 1 if flag else
+0001fa90: 2030 0a20 2020 2020 2020 2072 6574 7572   0.        retur
+0001faa0: 6e20 7365 6c66 2e5f 7365 6e64 5f63 6f64  n self._send_cod
+0001fab0: 6528 3078 6464 2c20 7661 6c75 652c 206c  e(0xdd, value, l
+0001fac0: 6162 656c 3d22 5345 545f 4d4f 445f 4c49  abel="SET_MOD_LI
+0001fad0: 4e4b 4544 5f54 4f5f 494e 5445 4752 4154  NKED_TO_INTEGRAT
+0001fae0: 494f 4e22 290a 0a20 2020 2064 6566 2067  ION")..    def g
+0001faf0: 6574 5f6d 6f64 5f6c 696e 6b65 645f 746f  et_mod_linked_to
+0001fb00: 5f69 6e74 6567 7261 7469 6f6e 2873 656c  _integration(sel
+0001fb10: 6629 3a0a 2020 2020 2020 2020 7265 7320  f):.        res 
+0001fb20: 3d20 7365 6c66 2e5f 6765 745f 636f 6465  = self._get_code
+0001fb30: 2830 7864 652c 206c 6162 656c 3d22 4745  (0xde, label="GE
+0001fb40: 545f 4d4f 445f 4c49 4e4b 4544 5f54 4f5f  T_MOD_LINKED_TO_
+0001fb50: 494e 5445 4752 4154 494f 4e22 2c20 6d73  INTEGRATION", ms
+0001fb60: 625f 6c65 6e3d 3129 0a20 2020 2020 2020  b_len=1).       
+0001fb70: 2069 6620 7265 732e 6572 726f 725f 6d73   if res.error_ms
+0001fb80: 6720 213d 2027 273a 0a20 2020 2020 2020  g != '':.       
+0001fb90: 2020 2020 2072 6574 7572 6e20 7265 730a       return res.
+0001fba0: 2020 2020 2020 2020 7265 732e 6461 7461          res.data
+0001fbb0: 203d 2030 2021 3d20 7265 732e 6461 7461   = 0 != res.data
+0001fbc0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0001fbd0: 7265 730a 0a20 2020 2064 6566 2067 6574  res..    def get
+0001fbe0: 5f73 656c 6563 7465 645f 6164 6328 7365  _selected_adc(se
+0001fbf0: 6c66 293a 0a20 2020 2020 2020 2076 616c  lf):.        val
+0001fc00: 7565 203d 2073 656c 662e 5f67 6574 5f63  ue = self._get_c
+0001fc10: 6f64 6528 3078 6565 2c20 6c61 6265 6c3d  ode(0xee, label=
+0001fc20: 2247 4554 5f53 454c 4543 5445 445f 4144  "GET_SELECTED_AD
+0001fc30: 4322 2c20 6d73 625f 6c65 6e3d 3129 0a20  C", msb_len=1). 
+0001fc40: 2020 2020 2020 2069 6620 7661 6c75 652e         if value.
+0001fc50: 6572 726f 725f 6d73 6720 213d 2027 273a  error_msg != '':
+0001fc60: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0001fc70: 7572 6e20 7661 6c75 650a 2020 2020 2020  urn value.      
+0001fc80: 2020 6966 2073 656c 662e 7365 7474 696e    if self.settin
+0001fc90: 6773 2e73 7461 7465 2e73 656c 6563 7465  gs.state.selecte
+0001fca0: 645f 6164 6320 213d 2076 616c 7565 2e64  d_adc != value.d
+0001fcb0: 6174 613a 0a20 2020 2020 2020 2020 2020  ata:.           
+0001fcc0: 206c 6f67 2e65 7272 6f72 2822 4745 545f   log.error("GET_
+0001fcd0: 5345 4c45 4354 4544 5f41 4443 2025 6420  SELECTED_ADC %d 
+0001fce0: 213d 2073 7461 7465 2e73 656c 6563 7465  != state.selecte
+0001fcf0: 645f 6164 6320 2564 222c 2076 616c 7565  d_adc %d", value
+0001fd00: 2c20 7365 6c66 2e73 6574 7469 6e67 732e  , self.settings.
+0001fd10: 7374 6174 652e 7365 6c65 6374 6564 5f61  state.selected_a
+0001fd20: 6463 290a 2020 2020 2020 2020 2020 2020  dc).            
+0001fd30: 7365 6c66 2e73 6574 7469 6e67 732e 7374  self.settings.st
+0001fd40: 6174 652e 7365 6c65 6374 6564 5f61 6463  ate.selected_adc
+0001fd50: 203d 2076 616c 7565 2e64 6174 610a 2020   = value.data.  
+0001fd60: 2020 2020 2020 7265 7475 726e 2076 616c        return val
+0001fd70: 7565 0a0a 2020 2020 6465 6620 7365 745f  ue..    def set_
+0001fd80: 7472 6967 6765 725f 6465 6c61 7928 7365  trigger_delay(se
+0001fd90: 6c66 2c20 6861 6c66 5f75 733a 2066 6c6f  lf, half_us: flo
+0001fda0: 6174 293a 0a20 2020 2020 2020 2022 2222  at):.        """
+0001fdb0: 0a20 2020 2020 2020 2041 2063 6f6e 6665  .        A confe
+0001fdc0: 6e75 7261 626c 6520 6465 6c61 7920 6672  nurable delay fr
+0001fdd0: 6f6d 2077 6865 6e20 616e 2069 6e62 6f75  om when an inbou
+0001fde0: 6e64 2074 7269 6767 6572 2073 6967 6e61  nd trigger signa
+0001fdf0: 6c20 6973 0a20 2020 2020 2020 2072 6563  l is.        rec
+0001fe00: 6569 7665 6420 6279 2074 6865 2073 7065  eived by the spe
+0001fe10: 6374 726f 6d65 7465 722c 2075 6e74 696c  ctrometer, until
+0001fe20: 2074 6865 2074 7269 6767 6572 6564 2061   the triggered a
+0001fe30: 6371 7569 7369 7469 6f6e 2061 6374 7561  cquisition actua
+0001fe40: 6c6c 7920 7374 6172 7473 2e0a 2020 2020  lly starts..    
+0001fe50: 2020 2020 0a20 2020 2020 2020 2044 6566      .        Def
+0001fe60: 6175 6c74 2076 616c 7565 2069 7320 3075  ault value is 0u
+0001fe70: 732e 0a20 2020 2020 2020 200a 2020 2020  s..        .    
+0001fe80: 2020 2020 556e 6974 2069 7320 696e 2030      Unit is in 0
+0001fe90: 2e35 206d 6963 726f 7365 636f 6e64 7320  .5 microseconds 
+0001fea0: 2835 3030 6e73 292c 2073 6f20 7661 6c75  (500ns), so valu
+0001feb0: 6520 6f66 2032 3520 776f 756c 6420 7265  e of 25 would re
+0001fec0: 7072 6573 656e 7420 3132 2e35 7573 2e0a  present 12.5us..
+0001fed0: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
+0001fee0: 2056 616c 7565 2069 7320 3234 6269 742c   Value is 24bit,
+0001fef0: 2073 6f20 6d61 7820 7661 6c75 6520 6973   so max value is
+0001ff00: 2031 3637 3737 3231 3620 2838 2e33 3838   16777216 (8.388
+0001ff10: 3630 3820 7365 6329 2e0a 2020 2020 2020  608 sec)..      
+0001ff20: 2020 0a20 2020 2020 2020 204c 696b 6520    .        Like 
+0001ff30: 7472 6967 6765 7269 6e67 2c20 6f6e 6c79  triggering, only
+0001ff40: 2063 7572 7265 6e74 6c79 2073 7570 706f   currently suppo
+0001ff50: 7274 6564 206f 6e20 4152 4d2e 0a20 2020  rted on ARM..   
+0001ff60: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+0001ff70: 2069 6620 6e6f 7420 7365 6c66 2e73 6574   if not self.set
+0001ff80: 7469 6e67 732e 6973 5f61 726d 2829 3a0a  tings.is_arm():.
+0001ff90: 2020 2020 2020 2020 2020 2020 6c6f 672e              log.
+0001ffa0: 6572 726f 7228 2253 4554 5f54 5249 4747  error("SET_TRIGG
+0001ffb0: 4552 5f44 454c 4159 206f 6e6c 7920 7375  ER_DELAY only su
+0001ffc0: 7070 6f72 7465 6420 6f6e 2041 524d 2229  pported on ARM")
+0001ffd0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0001ffe0: 7572 6e20 4661 6c73 650a 2020 2020 2020  urn False.      
+0001fff0: 2020 6c73 7720 3d20 6861 6c66 5f75 7320    lsw = half_us 
+00020000: 2620 3078 6666 6666 0a20 2020 2020 2020  & 0xffff.       
+00020010: 206d 7362 203d 2028 6861 6c66 5f75 7320   msb = (half_us 
+00020020: 3e3e 2031 3629 2026 2030 7866 660a 2020  >> 16) & 0xff.  
+00020030: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+00020040: 662e 5f73 656e 645f 636f 6465 2830 7861  f._send_code(0xa
+00020050: 612c 2077 5661 6c75 653d 6c73 772c 2077  a, wValue=lsw, w
+00020060: 496e 6465 783d 6d73 622c 206c 6162 656c  Index=msb, label
+00020070: 3d22 5345 545f 5452 4947 4745 525f 4445  ="SET_TRIGGER_DE
+00020080: 4c41 5922 290a 0a20 2020 2023 206e 6f74  LAY")..    # not
+00020090: 2074 6573 7465 640a 2020 2020 6465 6620   tested.    def 
+000200a0: 6765 745f 7472 6967 6765 725f 6465 6c61  get_trigger_dela
+000200b0: 7928 7365 6c66 293a 0a20 2020 2020 2020  y(self):.       
+000200c0: 2069 6620 6e6f 7420 7365 6c66 2e73 6574   if not self.set
+000200d0: 7469 6e67 732e 6973 5f61 726d 2829 3a0a  tings.is_arm():.
+000200e0: 2020 2020 2020 2020 2020 2020 6d73 6720              msg 
+000200f0: 3d20 2247 4554 5f54 5249 4747 4552 5f44  = "GET_TRIGGER_D
+00020100: 454c 4159 206f 6e6c 7920 7375 7070 6f72  ELAY only suppor
+00020110: 7465 6420 6f6e 2041 524d 220a 2020 2020  ted on ARM".    
+00020120: 2020 2020 2020 2020 6c6f 672e 6572 726f          log.erro
+00020130: 7228 6d73 6729 0a20 2020 2020 2020 2020  r(msg).         
+00020140: 2020 2072 6574 7572 6e20 5370 6563 7472     return Spectr
+00020150: 6f6d 6574 6572 5265 7370 6f6e 7365 2865  ometerResponse(e
+00020160: 7272 6f72 5f6c 766c 3d45 7272 6f72 4c65  rror_lvl=ErrorLe
+00020170: 7665 6c2e 6c6f 772c 2065 7272 6f72 5f6d  vel.low, error_m
+00020180: 7367 3d6d 7367 290a 2020 2020 2020 2020  sg=msg).        
+00020190: 7265 7475 726e 2073 656c 662e 5f67 6574  return self._get
+000201a0: 5f63 6f64 6528 3078 6534 2c20 6c61 6265  _code(0xe4, labe
+000201b0: 6c3d 2247 4554 5f54 5249 4747 4552 5f44  l="GET_TRIGGER_D
+000201c0: 454c 4159 222c 206c 7362 5f6c 656e 3d33  ELAY", lsb_len=3
+000201d0: 2920 2320 6e6f 7420 7375 7265 2061 626f  ) # not sure abo
+000201e0: 7574 204c 5342 0a0a 2020 2020 6465 6620  ut LSB..    def 
+000201f0: 6765 745f 7672 5f63 6f6e 7469 6e75 6f75  get_vr_continuou
+00020200: 735f 6363 6428 7365 6c66 293a 0a20 2020  s_ccd(self):.   
+00020210: 2020 2020 2072 6573 203d 2073 656c 662e       res = self.
+00020220: 5f67 6574 5f63 6f64 6528 3078 6363 2c20  _get_code(0xcc, 
+00020230: 6c61 6265 6c3d 2247 4554 5f56 525f 434f  label="GET_VR_CO
+00020240: 4e54 494e 554f 5553 5f43 4344 222c 206d  NTINUOUS_CCD", m
+00020250: 7362 5f6c 656e 3d31 290a 2020 2020 2020  sb_len=1).      
+00020260: 2020 6966 2072 6573 2e65 7272 6f72 5f6d    if res.error_m
+00020270: 7367 2021 3d20 2727 3a0a 2020 2020 2020  sg != '':.      
+00020280: 2020 2020 2020 7265 7475 726e 2072 6573        return res
+00020290: 0a20 2020 2020 2020 2072 6573 2e64 6174  .        res.dat
+000202a0: 6120 3d20 3020 213d 2072 6573 2e64 6174  a = 0 != res.dat
+000202b0: 610a 2020 2020 2020 2020 7265 7475 726e  a.        return
+000202c0: 2072 6573 0a0a 2020 2020 6465 6620 6765   res..    def ge
+000202d0: 745f 7672 5f6e 756d 5f66 7261 6d65 7328  t_vr_num_frames(
+000202e0: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
+000202f0: 6574 7572 6e20 7365 6c66 2e5f 6765 745f  eturn self._get_
+00020300: 636f 6465 2830 7863 642c 206c 6162 656c  code(0xcd, label
+00020310: 3d22 4745 545f 5652 5f4e 554d 5f46 5241  ="GET_VR_NUM_FRA
+00020320: 4d45 5322 2c20 6d73 625f 6c65 6e3d 3129  MES", msb_len=1)
+00020330: 0a0a 2020 2020 6465 6620 6765 745f 6f70  ..    def get_op
+00020340: 745f 6163 7475 616c 5f69 6e74 6567 7261  t_actual_integra
+00020350: 7469 6f6e 5f74 696d 6528 7365 6c66 293a  tion_time(self):
+00020360: 0a20 2020 2020 2020 2072 6573 203d 2073  .        res = s
+00020370: 656c 662e 6765 745f 7570 7065 725f 636f  elf.get_upper_co
+00020380: 6465 2830 7830 622c 206c 6162 656c 3d22  de(0x0b, label="
+00020390: 4745 545f 4f50 545f 4143 545f 494e 545f  GET_OPT_ACT_INT_
+000203a0: 5449 4d45 222c 206d 7362 5f6c 656e 3d31  TIME", msb_len=1
+000203b0: 2920 0a20 2020 2020 2020 2069 6620 7265  ) .        if re
+000203c0: 732e 6572 726f 725f 6d73 6720 213d 2027  s.error_msg != '
+000203d0: 273a 0a20 2020 2020 2020 2020 2020 2072  ':.            r
+000203e0: 6574 7572 6e20 7265 730a 2020 2020 2020  eturn res.      
+000203f0: 2020 7265 732e 6461 7461 203d 2030 2021    res.data = 0 !
+00020400: 3d20 7265 732e 6461 7461 0a20 2020 2020  = res.data.     
+00020410: 2020 2072 6574 7572 6e20 7265 730a 0a20     return res.. 
+00020420: 2020 2064 6566 2067 6574 5f6f 7074 5f61     def get_opt_a
+00020430: 7265 615f 7363 616e 2873 656c 6629 3a0a  rea_scan(self):.
+00020440: 2020 2020 2020 2020 7265 7320 3d20 7365          res = se
+00020450: 6c66 2e67 6574 5f75 7070 6572 5f63 6f64  lf.get_upper_cod
+00020460: 6528 3078 3061 2c20 6c61 6265 6c3d 2247  e(0x0a, label="G
+00020470: 4554 5f4f 5054 5f41 5245 415f 5343 414e  ET_OPT_AREA_SCAN
+00020480: 222c 206d 7362 5f6c 656e 3d31 290a 2020  ", msb_len=1).  
+00020490: 2020 2020 2020 6966 2072 6573 2e65 7272        if res.err
+000204a0: 6f72 5f6d 7367 2021 3d20 2727 3a0a 2020  or_msg != '':.  
+000204b0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+000204c0: 2072 6573 0a20 2020 2020 2020 2072 6573   res.        res
+000204d0: 2e64 6174 6120 3d20 3020 213d 2072 6573  .data = 0 != res
+000204e0: 2e64 6174 610a 2020 2020 2020 2020 7265  .data.        re
+000204f0: 7475 726e 2072 6573 0a0a 2020 2020 6465  turn res..    de
+00020500: 6620 6765 745f 6f70 745f 6366 5f73 656c  f get_opt_cf_sel
+00020510: 6563 7428 7365 6c66 293a 0a20 2020 2020  ect(self):.     
+00020520: 2020 2072 6573 203d 2073 656c 662e 6765     res = self.ge
+00020530: 745f 7570 7065 725f 636f 6465 2830 7830  t_upper_code(0x0
+00020540: 372c 206c 6162 656c 3d22 4745 545f 4f50  7, label="GET_OP
+00020550: 545f 4346 5f53 454c 4543 5422 2c20 6d73  T_CF_SELECT", ms
+00020560: 625f 6c65 6e3d 3129 0a20 2020 2020 2020  b_len=1).       
+00020570: 2069 6620 7265 732e 6572 726f 725f 6d73   if res.error_ms
+00020580: 6720 213d 2027 273a 0a20 2020 2020 2020  g != '':.       
+00020590: 2020 2020 2072 6574 7572 6e20 7265 730a       return res.
+000205a0: 2020 2020 2020 2020 7265 732e 6461 7461          res.data
+000205b0: 203d 2030 2021 3d20 7265 732e 6461 7461   = 0 != res.data
+000205c0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+000205d0: 7265 730a 0a20 2020 2064 6566 2067 6574  res..    def get
+000205e0: 5f6f 7074 5f64 6174 615f 6865 6164 6572  _opt_data_header
+000205f0: 5f74 6162 2873 656c 6629 3a0a 2020 2020  _tab(self):.    
+00020600: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+00020610: 6765 745f 7570 7065 725f 636f 6465 2830  get_upper_code(0
+00020620: 7830 362c 206c 6162 656c 3d22 4745 545f  x06, label="GET_
+00020630: 4f50 545f 4441 5441 5f48 4541 4445 525f  OPT_DATA_HEADER_
+00020640: 5441 4222 2c20 6d73 625f 6c65 6e3d 3129  TAB", msb_len=1)
+00020650: 0a0a 2020 2020 6465 6620 6765 745f 6f70  ..    def get_op
+00020660: 745f 686f 7269 7a6f 6e74 616c 5f62 696e  t_horizontal_bin
+00020670: 6e69 6e67 2873 656c 6629 3a0a 2020 2020  ning(self):.    
+00020680: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+00020690: 6765 745f 7570 7065 725f 636f 6465 2830  get_upper_code(0
+000206a0: 7830 632c 206c 6162 656c 3d22 4745 545f  x0c, label="GET_
+000206b0: 4f50 545f 484f 5249 5a4f 4e54 414c 5f42  OPT_HORIZONTAL_B
+000206c0: 494e 4e49 4e47 222c 206d 7362 5f6c 656e  INNING", msb_len
+000206d0: 3d31 290a 0a20 2020 2064 6566 2067 6574  =1)..    def get
+000206e0: 5f6f 7074 5f69 6e74 6567 7261 7469 6f6e  _opt_integration
+000206f0: 5f74 696d 655f 7265 736f 6c75 7469 6f6e  _time_resolution
+00020700: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00020710: 7265 7475 726e 2073 656c 662e 6765 745f  return self.get_
+00020720: 7570 7065 725f 636f 6465 2830 7830 352c  upper_code(0x05,
+00020730: 206c 6162 656c 3d22 4745 545f 4f50 545f   label="GET_OPT_
+00020740: 494e 5445 4752 4154 494f 4e5f 5449 4d45  INTEGRATION_TIME
+00020750: 5f52 4553 4f4c 5554 494f 4e22 2c20 6d73  _RESOLUTION", ms
+00020760: 625f 6c65 6e3d 3129 0a0a 2020 2020 2320  b_len=1)..    # 
+00020770: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00020780: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00020790: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000207a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000207b0: 2323 2323 2323 2323 2323 0a20 2020 2023  ##########.    #
+000207c0: 2041 6e61 6c6f 6720 6f75 7470 7574 0a20   Analog output. 
+000207d0: 2020 2023 2023 2323 2323 2323 2323 2323     # ###########
+000207e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000207f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00020800: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00020810: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
+00020820: 0a20 2020 2023 2320 4070 6172 616d 2076  .    ## @param v
+00020830: 616c 7565 2028 496e 7075 7429 2074 7570  alue (Input) tup
+00020840: 6c65 206f 6620 2862 6f6f 6c20 656e 6162  le of (bool enab
+00020850: 6c65 2c20 696e 7420 6d6f 6465 290a 2020  le, int mode).  
+00020860: 2020 6465 6620 7365 745f 616e 616c 6f67    def set_analog
+00020870: 5f6f 7574 7075 745f 6d6f 6465 2873 656c  _output_mode(sel
+00020880: 662c 2076 616c 7565 3a20 7475 706c 655b  f, value: tuple[
+00020890: 626f 6f6c 2c20 696e 745d 293a 0a20 2020  bool, int]):.   
+000208a0: 2020 2020 2069 6620 6e6f 7420 7365 6c66       if not self
+000208b0: 2e73 6574 7469 6e67 732e 6973 5f67 656e  .settings.is_gen
+000208c0: 3228 293a 0a20 2020 2020 2020 2020 2020  2():.           
+000208d0: 206c 6f67 2e65 7272 6f72 2822 616e 616c   log.error("anal
+000208e0: 6f67 206f 7574 7075 7420 6f6e 6c79 2061  og output only a
+000208f0: 7661 696c 6162 6c65 206f 6e20 4765 6e32  vailable on Gen2
+00020900: 2229 0a20 2020 2020 2020 2020 2020 2072  ").            r
+00020910: 6574 7572 6e20 5370 6563 7472 6f6d 6574  eturn Spectromet
+00020920: 6572 5265 7370 6f6e 7365 2864 6174 613d  erResponse(data=
+00020930: 4661 6c73 652c 6572 726f 725f 6d73 673d  False,error_msg=
+00020940: 2261 6e61 6c6f 6720 6f75 7470 7574 2075  "analog output u
+00020950: 6e73 7570 706f 7274 6564 2229 0a0a 2020  nsupported")..  
+00020960: 2020 2020 2020 7749 6e64 6578 203d 2030        wIndex = 0
+00020970: 0a0a 2020 2020 2020 2020 2320 7061 7273  ..        # pars
+00020980: 6520 656e 6162 6c65 2061 6e64 206d 6f64  e enable and mod
+00020990: 6520 6672 6f6d 2076 616c 7565 2074 7570  e from value tup
+000209a0: 6c65 0a20 2020 2020 2020 2074 7279 3a0a  le.        try:.
+000209b0: 2020 2020 2020 2020 2020 2020 6966 2069              if i
+000209c0: 7369 6e73 7461 6e63 6528 7661 6c75 655b  sinstance(value[
+000209d0: 305d 2c20 626f 6f6c 293a 0a20 2020 2020  0], bool):.     
+000209e0: 2020 2020 2020 2020 2020 2065 6e61 626c             enabl
+000209f0: 6520 3d20 7661 6c75 655b 305d 0a20 2020  e = value[0].   
+00020a00: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+00020a10: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+00020a20: 6e61 626c 6520 3d20 7661 6c75 655b 305d  nable = value[0]
+00020a30: 2021 3d20 300a 0a20 2020 2020 2020 2020   != 0..         
+00020a40: 2020 206d 6f64 6520 3d20 696e 7428 7661     mode = int(va
+00020a50: 6c75 655b 315d 290a 2020 2020 2020 2020  lue[1]).        
+00020a60: 2020 2020 6966 2028 6d6f 6465 2021 3d20      if (mode != 
+00020a70: 3020 616e 6420 6d6f 6465 2021 3d20 3129  0 and mode != 1)
+00020a80: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00020a90: 2020 6c6f 672e 6572 726f 7228 2269 6e76    log.error("inv
+00020aa0: 616c 6964 2061 6e61 6c6f 6720 6f75 7470  alid analog outp
+00020ab0: 7574 206d 6f64 6520 3078 2530 3278 2c20  ut mode 0x%02x, 
+00020ac0: 6469 7361 626c 696e 6722 2c20 6d6f 6465  disabling", mode
+00020ad0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00020ae0: 2020 656e 6162 6c65 203d 2046 616c 7365    enable = False
+00020af0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00020b00: 206d 6f64 6520 3d20 300a 0a20 2020 2020   mode = 0..     
+00020b10: 2020 2020 2020 2069 6620 656e 6162 6c65         if enable
+00020b20: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00020b30: 2020 7749 6e64 6578 203d 2030 7830 3220    wIndex = 0x02 
+00020b40: 7c20 6d6f 6465 2023 2030 7830 3220 7365  | mode # 0x02 se
+00020b50: 7473 2074 6865 2022 656e 6162 6c65 2220  ts the "enable" 
+00020b60: 6269 740a 2020 2020 2020 2020 2020 2020  bit.            
+00020b70: 2020 2020 7365 6c66 2e73 7461 7465 2e61      self.state.a
+00020b80: 6e61 6c6f 675f 6f75 745f 656e 6162 6c65  nalog_out_enable
+00020b90: 203d 2054 7275 650a 2020 2020 2020 2020   = True.        
+00020ba0: 2020 2020 2020 2020 7365 6c66 2e73 7461          self.sta
+00020bb0: 7465 2e61 6e61 6c6f 675f 6f75 745f 6d6f  te.analog_out_mo
+00020bc0: 6465 203d 206d 6f64 650a 2020 2020 2020  de = mode.      
+00020bd0: 2020 2020 2020 2020 2020 7365 6c66 2e73            self.s
+00020be0: 7461 7465 2e61 6e61 6c6f 675f 6f75 745f  tate.analog_out_
+00020bf0: 7661 6c75 6520 3d20 3020 6966 206d 6f64  value = 0 if mod
+00020c00: 6520 3d3d 2030 2065 6c73 6520 3430 2023  e == 0 else 40 #
+00020c10: 2034 6d41 2064 6566 6175 6c74 2063 7572   4mA default cur
+00020c20: 7265 6e74 2069 6e20 6465 6369 2d6d 410a  rent in deci-mA.
+00020c30: 2020 2020 2020 2020 2020 2020 656c 7365              else
+00020c40: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00020c50: 2020 7749 6e64 6578 203d 2030 0a20 2020    wIndex = 0.   
+00020c60: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+00020c70: 662e 7374 6174 652e 616e 616c 6f67 5f6f  f.state.analog_o
+00020c80: 7574 5f65 6e61 626c 6520 3d20 4661 6c73  ut_enable = Fals
+00020c90: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+00020ca0: 2020 7365 6c66 2e73 7461 7465 2e61 6e61    self.state.ana
+00020cb0: 6c6f 675f 6f75 745f 6d6f 6465 203d 2030  log_out_mode = 0
+00020cc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00020cd0: 2073 656c 662e 7374 6174 652e 616e 616c   self.state.anal
+00020ce0: 6f67 5f6f 7574 5f76 616c 7565 203d 2030  og_out_value = 0
+00020cf0: 0a0a 2020 2020 2020 2020 6578 6365 7074  ..        except
+00020d00: 3a0a 2020 2020 2020 2020 2020 2020 6c6f  :.            lo
+00020d10: 672e 6572 726f 7228 2273 6574 5f61 6e61  g.error("set_ana
+00020d20: 6c6f 675f 6f75 7470 7574 5f6d 6f64 6520  log_output_mode 
+00020d30: 7461 6b65 7320 7475 706c 6520 6f66 2028  takes tuple of (
+00020d40: 626f 6f6c 2c20 696e 7429 2c20 6469 7361  bool, int), disa
+00020d50: 626c 696e 6722 290a 2020 2020 2020 2020  bling").        
+00020d60: 2020 2020 7749 6e64 6578 203d 2030 0a0a      wIndex = 0..
+00020d70: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00020d80: 656c 662e 5f73 656e 645f 636f 6465 2862  elf._send_code(b
+00020d90: 5265 7175 6573 7420 203d 2030 7866 662c  Request  = 0xff,
+00020da0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00020db0: 2020 2020 2020 2020 2020 2020 2020 2077                 w
+00020dc0: 5661 6c75 6520 2020 203d 2030 7831 312c  Value    = 0x11,
+00020dd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00020de0: 2020 2020 2020 2020 2020 2020 2020 2077                 w
+00020df0: 496e 6465 7820 2020 203d 2077 496e 6465  Index    = wInde
+00020e00: 782c 0a20 2020 2020 2020 2020 2020 2020  x,.             
+00020e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020e20: 206c 6162 656c 2020 2020 203d 2022 5345   label     = "SE
+00020e30: 545f 414e 414c 4f47 5f4f 5554 5f4d 4f44  T_ANALOG_OUT_MOD
+00020e40: 4522 290a 0a20 2020 2064 6566 2073 6574  E")..    def set
+00020e50: 5f61 6e61 6c6f 675f 6f75 7470 7574 5f76  _analog_output_v
+00020e60: 616c 7565 2873 656c 662c 2076 616c 7565  alue(self, value
+00020e70: 3a20 696e 7429 3a0a 2020 2020 2020 2020  : int):.        
+00020e80: 6966 206e 6f74 2073 656c 662e 7365 7474  if not self.sett
+00020e90: 696e 6773 2e69 735f 6765 6e32 2829 3a0a  ings.is_gen2():.
 00020ea0: 2020 2020 2020 2020 2020 2020 6c6f 672e              log.
-00020eb0: 6572 726f 7228 2266 6169 6c65 6420 746f  error("failed to
-00020ec0: 2065 6e71 7565 7565 2053 7461 7475 734d   enqueue StatusM
-00020ed0: 6573 7361 6765 2028 2573 2c20 2573 2922  essage (%s, %s)"
-00020ee0: 2c20 7365 7474 696e 672c 2076 616c 7565  , setting, value
-00020ef0: 2c20 6578 635f 696e 666f 3d31 290d 0a20  , exc_info=1).. 
-00020f00: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00020f10: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
-00020f20: 7370 6f6e 7365 2864 6174 613d 4661 6c73  sponse(data=Fals
-00020f30: 652c 6572 726f 725f 6d73 673d 2266 6169  e,error_msg="fai
-00020f40: 6c65 6420 746f 2065 6e71 7565 7565 206d  led to enqueue m
-00020f50: 6573 7373 6167 6522 290d 0a20 2020 2020  esssage")..     
-00020f60: 2020 2072 6574 7572 6e20 5370 6563 7472     return Spectr
-00020f70: 6f6d 6574 6572 5265 7370 6f6e 7365 2864  ometerResponse(d
-00020f80: 6174 613d 5472 7565 290d 0a0d 0a20 2020  ata=True)....   
-00020f90: 2064 6566 205f 696e 6974 5f70 726f 6365   def _init_proce
-00020fa0: 7373 5f66 756e 6373 2873 656c 6629 3a20  ss_funcs(self): 
-00020fb0: 2320 2d3e 2064 6963 745b 7374 722c 2043  # -> dict[str, C
-00020fc0: 616c 6c61 626c 655b 2e2e 2e2c 2041 6e79  allable[..., Any
-00020fd0: 5d5d 200d 0a20 2020 2020 2020 2022 2222  ]] ..        """
-00020fe0: 0d0a 2020 2020 2020 2020 4973 2069 7420  ..        Is it 
-00020ff0: 7468 6520 6578 7065 6374 6174 696f 6e20  the expectation 
-00021000: 7468 6174 2061 6c6c 206f 6620 7468 6573  that all of thes
-00021010: 6520 6675 6e63 7469 6f6e 7320 7769 6c6c  e functions will
-00021020: 2072 6574 7572 6e20 0d0a 2020 2020 2020   return ..      
-00021030: 2020 5370 6563 7472 6f6d 6574 6572 5265    SpectrometerRe
-00021040: 7370 6f6e 7365 3f20 4966 2073 6f2c 2074  sponse? If so, t
-00021050: 6861 7420 7368 6f75 6c64 2062 6520 6d61  hat should be ma
-00021060: 6465 2065 7870 6c69 6369 742e 0d0a 2020  de explicit...  
-00021070: 2020 2020 2020 2222 220d 0a20 2020 2020        """..     
-00021080: 2020 2070 726f 6365 7373 5f66 203d 207b     process_f = {
-00021090: 7d0d 0a0d 0a20 2020 2020 2020 2066 6f72  }....        for
-000210a0: 2066 6e5f 6e61 6d65 2069 6e20 5b20 2263   fn_name in [ "c
-000210b0: 6f6e 6e65 6374 222c 0d0a 2020 2020 2020  onnect",..      
-000210c0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-000210d0: 6469 7363 6f6e 6e65 6374 222c 0d0a 2020  disconnect",..  
-000210e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000210f0: 2020 2022 6765 745f 6261 7474 6572 795f     "get_battery_
-00021100: 7265 6769 7374 6572 222c 0d0a 2020 2020  register",..    
-00021110: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021120: 2022 6765 745f 6261 7474 6572 795f 7374   "get_battery_st
-00021130: 6174 655f 7261 7722 2c0d 0a20 2020 2020  ate_raw",..     
-00021140: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021150: 2267 6574 5f62 6174 7465 7279 5f70 6572  "get_battery_per
-00021160: 6365 6e74 6167 6522 2c0d 0a20 2020 2020  centage",..     
-00021170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021180: 2267 6574 5f62 6174 7465 7279 5f63 6861  "get_battery_cha
-00021190: 7267 696e 6722 2c0d 0a20 2020 2020 2020  rging",..       
-000211a0: 2020 2020 2020 2020 2020 2020 2020 2267                "g
-000211b0: 6574 5f69 6e74 6567 7261 7469 6f6e 5f74  et_integration_t
-000211c0: 696d 655f 6d73 222c 0d0a 2020 2020 2020  ime_ms",..      
-000211d0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-000211e0: 7365 745f 6466 755f 656e 6162 6c65 222c  set_dfu_enable",
-000211f0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00021200: 2020 2020 2020 2022 7365 745f 6465 7465         "set_dete
-00021210: 6374 6f72 5f6f 6666 7365 7422 2c0d 0a20  ctor_offset",.. 
-00021220: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021230: 2020 2020 2273 6574 5f64 6574 6563 746f      "set_detecto
-00021240: 725f 6f66 6673 6574 5f6f 6464 222c 0d0a  r_offset_odd",..
-00021250: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021260: 2020 2020 2022 6765 745f 6465 7465 6374       "get_detect
-00021270: 6f72 5f67 6169 6e22 2c0d 0a20 2020 2020  or_gain",..     
-00021280: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021290: 2267 6574 5f64 6574 6563 746f 725f 6761  "get_detector_ga
-000212a0: 696e 5f6f 6464 222c 0d0a 2020 2020 2020  in_odd",..      
-000212b0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-000212c0: 7365 745f 6465 7465 6374 6f72 5f67 6169  set_detector_gai
-000212d0: 6e22 2c0d 0a20 2020 2020 2020 2020 2020  n",..           
-000212e0: 2020 2020 2020 2020 2020 2273 6574 5f64            "set_d
-000212f0: 6574 6563 746f 725f 6761 696e 5f6f 6464  etector_gain_odd
-00021300: 222c 0d0a 2020 2020 2020 2020 2020 2020  ",..            
-00021310: 2020 2020 2020 2020 2022 7365 745f 6172           "set_ar
-00021320: 6561 5f73 6361 6e5f 656e 6162 6c65 222c  ea_scan_enable",
-00021330: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00021340: 2020 2020 2020 2022 6765 745f 7365 6e73         "get_sens
-00021350: 6f72 5f6c 696e 655f 6c65 6e67 7468 222c  or_line_length",
-00021360: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00021370: 2020 2020 2020 2022 6765 745f 6d69 6372         "get_micr
-00021380: 6f63 6f6e 7472 6f6c 6c65 725f 6669 726d  ocontroller_firm
-00021390: 7761 7265 5f76 6572 7369 6f6e 222c 0d0a  ware_version",..
-000213a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000213b0: 2020 2020 2022 6765 745f 6670 6761 5f66       "get_fpga_f
-000213c0: 6972 6d77 6172 655f 7665 7273 696f 6e22  irmware_version"
-000213d0: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-000213e0: 2020 2020 2020 2020 2267 6574 5f6c 696e          "get_lin
-000213f0: 6522 2c0d 0a20 2020 2020 2020 2020 2020  e",..           
-00021400: 2020 2020 2020 2020 2020 2273 6574 5f69            "set_i
-00021410: 6e74 6567 7261 7469 6f6e 5f74 696d 655f  ntegration_time_
-00021420: 6d73 222c 0d0a 2020 2020 2020 2020 2020  ms",..          
-00021430: 2020 2020 2020 2020 2020 2022 7365 6c65             "sele
-00021440: 6374 5f61 6463 222c 0d0a 2020 2020 2020  ct_adc",..      
-00021450: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-00021460: 6765 745f 7365 636f 6e64 6172 795f 6164  get_secondary_ad
-00021470: 635f 6361 6c69 6272 6174 6564 222c 0d0a  c_calibrated",..
-00021480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021490: 2020 2020 2022 6765 745f 7365 636f 6e64       "get_second
-000214a0: 6172 795f 6164 635f 7261 7722 2c0d 0a20  ary_adc_raw",.. 
-000214b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000214c0: 2020 2020 2267 6574 5f6c 6173 6572 5f74      "get_laser_t
-000214d0: 656d 7065 7261 7475 7265 5f72 6177 222c  emperature_raw",
-000214e0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000214f0: 2020 2020 2020 2022 6765 745f 6c61 7365         "get_lase
-00021500: 725f 7465 6d70 6572 6174 7572 655f 6465  r_temperature_de
-00021510: 6743 222c 0d0a 2020 2020 2020 2020 2020  gC",..          
-00021520: 2020 2020 2020 2020 2020 2022 6765 745f             "get_
-00021530: 6465 7465 6374 6f72 5f74 656d 7065 7261  detector_tempera
-00021540: 7475 7265 5f72 6177 222c 0d0a 2020 2020  ture_raw",..    
-00021550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021560: 2022 6765 745f 6465 7465 6374 6f72 5f74   "get_detector_t
-00021570: 656d 7065 7261 7475 7265 5f64 6567 4322  emperature_degC"
-00021580: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-00021590: 2020 2020 2020 2020 2267 6574 5f64 6574          "get_det
-000215a0: 6563 746f 725f 7465 635f 7365 7470 6f69  ector_tec_setpoi
-000215b0: 6e74 5f64 6567 4322 2c0d 0a20 2020 2020  nt_degC",..     
-000215c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000215d0: 2267 6574 5f64 6163 222c 0d0a 2020 2020  "get_dac",..    
-000215e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000215f0: 2022 7365 745f 7465 635f 656e 6162 6c65   "set_tec_enable
-00021600: 222c 0d0a 2020 2020 2020 2020 2020 2020  ",..            
-00021610: 2020 2020 2020 2020 2022 7365 745f 7472           "set_tr
-00021620: 6967 6765 725f 736f 7572 6365 222c 0d0a  igger_source",..
-00021630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021640: 2020 2020 2022 7365 745f 6869 6768 5f67       "set_high_g
-00021650: 6169 6e5f 6d6f 6465 5f65 6e61 626c 6522  ain_mode_enable"
-00021660: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-00021670: 2020 2020 2020 2020 2267 6574 5f68 6967          "get_hig
-00021680: 685f 6761 696e 5f6d 6f64 655f 656e 6162  h_gain_mode_enab
-00021690: 6c65 6422 2c0d 0a20 2020 2020 2020 2020  led",..         
-000216a0: 2020 2020 2020 2020 2020 2020 2267 6574              "get
-000216b0: 5f6f 7074 5f6c 6173 6572 5f63 6f6e 7472  _opt_laser_contr
-000216c0: 6f6c 222c 0d0a 2020 2020 2020 2020 2020  ol",..          
-000216d0: 2020 2020 2020 2020 2020 2022 6765 745f             "get_
-000216e0: 6f70 745f 6861 735f 6c61 7365 7222 2c0d  opt_has_laser",.
-000216f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00021700: 2020 2020 2020 2273 6574 5f64 6574 6563        "set_detec
-00021710: 746f 725f 7465 635f 7365 7470 6f69 6e74  tor_tec_setpoint
-00021720: 5f64 6567 4322 2c0d 0a20 2020 2020 2020  _degC",..       
-00021730: 2020 2020 2020 2020 2020 2020 2020 2267                "g
-00021740: 6574 5f64 6574 6563 746f 725f 7465 635f  et_detector_tec_
-00021750: 7365 7470 6f69 6e74 5f72 6177 222c 0d0a  setpoint_raw",..
-00021760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021770: 2020 2020 2022 7365 745f 7365 6c65 6374       "set_select
-00021780: 6564 5f6c 6173 6572 222c 0d0a 2020 2020  ed_laser",..    
-00021790: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000217a0: 2022 6765 745f 7365 6c65 6374 6564 5f6c   "get_selected_l
-000217b0: 6173 6572 222c 0d0a 2020 2020 2020 2020  aser",..        
-000217c0: 2020 2020 2020 2020 2020 2020 2022 6765               "ge
-000217d0: 745f 6c61 7365 725f 656e 6162 6c65 6422  t_laser_enabled"
-000217e0: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-000217f0: 2020 2020 2020 2020 2273 6574 5f6c 6173          "set_las
-00021800: 6572 5f65 6e61 626c 6522 2c0d 0a20 2020  er_enable",..   
-00021810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021820: 2020 2273 6574 5f6c 6173 6572 5f70 6f77    "set_laser_pow
-00021830: 6572 5f72 616d 7069 6e67 5f65 6e61 626c  er_ramping_enabl
-00021840: 6522 2c0d 0a20 2020 2020 2020 2020 2020  e",..           
-00021850: 2020 2020 2020 2020 2020 2267 6574 5f6c            "get_l
-00021860: 6173 6572 5f70 6f77 6572 5f72 616d 7069  aser_power_rampi
-00021870: 6e67 5f65 6e61 626c 6564 222c 0d0a 2020  ng_enabled",..  
-00021880: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021890: 2020 2022 7365 745f 6c61 7365 725f 706f     "set_laser_po
-000218a0: 7765 725f 6d57 222c 0d0a 2020 2020 2020  wer_mW",..      
-000218b0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-000218c0: 7365 745f 6c61 7365 725f 706f 7765 725f  set_laser_power_
-000218d0: 6869 6768 5f72 6573 6f6c 7574 696f 6e22  high_resolution"
-000218e0: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-000218f0: 2020 2020 2020 2020 2273 6574 5f6c 6173          "set_las
-00021900: 6572 5f70 6f77 6572 5f72 6571 7569 7265  er_power_require
-00021910: 5f6d 6f64 756c 6174 696f 6e22 2c0d 0a20  _modulation",.. 
-00021920: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021930: 2020 2020 2273 6574 5f6c 6173 6572 5f70      "set_laser_p
-00021940: 6f77 6572 5f70 6572 6322 2c0d 0a20 2020  ower_perc",..   
-00021950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021960: 2020 2273 6574 5f6c 6173 6572 5f70 6f77    "set_laser_pow
-00021970: 6572 5f70 6572 635f 696d 6d65 6469 6174  er_perc_immediat
-00021980: 6522 2c0d 0a20 2020 2020 2020 2020 2020  e",..           
-00021990: 2020 2020 2020 2020 2020 2267 6574 5f6c            "get_l
-000219a0: 6173 6572 5f74 656d 7065 7261 7475 7265  aser_temperature
-000219b0: 5f73 6574 706f 696e 745f 7261 7722 2c0d  _setpoint_raw",.
-000219c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000219d0: 2020 2020 2020 2273 6574 5f6c 6173 6572        "set_laser
-000219e0: 5f74 656d 7065 7261 7475 7265 5f73 6574  _temperature_set
-000219f0: 706f 696e 745f 7261 7722 2c0d 0a20 2020  point_raw",..   
-00021a00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021a10: 2020 2275 7064 6174 655f 6c61 7365 725f    "update_laser_
-00021a20: 7761 7463 6864 6f67 222c 0d0a 2020 2020  watchdog",..    
-00021a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021a40: 2022 6765 745f 6c61 7365 725f 696e 7465   "get_laser_inte
-00021a50: 726c 6f63 6b22 2c0d 0a20 2020 2020 2020  rlock",..       
-00021a60: 2020 2020 2020 2020 2020 2020 2020 2263                "c
-00021a70: 616e 5f6c 6173 6572 5f66 6972 6522 2c0d  an_laser_fire",.
-00021a80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00021a90: 2020 2020 2020 2272 6573 6574 5f66 7067        "reset_fpg
-00021aa0: 6122 2c0d 0a20 2020 2020 2020 2020 2020  a",..           
-00021ab0: 2020 2020 2020 2020 2020 2267 6574 5f74            "get_t
-00021ac0: 7269 6767 6572 5f73 6f75 7263 6522 2c0d  rigger_source",.
-00021ad0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00021ae0: 2020 2020 2020 2267 6574 5f72 616d 616e        "get_raman
-00021af0: 5f64 656c 6179 5f6d 7322 2c0d 0a20 2020  _delay_ms",..   
-00021b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021b10: 2020 2273 6574 5f72 616d 616e 5f64 656c    "set_raman_del
-00021b20: 6179 5f6d 7322 2c0d 0a20 2020 2020 2020  ay_ms",..       
-00021b30: 2020 2020 2020 2020 2020 2020 2020 2267                "g
-00021b40: 6574 5f6c 6173 6572 5f77 6174 6368 646f  et_laser_watchdo
-00021b50: 675f 7365 6322 2c0d 0a20 2020 2020 2020  g_sec",..       
-00021b60: 2020 2020 2020 2020 2020 2020 2020 2273                "s
-00021b70: 6574 5f6c 6173 6572 5f77 6174 6368 646f  et_laser_watchdo
-00021b80: 675f 7365 6322 2c0d 0a20 2020 2020 2020  g_sec",..       
-00021b90: 2020 2020 2020 2020 2020 2020 2020 2273                "s
-00021ba0: 6574 5f76 6572 7469 6361 6c5f 6269 6e6e  et_vertical_binn
-00021bb0: 696e 6722 2c0d 0a20 2020 2020 2020 2020  ing",..         
-00021bc0: 2020 2020 2020 2020 2020 2020 2273 6574              "set
-00021bd0: 5f70 6978 656c 5f6d 6f64 6522 2c0d 0a20  _pixel_mode",.. 
-00021be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021bf0: 2020 2020 2263 6c65 6172 5f72 6567 696f      "clear_regio
-00021c00: 6e73 222c 0d0a 2020 2020 2020 2020 2020  ns",..          
-00021c10: 2020 2020 2020 2020 2020 2022 7365 745f             "set_
-00021c20: 7369 6e67 6c65 5f72 6567 696f 6e22 2c0d  single_region",.
-00021c30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00021c40: 2020 2020 2020 2273 6574 5f64 6574 6563        "set_detec
-00021c50: 746f 725f 726f 6922 2c0d 0a20 2020 2020  tor_roi",..     
-00021c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021c70: 2267 6574 5f66 7067 615f 636f 6e66 6967  "get_fpga_config
-00021c80: 7572 6174 696f 6e5f 7265 6769 7374 6572  uration_register
-00021c90: 222c 0d0a 2020 2020 2020 2020 2020 2020  ",..            
-00021ca0: 2020 2020 2020 2020 2022 7365 745f 6163           "set_ac
-00021cb0: 6365 7373 6f72 795f 656e 6162 6c65 222c  cessory_enable",
-00021cc0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00021cd0: 2020 2020 2020 2022 6765 745f 6469 7363         "get_disc
-00021ce0: 7265 7465 735f 656e 6162 6c65 6422 2c0d  retes_enabled",.
-00021cf0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00021d00: 2020 2020 2020 2273 6574 5f66 616e 5f65        "set_fan_e
-00021d10: 6e61 626c 6522 2c0d 0a20 2020 2020 2020  nable",..       
-00021d20: 2020 2020 2020 2020 2020 2020 2020 2267                "g
-00021d30: 6574 5f66 616e 5f65 6e61 626c 6564 222c  et_fan_enabled",
-00021d40: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00021d50: 2020 2020 2020 2022 7365 745f 6c61 6d70         "set_lamp
-00021d60: 5f65 6e61 626c 6522 2c0d 0a20 2020 2020  _enable",..     
-00021d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021d80: 2267 6574 5f6c 616d 705f 656e 6162 6c65  "get_lamp_enable
-00021d90: 6422 2c0d 0a20 2020 2020 2020 2020 2020  d",..           
-00021da0: 2020 2020 2020 2020 2020 2273 6574 5f73            "set_s
-00021db0: 6875 7474 6572 5f65 6e61 626c 6522 2c0d  hutter_enable",.
-00021dc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00021dd0: 2020 2020 2020 2267 6574 5f73 6875 7474        "get_shutt
-00021de0: 6572 5f65 6e61 626c 6564 222c 0d0a 2020  er_enabled",..  
-00021df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021e00: 2020 2022 7365 745f 6d6f 645f 656e 6162     "set_mod_enab
-00021e10: 6c65 222c 0d0a 2020 2020 2020 2020 2020  le",..          
-00021e20: 2020 2020 2020 2020 2020 2022 6765 745f             "get_
-00021e30: 6d6f 645f 656e 6162 6c65 6422 2c0d 0a20  mod_enabled",.. 
-00021e40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021e50: 2020 2020 2273 6574 5f6d 6f64 5f70 6572      "set_mod_per
-00021e60: 696f 645f 7573 222c 0d0a 2020 2020 2020  iod_us",..      
-00021e70: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-00021e80: 6765 745f 6d6f 645f 7065 7269 6f64 5f75  get_mod_period_u
-00021e90: 7322 2c0d 0a20 2020 2020 2020 2020 2020  s",..           
-00021ea0: 2020 2020 2020 2020 2020 2273 6574 5f6d            "set_m
-00021eb0: 6f64 5f77 6964 7468 5f75 7322 2c0d 0a20  od_width_us",.. 
-00021ec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021ed0: 2020 2020 2267 6574 5f6d 6f64 5f77 6964      "get_mod_wid
-00021ee0: 7468 5f75 7322 2c0d 0a20 2020 2020 2020  th_us",..       
-00021ef0: 2020 2020 2020 2020 2020 2020 2020 2273                "s
-00021f00: 6574 5f6d 6f64 5f64 656c 6179 5f75 7322  et_mod_delay_us"
-00021f10: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-00021f20: 2020 2020 2020 2020 2267 6574 5f6d 6f64          "get_mod
-00021f30: 5f64 656c 6179 5f75 7322 2c0d 0a20 2020  _delay_us",..   
-00021f40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021f50: 2020 2267 6574 5f6d 6f64 5f64 7572 6174    "get_mod_durat
-00021f60: 696f 6e5f 7573 222c 0d0a 2020 2020 2020  ion_us",..      
-00021f70: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-00021f80: 7365 745f 7374 726f 6265 5f65 6e61 626c  set_strobe_enabl
-00021f90: 6522 2c0d 0a20 2020 2020 2020 2020 2020  e",..           
-00021fa0: 2020 2020 2020 2020 2020 2267 6574 5f73            "get_s
-00021fb0: 7472 6f62 655f 656e 6162 6c65 6422 2c0d  trobe_enabled",.
-00021fc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00021fd0: 2020 2020 2020 2267 6574 5f61 6d62 6965        "get_ambie
-00021fe0: 6e74 5f74 656d 7065 7261 7475 7265 5f64  nt_temperature_d
-00021ff0: 6567 4322 2c0d 0a20 2020 2020 2020 2020  egC",..         
-00022000: 2020 2020 2020 2020 2020 2020 2267 6574              "get
-00022010: 5f74 6563 5f65 6e61 626c 6564 222c 0d0a  _tec_enabled",..
-00022020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022030: 2020 2020 2022 6765 745f 6163 7475 616c       "get_actual
-00022040: 5f66 7261 6d65 7322 2c0d 0a20 2020 2020  _frames",..     
-00022050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022060: 2267 6574 5f61 6374 7561 6c5f 696e 7465  "get_actual_inte
-00022070: 6772 6174 696f 6e5f 7469 6d65 5f75 7322  gration_time_us"
-00022080: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-00022090: 2020 2020 2020 2020 2267 6574 5f64 6574          "get_det
-000220a0: 6563 746f 725f 6f66 6673 6574 222c 0d0a  ector_offset",..
-000220b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000220c0: 2020 2020 2022 6765 745f 6465 7465 6374       "get_detect
-000220d0: 6f72 5f6f 6666 7365 745f 6f64 6422 2c0d  or_offset_odd",.
-000220e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000220f0: 2020 2020 2020 2267 6574 5f63 6364 5f73        "get_ccd_s
-00022100: 656e 7369 6e67 5f74 6872 6573 686f 6c64  ensing_threshold
-00022110: 222c 0d0a 2020 2020 2020 2020 2020 2020  ",..            
-00022120: 2020 2020 2020 2020 2022 6765 745f 6363           "get_cc
-00022130: 645f 7468 7265 7368 6f6c 645f 7365 6e73  d_threshold_sens
-00022140: 696e 675f 6d6f 6465 222c 0d0a 2020 2020  ing_mode",..    
-00022150: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022160: 2022 6765 745f 6578 7465 726e 616c 5f74   "get_external_t
-00022170: 7269 6767 6572 5f6f 7574 7075 7422 2c0d  rigger_output",.
-00022180: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00022190: 2020 2020 2020 2267 6574 5f6c 6173 6572        "get_laser
-000221a0: 5f69 6e74 6572 6c6f 636b 222c 0d0a 2020  _interlock",..  
-000221b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000221c0: 2020 2022 6361 6e5f 6c61 7365 725f 6669     "can_laser_fi
-000221d0: 7265 222c 0d0a 2020 2020 2020 2020 2020  re",..          
-000221e0: 2020 2020 2020 2020 2020 2022 6973 5f6c             "is_l
-000221f0: 6173 6572 5f66 6972 696e 6722 2c0d 0a20  aser_firing",.. 
-00022200: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022210: 2020 2020 2267 6574 5f6c 6173 6572 5f65      "get_laser_e
-00022220: 6e61 626c 6564 222c 0d0a 2020 2020 2020  nabled",..      
-00022230: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-00022240: 7365 745f 6d6f 645f 6c69 6e6b 6564 5f74  set_mod_linked_t
-00022250: 6f5f 696e 7465 6772 6174 696f 6e22 2c0d  o_integration",.
-00022260: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00022270: 2020 2020 2020 2267 6574 5f73 656c 6563        "get_selec
-00022280: 7465 645f 6164 6322 2c0d 0a20 2020 2020  ted_adc",..     
+00020eb0: 6572 726f 7228 2261 6e61 6c6f 6720 6f75  error("analog ou
+00020ec0: 7470 7574 206f 6e6c 7920 6176 6169 6c61  tput only availa
+00020ed0: 626c 6520 6f6e 2047 656e 3222 290a 2020  ble on Gen2").  
+00020ee0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00020ef0: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
+00020f00: 706f 6e73 6528 6461 7461 3d46 616c 7365  ponse(data=False
+00020f10: 2c65 7272 6f72 5f6d 7367 3d22 616e 616c  ,error_msg="anal
+00020f20: 6f67 206f 7574 7075 7420 756e 7375 7070  og output unsupp
+00020f30: 6f72 7465 6422 290a 0a20 2020 2020 2020  orted")..       
+00020f40: 2023 2073 7065 6374 726f 6d65 7465 7220   # spectrometer 
+00020f50: 7368 6f75 6c64 2072 616e 6765 2d6c 696d  should range-lim
+00020f60: 6974 2c20 6275 7420 6a75 7374 2074 6f20  it, but just to 
+00020f70: 636f 6469 6679 3a0a 2020 2020 2020 2020  codify:.        
+00020f80: 6966 2073 656c 662e 7374 6174 652e 616e  if self.state.an
+00020f90: 616c 6f67 5f6f 7574 5f6d 6f64 6520 3d3d  alog_out_mode ==
+00020fa0: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
+00020fb0: 2320 766f 6c74 6167 6520 2864 6563 6976  # voltage (deciv
+00020fc0: 6f6c 7473 2c20 7261 6e67 6520 302d 3530  olts, range 0-50
+00020fd0: 2028 302d 3556 2929 0a20 2020 2020 2020   (0-5V)).       
+00020fe0: 2020 2020 2069 6620 7661 6c75 6520 3c20       if value < 
+00020ff0: 303a 0a20 2020 2020 2020 2020 2020 2020  0:.             
+00021000: 2020 2076 616c 7565 203d 2030 0a20 2020     value = 0.   
+00021010: 2020 2020 2020 2020 2069 6620 7661 6c75           if valu
+00021020: 6520 3e20 3530 3a0a 2020 2020 2020 2020  e > 50:.        
+00021030: 2020 2020 2020 2020 7661 6c75 6520 3d20          value = 
+00021040: 3530 0a20 2020 2020 2020 2065 6c69 6620  50.        elif 
+00021050: 7365 6c66 2e73 7461 7465 2e61 6e61 6c6f  self.state.analo
+00021060: 675f 6f75 745f 6d6f 6465 203d 3d20 313a  g_out_mode == 1:
+00021070: 0a20 2020 2020 2020 2020 2020 2023 2063  .            # c
+00021080: 7572 7265 6e74 2028 6465 6369 2d6d 412c  urrent (deci-mA,
+00021090: 2072 616e 6765 2034 302d 3230 3020 2834   range 40-200 (4
+000210a0: 2d32 306d 4129 290a 2020 2020 2020 2020  -20mA)).        
+000210b0: 2020 2020 6966 2076 616c 7565 203c 2034      if value < 4
+000210c0: 303a 0a20 2020 2020 2020 2020 2020 2020  0:.             
+000210d0: 2020 2076 616c 7565 203d 2034 300a 2020     value = 40.  
+000210e0: 2020 2020 2020 2020 2020 656c 6966 2076            elif v
+000210f0: 616c 7565 203e 2032 3030 3a0a 2020 2020  alue > 200:.    
+00021100: 2020 2020 2020 2020 2020 2020 7661 6c75              valu
+00021110: 6520 3d20 3230 300a 2020 2020 2020 2020  e = 200.        
+00021120: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00021130: 2020 6c6f 672e 6572 726f 7228 2269 6e76    log.error("inv
+00021140: 616c 6964 2061 6e61 6c6f 6720 6f75 7420  alid analog out 
+00021150: 6d6f 6465 2025 642c 2069 676e 6f72 696e  mode %d, ignorin
+00021160: 6720 7661 6c75 6522 2c20 7365 6c66 2e73  g value", self.s
+00021170: 7461 7465 2e61 6e61 6c6f 675f 6f75 745f  tate.analog_out_
+00021180: 6d6f 6465 290a 2020 2020 2020 2020 2020  mode).          
+00021190: 2020 7265 7475 726e 2053 7065 6374 726f    return Spectro
+000211a0: 6d65 7465 7252 6573 706f 6e73 6528 6461  meterResponse(da
+000211b0: 7461 3d46 616c 7365 2c65 7272 6f72 5f6d  ta=False,error_m
+000211c0: 7367 3d22 696e 7661 6c69 6420 6d6f 6465  sg="invalid mode
+000211d0: 2229 0a0a 2020 2020 2020 2020 7265 7475  ")..        retu
+000211e0: 726e 2073 656c 662e 5f73 656e 645f 636f  rn self._send_co
+000211f0: 6465 2862 5265 7175 6573 7420 203d 2030  de(bRequest  = 0
+00021200: 7866 662c 0a20 2020 2020 2020 2020 2020  xff,.           
+00021210: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021220: 2020 2077 5661 6c75 6520 2020 203d 2030     wValue    = 0
+00021230: 7831 322c 0a20 2020 2020 2020 2020 2020  x12,.           
+00021240: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021250: 2020 2077 496e 6465 7820 2020 203d 2076     wIndex    = v
+00021260: 616c 7565 2c0a 2020 2020 2020 2020 2020  alue,.          
+00021270: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021280: 2020 2020 6c61 6265 6c20 2020 2020 3d20      label     = 
+00021290: 2253 4554 5f41 4e41 4c4f 475f 4f55 545f  "SET_ANALOG_OUT_
+000212a0: 5641 4c55 4522 290a 0a20 2020 2064 6566  VALUE")..    def
+000212b0: 2067 6574 5f61 6e61 6c6f 675f 6f75 7470   get_analog_outp
+000212c0: 7574 5f73 7461 7465 2873 656c 6629 3a0a  ut_state(self):.
+000212d0: 2020 2020 2020 2020 6966 206e 6f74 2073          if not s
+000212e0: 656c 662e 7365 7474 696e 6773 2e69 735f  elf.settings.is_
+000212f0: 6765 6e32 2829 3a0a 2020 2020 2020 2020  gen2():.        
+00021300: 2020 2020 6c6f 672e 6572 726f 7228 2261      log.error("a
+00021310: 6e61 6c6f 6720 6f75 7470 7574 206f 6e6c  nalog output onl
+00021320: 7920 6176 6169 6c61 626c 6520 6f6e 2047  y available on G
+00021330: 656e 3222 290a 2020 2020 2020 2020 2020  en2").          
+00021340: 2020 7265 7475 726e 2053 7065 6374 726f    return Spectro
+00021350: 6d65 7465 7252 6573 706f 6e73 6528 6461  meterResponse(da
+00021360: 7461 3d46 616c 7365 2c65 7272 6f72 5f6d  ta=False,error_m
+00021370: 7367 3d22 616e 616c 6f67 206f 7574 7075  sg="analog outpu
+00021380: 7420 756e 7375 7070 6f72 7465 6422 290a  t unsupported").
+00021390: 0a20 2020 2020 2020 2072 6573 203d 2073  .        res = s
+000213a0: 656c 662e 6765 745f 7570 7065 725f 636f  elf.get_upper_co
+000213b0: 6465 2830 7831 612c 2077 4c65 6e67 7468  de(0x1a, wLength
+000213c0: 3d33 2c20 6c61 6265 6c3d 2247 4554 5f41  =3, label="GET_A
+000213d0: 4e41 4c4f 475f 4f55 545f 5354 4154 4522  NALOG_OUT_STATE"
+000213e0: 290a 2020 2020 2020 2020 6966 2072 6573  ).        if res
+000213f0: 2e65 7272 6f72 5f6d 7367 2021 3d20 2727  .error_msg != ''
+00021400: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00021410: 7475 726e 2072 6573 0a20 2020 2020 2020  turn res.       
+00021420: 2064 6174 6120 3d20 7265 732e 6461 7461   data = res.data
+00021430: 0a20 2020 2020 2020 2069 6620 2864 6174  .        if (dat
+00021440: 6120 6973 204e 6f6e 6520 6f72 206c 656e  a is None or len
+00021450: 2864 6174 6129 2021 3d20 3329 3a0a 2020  (data) != 3):.  
+00021460: 2020 2020 2020 2020 2020 6c6f 672e 6572            log.er
+00021470: 726f 7228 2269 6e76 616c 6964 2061 6e61  ror("invalid ana
+00021480: 6c6f 6720 6f75 7420 7374 6174 6520 7265  log out state re
+00021490: 6164 3a20 2573 222c 2064 6174 6129 0a20  ad: %s", data). 
+000214a0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+000214b0: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
+000214c0: 7370 6f6e 7365 2864 6174 613d 4661 6c73  sponse(data=Fals
+000214d0: 652c 6572 726f 725f 6d73 673d 2269 6e76  e,error_msg="inv
+000214e0: 616c 6964 2061 6e61 6c6f 6720 6f75 7420  alid analog out 
+000214f0: 7374 6174 6520 7265 6164 2229 0a0a 2020  state read")..  
+00021500: 2020 2020 2020 6966 2064 6174 615b 305d        if data[0]
+00021510: 2021 3d20 3020 616e 6420 6461 7461 5b30   != 0 and data[0
+00021520: 5d20 213d 2031 3a0a 2020 2020 2020 2020  ] != 1:.        
+00021530: 2020 2020 6c6f 672e 6572 726f 7228 2272      log.error("r
+00021540: 6563 6569 7665 6420 696e 7661 6c69 6420  eceived invalid 
+00021550: 616e 616c 6f67 206f 7574 2065 6e61 626c  analog out enabl
+00021560: 653a 2025 6422 2c20 6461 7461 5b30 5d29  e: %d", data[0])
+00021570: 0a20 2020 2020 2020 2069 6620 6461 7461  .        if data
+00021580: 5b31 5d20 213d 2030 2061 6e64 2064 6174  [1] != 0 and dat
+00021590: 615b 315d 2021 3d20 313a 0a20 2020 2020  a[1] != 1:.     
+000215a0: 2020 2020 2020 206c 6f67 2e65 7272 6f72         log.error
+000215b0: 2822 7265 6365 6976 6564 2069 6e76 616c  ("received inval
+000215c0: 6964 2061 6e61 6c6f 6720 6f75 7420 6d6f  id analog out mo
+000215d0: 6465 3a20 2564 222c 2064 6174 615b 315d  de: %d", data[1]
+000215e0: 290a 0a20 2020 2020 2020 2073 656c 662e  )..        self.
+000215f0: 7374 6174 652e 616e 616c 6f67 5f6f 7574  state.analog_out
+00021600: 5f65 6e61 626c 6520 3d20 6461 7461 5b30  _enable = data[0
+00021610: 5d20 213d 2030 0a20 2020 2020 2020 2073  ] != 0.        s
+00021620: 656c 662e 7374 6174 652e 616e 616c 6f67  elf.state.analog
+00021630: 5f6f 7574 5f6d 6f64 6520 3d20 6461 7461  _out_mode = data
+00021640: 5b31 5d0a 2020 2020 2020 2020 7365 6c66  [1].        self
+00021650: 2e73 7461 7465 2e61 6e61 6c6f 675f 6f75  .state.analog_ou
+00021660: 745f 7661 6c75 6520 3d20 6461 7461 5b32  t_value = data[2
+00021670: 5d20 2320 6e6f 2072 616e 6765 2d63 6865  ] # no range-che
+00021680: 636b 696e 6720 6170 706c 6965 640a 2020  cking applied.  
+00021690: 2020 2020 2020 6461 7461 203d 2028 7365        data = (se
+000216a0: 6c66 2e73 7461 7465 2e61 6e61 6c6f 675f  lf.state.analog_
+000216b0: 6f75 745f 656e 6162 6c65 2c0a 2020 2020  out_enable,.    
+000216c0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+000216d0: 2e73 7461 7465 2e61 6e61 6c6f 675f 6f75  .state.analog_ou
+000216e0: 745f 6d6f 6465 2c0a 2020 2020 2020 2020  t_mode,.        
+000216f0: 2020 2020 2020 2020 7365 6c66 2e73 7461          self.sta
+00021700: 7465 2e61 6e61 6c6f 675f 6f75 745f 7661  te.analog_out_va
+00021710: 6c75 6529 0a20 2020 2020 2020 2072 6574  lue).        ret
+00021720: 7572 6e20 5370 6563 7472 6f6d 6574 6572  urn Spectrometer
+00021730: 5265 7370 6f6e 7365 2864 6174 613d 6461  Response(data=da
+00021740: 7461 290a 0a20 2020 2023 2040 7265 7475  ta)..    # @retu
+00021750: 726e 7320 6465 6369 766f 6c74 730a 2020  rns decivolts.  
+00021760: 2020 6465 6620 6765 745f 616e 616c 6f67    def get_analog
+00021770: 5f69 6e70 7574 5f76 616c 7565 2873 656c  _input_value(sel
+00021780: 6629 3a0a 2020 2020 2020 2020 6966 206e  f):.        if n
+00021790: 6f74 2073 656c 662e 7365 7474 696e 6773  ot self.settings
+000217a0: 2e69 735f 6765 6e32 2829 3a0a 2020 2020  .is_gen2():.    
+000217b0: 2020 2020 2020 2020 6c6f 672e 6572 726f          log.erro
+000217c0: 7228 2261 6e61 6c6f 6720 696e 7075 7420  r("analog input 
+000217d0: 6f6e 6c79 2061 7661 696c 6162 6c65 206f  only available o
+000217e0: 6e20 4765 6e32 2229 0a20 2020 2020 2020  n Gen2").       
+000217f0: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
+00021800: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
+00021810: 2864 6174 613d 4661 6c73 652c 6572 726f  (data=False,erro
+00021820: 725f 6d73 673d 2261 6e61 6c6f 6720 696e  r_msg="analog in
+00021830: 7075 7420 756e 7375 7070 6f72 7465 6422  put unsupported"
+00021840: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+00021850: 2073 656c 662e 6765 745f 7570 7065 725f   self.get_upper_
+00021860: 636f 6465 2830 7831 622c 206c 7362 5f6c  code(0x1b, lsb_l
+00021870: 656e 3d31 2c20 6c61 6265 6c3d 2247 4554  en=1, label="GET
+00021880: 5f41 4e41 4c4f 475f 494e 5f56 414c 5545  _ANALOG_IN_VALUE
+00021890: 2229 0a0a 2020 2020 2320 2323 2323 2323  ")..    # ######
+000218a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000218b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000218c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000218d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000218e0: 2323 2323 0a20 2020 2023 2045 4550 524f  ####.    # EEPRO
+000218f0: 4d20 4372 7566 740a 2020 2020 2320 2323  M Cruft.    # ##
+00021900: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00021910: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00021920: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00021930: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00021940: 2323 2323 2323 2323 0a0a 2020 2020 6465  ########..    de
+00021950: 6620 7570 6461 7465 5f73 6573 7369 6f6e  f update_session
+00021960: 5f65 6570 726f 6d28 7365 6c66 2c20 7061  _eeprom(self, pa
+00021970: 6972 3a20 7475 706c 655b 7374 722c 2045  ir: tuple[str, E
+00021980: 4550 524f 4d5d 293a 0a20 2020 2020 2020  EPROM]):.       
+00021990: 2022 2222 0a20 2020 2020 2020 2047 6976   """.        Giv
+000219a0: 656e 2061 2028 7365 7269 616c 5f6e 756d  en a (serial_num
+000219b0: 6265 722c 2045 4550 524f 4d29 2070 6169  ber, EEPROM) pai
+000219c0: 722c 2075 7064 6174 6520 7468 6973 2070  r, update this p
+000219d0: 726f 6365 7373 2773 2022 7365 7373 696f  rocess's "sessio
+000219e0: 6e22 0a20 2020 2020 2020 2045 4550 524f  n".        EEPRO
+000219f0: 4d20 7769 7468 206a 7573 7420 7468 6520  M with just the 
+00021a00: 4544 4954 4142 4c45 2066 6965 6c64 7320  EDITABLE fields 
+00021a10: 6f66 2074 6865 2070 6173 7365 6420 4545  of the passed EE
+00021a20: 5052 4f4d 2e0a 2020 2020 2020 2020 2222  PROM..        ""
+00021a30: 220a 2020 2020 2020 2020 6c6f 672e 6465  ".        log.de
+00021a40: 6275 6728 2266 6964 2e75 7064 6174 655f  bug("fid.update_
+00021a50: 7365 7373 696f 6e5f 6565 7072 6f6d 3a20  session_eeprom: 
+00021a60: 2573 2075 7064 6174 696e 6720 4545 5052  %s updating EEPR
+00021a70: 4f4d 2069 6e73 7461 6e63 6522 2c20 7365  OM instance", se
+00021a80: 6c66 2e73 6574 7469 6e67 732e 6565 7072  lf.settings.eepr
+00021a90: 6f6d 2e73 6572 6961 6c5f 6e75 6d62 6572  om.serial_number
+00021aa0: 290a 0a20 2020 2020 2020 2069 6620 6e6f  )..        if no
+00021ab0: 7420 7365 6c66 2e65 6570 726f 6d5f 6261  t self.eeprom_ba
+00021ac0: 636b 7570 3a0a 2020 2020 2020 2020 2020  ckup:.          
+00021ad0: 2020 7365 6c66 2e65 6570 726f 6d5f 6261    self.eeprom_ba
+00021ae0: 636b 7570 203d 2063 6f70 792e 6465 6570  ckup = copy.deep
+00021af0: 636f 7079 2873 656c 662e 7365 7474 696e  copy(self.settin
+00021b00: 6773 2e65 6570 726f 6d29 0a0a 2020 2020  gs.eeprom)..    
+00021b10: 2020 2020 7365 6c66 2e73 6574 7469 6e67      self.setting
+00021b20: 732e 6565 7072 6f6d 2e75 7064 6174 655f  s.eeprom.update_
+00021b30: 6564 6974 6162 6c65 2870 6169 725b 315d  editable(pair[1]
+00021b40: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+00021b50: 2053 7065 6374 726f 6d65 7465 7252 6573   SpectrometerRes
+00021b60: 706f 6e73 6528 6461 7461 3d54 7275 6529  ponse(data=True)
+00021b70: 0a0a 2020 2020 6465 6620 7265 706c 6163  ..    def replac
+00021b80: 655f 7365 7373 696f 6e5f 6565 7072 6f6d  e_session_eeprom
+00021b90: 2873 656c 662c 2070 6169 723a 2074 7570  (self, pair: tup
+00021ba0: 6c65 5b73 7472 2c20 4545 5052 4f4d 5d29  le[str, EEPROM])
+00021bb0: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
+00021bc0: 2020 2020 2020 4769 7665 6e20 6120 2873        Given a (s
+00021bd0: 6572 6961 6c5f 6e75 6d62 6572 2c20 4545  erial_number, EE
+00021be0: 5052 4f4d 2920 7061 6972 2c20 7265 706c  PROM) pair, repl
+00021bf0: 6163 6520 7468 6973 2070 726f 6365 7373  ace this process
+00021c00: 2773 2022 7365 7373 696f 6e22 0a20 2020  's "session".   
+00021c10: 2020 2020 2045 4550 524f 4d20 7769 7468       EEPROM with
+00021c20: 2074 6865 2070 6173 7365 6420 4545 5052   the passed EEPR
+00021c30: 4f4d 2e0a 2020 2020 2020 2020 2222 220a  OM..        """.
+00021c40: 2020 2020 2020 2020 6c6f 672e 6465 6275          log.debu
+00021c50: 6728 2266 6964 2e72 6570 6c61 6365 5f73  g("fid.replace_s
+00021c60: 6573 7369 6f6e 5f65 6570 726f 6d3a 2025  ession_eeprom: %
+00021c70: 7320 7265 706c 6163 696e 6720 4545 5052  s replacing EEPR
+00021c80: 4f4d 2069 6e73 7461 6e63 6522 2c20 7365  OM instance", se
+00021c90: 6c66 2e73 6574 7469 6e67 732e 6565 7072  lf.settings.eepr
+00021ca0: 6f6d 2e73 6572 6961 6c5f 6e75 6d62 6572  om.serial_number
+00021cb0: 290a 0a20 2020 2020 2020 2069 6620 6e6f  )..        if no
+00021cc0: 7420 7365 6c66 2e65 6570 726f 6d5f 6261  t self.eeprom_ba
+00021cd0: 636b 7570 3a0a 2020 2020 2020 2020 2020  ckup:.          
+00021ce0: 2020 7365 6c66 2e65 6570 726f 6d5f 6261    self.eeprom_ba
+00021cf0: 636b 7570 203d 2063 6f70 792e 6465 6570  ckup = copy.deep
+00021d00: 636f 7079 2873 656c 662e 7365 7474 696e  copy(self.settin
+00021d10: 6773 2e65 6570 726f 6d29 0a0a 2020 2020  gs.eeprom)..    
+00021d20: 2020 2020 7365 6c66 2e73 6574 7469 6e67      self.setting
+00021d30: 732e 6565 7072 6f6d 203d 2070 6169 725b  s.eeprom = pair[
+00021d40: 315d 0a20 2020 2020 2020 2073 656c 662e  1].        self.
+00021d50: 7365 7474 696e 6773 2e65 6570 726f 6d2e  settings.eeprom.
+00021d60: 6475 6d70 2829 0a20 2020 2020 2020 2072  dump().        r
+00021d70: 6574 7572 6e20 5370 6563 7472 6f6d 6574  eturn Spectromet
+00021d80: 6572 5265 7370 6f6e 7365 2829 0a0a 2020  erResponse()..  
+00021d90: 2020 2323 2041 6374 7561 6c6c 7920 7374    ## Actually st
+00021da0: 6f72 6520 7468 6520 6375 7272 656e 7420  ore the current 
+00021db0: 7365 7373 696f 6e20 4545 5052 4f4d 2066  session EEPROM f
+00021dc0: 6965 6c64 7320 746f 2074 6865 2073 7065  ields to the spe
+00021dd0: 6374 726f 6d65 7465 722e 0a20 2020 2064  ctrometer..    d
+00021de0: 6566 2077 7269 7465 5f65 6570 726f 6d28  ef write_eeprom(
+00021df0: 7365 6c66 293a 0a20 2020 2020 2020 2069  self):.        i
+00021e00: 6620 6e6f 7420 7365 6c66 2e65 6570 726f  f not self.eepro
+00021e10: 6d5f 6261 636b 7570 3a0a 2020 2020 2020  m_backup:.      
+00021e20: 2020 2020 2020 6c6f 672e 6372 6974 6963        log.critic
+00021e30: 616c 2822 6578 7065 6374 6564 2074 6f20  al("expected to 
+00021e40: 7570 6461 7465 206f 7220 7265 706c 6163  update or replac
+00021e50: 6520 4545 5052 4f4d 206f 626a 6563 7420  e EEPROM object 
+00021e60: 6265 666f 7265 2077 7269 7465 2063 6f6d  before write com
+00021e70: 6d61 6e64 2229 0a20 2020 2020 2020 2020  mand").         
+00021e80: 2020 2073 656c 662e 7175 6575 655f 6d65     self.queue_me
+00021e90: 7373 6167 6528 226d 6172 7175 6565 5f65  ssage("marquee_e
+00021ea0: 7272 6f72 222c 2022 4661 696c 6564 2074  rror", "Failed t
+00021eb0: 6f20 7772 6974 6520 4545 5052 4f4d 2229  o write EEPROM")
+00021ec0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00021ed0: 7572 6e20 5370 6563 7472 6f6d 6574 6572  urn Spectrometer
+00021ee0: 5265 7370 6f6e 7365 2864 6174 613d 4661  Response(data=Fa
+00021ef0: 6c73 652c 6572 726f 725f 6d73 673d 2266  lse,error_msg="f
+00021f00: 6169 6c65 6420 746f 2077 7269 7465 2065  ailed to write e
+00021f10: 6570 726f 6d22 290a 0a20 2020 2020 2020  eprom")..       
+00021f20: 2023 2062 6163 6b75 7020 636f 6e74 656e   # backup conten
+00021f30: 7473 206f 6620 7072 6576 696f 7573 2045  ts of previous E
+00021f40: 4550 524f 4d20 696e 206c 6f67 0a20 2020  EPROM in log.   
+00021f50: 2020 2020 206c 6f67 2e64 6562 7567 2822       log.debug("
+00021f60: 4f72 6967 696e 616c 2045 4550 524f 4d20  Original EEPROM 
+00021f70: 636f 6e74 656e 7473 2229 0a20 2020 2020  contents").     
+00021f80: 2020 2073 656c 662e 6565 7072 6f6d 5f62     self.eeprom_b
+00021f90: 6163 6b75 702e 6475 6d70 2829 0a20 2020  ackup.dump().   
+00021fa0: 2020 2020 206c 6f67 2e64 6562 7567 2822       log.debug("
+00021fb0: 4f72 6967 696e 616c 2045 4550 524f 4d20  Original EEPROM 
+00021fc0: 6275 6666 6572 733a 2025 7322 2c20 7365  buffers: %s", se
+00021fd0: 6c66 2e65 6570 726f 6d5f 6261 636b 7570  lf.eeprom_backup
+00021fe0: 2e62 7566 6665 7273 290a 0a20 2020 2020  .buffers)..     
+00021ff0: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
+00022000: 2020 2020 7365 6c66 2e73 6574 7469 6e67      self.setting
+00022010: 732e 6565 7072 6f6d 2e67 656e 6572 6174  s.eeprom.generat
+00022020: 655f 7772 6974 655f 6275 6666 6572 7328  e_write_buffers(
+00022030: 290a 2020 2020 2020 2020 6578 6365 7074  ).        except
+00022040: 3a0a 2020 2020 2020 2020 2020 2020 6c6f  :.            lo
+00022050: 672e 6372 6974 6963 616c 2822 6661 696c  g.critical("fail
+00022060: 6564 2074 6f20 7265 6e64 6572 2045 4550  ed to render EEP
+00022070: 524f 4d20 7772 6974 6520 6275 6666 6572  ROM write buffer
+00022080: 7322 2c20 6578 635f 696e 666f 3d31 290a  s", exc_info=1).
+00022090: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+000220a0: 2e71 7565 7565 5f6d 6573 7361 6765 2822  .queue_message("
+000220b0: 6d61 7271 7565 655f 6572 726f 7222 2c20  marquee_error", 
+000220c0: 2246 6169 6c65 6420 746f 2077 7269 7465  "Failed to write
+000220d0: 2045 4550 524f 4d22 290a 2020 2020 2020   EEPROM").      
+000220e0: 2020 2020 2020 7265 7475 726e 2053 7065        return Spe
+000220f0: 6374 726f 6d65 7465 7252 6573 706f 6e73  ctrometerRespons
+00022100: 6528 6461 7461 3d46 616c 7365 2c65 7272  e(data=False,err
+00022110: 6f72 5f6d 7367 3d22 6661 696c 6564 2074  or_msg="failed t
+00022120: 6f20 6765 6e65 7261 7465 2065 6570 726f  o generate eepro
+00022130: 6d22 290a 0a20 2020 2020 2020 206c 6f67  m")..        log
+00022140: 2e64 6562 7567 2822 576f 756c 6420 7772  .debug("Would wr
+00022150: 6974 6520 6e65 7720 6275 6666 6572 733a  ite new buffers:
+00022160: 2025 7322 2c20 7365 6c66 2e73 6574 7469   %s", self.setti
+00022170: 6e67 732e 6565 7072 6f6d 2e77 7269 7465  ngs.eeprom.write
+00022180: 5f62 7566 6665 7273 290a 0a20 2020 2020  _buffers)..     
+00022190: 2020 2066 6f72 2070 6167 6520 696e 2072     for page in r
+000221a0: 616e 6765 2845 4550 524f 4d2e 4d41 585f  ange(EEPROM.MAX_
+000221b0: 5041 4745 5329 3a0a 2020 2020 2020 2020  PAGES):.        
+000221c0: 2020 2020 6966 2073 656c 662e 7365 7474      if self.sett
+000221d0: 696e 6773 2e69 735f 6172 6d28 293a 0a20  ings.is_arm():. 
+000221e0: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+000221f0: 6f67 2e64 6562 7567 2822 7772 6974 696e  og.debug("writin
+00022200: 6720 7061 6765 2025 643a 2025 7322 2c20  g page %d: %s", 
+00022210: 7061 6765 2c20 7365 6c66 2e73 6574 7469  page, self.setti
+00022220: 6e67 732e 6565 7072 6f6d 2e77 7269 7465  ngs.eeprom.write
+00022230: 5f62 7566 6665 7273 5b70 6167 655d 290a  _buffers[page]).
+00022240: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022250: 7365 6c66 2e5f 7365 6e64 5f63 6f64 6528  self._send_code(
+00022260: 6252 6571 7565 7374 2020 2020 2020 2020  bRequest        
+00022270: 3d20 3078 6666 2c20 2320 7365 636f 6e64  = 0xff, # second
+00022280: 2d74 6965 720a 2020 2020 2020 2020 2020  -tier.          
 00022290: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000222a0: 2273 6574 5f74 7269 6767 6572 5f64 656c  "set_trigger_del
-000222b0: 6179 222c 0d0a 2020 2020 2020 2020 2020  ay",..          
-000222c0: 2020 2020 2020 2020 2020 2022 6765 745f             "get_
-000222d0: 7472 6967 6765 725f 6465 6c61 7922 2c0d  trigger_delay",.
-000222e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000222f0: 2020 2020 2020 2267 6574 5f76 725f 636f        "get_vr_co
-00022300: 6e74 696e 756f 7573 5f63 6364 222c 0d0a  ntinuous_ccd",..
-00022310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022320: 2020 2020 2022 6765 745f 7672 5f6e 756d       "get_vr_num
-00022330: 5f66 7261 6d65 7322 2c0d 0a20 2020 2020  _frames",..     
-00022340: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022350: 2267 6574 5f6f 7074 5f61 6374 7561 6c5f  "get_opt_actual_
-00022360: 696e 7465 6772 6174 696f 6e5f 7469 6d65  integration_time
-00022370: 222c 0d0a 2020 2020 2020 2020 2020 2020  ",..            
-00022380: 2020 2020 2020 2020 2022 6765 745f 6f70           "get_op
-00022390: 745f 6172 6561 5f73 6361 6e22 2c0d 0a20  t_area_scan",.. 
-000223a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000223b0: 2020 2020 2267 6574 5f6f 7074 5f63 665f      "get_opt_cf_
-000223c0: 7365 6c65 6374 222c 0d0a 2020 2020 2020  select",..      
-000223d0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-000223e0: 6765 745f 6f70 745f 6461 7461 5f68 6561  get_opt_data_hea
-000223f0: 6465 725f 7461 6222 2c0d 0a20 2020 2020  der_tab",..     
-00022400: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022410: 2267 6574 5f6f 7074 5f68 6f72 697a 6f6e  "get_opt_horizon
-00022420: 7461 6c5f 6269 6e6e 696e 6722 2c0d 0a20  tal_binning",.. 
-00022430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022440: 2020 2020 2267 6574 5f6f 7074 5f69 6e74      "get_opt_int
-00022450: 6567 7261 7469 6f6e 5f74 696d 655f 7265  egration_time_re
-00022460: 736f 6c75 7469 6f6e 222c 0d0a 2020 2020  solution",..    
+000222a0: 2020 2020 2077 5661 6c75 6520 2020 2020       wValue     
+000222b0: 2020 2020 203d 2030 7830 322c 0a20 2020       = 0x02,.   
+000222c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000222d0: 2020 2020 2020 2020 2020 2020 7749 6e64              wInd
+000222e0: 6578 2020 2020 2020 2020 2020 3d20 7061  ex          = pa
+000222f0: 6765 2c0a 2020 2020 2020 2020 2020 2020  ge,.            
+00022300: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022310: 2020 2064 6174 615f 6f72 5f77 4c65 6e67     data_or_wLeng
+00022320: 7468 203d 2073 656c 662e 7365 7474 696e  th = self.settin
+00022330: 6773 2e65 6570 726f 6d2e 7772 6974 655f  gs.eeprom.write_
+00022340: 6275 6666 6572 735b 7061 6765 5d2c 0a20  buffers[page],. 
+00022350: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022360: 2020 2020 2020 2020 2020 2020 2020 6c61                la
+00022370: 6265 6c20 2020 2020 2020 2020 2020 3d20  bel           = 
+00022380: 2257 5249 5445 5f45 4550 524f 4d22 290a  "WRITE_EEPROM").
+00022390: 2020 2020 2020 2020 2020 2020 656c 7365              else
+000223a0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000223b0: 2020 4441 5441 5f53 5441 5254 203d 2030    DATA_START = 0
+000223c0: 7833 6330 300a 2020 2020 2020 2020 2020  x3c00.          
+000223d0: 2020 2020 2020 6f66 6673 6574 203d 2044        offset = D
+000223e0: 4154 415f 5354 4152 5420 2b20 7061 6765  ATA_START + page
+000223f0: 202a 2036 340a 2020 2020 2020 2020 2020   * 64.          
+00022400: 2020 2020 2020 6c6f 672e 6465 6275 6728        log.debug(
+00022410: 2277 7269 7469 6e67 2070 6167 6520 2564  "writing page %d
+00022420: 2061 7420 6f66 6673 6574 2030 7825 3034   at offset 0x%04
+00022430: 783a 2025 7322 2c20 7061 6765 2c20 6f66  x: %s", page, of
+00022440: 6673 6574 2c20 7365 6c66 2e73 6574 7469  fset, self.setti
+00022450: 6e67 732e 6565 7072 6f6d 2e77 7269 7465  ngs.eeprom.write
+00022460: 5f62 7566 6665 7273 5b70 6167 655d 290a  _buffers[page]).
 00022470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022480: 2022 7365 745f 616e 616c 6f67 5f6f 7574   "set_analog_out
-00022490: 7075 745f 6d6f 6465 222c 0d0a 2020 2020  put_mode",..    
-000224a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000224b0: 2022 7365 745f 616e 616c 6f67 5f6f 7574   "set_analog_out
-000224c0: 7075 745f 7661 6c75 6522 2c0d 0a20 2020  put_value",..   
-000224d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000224e0: 2020 2267 6574 5f61 6e61 6c6f 675f 6f75    "get_analog_ou
-000224f0: 7470 7574 5f73 7461 7465 222c 0d0a 2020  tput_state",..  
-00022500: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022510: 2020 2022 6765 745f 616e 616c 6f67 5f69     "get_analog_i
-00022520: 6e70 7574 5f76 616c 7565 222c 0d0a 2020  nput_value",..  
-00022530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022540: 2020 2022 7570 6461 7465 5f73 6573 7369     "update_sessi
-00022550: 6f6e 5f65 6570 726f 6d22 2c0d 0a20 2020  on_eeprom",..   
-00022560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022570: 2020 2272 6570 6c61 6365 5f73 6573 7369    "replace_sessi
-00022580: 6f6e 5f65 6570 726f 6d22 2c0d 0a20 2020  on_eeprom",..   
-00022590: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000225a0: 2020 2277 7269 7465 5f65 6570 726f 6d22    "write_eeprom"
-000225b0: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
-000225c0: 2020 2020 2020 2020 2273 6574 5f6c 6f67          "set_log
-000225d0: 5f6c 6576 656c 222c 0d0a 2020 2020 2020  _level",..      
-000225e0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-000225f0: 7175 6575 655f 6d65 7373 6167 6522 205d  queue_message" ]
-00022600: 3a0d 0a20 2020 2020 2020 2020 2020 2070  :..            p
-00022610: 726f 6365 7373 5f66 5b66 6e5f 6e61 6d65  rocess_f[fn_name
-00022620: 5d20 3d20 6765 7461 7474 7228 7365 6c66  ] = getattr(self
-00022630: 2c20 666e 5f6e 616d 6529 0d0a 2020 2020  , fn_name)..    
-00022640: 0d0a 2020 2020 2020 2020 2323 2323 2323  ..        ######
-00022650: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00022660: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00022670: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00022680: 2323 2323 2323 2323 2323 2323 0d0a 2020  ############..  
-00022690: 2020 2020 2020 2320 5768 6174 2066 6f6c        # What fol
-000226a0: 6c6f 7773 2069 7320 7468 6520 6f6c 6420  lows is the old 
-000226b0: 696e 6974 2d6c 616d 6264 6173 2074 6861  init-lambdas tha
-000226c0: 7420 6172 6520 7371 7561 7368 6564 2069  t are squashed i
-000226d0: 6e74 6f20 7072 6f63 6573 735f 660d 0a20  nto process_f.. 
-000226e0: 2020 2020 2020 2023 204c 6f6e 6720 7465         # Long te
-000226f0: 726d 2c20 7468 6520 7570 7374 7265 616d  rm, the upstream
-00022700: 2072 6571 7565 7374 7320 7368 6f75 6c64   requests should
-00022710: 2062 6520 6368 616e 6765 6420 746f 206d   be changed to m
-00022720: 6174 6368 2074 6865 206e 6577 2066 6f72  atch the new for
-00022730: 6d61 740d 0a20 2020 2020 2020 2023 2054  mat..        # T
-00022740: 6869 7320 6973 2061 6e20 6561 7379 2066  his is an easy f
-00022750: 6978 2066 6f72 2074 6865 2074 696d 6520  ix for the time 
-00022760: 6265 696e 6720 746f 206d 616b 6520 7468  being to make th
-00022770: 696e 6773 2062 6568 6176 650d 0a20 2020  ings behave..   
-00022780: 2020 2020 2023 2323 2323 2323 2323 2323       ###########
-00022790: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000227a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000227b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000227c0: 2323 2323 2323 230d 0a20 2020 2020 2020  #######..       
-000227d0: 2023 2073 7065 6374 726f 6d65 7465 7220   # spectrometer 
-000227e0: 636f 6e74 726f 6c0d 0a20 2020 2020 2020  control..       
-000227f0: 2070 726f 6365 7373 5f66 5b22 6c61 7365   process_f["lase
-00022800: 725f 656e 6162 6c65 225d 2020 2020 2020  r_enable"]      
-00022810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022820: 203d 206c 616d 6264 6120 783a 2073 656c   = lambda x: sel
-00022830: 662e 7365 745f 6c61 7365 725f 656e 6162  f.set_laser_enab
-00022840: 6c65 2862 6f6f 6c28 7829 290d 0a20 2020  le(bool(x))..   
-00022850: 2020 2020 2070 726f 6365 7373 5f66 5b22       process_f["
-00022860: 696e 7465 6772 6174 696f 6e5f 7469 6d65  integration_time
-00022870: 5f6d 7322 5d20 2020 2020 2020 2020 2020  _ms"]           
-00022880: 2020 2020 203d 206c 616d 6264 6120 783a       = lambda x:
-00022890: 2073 656c 662e 7365 745f 696e 7465 6772   self.set_integr
-000228a0: 6174 696f 6e5f 7469 6d65 5f6d 7328 7829  ation_time_ms(x)
-000228b0: 0d0a 0d0a 2020 2020 2020 2020 7072 6f63  ....        proc
-000228c0: 6573 735f 665b 2264 6574 6563 746f 725f  ess_f["detector_
-000228d0: 7465 635f 7365 7470 6f69 6e74 5f64 6567  tec_setpoint_deg
-000228e0: 4322 5d20 2020 2020 2020 2020 3d20 6c61  C"]         = la
-000228f0: 6d62 6461 2078 3a20 7365 6c66 2e73 6574  mbda x: self.set
-00022900: 5f64 6574 6563 746f 725f 7465 635f 7365  _detector_tec_se
-00022910: 7470 6f69 6e74 5f64 6567 4328 696e 7428  tpoint_degC(int(
-00022920: 726f 756e 6428 7829 2929 0d0a 2020 2020  round(x)))..    
-00022930: 2020 2020 7072 6f63 6573 735f 665b 2264      process_f["d
-00022940: 6574 6563 746f 725f 7465 635f 656e 6162  etector_tec_enab
-00022950: 6c65 225d 2020 2020 2020 2020 2020 2020  le"]            
-00022960: 2020 2020 3d20 6c61 6d62 6461 2078 3a20      = lambda x: 
-00022970: 7365 6c66 2e73 6574 5f74 6563 5f65 6e61  self.set_tec_ena
-00022980: 626c 6528 626f 6f6c 2878 2929 0d0a 2020  ble(bool(x))..  
-00022990: 2020 2020 2020 7072 6f63 6573 735f 665b        process_f[
-000229a0: 2264 6574 6563 746f 725f 6761 696e 225d  "detector_gain"]
-000229b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000229c0: 2020 2020 2020 3d20 6c61 6d62 6461 2078        = lambda x
-000229d0: 3a20 7365 6c66 2e73 6574 5f64 6574 6563  : self.set_detec
-000229e0: 746f 725f 6761 696e 2866 6c6f 6174 2878  tor_gain(float(x
-000229f0: 2929 0d0a 2020 2020 2020 2020 7072 6f63  ))..        proc
-00022a00: 6573 735f 665b 2264 6574 6563 746f 725f  ess_f["detector_
-00022a10: 6f66 6673 6574 225d 2020 2020 2020 2020  offset"]        
-00022a20: 2020 2020 2020 2020 2020 2020 3d20 6c61              = la
-00022a30: 6d62 6461 2078 3a20 7365 6c66 2e73 6574  mbda x: self.set
-00022a40: 5f64 6574 6563 746f 725f 6f66 6673 6574  _detector_offset
-00022a50: 2869 6e74 2872 6f75 6e64 2878 2929 290d  (int(round(x))).
-00022a60: 0a20 2020 2020 2020 2070 726f 6365 7373  .        process
-00022a70: 5f66 5b22 6465 7465 6374 6f72 5f67 6169  _f["detector_gai
-00022a80: 6e5f 6f64 6422 5d20 2020 2020 2020 2020  n_odd"]         
-00022a90: 2020 2020 2020 2020 203d 206c 616d 6264           = lambd
-00022aa0: 6120 783a 2073 656c 662e 7365 745f 6465  a x: self.set_de
-00022ab0: 7465 6374 6f72 5f67 6169 6e5f 6f64 6428  tector_gain_odd(
-00022ac0: 666c 6f61 7428 7829 290d 0a20 2020 2020  float(x))..     
-00022ad0: 2020 2070 726f 6365 7373 5f66 5b22 6465     process_f["de
-00022ae0: 7465 6374 6f72 5f6f 6666 7365 745f 6f64  tector_offset_od
-00022af0: 6422 5d20 2020 2020 2020 2020 2020 2020  d"]             
-00022b00: 2020 203d 206c 616d 6264 6120 783a 2073     = lambda x: s
-00022b10: 656c 662e 7365 745f 6465 7465 6374 6f72  elf.set_detector
-00022b20: 5f6f 6666 7365 745f 6f64 6428 696e 7428  _offset_odd(int(
-00022b30: 726f 756e 6428 7829 2929 0d0a 2020 2020  round(x)))..    
-00022b40: 2020 2020 7072 6f63 6573 735f 665b 2264      process_f["d
-00022b50: 6567 435f 746f 5f64 6163 5f63 6f65 6666  egC_to_dac_coeff
-00022b60: 7322 5d20 2020 2020 2020 2020 2020 2020  s"]             
-00022b70: 2020 2020 3d20 6c61 6d62 6461 2078 3a20      = lambda x: 
-00022b80: 7365 6c66 2e73 6574 7469 6e67 732e 6565  self.settings.ee
-00022b90: 7072 6f6d 2e73 6574 2822 6465 6743 5f74  prom.set("degC_t
-00022ba0: 6f5f 6461 635f 636f 6566 6673 222c 2078  o_dac_coeffs", x
-00022bb0: 290d 0a0d 0a20 2020 2020 2020 2070 726f  )....        pro
-00022bc0: 6365 7373 5f66 5b22 6c61 7365 725f 706f  cess_f["laser_po
-00022bd0: 7765 725f 7065 7263 225d 2020 2020 2020  wer_perc"]      
-00022be0: 2020 2020 2020 2020 2020 2020 203d 206c               = l
-00022bf0: 616d 6264 6120 783a 2073 656c 662e 7365  ambda x: self.se
-00022c00: 745f 6c61 7365 725f 706f 7765 725f 7065  t_laser_power_pe
-00022c10: 7263 2878 290d 0a20 2020 2020 2020 2070  rc(x)..        p
-00022c20: 726f 6365 7373 5f66 5b22 6c61 7365 725f  rocess_f["laser_
-00022c30: 706f 7765 725f 6d57 225d 2020 2020 2020  power_mW"]      
-00022c40: 2020 2020 2020 2020 2020 2020 2020 203d                 =
-00022c50: 206c 616d 6264 6120 783a 2073 656c 662e   lambda x: self.
-00022c60: 7365 745f 6c61 7365 725f 706f 7765 725f  set_laser_power_
-00022c70: 6d57 2878 290d 0a20 2020 2020 2020 2070  mW(x)..        p
-00022c80: 726f 6365 7373 5f66 5b22 6c61 7365 725f  rocess_f["laser_
-00022c90: 7465 6d70 6572 6174 7572 655f 7365 7470  temperature_setp
-00022ca0: 6f69 6e74 5f72 6177 225d 2020 2020 203d  oint_raw"]     =
-00022cb0: 206c 616d 6264 6120 783a 2073 656c 662e   lambda x: self.
-00022cc0: 7365 745f 6c61 7365 725f 7465 6d70 6572  set_laser_temper
-00022cd0: 6174 7572 655f 7365 7470 6f69 6e74 5f72  ature_setpoint_r
-00022ce0: 6177 2869 6e74 2872 6f75 6e64 2878 2929  aw(int(round(x))
-00022cf0: 290d 0a20 2020 2020 2020 2070 726f 6365  )..        proce
-00022d00: 7373 5f66 5b22 6c61 7365 725f 706f 7765  ss_f["laser_powe
-00022d10: 725f 6174 7465 6e75 6174 6f72 225d 2020  r_attenuator"]  
-00022d20: 2020 2020 2020 2020 2020 203d 206c 616d             = lam
-00022d30: 6264 6120 783a 2073 656c 662e 7365 745f  bda x: self.set_
-00022d40: 6c61 7365 725f 706f 7765 725f 6174 7465  laser_power_atte
-00022d50: 6e75 6174 6f72 2869 6e74 2872 6f75 6e64  nuator(int(round
-00022d60: 2878 2929 290d 0a20 2020 2020 2020 2070  (x)))..        p
-00022d70: 726f 6365 7373 5f66 5b22 6c61 7365 725f  rocess_f["laser_
-00022d80: 706f 7765 725f 7261 6d70 696e 675f 656e  power_ramping_en
-00022d90: 6162 6c65 225d 2020 2020 2020 2020 203d  able"]         =
-00022da0: 206c 616d 6264 6120 783a 2073 656c 662e   lambda x: self.
-00022db0: 7365 745f 6c61 7365 725f 706f 7765 725f  set_laser_power_
-00022dc0: 7261 6d70 696e 675f 656e 6162 6c65 2862  ramping_enable(b
-00022dd0: 6f6f 6c28 7829 290d 0a20 2020 2020 2020  ool(x))..       
-00022de0: 2070 726f 6365 7373 5f66 5b22 6c61 7365   process_f["lase
-00022df0: 725f 706f 7765 725f 6869 6768 5f72 6573  r_power_high_res
-00022e00: 6f6c 7574 696f 6e22 5d20 2020 2020 2020  olution"]       
-00022e10: 203d 206c 616d 6264 6120 783a 2073 656c   = lambda x: sel
-00022e20: 662e 7365 745f 6c61 7365 725f 706f 7765  f.set_laser_powe
-00022e30: 725f 6869 6768 5f72 6573 6f6c 7574 696f  r_high_resolutio
-00022e40: 6e28 7829 0d0a 2020 2020 2020 2020 7072  n(x)..        pr
-00022e50: 6f63 6573 735f 665b 226c 6173 6572 5f70  ocess_f["laser_p
-00022e60: 6f77 6572 5f72 6571 7569 7265 5f6d 6f64  ower_require_mod
-00022e70: 756c 6174 696f 6e22 5d20 2020 2020 3d20  ulation"]     = 
-00022e80: 6c61 6d62 6461 2078 3a20 7365 6c66 2e73  lambda x: self.s
-00022e90: 6574 5f6c 6173 6572 5f70 6f77 6572 5f72  et_laser_power_r
-00022ea0: 6571 7569 7265 5f6d 6f64 756c 6174 696f  equire_modulatio
-00022eb0: 6e28 7829 0d0a 2020 2020 2020 2020 7072  n(x)..        pr
-00022ec0: 6f63 6573 735f 665b 2273 656c 6563 7465  ocess_f["selecte
-00022ed0: 645f 6c61 7365 7222 5d20 2020 2020 2020  d_laser"]       
-00022ee0: 2020 2020 2020 2020 2020 2020 2020 3d20                = 
-00022ef0: 6c61 6d62 6461 2078 3a20 7365 6c66 2e73  lambda x: self.s
-00022f00: 6574 5f73 656c 6563 7465 645f 6c61 7365  et_selected_lase
-00022f10: 7228 696e 7428 7829 290d 0a0d 0a20 2020  r(int(x))....   
-00022f20: 2020 2020 2070 726f 6365 7373 5f66 5b22       process_f["
-00022f30: 6869 6768 5f67 6169 6e5f 6d6f 6465 5f65  high_gain_mode_e
-00022f40: 6e61 626c 6522 5d20 2020 2020 2020 2020  nable"]         
-00022f50: 2020 2020 203d 206c 616d 6264 6120 783a       = lambda x:
-00022f60: 2073 656c 662e 7365 745f 6869 6768 5f67   self.set_high_g
-00022f70: 6169 6e5f 6d6f 6465 5f65 6e61 626c 6528  ain_mode_enable(
-00022f80: 626f 6f6c 2878 2929 0d0a 2020 2020 2020  bool(x))..      
-00022f90: 2020 7072 6f63 6573 735f 665b 2274 7269    process_f["tri
-00022fa0: 6767 6572 5f73 6f75 7263 6522 5d20 2020  gger_source"]   
-00022fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022fc0: 2020 3d20 6c61 6d62 6461 2078 3a20 7365    = lambda x: se
-00022fd0: 6c66 2e73 6574 5f74 7269 6767 6572 5f73  lf.set_trigger_s
-00022fe0: 6f75 7263 6528 696e 7428 7829 290d 0a20  ource(int(x)).. 
-00022ff0: 2020 2020 2020 2070 726f 6365 7373 5f66         process_f
-00023000: 5b22 656e 6162 6c65 5f73 6563 6f6e 6461  ["enable_seconda
-00023010: 7279 5f61 6463 225d 2020 2020 2020 2020  ry_adc"]        
-00023020: 2020 2020 2020 203d 206c 616d 6264 6120         = lambda 
-00023030: 783a 2073 656c 662e 7365 7474 696e 6773  x: self.settings
-00023040: 2e73 7461 7465 2e73 6574 2822 7365 636f  .state.set("seco
-00023050: 6e64 6172 795f 6164 635f 656e 6162 6c65  ndary_adc_enable
-00023060: 6422 2c20 626f 6f6c 2878 2929 0d0a 2020  d", bool(x))..  
-00023070: 2020 2020 2020 7072 6f63 6573 735f 665b        process_f[
-00023080: 2261 7265 615f 7363 616e 5f65 6e61 626c  "area_scan_enabl
-00023090: 6522 5d20 2020 2020 2020 2020 2020 2020  e"]             
-000230a0: 2020 2020 2020 3d20 6c61 6d62 6461 2078        = lambda x
-000230b0: 3a20 7365 6c66 2e73 6574 5f61 7265 615f  : self.set_area_
-000230c0: 7363 616e 5f65 6e61 626c 6528 626f 6f6c  scan_enable(bool
-000230d0: 2878 2929 0d0a 2020 2020 2020 2020 7072  (x))..        pr
-000230e0: 6f63 6573 735f 665b 2261 7265 615f 7363  ocess_f["area_sc
-000230f0: 616e 5f66 6173 7422 5d20 2020 2020 2020  an_fast"]       
-00023100: 2020 2020 2020 2020 2020 2020 2020 3d20                = 
-00023110: 6c61 6d62 6461 2078 3a20 7365 6c66 2e73  lambda x: self.s
-00023120: 6574 7469 6e67 732e 7374 6174 652e 7365  ettings.state.se
-00023130: 7428 2261 7265 615f 7363 616e 5f66 6173  t("area_scan_fas
-00023140: 7422 2c20 626f 6f6c 2878 2929 0d0a 0d0a  t", bool(x))....
-00023150: 2020 2020 2020 2020 7072 6f63 6573 735f          process_
-00023160: 665b 2262 6164 5f70 6978 656c 5f6d 6f64  f["bad_pixel_mod
-00023170: 6522 5d20 2020 2020 2020 2020 2020 2020  e"]             
-00023180: 2020 2020 2020 2020 3d20 6c61 6d62 6461          = lambda
-00023190: 2078 3a20 7365 6c66 2e73 6574 7469 6e67   x: self.setting
-000231a0: 732e 7374 6174 652e 7365 7428 2262 6164  s.state.set("bad
-000231b0: 5f70 6978 656c 5f6d 6f64 6522 2c20 696e  _pixel_mode", in
-000231c0: 7428 7829 290d 0a20 2020 2020 2020 2070  t(x))..        p
-000231d0: 726f 6365 7373 5f66 5b22 6d69 6e5f 7573  rocess_f["min_us
-000231e0: 625f 696e 7465 7276 616c 5f6d 7322 5d20  b_interval_ms"] 
-000231f0: 2020 2020 2020 2020 2020 2020 2020 203d                 =
-00023200: 206c 616d 6264 6120 783a 2073 656c 662e   lambda x: self.
-00023210: 7365 7474 696e 6773 2e73 7461 7465 2e73  settings.state.s
-00023220: 6574 2822 6d69 6e5f 7573 625f 696e 7465  et("min_usb_inte
-00023230: 7276 616c 5f6d 7322 2c20 696e 7428 726f  rval_ms", int(ro
-00023240: 756e 6428 7829 2929 0d0a 2020 2020 2020  und(x)))..      
-00023250: 2020 7072 6f63 6573 735f 665b 226d 6178    process_f["max
-00023260: 5f75 7362 5f69 6e74 6572 7661 6c5f 6d73  _usb_interval_ms
-00023270: 225d 2020 2020 2020 2020 2020 2020 2020  "]              
-00023280: 2020 3d20 6c61 6d62 6461 2078 3a20 7365    = lambda x: se
-00023290: 6c66 2e73 6574 7469 6e67 732e 7374 6174  lf.settings.stat
-000232a0: 652e 7365 7428 226d 6178 5f75 7362 5f69  e.set("max_usb_i
-000232b0: 6e74 6572 7661 6c5f 6d73 222c 2069 6e74  nterval_ms", int
-000232c0: 2872 6f75 6e64 2878 2929 290d 0a0d 0a20  (round(x))).... 
-000232d0: 2020 2020 2020 2070 726f 6365 7373 5f66         process_f
-000232e0: 5b22 6163 6365 7373 6f72 795f 656e 6162  ["accessory_enab
-000232f0: 6c65 225d 2020 2020 2020 2020 2020 2020  le"]            
-00023300: 2020 2020 2020 203d 206c 616d 6264 6120         = lambda 
-00023310: 783a 2073 656c 662e 7365 745f 6163 6365  x: self.set_acce
-00023320: 7373 6f72 795f 656e 6162 6c65 2862 6f6f  ssory_enable(boo
-00023330: 6c28 7829 290d 0a20 2020 2020 2020 2070  l(x))..        p
-00023340: 726f 6365 7373 5f66 5b22 6661 6e5f 656e  rocess_f["fan_en
-00023350: 6162 6c65 225d 2020 2020 2020 2020 2020  able"]          
-00023360: 2020 2020 2020 2020 2020 2020 2020 203d                 =
-00023370: 206c 616d 6264 6120 783a 2073 656c 662e   lambda x: self.
-00023380: 7365 745f 6661 6e5f 656e 6162 6c65 2862  set_fan_enable(b
-00023390: 6f6f 6c28 7829 290d 0a20 2020 2020 2020  ool(x))..       
-000233a0: 2070 726f 6365 7373 5f66 5b22 6c61 6d70   process_f["lamp
-000233b0: 5f65 6e61 626c 6522 5d20 2020 2020 2020  _enable"]       
+00022480: 7365 6c66 2e5f 7365 6e64 5f63 6f64 6528  self._send_code(
+00022490: 6252 6571 7565 7374 2020 2020 2020 2020  bRequest        
+000224a0: 3d20 3078 6132 2c20 2020 2320 6461 6e67  = 0xa2,   # dang
+000224b0: 6572 6f75 730a 2020 2020 2020 2020 2020  erous.          
+000224c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000224d0: 2020 2020 2077 5661 6c75 6520 2020 2020       wValue     
+000224e0: 2020 2020 203d 206f 6666 7365 742c 2023       = offset, #
+000224f0: 2061 7267 7561 626c 7920 616e 2069 6e64   arguably an ind
+00022500: 6578 2062 7574 2068 6579 0a20 2020 2020  ex but hey.     
+00022510: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022520: 2020 2020 2020 2020 2020 7749 6e64 6578            wIndex
+00022530: 2020 2020 2020 2020 2020 3d20 302c 0a20            = 0,. 
+00022540: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022550: 2020 2020 2020 2020 2020 2020 2020 6461                da
+00022560: 7461 5f6f 725f 774c 656e 6774 6820 3d20  ta_or_wLength = 
+00022570: 7365 6c66 2e73 6574 7469 6e67 732e 6565  self.settings.ee
+00022580: 7072 6f6d 2e77 7269 7465 5f62 7566 6665  prom.write_buffe
+00022590: 7273 5b70 6167 655d 2c0a 2020 2020 2020  rs[page],.      
+000225a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000225b0: 2020 2020 2020 2020 206c 6162 656c 2020           label  
+000225c0: 2020 2020 2020 2020 203d 2022 5752 4954           = "WRIT
+000225d0: 455f 4545 5052 4f4d 2229 0a0a 2020 2020  E_EEPROM")..    
+000225e0: 2020 2020 7365 6c66 2e71 7565 7565 5f6d      self.queue_m
+000225f0: 6573 7361 6765 2822 6d61 7271 7565 655f  essage("marquee_
+00022600: 696e 666f 222c 2022 4545 5052 4f4d 2073  info", "EEPROM s
+00022610: 7563 6365 7373 6675 6c6c 7920 7570 6461  uccessfully upda
+00022620: 7465 6422 290a 0a20 2020 2020 2020 2023  ted")..        #
+00022630: 2061 6e79 2076 616c 7565 2069 6e20 646f   any value in do
+00022640: 696e 6720 7468 6973 3f0a 2020 2020 2020  ing this?.      
+00022650: 2020 7365 6c66 2e73 6574 7469 6e67 732e    self.settings.
+00022660: 6565 7072 6f6d 2e62 7566 6665 7273 203d  eeprom.buffers =
+00022670: 2073 656c 662e 7365 7474 696e 6773 2e65   self.settings.e
+00022680: 6570 726f 6d2e 7772 6974 655f 6275 6666  eprom.write_buff
+00022690: 6572 730a 0a20 2020 2020 2020 2072 6574  ers..        ret
+000226a0: 7572 6e20 5370 6563 7472 6f6d 6574 6572  urn Spectrometer
+000226b0: 5265 7370 6f6e 7365 2864 6174 613d 5472  Response(data=Tr
+000226c0: 7565 290a 0a20 2020 2023 2023 2323 2323  ue)..    # #####
+000226d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000226e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000226f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00022700: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00022710: 2323 2323 230a 2020 2020 2320 496e 7465  #####.    # Inte
+00022720: 7270 726f 6365 7373 2043 6f6d 6d75 6e69  rprocess Communi
+00022730: 6361 7469 6f6e 730a 2020 2020 2320 2323  cations.    # ##
+00022740: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00022750: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00022760: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00022770: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00022780: 2323 2323 2323 2323 0a0a 2020 2020 2320  ########..    # 
+00022790: 4074 6f64 6f20 6d6f 7665 2073 7472 696e  @todo move strin
+000227a0: 672d 746f 2d65 6e75 6d20 636f 6e76 6572  g-to-enum conver
+000227b0: 7465 7220 746f 2041 7070 4c6f 670a 2020  ter to AppLog.  
+000227c0: 2020 6465 6620 7365 745f 6c6f 675f 6c65    def set_log_le
+000227d0: 7665 6c28 7365 6c66 2c20 733a 2073 7472  vel(self, s: str
+000227e0: 293a 0a20 2020 2020 2020 206c 766c 203d  ):.        lvl =
+000227f0: 206c 6f67 6769 6e67 2e44 4542 5547 2069   logging.DEBUG i
+00022800: 6620 7320 3d3d 2022 4445 4255 4722 2065  f s == "DEBUG" e
+00022810: 6c73 6520 6c6f 6767 696e 672e 494e 464f  lse logging.INFO
+00022820: 0a20 2020 2020 2020 206c 6f67 2e64 6562  .        log.deb
+00022830: 7567 2822 6669 642e 7365 745f 6c6f 675f  ug("fid.set_log_
+00022840: 6c65 7665 6c3a 2073 6574 7469 6e67 2074  level: setting t
+00022850: 6f20 2573 222c 206c 766c 290a 2020 2020  o %s", lvl).    
+00022860: 2020 2020 6c6f 6767 696e 672e 6765 744c      logging.getL
+00022870: 6f67 6765 7228 292e 7365 744c 6576 656c  ogger().setLevel
+00022880: 286c 766c 290a 2020 2020 2020 2020 7265  (lvl).        re
+00022890: 7475 726e 2053 7065 6374 726f 6d65 7465  turn Spectromete
+000228a0: 7252 6573 706f 6e73 6528 290a 0a20 2020  rResponse()..   
+000228b0: 2064 6566 2071 7565 7565 5f6d 6573 7361   def queue_messa
+000228c0: 6765 2873 656c 662c 2073 6574 7469 6e67  ge(self, setting
+000228d0: 2c20 7661 6c75 6529 3a0a 2020 2020 2020  , value):.      
+000228e0: 2020 2222 220a 2020 2020 2020 2020 4966    """.        If
+000228f0: 2061 6e20 7570 7374 7265 616d 2071 7565   an upstream que
+00022900: 7565 2069 7320 6465 6669 6e65 642c 2073  ue is defined, s
+00022910: 656e 6420 7468 6520 6e61 6d65 2d76 616c  end the name-val
+00022920: 7565 2070 6169 722e 2020 446f 6573 206e  ue pair.  Does n
+00022930: 6f74 6869 6e67 0a20 2020 2020 2020 2069  othing.        i
+00022940: 6620 7468 6520 6361 6c6c 6572 2068 6173  f the caller has
+00022950: 6e27 7420 7072 6f76 6964 6564 2061 2071  n't provided a q
+00022960: 7565 7565 2e0a 2020 2020 2020 2020 2222  ueue..        ""
+00022970: 220a 2020 2020 2020 2020 6966 2073 656c  ".        if sel
+00022980: 662e 6d65 7373 6167 655f 7175 6575 6520  f.message_queue 
+00022990: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
+000229a0: 2020 2020 2072 6574 7572 6e20 5370 6563       return Spec
+000229b0: 7472 6f6d 6574 6572 5265 7370 6f6e 7365  trometerResponse
+000229c0: 2864 6174 613d 4661 6c73 6529 0a0a 2020  (data=False)..  
+000229d0: 2020 2020 2020 6d73 6720 3d20 5374 6174        msg = Stat
+000229e0: 7573 4d65 7373 6167 6528 7365 7474 696e  usMessage(settin
+000229f0: 672c 2076 616c 7565 290a 2020 2020 2020  g, value).      
+00022a00: 2020 7472 793a 0a20 2020 2020 2020 2020    try:.         
+00022a10: 2020 2073 656c 662e 6d65 7373 6167 655f     self.message_
+00022a20: 7175 6575 652e 7075 7428 6d73 6729 2023  queue.put(msg) #
+00022a30: 2070 7574 5f6e 6f77 6169 7428 6d73 6729   put_nowait(msg)
+00022a40: 0a20 2020 2020 2020 2065 7863 6570 743a  .        except:
+00022a50: 0a20 2020 2020 2020 2020 2020 206c 6f67  .            log
+00022a60: 2e65 7272 6f72 2822 6661 696c 6564 2074  .error("failed t
+00022a70: 6f20 656e 7175 6575 6520 5374 6174 7573  o enqueue Status
+00022a80: 4d65 7373 6167 6520 2825 732c 2025 7329  Message (%s, %s)
+00022a90: 222c 2073 6574 7469 6e67 2c20 7661 6c75  ", setting, valu
+00022aa0: 652c 2065 7863 5f69 6e66 6f3d 3129 0a20  e, exc_info=1). 
+00022ab0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00022ac0: 6e20 5370 6563 7472 6f6d 6574 6572 5265  n SpectrometerRe
+00022ad0: 7370 6f6e 7365 2864 6174 613d 4661 6c73  sponse(data=Fals
+00022ae0: 652c 6572 726f 725f 6d73 673d 2266 6169  e,error_msg="fai
+00022af0: 6c65 6420 746f 2065 6e71 7565 7565 206d  led to enqueue m
+00022b00: 6573 7373 6167 6522 290a 2020 2020 2020  esssage").      
+00022b10: 2020 7265 7475 726e 2053 7065 6374 726f    return Spectro
+00022b20: 6d65 7465 7252 6573 706f 6e73 6528 6461  meterResponse(da
+00022b30: 7461 3d54 7275 6529 0a0a 2020 2020 6465  ta=True)..    de
+00022b40: 6620 5f69 6e69 745f 7072 6f63 6573 735f  f _init_process_
+00022b50: 6675 6e63 7328 7365 6c66 293a 0a20 2020  funcs(self):.   
+00022b60: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00022b70: 2049 7320 6974 2074 6865 2065 7870 6563   Is it the expec
+00022b80: 7461 7469 6f6e 2074 6861 7420 616c 6c20  tation that all 
+00022b90: 6f66 2074 6865 7365 2066 756e 6374 696f  of these functio
+00022ba0: 6e73 2077 696c 6c20 7265 7475 726e 200a  ns will return .
+00022bb0: 2020 2020 2020 2020 5370 6563 7472 6f6d          Spectrom
+00022bc0: 6574 6572 5265 7370 6f6e 7365 3f20 4966  eterResponse? If
+00022bd0: 2073 6f2c 2074 6861 7420 7368 6f75 6c64   so, that should
+00022be0: 2062 6520 6d61 6465 2065 7870 6c69 6369   be made explici
+00022bf0: 742e 0a20 2020 2020 2020 2022 2222 0a20  t..        """. 
+00022c00: 2020 2020 2020 2070 726f 6365 7373 5f66         process_f
+00022c10: 203d 207b 7d0a 0a20 2020 2020 2020 2066   = {}..        f
+00022c20: 6f72 2066 6e5f 6e61 6d65 2069 6e20 5b20  or fn_name in [ 
+00022c30: 2263 6f6e 6e65 6374 222c 0a20 2020 2020  "connect",.     
+00022c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022c50: 2264 6973 636f 6e6e 6563 7422 2c0a 2020  "disconnect",.  
+00022c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022c70: 2020 2022 6765 745f 6261 7474 6572 795f     "get_battery_
+00022c80: 7265 6769 7374 6572 222c 0a20 2020 2020  register",.     
+00022c90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022ca0: 2267 6574 5f62 6174 7465 7279 5f73 7461  "get_battery_sta
+00022cb0: 7465 5f72 6177 222c 0a20 2020 2020 2020  te_raw",.       
+00022cc0: 2020 2020 2020 2020 2020 2020 2020 2267                "g
+00022cd0: 6574 5f62 6174 7465 7279 5f70 6572 6365  et_battery_perce
+00022ce0: 6e74 6167 6522 2c0a 2020 2020 2020 2020  ntage",.        
+00022cf0: 2020 2020 2020 2020 2020 2020 2022 6765               "ge
+00022d00: 745f 6261 7474 6572 795f 6368 6172 6769  t_battery_chargi
+00022d10: 6e67 222c 0a20 2020 2020 2020 2020 2020  ng",.           
+00022d20: 2020 2020 2020 2020 2020 2267 6574 5f69            "get_i
+00022d30: 6e74 6567 7261 7469 6f6e 5f74 696d 655f  ntegration_time_
+00022d40: 6d73 222c 0a20 2020 2020 2020 2020 2020  ms",.           
+00022d50: 2020 2020 2020 2020 2020 2273 6574 5f64            "set_d
+00022d60: 6675 5f65 6e61 626c 6522 2c0a 2020 2020  fu_enable",.    
+00022d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022d80: 2022 7365 745f 6465 7465 6374 6f72 5f6f   "set_detector_o
+00022d90: 6666 7365 7422 2c0a 2020 2020 2020 2020  ffset",.        
+00022da0: 2020 2020 2020 2020 2020 2020 2022 7365               "se
+00022db0: 745f 6465 7465 6374 6f72 5f6f 6666 7365  t_detector_offse
+00022dc0: 745f 6f64 6422 2c0a 2020 2020 2020 2020  t_odd",.        
+00022dd0: 2020 2020 2020 2020 2020 2020 2022 6765               "ge
+00022de0: 745f 6465 7465 6374 6f72 5f67 6169 6e22  t_detector_gain"
+00022df0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00022e00: 2020 2020 2020 2022 6765 745f 6465 7465         "get_dete
+00022e10: 6374 6f72 5f67 6169 6e5f 6f64 6422 2c0a  ctor_gain_odd",.
+00022e20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022e30: 2020 2020 2022 7365 745f 6465 7465 6374       "set_detect
+00022e40: 6f72 5f67 6169 6e22 2c0a 2020 2020 2020  or_gain",.      
+00022e50: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+00022e60: 7365 745f 6465 7465 6374 6f72 5f67 6169  set_detector_gai
+00022e70: 6e5f 6f64 6422 2c0a 2020 2020 2020 2020  n_odd",.        
+00022e80: 2020 2020 2020 2020 2020 2020 2022 7365               "se
+00022e90: 745f 6172 6561 5f73 6361 6e5f 656e 6162  t_area_scan_enab
+00022ea0: 6c65 222c 0a20 2020 2020 2020 2020 2020  le",.           
+00022eb0: 2020 2020 2020 2020 2020 2267 6574 5f73            "get_s
+00022ec0: 656e 736f 725f 6c69 6e65 5f6c 656e 6774  ensor_line_lengt
+00022ed0: 6822 2c0a 2020 2020 2020 2020 2020 2020  h",.            
+00022ee0: 2020 2020 2020 2020 2022 6765 745f 6d69           "get_mi
+00022ef0: 6372 6f63 6f6e 7472 6f6c 6c65 725f 6669  crocontroller_fi
+00022f00: 726d 7761 7265 5f76 6572 7369 6f6e 222c  rmware_version",
+00022f10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00022f20: 2020 2020 2020 2267 6574 5f66 7067 615f        "get_fpga_
+00022f30: 6669 726d 7761 7265 5f76 6572 7369 6f6e  firmware_version
+00022f40: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+00022f50: 2020 2020 2020 2020 2267 6574 5f6c 696e          "get_lin
+00022f60: 6522 2c0a 2020 2020 2020 2020 2020 2020  e",.            
+00022f70: 2020 2020 2020 2020 2022 7365 745f 696e           "set_in
+00022f80: 7465 6772 6174 696f 6e5f 7469 6d65 5f6d  tegration_time_m
+00022f90: 7322 2c0a 2020 2020 2020 2020 2020 2020  s",.            
+00022fa0: 2020 2020 2020 2020 2022 7365 6c65 6374           "select
+00022fb0: 5f61 6463 222c 0a20 2020 2020 2020 2020  _adc",.         
+00022fc0: 2020 2020 2020 2020 2020 2020 2267 6574              "get
+00022fd0: 5f73 6563 6f6e 6461 7279 5f61 6463 5f63  _secondary_adc_c
+00022fe0: 616c 6962 7261 7465 6422 2c0a 2020 2020  alibrated",.    
+00022ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023000: 2022 6765 745f 7365 636f 6e64 6172 795f   "get_secondary_
+00023010: 6164 635f 7261 7722 2c0a 2020 2020 2020  adc_raw",.      
+00023020: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+00023030: 6765 745f 6c61 7365 725f 7465 6d70 6572  get_laser_temper
+00023040: 6174 7572 655f 7261 7722 2c0a 2020 2020  ature_raw",.    
+00023050: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023060: 2022 6765 745f 6c61 7365 725f 7465 6d70   "get_laser_temp
+00023070: 6572 6174 7572 655f 6465 6743 222c 0a20  erature_degC",. 
+00023080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023090: 2020 2020 2267 6574 5f64 6574 6563 746f      "get_detecto
+000230a0: 725f 7465 6d70 6572 6174 7572 655f 7261  r_temperature_ra
+000230b0: 7722 2c0a 2020 2020 2020 2020 2020 2020  w",.            
+000230c0: 2020 2020 2020 2020 2022 6765 745f 6465           "get_de
+000230d0: 7465 6374 6f72 5f74 656d 7065 7261 7475  tector_temperatu
+000230e0: 7265 5f64 6567 4322 2c0a 2020 2020 2020  re_degC",.      
+000230f0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+00023100: 6765 745f 6465 7465 6374 6f72 5f74 6563  get_detector_tec
+00023110: 5f73 6574 706f 696e 745f 6465 6743 222c  _setpoint_degC",
+00023120: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00023130: 2020 2020 2020 2267 6574 5f64 6163 222c        "get_dac",
+00023140: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00023150: 2020 2020 2020 2273 6574 5f74 6563 5f65        "set_tec_e
+00023160: 6e61 626c 6522 2c0a 2020 2020 2020 2020  nable",.        
+00023170: 2020 2020 2020 2020 2020 2020 2022 7365               "se
+00023180: 745f 6c61 7365 725f 7465 635f 6d6f 6465  t_laser_tec_mode
+00023190: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+000231a0: 2020 2020 2020 2020 2267 6574 5f6c 6173          "get_las
+000231b0: 6572 5f74 6563 5f6d 6f64 6522 2c0a 2020  er_tec_mode",.  
+000231c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000231d0: 2020 2022 7365 745f 7472 6967 6765 725f     "set_trigger_
+000231e0: 736f 7572 6365 222c 0a20 2020 2020 2020  source",.       
+000231f0: 2020 2020 2020 2020 2020 2020 2020 2273                "s
+00023200: 6574 5f68 6967 685f 6761 696e 5f6d 6f64  et_high_gain_mod
+00023210: 655f 656e 6162 6c65 222c 0a20 2020 2020  e_enable",.     
+00023220: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023230: 2267 6574 5f68 6967 685f 6761 696e 5f6d  "get_high_gain_m
+00023240: 6f64 655f 656e 6162 6c65 6422 2c0a 2020  ode_enabled",.  
+00023250: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023260: 2020 2022 6765 745f 6f70 745f 6c61 7365     "get_opt_lase
+00023270: 725f 636f 6e74 726f 6c22 2c0a 2020 2020  r_control",.    
+00023280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023290: 2022 6765 745f 6f70 745f 6861 735f 6c61   "get_opt_has_la
+000232a0: 7365 7222 2c0a 2020 2020 2020 2020 2020  ser",.          
+000232b0: 2020 2020 2020 2020 2020 2022 7365 745f             "set_
+000232c0: 6465 7465 6374 6f72 5f74 6563 5f73 6574  detector_tec_set
+000232d0: 706f 696e 745f 6465 6743 222c 0a20 2020  point_degC",.   
+000232e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000232f0: 2020 2267 6574 5f64 6574 6563 746f 725f    "get_detector_
+00023300: 7465 635f 7365 7470 6f69 6e74 5f72 6177  tec_setpoint_raw
+00023310: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+00023320: 2020 2020 2020 2020 2273 6574 5f73 656c          "set_sel
+00023330: 6563 7465 645f 6c61 7365 7222 2c0a 2020  ected_laser",.  
+00023340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023350: 2020 2022 6765 745f 7365 6c65 6374 6564     "get_selected
+00023360: 5f6c 6173 6572 222c 0a20 2020 2020 2020  _laser",.       
+00023370: 2020 2020 2020 2020 2020 2020 2020 2267                "g
+00023380: 6574 5f6c 6173 6572 5f65 6e61 626c 6564  et_laser_enabled
+00023390: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+000233a0: 2020 2020 2020 2020 2273 6574 5f6c 6173          "set_las
+000233b0: 6572 5f65 6e61 626c 6522 2c0a 2020 2020  er_enable",.    
 000233c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000233d0: 203d 206c 616d 6264 6120 783a 2073 656c   = lambda x: sel
-000233e0: 662e 7365 745f 6c61 6d70 5f65 6e61 626c  f.set_lamp_enabl
-000233f0: 6528 626f 6f6c 2878 2929 0d0a 2020 2020  e(bool(x))..    
-00023400: 2020 2020 7072 6f63 6573 735f 665b 2273      process_f["s
-00023410: 6875 7474 6572 5f65 6e61 626c 6522 5d20  hutter_enable"] 
+000233d0: 2022 7365 745f 6c61 7365 725f 706f 7765   "set_laser_powe
+000233e0: 725f 6d57 222c 0a20 2020 2020 2020 2020  r_mW",.         
+000233f0: 2020 2020 2020 2020 2020 2020 2273 6574              "set
+00023400: 5f6c 6173 6572 5f70 6f77 6572 5f68 6967  _laser_power_hig
+00023410: 685f 7265 736f 6c75 7469 6f6e 222c 0a20  h_resolution",. 
 00023420: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023430: 2020 2020 3d20 6c61 6d62 6461 2078 3a20      = lambda x: 
-00023440: 7365 6c66 2e73 6574 5f73 6875 7474 6572  self.set_shutter
-00023450: 5f65 6e61 626c 6528 626f 6f6c 2878 2929  _enable(bool(x))
-00023460: 0d0a 2020 2020 2020 2020 7072 6f63 6573  ..        proces
-00023470: 735f 665b 2273 7472 6f62 655f 656e 6162  s_f["strobe_enab
-00023480: 6c65 225d 2020 2020 2020 2020 2020 2020  le"]            
-00023490: 2020 2020 2020 2020 2020 3d20 6c61 6d62            = lamb
-000234a0: 6461 2078 3a20 7365 6c66 2e73 6574 5f73  da x: self.set_s
-000234b0: 7472 6f62 655f 656e 6162 6c65 2862 6f6f  trobe_enable(boo
-000234c0: 6c28 7829 290d 0a20 2020 2020 2020 2070  l(x))..        p
-000234d0: 726f 6365 7373 5f66 5b22 6d6f 645f 656e  rocess_f["mod_en
-000234e0: 6162 6c65 225d 2020 2020 2020 2020 2020  able"]          
-000234f0: 2020 2020 2020 2020 2020 2020 2020 203d                 =
-00023500: 206c 616d 6264 6120 783a 2073 656c 662e   lambda x: self.
-00023510: 7365 745f 6d6f 645f 656e 6162 6c65 2862  set_mod_enable(b
-00023520: 6f6f 6c28 7829 290d 0a20 2020 2020 2020  ool(x))..       
-00023530: 2070 726f 6365 7373 5f66 5b22 6d6f 645f   process_f["mod_
-00023540: 7065 7269 6f64 5f75 7322 5d20 2020 2020  period_us"]     
-00023550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023560: 203d 206c 616d 6264 6120 783a 2073 656c   = lambda x: sel
-00023570: 662e 7365 745f 6d6f 645f 7065 7269 6f64  f.set_mod_period
-00023580: 5f75 7328 696e 7428 726f 756e 6428 7829  _us(int(round(x)
-00023590: 2929 0d0a 2020 2020 2020 2020 7072 6f63  ))..        proc
-000235a0: 6573 735f 665b 226d 6f64 5f77 6964 7468  ess_f["mod_width
-000235b0: 5f75 7322 5d20 2020 2020 2020 2020 2020  _us"]           
-000235c0: 2020 2020 2020 2020 2020 2020 3d20 6c61              = la
-000235d0: 6d62 6461 2078 3a20 7365 6c66 2e73 6574  mbda x: self.set
-000235e0: 5f6d 6f64 5f77 6964 7468 5f75 7328 696e  _mod_width_us(in
-000235f0: 7428 726f 756e 6428 7829 2929 0d0a 0d0a  t(round(x)))....
-00023600: 2020 2020 2020 2020 2320 4261 7463 6843          # BatchC
-00023610: 6f6c 6c65 6374 696f 6e0d 0a20 2020 2020  ollection..     
-00023620: 2020 2070 726f 6365 7373 5f66 5b22 6672     process_f["fr
-00023630: 6565 5f72 756e 6e69 6e67 5f6d 6f64 6522  ee_running_mode"
-00023640: 5d20 2020 2020 2020 2020 2020 2020 2020  ]               
-00023650: 2020 203d 206c 616d 6264 6120 783a 2073     = lambda x: s
-00023660: 656c 662e 7365 7474 696e 6773 2e73 7461  elf.settings.sta
-00023670: 7465 2e73 6574 2822 6672 6565 5f72 756e  te.set("free_run
-00023680: 6e69 6e67 5f6d 6f64 6522 2c20 626f 6f6c  ning_mode", bool
-00023690: 2878 2929 0d0a 2020 2020 2020 2020 7072  (x))..        pr
-000236a0: 6f63 6573 735f 665b 2261 6371 7569 7369  ocess_f["acquisi
-000236b0: 7469 6f6e 5f6c 6173 6572 5f74 7269 6767  tion_laser_trigg
-000236c0: 6572 5f65 6e61 626c 6522 5d20 2020 3d20  er_enable"]   = 
-000236d0: 6c61 6d62 6461 2078 3a20 7365 6c66 2e73  lambda x: self.s
-000236e0: 6574 7469 6e67 732e 7374 6174 652e 7365  ettings.state.se
-000236f0: 7428 2261 6371 7569 7369 7469 6f6e 5f6c  t("acquisition_l
-00023700: 6173 6572 5f74 7269 6767 6572 5f65 6e61  aser_trigger_ena
-00023710: 626c 6522 2c20 626f 6f6c 2878 2929 0d0a  ble", bool(x))..
-00023720: 2020 2020 2020 2020 7072 6f63 6573 735f          process_
-00023730: 665b 2261 6371 7569 7369 7469 6f6e 5f6c  f["acquisition_l
-00023740: 6173 6572 5f74 7269 6767 6572 5f64 656c  aser_trigger_del
-00023750: 6179 5f6d 7322 5d20 3d20 6c61 6d62 6461  ay_ms"] = lambda
-00023760: 2078 3a20 7365 6c66 2e73 6574 7469 6e67   x: self.setting
-00023770: 732e 7374 6174 652e 7365 7428 2261 6371  s.state.set("acq
-00023780: 7569 7369 7469 6f6e 5f6c 6173 6572 5f74  uisition_laser_t
-00023790: 7269 6767 6572 5f64 656c 6179 5f6d 7322  rigger_delay_ms"
-000237a0: 2c20 696e 7428 726f 756e 6428 7829 2929  , int(round(x)))
-000237b0: 0d0a 2020 2020 2020 2020 7072 6f63 6573  ..        proces
-000237c0: 735f 665b 2261 6371 7569 7369 7469 6f6e  s_f["acquisition
-000237d0: 5f74 616b 655f 6461 726b 5f65 6e61 626c  _take_dark_enabl
-000237e0: 6522 5d20 2020 2020 2020 3d20 6c61 6d62  e"]       = lamb
-000237f0: 6461 2078 3a20 7365 6c66 2e73 6574 7469  da x: self.setti
-00023800: 6e67 732e 7374 6174 652e 7365 7428 2261  ngs.state.set("a
-00023810: 6371 7569 7369 7469 6f6e 5f74 616b 655f  cquisition_take_
-00023820: 6461 726b 5f65 6e61 626c 6522 2c20 626f  dark_enable", bo
-00023830: 6f6c 2878 2929 0d0a 0d0a 2020 2020 2020  ol(x))....      
-00023840: 2020 2320 5365 7269 6573 2d58 530d 0a20    # Series-XS.. 
-00023850: 2020 2020 2020 2366 5b22 7261 6d61 6e5f        #f["raman_
-00023860: 6d6f 6465 5f65 6e61 626c 6522 5d20 2020  mode_enable"]   
-00023870: 2020 2020 2020 2020 2020 2020 2020 203d                 =
-00023880: 206c 616d 6264 6120 783a 2073 656c 662e   lambda x: self.
-00023890: 7365 745f 7261 6d61 6e5f 6d6f 6465 5f65  set_raman_mode_e
-000238a0: 6e61 626c 6528 626f 6f6c 2878 2929 0d0a  nable(bool(x))..
-000238b0: 2020 2020 2020 2020 7072 6f63 6573 735f          process_
-000238c0: 665b 2272 616d 616e 5f64 656c 6179 5f6d  f["raman_delay_m
-000238d0: 7322 5d20 2020 2020 2020 2020 2020 2020  s"]             
-000238e0: 2020 2020 2020 2020 3d20 6c61 6d62 6461          = lambda
-000238f0: 2078 3a20 7365 6c66 2e73 6574 5f72 616d   x: self.set_ram
-00023900: 616e 5f64 656c 6179 5f6d 7328 696e 7428  an_delay_ms(int(
-00023910: 726f 756e 6428 7829 2929 0d0a 2020 2020  round(x)))..    
-00023920: 2020 2020 7072 6f63 6573 735f 665b 226c      process_f["l
-00023930: 6173 6572 5f77 6174 6368 646f 675f 7365  aser_watchdog_se
-00023940: 6322 5d20 2020 2020 2020 2020 2020 2020  c"]             
-00023950: 2020 2020 3d20 6c61 6d62 6461 2078 3a20      = lambda x: 
-00023960: 7365 6c66 2e73 6574 5f6c 6173 6572 5f77  self.set_laser_w
-00023970: 6174 6368 646f 675f 7365 6328 696e 7428  atchdog_sec(int(
-00023980: 726f 756e 6428 7829 2929 0d0a 0d0a 2020  round(x)))....  
-00023990: 2020 2020 2020 2320 7265 6769 6f6e 730d        # regions.
-000239a0: 0a20 2020 2020 2020 2070 726f 6365 7373  .        process
-000239b0: 5f66 5b22 7665 7274 6963 616c 5f62 696e  _f["vertical_bin
-000239c0: 6e69 6e67 225d 2020 2020 2020 2020 2020  ning"]          
-000239d0: 2020 2020 2020 2020 203d 206c 616d 6264           = lambd
-000239e0: 6120 783a 2073 656c 662e 7365 745f 7665  a x: self.set_ve
-000239f0: 7274 6963 616c 5f62 696e 6e69 6e67 2878  rtical_binning(x
-00023a00: 290d 0a20 2020 2020 2020 2070 726f 6365  )..        proce
-00023a10: 7373 5f66 5b22 7369 6e67 6c65 5f72 6567  ss_f["single_reg
-00023a20: 696f 6e22 5d20 2020 2020 2020 2020 2020  ion"]           
-00023a30: 2020 2020 2020 2020 2020 203d 206c 616d             = lam
-00023a40: 6264 6120 783a 2073 656c 662e 7365 745f  bda x: self.set_
-00023a50: 7369 6e67 6c65 5f72 6567 696f 6e28 696e  single_region(in
-00023a60: 7428 726f 756e 6428 7829 2929 0d0a 2020  t(round(x)))..  
-00023a70: 2020 2020 2020 7072 6f63 6573 735f 665b        process_f[
-00023a80: 2263 6c65 6172 5f72 6567 696f 6e73 225d  "clear_regions"]
-00023a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023aa0: 2020 2020 2020 3d20 6c61 6d62 6461 2078        = lambda x
-00023ab0: 3a20 7365 6c66 2e63 6c65 6172 5f72 6567  : self.clear_reg
-00023ac0: 696f 6e73 2829 0d0a 2020 2020 2020 2020  ions()..        
-00023ad0: 7072 6f63 6573 735f 665b 2264 6574 6563  process_f["detec
-00023ae0: 746f 725f 726f 6922 5d20 2020 2020 2020  tor_roi"]       
-00023af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023b00: 3d20 6c61 6d62 6461 2078 3a20 7365 6c66  = lambda x: self
-00023b10: 2e73 6574 5f64 6574 6563 746f 725f 726f  .set_detector_ro
-00023b20: 6928 7829 0d0a 2020 2020 2020 2020 7072  i(x)..        pr
-00023b30: 6f63 6573 735f 665b 2270 6978 656c 5f6d  ocess_f["pixel_m
-00023b40: 6f64 6522 5d20 2020 2020 2020 2020 2020  ode"]           
-00023b50: 2020 2020 2020 2020 2020 2020 2020 3d20                = 
-00023b60: 6c61 6d62 6461 2078 3a20 7365 6c66 2e73  lambda x: self.s
-00023b70: 6574 5f70 6978 656c 5f6d 6f64 6528 7829  et_pixel_mode(x)
-00023b80: 0d0a 0d0a 2020 2020 2020 2020 2320 4545  ....        # EE
-00023b90: 5052 4f4d 2075 7064 6174 6573 0d0a 2020  PROM updates..  
-00023ba0: 2020 2020 2020 7072 6f63 6573 735f 665b        process_f[
-00023bb0: 2275 7064 6174 655f 6565 7072 6f6d 225d  "update_eeprom"]
+00023430: 2020 2020 2273 6574 5f6c 6173 6572 5f70      "set_laser_p
+00023440: 6f77 6572 5f72 6571 7569 7265 5f6d 6f64  ower_require_mod
+00023450: 756c 6174 696f 6e22 2c0a 2020 2020 2020  ulation",.      
+00023460: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+00023470: 7365 745f 6c61 7365 725f 706f 7765 725f  set_laser_power_
+00023480: 7065 7263 222c 0a20 2020 2020 2020 2020  perc",.         
+00023490: 2020 2020 2020 2020 2020 2020 2273 6574              "set
+000234a0: 5f6c 6173 6572 5f70 6f77 6572 5f70 6572  _laser_power_per
+000234b0: 635f 696d 6d65 6469 6174 6522 2c0a 2020  c_immediate",.  
+000234c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000234d0: 2020 2022 6765 745f 6c61 7365 725f 7465     "get_laser_te
+000234e0: 6d70 6572 6174 7572 655f 7365 7470 6f69  mperature_setpoi
+000234f0: 6e74 5f72 6177 222c 0a20 2020 2020 2020  nt_raw",.       
+00023500: 2020 2020 2020 2020 2020 2020 2020 2273                "s
+00023510: 6574 5f6c 6173 6572 5f74 656d 7065 7261  et_laser_tempera
+00023520: 7475 7265 5f73 6574 706f 696e 745f 7261  ture_setpoint_ra
+00023530: 7722 2c0a 2020 2020 2020 2020 2020 2020  w",.            
+00023540: 2020 2020 2020 2020 2022 7570 6461 7465           "update
+00023550: 5f6c 6173 6572 5f77 6174 6368 646f 6722  _laser_watchdog"
+00023560: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00023570: 2020 2020 2020 2022 6765 745f 6c61 7365         "get_lase
+00023580: 725f 696e 7465 726c 6f63 6b22 2c0a 2020  r_interlock",.  
+00023590: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000235a0: 2020 2022 6361 6e5f 6c61 7365 725f 6669     "can_laser_fi
+000235b0: 7265 222c 0a20 2020 2020 2020 2020 2020  re",.           
+000235c0: 2020 2020 2020 2020 2020 2272 6573 6574            "reset
+000235d0: 5f66 7067 6122 2c0a 2020 2020 2020 2020  _fpga",.        
+000235e0: 2020 2020 2020 2020 2020 2020 2022 6765               "ge
+000235f0: 745f 7472 6967 6765 725f 736f 7572 6365  t_trigger_source
+00023600: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+00023610: 2020 2020 2020 2020 2267 6574 5f72 616d          "get_ram
+00023620: 616e 5f64 656c 6179 5f6d 7322 2c0a 2020  an_delay_ms",.  
+00023630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023640: 2020 2022 7365 745f 7261 6d61 6e5f 6465     "set_raman_de
+00023650: 6c61 795f 6d73 222c 0a20 2020 2020 2020  lay_ms",.       
+00023660: 2020 2020 2020 2020 2020 2020 2020 2267                "g
+00023670: 6574 5f6c 6173 6572 5f77 6174 6368 646f  et_laser_watchdo
+00023680: 675f 7365 6322 2c0a 2020 2020 2020 2020  g_sec",.        
+00023690: 2020 2020 2020 2020 2020 2020 2022 7365               "se
+000236a0: 745f 6c61 7365 725f 7761 7463 6864 6f67  t_laser_watchdog
+000236b0: 5f73 6563 222c 0a20 2020 2020 2020 2020  _sec",.         
+000236c0: 2020 2020 2020 2020 2020 2020 2273 6574              "set
+000236d0: 5f76 6572 7469 6361 6c5f 6269 6e6e 696e  _vertical_binnin
+000236e0: 6722 2c0a 2020 2020 2020 2020 2020 2020  g",.            
+000236f0: 2020 2020 2020 2020 2022 7365 745f 7069           "set_pi
+00023700: 7865 6c5f 6d6f 6465 222c 0a20 2020 2020  xel_mode",.     
+00023710: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023720: 2263 6c65 6172 5f72 6567 696f 6e73 222c  "clear_regions",
+00023730: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00023740: 2020 2020 2020 2273 6574 5f73 696e 676c        "set_singl
+00023750: 655f 7265 6769 6f6e 222c 0a20 2020 2020  e_region",.     
+00023760: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023770: 2273 6574 5f64 6574 6563 746f 725f 726f  "set_detector_ro
+00023780: 6922 2c0a 2020 2020 2020 2020 2020 2020  i",.            
+00023790: 2020 2020 2020 2020 2022 6765 745f 6670           "get_fp
+000237a0: 6761 5f63 6f6e 6669 6775 7261 7469 6f6e  ga_configuration
+000237b0: 5f72 6567 6973 7465 7222 2c0a 2020 2020  _register",.    
+000237c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000237d0: 2022 7365 745f 6163 6365 7373 6f72 795f   "set_accessory_
+000237e0: 656e 6162 6c65 222c 0a20 2020 2020 2020  enable",.       
+000237f0: 2020 2020 2020 2020 2020 2020 2020 2267                "g
+00023800: 6574 5f64 6973 6372 6574 6573 5f65 6e61  et_discretes_ena
+00023810: 626c 6564 222c 0a20 2020 2020 2020 2020  bled",.         
+00023820: 2020 2020 2020 2020 2020 2020 2273 6574              "set
+00023830: 5f66 616e 5f65 6e61 626c 6522 2c0a 2020  _fan_enable",.  
+00023840: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023850: 2020 2022 6765 745f 6661 6e5f 656e 6162     "get_fan_enab
+00023860: 6c65 6422 2c0a 2020 2020 2020 2020 2020  led",.          
+00023870: 2020 2020 2020 2020 2020 2022 7365 745f             "set_
+00023880: 6c61 6d70 5f65 6e61 626c 6522 2c0a 2020  lamp_enable",.  
+00023890: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000238a0: 2020 2022 6765 745f 6c61 6d70 5f65 6e61     "get_lamp_ena
+000238b0: 626c 6564 222c 0a20 2020 2020 2020 2020  bled",.         
+000238c0: 2020 2020 2020 2020 2020 2020 2273 6574              "set
+000238d0: 5f73 6875 7474 6572 5f65 6e61 626c 6522  _shutter_enable"
+000238e0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+000238f0: 2020 2020 2020 2022 6765 745f 7368 7574         "get_shut
+00023900: 7465 725f 656e 6162 6c65 6422 2c0a 2020  ter_enabled",.  
+00023910: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023920: 2020 2022 7365 745f 6d6f 645f 656e 6162     "set_mod_enab
+00023930: 6c65 222c 0a20 2020 2020 2020 2020 2020  le",.           
+00023940: 2020 2020 2020 2020 2020 2267 6574 5f6d            "get_m
+00023950: 6f64 5f65 6e61 626c 6564 222c 0a20 2020  od_enabled",.   
+00023960: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023970: 2020 2273 6574 5f6d 6f64 5f70 6572 696f    "set_mod_perio
+00023980: 645f 7573 222c 0a20 2020 2020 2020 2020  d_us",.         
+00023990: 2020 2020 2020 2020 2020 2020 2267 6574              "get
+000239a0: 5f6d 6f64 5f70 6572 696f 645f 7573 222c  _mod_period_us",
+000239b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000239c0: 2020 2020 2020 2273 6574 5f6d 6f64 5f77        "set_mod_w
+000239d0: 6964 7468 5f75 7322 2c0a 2020 2020 2020  idth_us",.      
+000239e0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+000239f0: 6765 745f 6d6f 645f 7769 6474 685f 7573  get_mod_width_us
+00023a00: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+00023a10: 2020 2020 2020 2020 2273 6574 5f6d 6f64          "set_mod
+00023a20: 5f64 656c 6179 5f75 7322 2c0a 2020 2020  _delay_us",.    
+00023a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023a40: 2022 6765 745f 6d6f 645f 6465 6c61 795f   "get_mod_delay_
+00023a50: 7573 222c 0a20 2020 2020 2020 2020 2020  us",.           
+00023a60: 2020 2020 2020 2020 2020 2267 6574 5f6d            "get_m
+00023a70: 6f64 5f64 7572 6174 696f 6e5f 7573 222c  od_duration_us",
+00023a80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00023a90: 2020 2020 2020 2273 6574 5f73 7472 6f62        "set_strob
+00023aa0: 655f 656e 6162 6c65 222c 0a20 2020 2020  e_enable",.     
+00023ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023ac0: 2267 6574 5f73 7472 6f62 655f 656e 6162  "get_strobe_enab
+00023ad0: 6c65 6422 2c0a 2020 2020 2020 2020 2020  led",.          
+00023ae0: 2020 2020 2020 2020 2020 2022 6765 745f             "get_
+00023af0: 616d 6269 656e 745f 7465 6d70 6572 6174  ambient_temperat
+00023b00: 7572 655f 6465 6743 222c 0a20 2020 2020  ure_degC",.     
+00023b10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023b20: 2267 6574 5f74 6563 5f65 6e61 626c 6564  "get_tec_enabled
+00023b30: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+00023b40: 2020 2020 2020 2020 2267 6574 5f61 6374          "get_act
+00023b50: 7561 6c5f 6672 616d 6573 222c 0a20 2020  ual_frames",.   
+00023b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023b70: 2020 2267 6574 5f61 6374 7561 6c5f 696e    "get_actual_in
+00023b80: 7465 6772 6174 696f 6e5f 7469 6d65 5f75  tegration_time_u
+00023b90: 7322 2c0a 2020 2020 2020 2020 2020 2020  s",.            
+00023ba0: 2020 2020 2020 2020 2022 6765 745f 6465           "get_de
+00023bb0: 7465 6374 6f72 5f6f 6666 7365 7422 2c0a  tector_offset",.
 00023bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023bd0: 2020 2020 2020 3d20 6c61 6d62 6461 2078        = lambda x
-00023be0: 3a20 7365 6c66 2e75 7064 6174 655f 7365  : self.update_se
-00023bf0: 7373 696f 6e5f 6565 7072 6f6d 2878 290d  ssion_eeprom(x).
-00023c00: 0a20 2020 2020 2020 2070 726f 6365 7373  .        process
-00023c10: 5f66 5b22 7265 706c 6163 655f 6565 7072  _f["replace_eepr
-00023c20: 6f6d 225d 2020 2020 2020 2020 2020 2020  om"]            
-00023c30: 2020 2020 2020 2020 203d 206c 616d 6264           = lambd
-00023c40: 6120 783a 2073 656c 662e 7265 706c 6163  a x: self.replac
-00023c50: 655f 7365 7373 696f 6e5f 6565 7072 6f6d  e_session_eeprom
-00023c60: 2878 290d 0a20 2020 2020 2020 2070 726f  (x)..        pro
-00023c70: 6365 7373 5f66 5b22 7772 6974 655f 6565  cess_f["write_ee
-00023c80: 7072 6f6d 225d 2020 2020 2020 2020 2020  prom"]          
-00023c90: 2020 2020 2020 2020 2020 2020 203d 206c               = l
-00023ca0: 616d 6264 6120 783a 2073 656c 662e 7772  ambda x: self.wr
-00023cb0: 6974 655f 6565 7072 6f6d 2829 0d0a 0d0a  ite_eeprom()....
-00023cc0: 2020 2020 2020 2020 2320 6d61 6e75 6661          # manufa
-00023cd0: 6374 7572 696e 670d 0a20 2020 2020 2020  cturing..       
-00023ce0: 2070 726f 6365 7373 5f66 5b22 7265 7365   process_f["rese
-00023cf0: 745f 6670 6761 225d 2020 2020 2020 2020  t_fpga"]        
-00023d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023d10: 203d 206c 616d 6264 6120 783a 2073 656c   = lambda x: sel
-00023d20: 662e 7265 7365 745f 6670 6761 2829 0d0a  f.reset_fpga()..
-00023d30: 2020 2020 2020 2020 7072 6f63 6573 735f          process_
-00023d40: 665b 2264 6675 5f65 6e61 626c 6522 5d20  f["dfu_enable"] 
-00023d50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023d60: 2020 2020 2020 2020 3d20 6c61 6d62 6461          = lambda
-00023d70: 2078 3a20 7365 6c66 2e73 6574 5f64 6675   x: self.set_dfu
-00023d80: 5f65 6e61 626c 6528 290d 0a0d 0a20 2020  _enable()....   
-00023d90: 2020 2020 2023 206c 6567 6163 790d 0a20       # legacy.. 
-00023da0: 2020 2020 2020 2070 726f 6365 7373 5f66         process_f
-00023db0: 5b22 616c 6c6f 775f 6465 6661 756c 745f  ["allow_default_
-00023dc0: 6761 696e 5f72 6573 6574 225d 2020 2020  gain_reset"]    
-00023dd0: 2020 2020 2020 203d 206c 616d 6264 6120         = lambda 
-00023de0: 783a 2073 6574 6174 7472 2873 656c 662c  x: setattr(self,
-00023df0: 2022 616c 6c6f 775f 6465 6661 756c 745f   "allow_default_
-00023e00: 6761 696e 5f72 6573 6574 222c 2062 6f6f  gain_reset", boo
-00023e10: 6c28 7829 290d 0a0d 0a20 2020 2020 2020  l(x))....       
-00023e20: 2023 2065 7870 6572 696d 656e 7461 6c20   # experimental 
-00023e30: 2852 2644 290d 0a20 2020 2020 2020 2070  (R&D)..        p
-00023e40: 726f 6365 7373 5f66 5b22 6772 6170 685f  rocess_f["graph_
-00023e50: 616c 7465 726e 6174 696e 675f 7069 7865  alternating_pixe
-00023e60: 6c73 225d 2020 2020 2020 2020 2020 203d  ls"]           =
-00023e70: 206c 616d 6264 6120 783a 2073 656c 662e   lambda x: self.
-00023e80: 7365 7474 696e 6773 2e73 7461 7465 2e73  settings.state.s
-00023e90: 6574 2822 6772 6170 685f 616c 7465 726e  et("graph_altern
-00023ea0: 6174 696e 675f 7069 7865 6c73 222c 2062  ating_pixels", b
-00023eb0: 6f6f 6c28 7829 290d 0a20 2020 2020 2020  ool(x))..       
-00023ec0: 2070 726f 6365 7373 5f66 5b22 7377 6170   process_f["swap
-00023ed0: 5f61 6c74 6572 6e61 7469 6e67 5f70 6978  _alternating_pix
-00023ee0: 656c 7322 5d20 2020 2020 2020 2020 2020  els"]           
-00023ef0: 203d 206c 616d 6264 6120 783a 2073 656c   = lambda x: sel
-00023f00: 662e 7365 7474 696e 6773 2e73 7461 7465  f.settings.state
-00023f10: 2e73 6574 2822 7377 6170 5f61 6c74 6572  .set("swap_alter
-00023f20: 6e61 7469 6e67 5f70 6978 656c 7322 2c20  nating_pixels", 
-00023f30: 626f 6f6c 2878 2929 0d0a 2020 2020 2020  bool(x))..      
-00023f40: 2020 7072 6f63 6573 735f 665b 2269 6e76    process_f["inv
-00023f50: 6572 745f 785f 6178 6973 225d 2020 2020  ert_x_axis"]    
-00023f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023f70: 2020 3d20 6c61 6d62 6461 2078 3a20 7365    = lambda x: se
-00023f80: 6c66 2e73 6574 7469 6e67 732e 6565 7072  lf.settings.eepr
-00023f90: 6f6d 2e73 6574 2822 696e 7665 7274 5f78  om.set("invert_x
-00023fa0: 5f61 7869 7322 2c20 626f 6f6c 2878 2929  _axis", bool(x))
-00023fb0: 0d0a 2020 2020 2020 2020 7072 6f63 6573  ..        proces
-00023fc0: 735f 665b 2262 696e 5f32 7832 225d 2020  s_f["bin_2x2"]  
+00023bd0: 2020 2020 2022 6765 745f 6465 7465 6374       "get_detect
+00023be0: 6f72 5f6f 6666 7365 745f 6f64 6422 2c0a  or_offset_odd",.
+00023bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023c00: 2020 2020 2022 6765 745f 6363 645f 7365       "get_ccd_se
+00023c10: 6e73 696e 675f 7468 7265 7368 6f6c 6422  nsing_threshold"
+00023c20: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00023c30: 2020 2020 2020 2022 6765 745f 6363 645f         "get_ccd_
+00023c40: 7468 7265 7368 6f6c 645f 7365 6e73 696e  threshold_sensin
+00023c50: 675f 6d6f 6465 222c 0a20 2020 2020 2020  g_mode",.       
+00023c60: 2020 2020 2020 2020 2020 2020 2020 2267                "g
+00023c70: 6574 5f65 7874 6572 6e61 6c5f 7472 6967  et_external_trig
+00023c80: 6765 725f 6f75 7470 7574 222c 0a20 2020  ger_output",.   
+00023c90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023ca0: 2020 2263 616e 5f6c 6173 6572 5f66 6972    "can_laser_fir
+00023cb0: 6522 2c0a 2020 2020 2020 2020 2020 2020  e",.            
+00023cc0: 2020 2020 2020 2020 2022 6973 5f6c 6173           "is_las
+00023cd0: 6572 5f66 6972 696e 6722 2c0a 2020 2020  er_firing",.    
+00023ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023cf0: 2022 6765 745f 6c61 7365 725f 656e 6162   "get_laser_enab
+00023d00: 6c65 6422 2c0a 2020 2020 2020 2020 2020  led",.          
+00023d10: 2020 2020 2020 2020 2020 2022 7365 745f             "set_
+00023d20: 6d6f 645f 6c69 6e6b 6564 5f74 6f5f 696e  mod_linked_to_in
+00023d30: 7465 6772 6174 696f 6e22 2c0a 2020 2020  tegration",.    
+00023d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023d50: 2022 6765 745f 7365 6c65 6374 6564 5f61   "get_selected_a
+00023d60: 6463 222c 0a20 2020 2020 2020 2020 2020  dc",.           
+00023d70: 2020 2020 2020 2020 2020 2273 6574 5f74            "set_t
+00023d80: 7269 6767 6572 5f64 656c 6179 222c 0a20  rigger_delay",. 
+00023d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023da0: 2020 2020 2267 6574 5f74 7269 6767 6572      "get_trigger
+00023db0: 5f64 656c 6179 222c 0a20 2020 2020 2020  _delay",.       
+00023dc0: 2020 2020 2020 2020 2020 2020 2020 2267                "g
+00023dd0: 6574 5f76 725f 636f 6e74 696e 756f 7573  et_vr_continuous
+00023de0: 5f63 6364 222c 0a20 2020 2020 2020 2020  _ccd",.         
+00023df0: 2020 2020 2020 2020 2020 2020 2267 6574              "get
+00023e00: 5f76 725f 6e75 6d5f 6672 616d 6573 222c  _vr_num_frames",
+00023e10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00023e20: 2020 2020 2020 2267 6574 5f6f 7074 5f61        "get_opt_a
+00023e30: 6374 7561 6c5f 696e 7465 6772 6174 696f  ctual_integratio
+00023e40: 6e5f 7469 6d65 222c 0a20 2020 2020 2020  n_time",.       
+00023e50: 2020 2020 2020 2020 2020 2020 2020 2267                "g
+00023e60: 6574 5f6f 7074 5f61 7265 615f 7363 616e  et_opt_area_scan
+00023e70: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+00023e80: 2020 2020 2020 2020 2267 6574 5f6f 7074          "get_opt
+00023e90: 5f63 665f 7365 6c65 6374 222c 0a20 2020  _cf_select",.   
+00023ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023eb0: 2020 2267 6574 5f6f 7074 5f64 6174 615f    "get_opt_data_
+00023ec0: 6865 6164 6572 5f74 6162 222c 0a20 2020  header_tab",.   
+00023ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023ee0: 2020 2267 6574 5f6f 7074 5f68 6f72 697a    "get_opt_horiz
+00023ef0: 6f6e 7461 6c5f 6269 6e6e 696e 6722 2c0a  ontal_binning",.
+00023f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023f10: 2020 2020 2022 6765 745f 6f70 745f 696e       "get_opt_in
+00023f20: 7465 6772 6174 696f 6e5f 7469 6d65 5f72  tegration_time_r
+00023f30: 6573 6f6c 7574 696f 6e22 2c0a 2020 2020  esolution",.    
+00023f40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023f50: 2022 7365 745f 616e 616c 6f67 5f6f 7574   "set_analog_out
+00023f60: 7075 745f 6d6f 6465 222c 0a20 2020 2020  put_mode",.     
+00023f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023f80: 2273 6574 5f61 6e61 6c6f 675f 6f75 7470  "set_analog_outp
+00023f90: 7574 5f76 616c 7565 222c 0a20 2020 2020  ut_value",.     
+00023fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023fb0: 2267 6574 5f61 6e61 6c6f 675f 6f75 7470  "get_analog_outp
+00023fc0: 7574 5f73 7461 7465 222c 0a20 2020 2020  ut_state",.     
 00023fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023fe0: 2020 2020 2020 2020 2020 3d20 6c61 6d62            = lamb
-00023ff0: 6461 2078 3a20 7365 6c66 2e73 6574 7469  da x: self.setti
-00024000: 6e67 732e 6565 7072 6f6d 2e73 6574 2822  ngs.eeprom.set("
-00024010: 6269 6e5f 3278 3222 2c20 626f 6f6c 2878  bin_2x2", bool(x
-00024020: 2929 0d0a 2020 2020 2020 2020 7072 6f63  ))..        proc
-00024030: 6573 735f 665b 2277 6176 656e 756d 6265  ess_f["wavenumbe
-00024040: 725f 636f 7272 6563 7469 6f6e 225d 2020  r_correction"]  
-00024050: 2020 2020 2020 2020 2020 2020 3d20 6c61              = la
-00024060: 6d62 6461 2078 3a20 7365 6c66 2e73 6574  mbda x: self.set
-00024070: 7469 6e67 732e 7365 745f 7761 7665 6e75  tings.set_wavenu
-00024080: 6d62 6572 5f63 6f72 7265 6374 696f 6e28  mber_correction(
-00024090: 666c 6f61 7428 7829 290d 0a0d 0a20 2020  float(x))....   
-000240a0: 2020 2020 2023 2068 6561 7274 6265 6174       # heartbeat
-000240b0: 7320 2620 636f 6e6e 6563 7469 6f6e 2064  s & connection d
-000240c0: 6174 610d 0a20 2020 2020 2020 2070 726f  ata..        pro
-000240d0: 6365 7373 5f66 5b22 7261 6973 655f 6578  cess_f["raise_ex
-000240e0: 6365 7074 696f 6e73 225d 2020 2020 2020  ceptions"]      
-000240f0: 2020 2020 2020 2020 2020 2020 203d 206c               = l
-00024100: 616d 6264 6120 783a 2073 6574 6174 7472  ambda x: setattr
-00024110: 2873 656c 662c 2022 7261 6973 655f 6578  (self, "raise_ex
-00024120: 6365 7074 696f 6e73 222c 2062 6f6f 6c28  ceptions", bool(
-00024130: 7829 290d 0a20 2020 2020 2020 2070 726f  x))..        pro
-00024140: 6365 7373 5f66 5b22 6c6f 675f 6c65 7665  cess_f["log_leve
-00024150: 6c22 5d20 2020 2020 2020 2020 2020 2020  l"]             
-00024160: 2020 2020 2020 2020 2020 2020 203d 206c               = l
-00024170: 616d 6264 6120 783a 2073 656c 662e 7365  ambda x: self.se
-00024180: 745f 6c6f 675f 6c65 7665 6c28 7829 0d0a  t_log_level(x)..
-00024190: 2020 2020 2020 2020 7072 6f63 6573 735f          process_
-000241a0: 665b 226e 756d 5f63 6f6e 6e65 6374 6564  f["num_connected
-000241b0: 5f64 6576 6963 6573 225d 2020 2020 2020  _devices"]      
-000241c0: 2020 2020 2020 2020 3d20 6c61 6d62 6461          = lambda
-000241d0: 2078 3a20 7365 6c66 2e73 6574 7469 6e67   x: self.setting
-000241e0: 732e 7365 745f 6e75 6d5f 636f 6e6e 6563  s.set_num_connec
-000241f0: 7465 645f 6465 7669 6365 7328 696e 7428  ted_devices(int(
-00024200: 7829 290d 0a20 2020 2020 2020 2070 726f  x))..        pro
-00024210: 6365 7373 5f66 5b22 7375 6270 726f 6365  cess_f["subproce
-00024220: 7373 5f74 696d 656f 7574 5f73 6563 225d  ss_timeout_sec"]
-00024230: 2020 2020 2020 2020 2020 2020 203d 206c               = l
-00024240: 616d 6264 6120 783a 204e 6f6e 650d 0a20  ambda x: None.. 
-00024250: 2020 2020 2020 2070 726f 6365 7373 5f66         process_f
-00024260: 5b22 6865 6172 7462 6561 7422 5d20 2020  ["heartbeat"]   
-00024270: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024280: 2020 2020 2020 203d 206c 616d 6264 6120         = lambda 
-00024290: 783a 204e 6f6e 650d 0a20 2020 2020 2020  x: None..       
-000242a0: 2070 726f 6365 7373 5f66 5b22 7265 7365   process_f["rese
-000242b0: 7422 5d20 2020 2020 2020 2020 2020 2020  t"]             
-000242c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000242d0: 203d 2073 656c 662e 7265 7365 740d 0a0d   = self.reset...
-000242e0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-000242f0: 7072 6f63 6573 735f 660d 0a              process_f..
+00023fe0: 2267 6574 5f61 6e61 6c6f 675f 696e 7075  "get_analog_inpu
+00023ff0: 745f 7661 6c75 6522 2c0a 2020 2020 2020  t_value",.      
+00024000: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+00024010: 7570 6461 7465 5f73 6573 7369 6f6e 5f65  update_session_e
+00024020: 6570 726f 6d22 2c0a 2020 2020 2020 2020  eprom",.        
+00024030: 2020 2020 2020 2020 2020 2020 2022 7265               "re
+00024040: 706c 6163 655f 7365 7373 696f 6e5f 6565  place_session_ee
+00024050: 7072 6f6d 222c 0a20 2020 2020 2020 2020  prom",.         
+00024060: 2020 2020 2020 2020 2020 2020 2277 7269              "wri
+00024070: 7465 5f65 6570 726f 6d22 2c0a 2020 2020  te_eeprom",.    
+00024080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024090: 2022 7365 745f 6c6f 675f 6c65 7665 6c22   "set_log_level"
+000240a0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+000240b0: 2020 2020 2020 2022 7175 6575 655f 6d65         "queue_me
+000240c0: 7373 6167 6522 205d 3a0a 2020 2020 2020  ssage" ]:.      
+000240d0: 2020 2020 2020 7072 6f63 6573 735f 665b        process_f[
+000240e0: 666e 5f6e 616d 655d 203d 2067 6574 6174  fn_name] = getat
+000240f0: 7472 2873 656c 662c 2066 6e5f 6e61 6d65  tr(self, fn_name
+00024100: 290a 2020 2020 0a20 2020 2020 2020 2023  ).    .        #
+00024110: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00024120: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00024130: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00024140: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00024150: 230a 2020 2020 2020 2020 2320 5768 6174  #.        # What
+00024160: 2066 6f6c 6c6f 7773 2069 7320 7468 6520   follows is the 
+00024170: 6f6c 6420 696e 6974 2d6c 616d 6264 6173  old init-lambdas
+00024180: 2074 6861 7420 6172 6520 7371 7561 7368   that are squash
+00024190: 6564 2069 6e74 6f20 7072 6f63 6573 735f  ed into process_
+000241a0: 660a 2020 2020 2020 2020 2320 4c6f 6e67  f.        # Long
+000241b0: 2074 6572 6d2c 2074 6865 2075 7073 7472   term, the upstr
+000241c0: 6561 6d20 7265 7175 6573 7473 2073 686f  eam requests sho
+000241d0: 756c 6420 6265 2063 6861 6e67 6564 2074  uld be changed t
+000241e0: 6f20 6d61 7463 6820 7468 6520 6e65 7720  o match the new 
+000241f0: 666f 726d 6174 0a20 2020 2020 2020 2023  format.        #
+00024200: 2054 6869 7320 6973 2061 6e20 6561 7379   This is an easy
+00024210: 2066 6978 2066 6f72 2074 6865 2074 696d   fix for the tim
+00024220: 6520 6265 696e 6720 746f 206d 616b 6520  e being to make 
+00024230: 7468 696e 6773 2062 6568 6176 650a 2020  things behave.  
+00024240: 2020 2020 2020 2323 2323 2323 2323 2323        ##########
+00024250: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00024260: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00024270: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00024280: 2323 2323 2323 2323 0a20 2020 2020 2020  ########.       
+00024290: 2023 2073 7065 6374 726f 6d65 7465 7220   # spectrometer 
+000242a0: 636f 6e74 726f 6c0a 2020 2020 2020 2020  control.        
+000242b0: 7072 6f63 6573 735f 665b 226c 6173 6572  process_f["laser
+000242c0: 5f65 6e61 626c 6522 5d20 2020 2020 2020  _enable"]       
+000242d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000242e0: 3d20 6c61 6d62 6461 2078 3a20 7365 6c66  = lambda x: self
+000242f0: 2e73 6574 5f6c 6173 6572 5f65 6e61 626c  .set_laser_enabl
+00024300: 6528 626f 6f6c 2878 2929 0a20 2020 2020  e(bool(x)).     
+00024310: 2020 2070 726f 6365 7373 5f66 5b22 696e     process_f["in
+00024320: 7465 6772 6174 696f 6e5f 7469 6d65 5f6d  tegration_time_m
+00024330: 7322 5d20 2020 2020 2020 2020 2020 2020  s"]             
+00024340: 2020 203d 206c 616d 6264 6120 783a 2073     = lambda x: s
+00024350: 656c 662e 7365 745f 696e 7465 6772 6174  elf.set_integrat
+00024360: 696f 6e5f 7469 6d65 5f6d 7328 7829 0a0a  ion_time_ms(x)..
+00024370: 2020 2020 2020 2020 7072 6f63 6573 735f          process_
+00024380: 665b 2264 6574 6563 746f 725f 7465 635f  f["detector_tec_
+00024390: 7365 7470 6f69 6e74 5f64 6567 4322 5d20  setpoint_degC"] 
+000243a0: 2020 2020 2020 2020 3d20 6c61 6d62 6461          = lambda
+000243b0: 2078 3a20 7365 6c66 2e73 6574 5f64 6574   x: self.set_det
+000243c0: 6563 746f 725f 7465 635f 7365 7470 6f69  ector_tec_setpoi
+000243d0: 6e74 5f64 6567 4328 696e 7428 726f 756e  nt_degC(int(roun
+000243e0: 6428 7829 2929 0a20 2020 2020 2020 2070  d(x))).        p
+000243f0: 726f 6365 7373 5f66 5b22 6465 7465 6374  rocess_f["detect
+00024400: 6f72 5f74 6563 5f65 6e61 626c 6522 5d20  or_tec_enable"] 
+00024410: 2020 2020 2020 2020 2020 2020 2020 203d                 =
+00024420: 206c 616d 6264 6120 783a 2073 656c 662e   lambda x: self.
+00024430: 7365 745f 7465 635f 656e 6162 6c65 2862  set_tec_enable(b
+00024440: 6f6f 6c28 7829 290a 2020 2020 2020 2020  ool(x)).        
+00024450: 7072 6f63 6573 735f 665b 2264 6574 6563  process_f["detec
+00024460: 746f 725f 6761 696e 225d 2020 2020 2020  tor_gain"]      
+00024470: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024480: 3d20 6c61 6d62 6461 2078 3a20 7365 6c66  = lambda x: self
+00024490: 2e73 6574 5f64 6574 6563 746f 725f 6761  .set_detector_ga
+000244a0: 696e 2866 6c6f 6174 2878 2929 0a20 2020  in(float(x)).   
+000244b0: 2020 2020 2070 726f 6365 7373 5f66 5b22       process_f["
+000244c0: 6465 7465 6374 6f72 5f6f 6666 7365 7422  detector_offset"
+000244d0: 5d20 2020 2020 2020 2020 2020 2020 2020  ]               
+000244e0: 2020 2020 203d 206c 616d 6264 6120 783a       = lambda x:
+000244f0: 2073 656c 662e 7365 745f 6465 7465 6374   self.set_detect
+00024500: 6f72 5f6f 6666 7365 7428 696e 7428 726f  or_offset(int(ro
+00024510: 756e 6428 7829 2929 0a20 2020 2020 2020  und(x))).       
+00024520: 2070 726f 6365 7373 5f66 5b22 6465 7465   process_f["dete
+00024530: 6374 6f72 5f67 6169 6e5f 6f64 6422 5d20  ctor_gain_odd"] 
+00024540: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024550: 203d 206c 616d 6264 6120 783a 2073 656c   = lambda x: sel
+00024560: 662e 7365 745f 6465 7465 6374 6f72 5f67  f.set_detector_g
+00024570: 6169 6e5f 6f64 6428 666c 6f61 7428 7829  ain_odd(float(x)
+00024580: 290a 2020 2020 2020 2020 7072 6f63 6573  ).        proces
+00024590: 735f 665b 2264 6574 6563 746f 725f 6f66  s_f["detector_of
+000245a0: 6673 6574 5f6f 6464 225d 2020 2020 2020  fset_odd"]      
+000245b0: 2020 2020 2020 2020 2020 3d20 6c61 6d62            = lamb
+000245c0: 6461 2078 3a20 7365 6c66 2e73 6574 5f64  da x: self.set_d
+000245d0: 6574 6563 746f 725f 6f66 6673 6574 5f6f  etector_offset_o
+000245e0: 6464 2869 6e74 2872 6f75 6e64 2878 2929  dd(int(round(x))
+000245f0: 290a 2020 2020 2020 2020 7072 6f63 6573  ).        proces
+00024600: 735f 665b 2264 6567 435f 746f 5f64 6163  s_f["degC_to_dac
+00024610: 5f63 6f65 6666 7322 5d20 2020 2020 2020  _coeffs"]       
+00024620: 2020 2020 2020 2020 2020 3d20 6c61 6d62            = lamb
+00024630: 6461 2078 3a20 7365 6c66 2e73 6574 7469  da x: self.setti
+00024640: 6e67 732e 6565 7072 6f6d 2e73 6574 2822  ngs.eeprom.set("
+00024650: 6465 6743 5f74 6f5f 6461 635f 636f 6566  degC_to_dac_coef
+00024660: 6673 222c 2078 290a 0a20 2020 2020 2020  fs", x)..       
+00024670: 2070 726f 6365 7373 5f66 5b22 6c61 7365   process_f["lase
+00024680: 725f 706f 7765 725f 7065 7263 225d 2020  r_power_perc"]  
+00024690: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000246a0: 203d 206c 616d 6264 6120 783a 2073 656c   = lambda x: sel
+000246b0: 662e 7365 745f 6c61 7365 725f 706f 7765  f.set_laser_powe
+000246c0: 725f 7065 7263 2878 290a 2020 2020 2020  r_perc(x).      
+000246d0: 2020 7072 6f63 6573 735f 665b 226c 6173    process_f["las
+000246e0: 6572 5f70 6f77 6572 5f6d 5722 5d20 2020  er_power_mW"]   
+000246f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024700: 2020 3d20 6c61 6d62 6461 2078 3a20 7365    = lambda x: se
+00024710: 6c66 2e73 6574 5f6c 6173 6572 5f70 6f77  lf.set_laser_pow
+00024720: 6572 5f6d 5728 7829 0a20 2020 2020 2020  er_mW(x).       
+00024730: 2070 726f 6365 7373 5f66 5b22 6c61 7365   process_f["lase
+00024740: 725f 7465 6d70 6572 6174 7572 655f 7365  r_temperature_se
+00024750: 7470 6f69 6e74 5f72 6177 225d 2020 2020  tpoint_raw"]    
+00024760: 203d 206c 616d 6264 6120 783a 2073 656c   = lambda x: sel
+00024770: 662e 7365 745f 6c61 7365 725f 7465 6d70  f.set_laser_temp
+00024780: 6572 6174 7572 655f 7365 7470 6f69 6e74  erature_setpoint
+00024790: 5f72 6177 2869 6e74 2872 6f75 6e64 2878  _raw(int(round(x
+000247a0: 2929 290a 2020 2020 2020 2020 7072 6f63  ))).        proc
+000247b0: 6573 735f 665b 226c 6173 6572 5f70 6f77  ess_f["laser_pow
+000247c0: 6572 5f61 7474 656e 7561 746f 7222 5d20  er_attenuator"] 
+000247d0: 2020 2020 2020 2020 2020 2020 3d20 6c61              = la
+000247e0: 6d62 6461 2078 3a20 7365 6c66 2e73 6574  mbda x: self.set
+000247f0: 5f6c 6173 6572 5f70 6f77 6572 5f61 7474  _laser_power_att
+00024800: 656e 7561 746f 7228 696e 7428 726f 756e  enuator(int(roun
+00024810: 6428 7829 2929 0a20 2020 2020 2020 2070  d(x))).        p
+00024820: 726f 6365 7373 5f66 5b22 6c61 7365 725f  rocess_f["laser_
+00024830: 706f 7765 725f 6869 6768 5f72 6573 6f6c  power_high_resol
+00024840: 7574 696f 6e22 5d20 2020 2020 2020 203d  ution"]        =
+00024850: 206c 616d 6264 6120 783a 2073 656c 662e   lambda x: self.
+00024860: 7365 745f 6c61 7365 725f 706f 7765 725f  set_laser_power_
+00024870: 6869 6768 5f72 6573 6f6c 7574 696f 6e28  high_resolution(
+00024880: 7829 0a20 2020 2020 2020 2070 726f 6365  x).        proce
+00024890: 7373 5f66 5b22 6c61 7365 725f 706f 7765  ss_f["laser_powe
+000248a0: 725f 7265 7175 6972 655f 6d6f 6475 6c61  r_require_modula
+000248b0: 7469 6f6e 225d 2020 2020 203d 206c 616d  tion"]     = lam
+000248c0: 6264 6120 783a 2073 656c 662e 7365 745f  bda x: self.set_
+000248d0: 6c61 7365 725f 706f 7765 725f 7265 7175  laser_power_requ
+000248e0: 6972 655f 6d6f 6475 6c61 7469 6f6e 2878  ire_modulation(x
+000248f0: 290a 2020 2020 2020 2020 7072 6f63 6573  ).        proces
+00024900: 735f 665b 2273 656c 6563 7465 645f 6c61  s_f["selected_la
+00024910: 7365 7222 5d20 2020 2020 2020 2020 2020  ser"]           
+00024920: 2020 2020 2020 2020 2020 3d20 6c61 6d62            = lamb
+00024930: 6461 2078 3a20 7365 6c66 2e73 6574 5f73  da x: self.set_s
+00024940: 656c 6563 7465 645f 6c61 7365 7228 696e  elected_laser(in
+00024950: 7428 7829 290a 0a20 2020 2020 2020 2070  t(x))..        p
+00024960: 726f 6365 7373 5f66 5b22 6869 6768 5f67  rocess_f["high_g
+00024970: 6169 6e5f 6d6f 6465 5f65 6e61 626c 6522  ain_mode_enable"
+00024980: 5d20 2020 2020 2020 2020 2020 2020 203d  ]              =
+00024990: 206c 616d 6264 6120 783a 2073 656c 662e   lambda x: self.
+000249a0: 7365 745f 6869 6768 5f67 6169 6e5f 6d6f  set_high_gain_mo
+000249b0: 6465 5f65 6e61 626c 6528 626f 6f6c 2878  de_enable(bool(x
+000249c0: 2929 0a20 2020 2020 2020 2070 726f 6365  )).        proce
+000249d0: 7373 5f66 5b22 7472 6967 6765 725f 736f  ss_f["trigger_so
+000249e0: 7572 6365 225d 2020 2020 2020 2020 2020  urce"]          
+000249f0: 2020 2020 2020 2020 2020 203d 206c 616d             = lam
+00024a00: 6264 6120 783a 2073 656c 662e 7365 745f  bda x: self.set_
+00024a10: 7472 6967 6765 725f 736f 7572 6365 2869  trigger_source(i
+00024a20: 6e74 2878 2929 0a20 2020 2020 2020 2070  nt(x)).        p
+00024a30: 726f 6365 7373 5f66 5b22 656e 6162 6c65  rocess_f["enable
+00024a40: 5f73 6563 6f6e 6461 7279 5f61 6463 225d  _secondary_adc"]
+00024a50: 2020 2020 2020 2020 2020 2020 2020 203d                 =
+00024a60: 206c 616d 6264 6120 783a 2073 656c 662e   lambda x: self.
+00024a70: 7365 7474 696e 6773 2e73 7461 7465 2e73  settings.state.s
+00024a80: 6574 2822 7365 636f 6e64 6172 795f 6164  et("secondary_ad
+00024a90: 635f 656e 6162 6c65 6422 2c20 626f 6f6c  c_enabled", bool
+00024aa0: 2878 2929 0a20 2020 2020 2020 2070 726f  (x)).        pro
+00024ab0: 6365 7373 5f66 5b22 6172 6561 5f73 6361  cess_f["area_sca
+00024ac0: 6e5f 656e 6162 6c65 225d 2020 2020 2020  n_enable"]      
+00024ad0: 2020 2020 2020 2020 2020 2020 203d 206c               = l
+00024ae0: 616d 6264 6120 783a 2073 656c 662e 7365  ambda x: self.se
+00024af0: 745f 6172 6561 5f73 6361 6e5f 656e 6162  t_area_scan_enab
+00024b00: 6c65 2862 6f6f 6c28 7829 290a 2020 2020  le(bool(x)).    
+00024b10: 2020 2020 7072 6f63 6573 735f 665b 2261      process_f["a
+00024b20: 7265 615f 7363 616e 5f66 6173 7422 5d20  rea_scan_fast"] 
+00024b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024b40: 2020 2020 3d20 6c61 6d62 6461 2078 3a20      = lambda x: 
+00024b50: 7365 6c66 2e73 6574 7469 6e67 732e 7374  self.settings.st
+00024b60: 6174 652e 7365 7428 2261 7265 615f 7363  ate.set("area_sc
+00024b70: 616e 5f66 6173 7422 2c20 626f 6f6c 2878  an_fast", bool(x
+00024b80: 2929 0a0a 2020 2020 2020 2020 7072 6f63  ))..        proc
+00024b90: 6573 735f 665b 2262 6164 5f70 6978 656c  ess_f["bad_pixel
+00024ba0: 5f6d 6f64 6522 5d20 2020 2020 2020 2020  _mode"]         
+00024bb0: 2020 2020 2020 2020 2020 2020 3d20 6c61              = la
+00024bc0: 6d62 6461 2078 3a20 7365 6c66 2e73 6574  mbda x: self.set
+00024bd0: 7469 6e67 732e 7374 6174 652e 7365 7428  tings.state.set(
+00024be0: 2262 6164 5f70 6978 656c 5f6d 6f64 6522  "bad_pixel_mode"
+00024bf0: 2c20 696e 7428 7829 290a 2020 2020 2020  , int(x)).      
+00024c00: 2020 7072 6f63 6573 735f 665b 226d 696e    process_f["min
+00024c10: 5f75 7362 5f69 6e74 6572 7661 6c5f 6d73  _usb_interval_ms
+00024c20: 225d 2020 2020 2020 2020 2020 2020 2020  "]              
+00024c30: 2020 3d20 6c61 6d62 6461 2078 3a20 7365    = lambda x: se
+00024c40: 6c66 2e73 6574 7469 6e67 732e 7374 6174  lf.settings.stat
+00024c50: 652e 7365 7428 226d 696e 5f75 7362 5f69  e.set("min_usb_i
+00024c60: 6e74 6572 7661 6c5f 6d73 222c 2069 6e74  nterval_ms", int
+00024c70: 2872 6f75 6e64 2878 2929 290a 2020 2020  (round(x))).    
+00024c80: 2020 2020 7072 6f63 6573 735f 665b 226d      process_f["m
+00024c90: 6178 5f75 7362 5f69 6e74 6572 7661 6c5f  ax_usb_interval_
+00024ca0: 6d73 225d 2020 2020 2020 2020 2020 2020  ms"]            
+00024cb0: 2020 2020 3d20 6c61 6d62 6461 2078 3a20      = lambda x: 
+00024cc0: 7365 6c66 2e73 6574 7469 6e67 732e 7374  self.settings.st
+00024cd0: 6174 652e 7365 7428 226d 6178 5f75 7362  ate.set("max_usb
+00024ce0: 5f69 6e74 6572 7661 6c5f 6d73 222c 2069  _interval_ms", i
+00024cf0: 6e74 2872 6f75 6e64 2878 2929 290a 0a20  nt(round(x))).. 
+00024d00: 2020 2020 2020 2070 726f 6365 7373 5f66         process_f
+00024d10: 5b22 6163 6365 7373 6f72 795f 656e 6162  ["accessory_enab
+00024d20: 6c65 225d 2020 2020 2020 2020 2020 2020  le"]            
+00024d30: 2020 2020 2020 203d 206c 616d 6264 6120         = lambda 
+00024d40: 783a 2073 656c 662e 7365 745f 6163 6365  x: self.set_acce
+00024d50: 7373 6f72 795f 656e 6162 6c65 2862 6f6f  ssory_enable(boo
+00024d60: 6c28 7829 290a 2020 2020 2020 2020 7072  l(x)).        pr
+00024d70: 6f63 6573 735f 665b 2266 616e 5f65 6e61  ocess_f["fan_ena
+00024d80: 626c 6522 5d20 2020 2020 2020 2020 2020  ble"]           
+00024d90: 2020 2020 2020 2020 2020 2020 2020 3d20                = 
+00024da0: 6c61 6d62 6461 2078 3a20 7365 6c66 2e73  lambda x: self.s
+00024db0: 6574 5f66 616e 5f65 6e61 626c 6528 626f  et_fan_enable(bo
+00024dc0: 6f6c 2878 2929 0a20 2020 2020 2020 2070  ol(x)).        p
+00024dd0: 726f 6365 7373 5f66 5b22 6c61 6d70 5f65  rocess_f["lamp_e
+00024de0: 6e61 626c 6522 5d20 2020 2020 2020 2020  nable"]         
+00024df0: 2020 2020 2020 2020 2020 2020 2020 203d                 =
+00024e00: 206c 616d 6264 6120 783a 2073 656c 662e   lambda x: self.
+00024e10: 7365 745f 6c61 6d70 5f65 6e61 626c 6528  set_lamp_enable(
+00024e20: 626f 6f6c 2878 2929 0a20 2020 2020 2020  bool(x)).       
+00024e30: 2070 726f 6365 7373 5f66 5b22 7368 7574   process_f["shut
+00024e40: 7465 725f 656e 6162 6c65 225d 2020 2020  ter_enable"]    
+00024e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024e60: 203d 206c 616d 6264 6120 783a 2073 656c   = lambda x: sel
+00024e70: 662e 7365 745f 7368 7574 7465 725f 656e  f.set_shutter_en
+00024e80: 6162 6c65 2862 6f6f 6c28 7829 290a 2020  able(bool(x)).  
+00024e90: 2020 2020 2020 7072 6f63 6573 735f 665b        process_f[
+00024ea0: 2273 7472 6f62 655f 656e 6162 6c65 225d  "strobe_enable"]
+00024eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024ec0: 2020 2020 2020 3d20 6c61 6d62 6461 2078        = lambda x
+00024ed0: 3a20 7365 6c66 2e73 6574 5f73 7472 6f62  : self.set_strob
+00024ee0: 655f 656e 6162 6c65 2862 6f6f 6c28 7829  e_enable(bool(x)
+00024ef0: 290a 2020 2020 2020 2020 7072 6f63 6573  ).        proces
+00024f00: 735f 665b 226d 6f64 5f65 6e61 626c 6522  s_f["mod_enable"
+00024f10: 5d20 2020 2020 2020 2020 2020 2020 2020  ]               
+00024f20: 2020 2020 2020 2020 2020 3d20 6c61 6d62            = lamb
+00024f30: 6461 2078 3a20 7365 6c66 2e73 6574 5f6d  da x: self.set_m
+00024f40: 6f64 5f65 6e61 626c 6528 626f 6f6c 2878  od_enable(bool(x
+00024f50: 2929 0a20 2020 2020 2020 2070 726f 6365  )).        proce
+00024f60: 7373 5f66 5b22 6d6f 645f 7065 7269 6f64  ss_f["mod_period
+00024f70: 5f75 7322 5d20 2020 2020 2020 2020 2020  _us"]           
+00024f80: 2020 2020 2020 2020 2020 203d 206c 616d             = lam
+00024f90: 6264 6120 783a 2073 656c 662e 7365 745f  bda x: self.set_
+00024fa0: 6d6f 645f 7065 7269 6f64 5f75 7328 696e  mod_period_us(in
+00024fb0: 7428 726f 756e 6428 7829 2929 0a20 2020  t(round(x))).   
+00024fc0: 2020 2020 2070 726f 6365 7373 5f66 5b22       process_f["
+00024fd0: 6d6f 645f 7769 6474 685f 7573 225d 2020  mod_width_us"]  
+00024fe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024ff0: 2020 2020 203d 206c 616d 6264 6120 783a       = lambda x:
+00025000: 2073 656c 662e 7365 745f 6d6f 645f 7769   self.set_mod_wi
+00025010: 6474 685f 7573 2869 6e74 2872 6f75 6e64  dth_us(int(round
+00025020: 2878 2929 290a 0a20 2020 2020 2020 2023  (x)))..        #
+00025030: 2042 6174 6368 436f 6c6c 6563 7469 6f6e   BatchCollection
+00025040: 0a20 2020 2020 2020 2370 726f 6365 7373  .       #process
+00025050: 5f66 5b22 6672 6565 5f72 756e 6e69 6e67  _f["free_running
+00025060: 5f6d 6f64 6522 5d20 2020 2020 2020 2020  _mode"]         
+00025070: 2020 2020 2020 2020 203d 206c 616d 6264           = lambd
+00025080: 6120 783a 2073 656c 662e 7365 7474 696e  a x: self.settin
+00025090: 6773 2e73 7461 7465 2e73 6574 2822 6672  gs.state.set("fr
+000250a0: 6565 5f72 756e 6e69 6e67 5f6d 6f64 6522  ee_running_mode"
+000250b0: 2c20 626f 6f6c 2878 2929 0a20 2020 2020  , bool(x)).     
+000250c0: 2020 2070 726f 6365 7373 5f66 5b22 7461     process_f["ta
+000250d0: 6b65 5f6f 6e65 5f72 6571 7565 7374 225d  ke_one_request"]
+000250e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000250f0: 2020 203d 206c 616d 6264 6120 783a 2073     = lambda x: s
+00025100: 656c 662e 7365 7474 696e 6773 2e73 7461  elf.settings.sta
+00025110: 7465 2e73 6574 2822 7461 6b65 5f6f 6e65  te.set("take_one
+00025120: 5f72 6571 7565 7374 222c 2078 290a 0a20  _request", x).. 
+00025130: 2020 2020 2020 2023 2053 6572 6965 732d         # Series-
+00025140: 5853 0a20 2020 2020 2020 2366 5b22 7261  XS.       #f["ra
+00025150: 6d61 6e5f 6d6f 6465 5f65 6e61 626c 6522  man_mode_enable"
+00025160: 5d20 2020 2020 2020 2020 2020 2020 2020  ]               
+00025170: 2020 203d 206c 616d 6264 6120 783a 2073     = lambda x: s
+00025180: 656c 662e 7365 745f 7261 6d61 6e5f 6d6f  elf.set_raman_mo
+00025190: 6465 5f65 6e61 626c 6528 626f 6f6c 2878  de_enable(bool(x
+000251a0: 2929 0a20 2020 2020 2020 2070 726f 6365  )).        proce
+000251b0: 7373 5f66 5b22 7261 6d61 6e5f 6465 6c61  ss_f["raman_dela
+000251c0: 795f 6d73 225d 2020 2020 2020 2020 2020  y_ms"]          
+000251d0: 2020 2020 2020 2020 2020 203d 206c 616d             = lam
+000251e0: 6264 6120 783a 2073 656c 662e 7365 745f  bda x: self.set_
+000251f0: 7261 6d61 6e5f 6465 6c61 795f 6d73 2869  raman_delay_ms(i
+00025200: 6e74 2872 6f75 6e64 2878 2929 290a 2020  nt(round(x))).  
+00025210: 2020 2020 2020 7072 6f63 6573 735f 665b        process_f[
+00025220: 226c 6173 6572 5f77 6174 6368 646f 675f  "laser_watchdog_
+00025230: 7365 6322 5d20 2020 2020 2020 2020 2020  sec"]           
+00025240: 2020 2020 2020 3d20 6c61 6d62 6461 2078        = lambda x
+00025250: 3a20 7365 6c66 2e73 6574 5f6c 6173 6572  : self.set_laser
+00025260: 5f77 6174 6368 646f 675f 7365 6328 696e  _watchdog_sec(in
+00025270: 7428 726f 756e 6428 7829 2929 0a0a 2020  t(round(x)))..  
+00025280: 2020 2020 2020 2320 7265 6769 6f6e 730a        # regions.
+00025290: 2020 2020 2020 2020 7072 6f63 6573 735f          process_
+000252a0: 665b 2276 6572 7469 6361 6c5f 6269 6e6e  f["vertical_binn
+000252b0: 696e 6722 5d20 2020 2020 2020 2020 2020  ing"]           
+000252c0: 2020 2020 2020 2020 3d20 6c61 6d62 6461          = lambda
+000252d0: 2078 3a20 7365 6c66 2e73 6574 5f76 6572   x: self.set_ver
+000252e0: 7469 6361 6c5f 6269 6e6e 696e 6728 7829  tical_binning(x)
+000252f0: 0a20 2020 2020 2020 2070 726f 6365 7373  .        process
+00025300: 5f66 5b22 7369 6e67 6c65 5f72 6567 696f  _f["single_regio
+00025310: 6e22 5d20 2020 2020 2020 2020 2020 2020  n"]             
+00025320: 2020 2020 2020 2020 203d 206c 616d 6264           = lambd
+00025330: 6120 783a 2073 656c 662e 7365 745f 7369  a x: self.set_si
+00025340: 6e67 6c65 5f72 6567 696f 6e28 696e 7428  ngle_region(int(
+00025350: 726f 756e 6428 7829 2929 0a20 2020 2020  round(x))).     
+00025360: 2020 2070 726f 6365 7373 5f66 5b22 636c     process_f["cl
+00025370: 6561 725f 7265 6769 6f6e 7322 5d20 2020  ear_regions"]   
+00025380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00025390: 2020 203d 206c 616d 6264 6120 783a 2073     = lambda x: s
+000253a0: 656c 662e 636c 6561 725f 7265 6769 6f6e  elf.clear_region
+000253b0: 7328 290a 2020 2020 2020 2020 7072 6f63  s().        proc
+000253c0: 6573 735f 665b 2264 6574 6563 746f 725f  ess_f["detector_
+000253d0: 726f 6922 5d20 2020 2020 2020 2020 2020  roi"]           
+000253e0: 2020 2020 2020 2020 2020 2020 3d20 6c61              = la
+000253f0: 6d62 6461 2078 3a20 7365 6c66 2e73 6574  mbda x: self.set
+00025400: 5f64 6574 6563 746f 725f 726f 6928 7829  _detector_roi(x)
+00025410: 0a20 2020 2020 2020 2070 726f 6365 7373  .        process
+00025420: 5f66 5b22 7069 7865 6c5f 6d6f 6465 225d  _f["pixel_mode"]
+00025430: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00025440: 2020 2020 2020 2020 203d 206c 616d 6264           = lambd
+00025450: 6120 783a 2073 656c 662e 7365 745f 7069  a x: self.set_pi
+00025460: 7865 6c5f 6d6f 6465 2878 290a 0a20 2020  xel_mode(x)..   
+00025470: 2020 2020 2023 2045 4550 524f 4d20 7570       # EEPROM up
+00025480: 6461 7465 730a 2020 2020 2020 2020 7072  dates.        pr
+00025490: 6f63 6573 735f 665b 2275 7064 6174 655f  ocess_f["update_
+000254a0: 6565 7072 6f6d 225d 2020 2020 2020 2020  eeprom"]        
+000254b0: 2020 2020 2020 2020 2020 2020 2020 3d20                = 
+000254c0: 6c61 6d62 6461 2078 3a20 7365 6c66 2e75  lambda x: self.u
+000254d0: 7064 6174 655f 7365 7373 696f 6e5f 6565  pdate_session_ee
+000254e0: 7072 6f6d 2878 290a 2020 2020 2020 2020  prom(x).        
+000254f0: 7072 6f63 6573 735f 665b 2272 6570 6c61  process_f["repla
+00025500: 6365 5f65 6570 726f 6d22 5d20 2020 2020  ce_eeprom"]     
+00025510: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00025520: 3d20 6c61 6d62 6461 2078 3a20 7365 6c66  = lambda x: self
+00025530: 2e72 6570 6c61 6365 5f73 6573 7369 6f6e  .replace_session
+00025540: 5f65 6570 726f 6d28 7829 0a20 2020 2020  _eeprom(x).     
+00025550: 2020 2070 726f 6365 7373 5f66 5b22 7772     process_f["wr
+00025560: 6974 655f 6565 7072 6f6d 225d 2020 2020  ite_eeprom"]    
+00025570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00025580: 2020 203d 206c 616d 6264 6120 783a 2073     = lambda x: s
+00025590: 656c 662e 7772 6974 655f 6565 7072 6f6d  elf.write_eeprom
+000255a0: 2829 0a0a 2020 2020 2020 2020 2320 6d61  ()..        # ma
+000255b0: 6e75 6661 6374 7572 696e 670a 2020 2020  nufacturing.    
+000255c0: 2020 2020 7072 6f63 6573 735f 665b 2272      process_f["r
+000255d0: 6573 6574 5f66 7067 6122 5d20 2020 2020  eset_fpga"]     
+000255e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000255f0: 2020 2020 3d20 6c61 6d62 6461 2078 3a20      = lambda x: 
+00025600: 7365 6c66 2e72 6573 6574 5f66 7067 6128  self.reset_fpga(
+00025610: 290a 2020 2020 2020 2020 7072 6f63 6573  ).        proces
+00025620: 735f 665b 2264 6675 5f65 6e61 626c 6522  s_f["dfu_enable"
+00025630: 5d20 2020 2020 2020 2020 2020 2020 2020  ]               
+00025640: 2020 2020 2020 2020 2020 3d20 6c61 6d62            = lamb
+00025650: 6461 2078 3a20 7365 6c66 2e73 6574 5f64  da x: self.set_d
+00025660: 6675 5f65 6e61 626c 6528 290a 0a20 2020  fu_enable()..   
+00025670: 2020 2020 2023 206c 6567 6163 790a 2020       # legacy.  
+00025680: 2020 2020 2020 7072 6f63 6573 735f 665b        process_f[
+00025690: 2261 6c6c 6f77 5f64 6566 6175 6c74 5f67  "allow_default_g
+000256a0: 6169 6e5f 7265 7365 7422 5d20 2020 2020  ain_reset"]     
+000256b0: 2020 2020 2020 3d20 6c61 6d62 6461 2078        = lambda x
+000256c0: 3a20 7365 7461 7474 7228 7365 6c66 2c20  : setattr(self, 
+000256d0: 2261 6c6c 6f77 5f64 6566 6175 6c74 5f67  "allow_default_g
+000256e0: 6169 6e5f 7265 7365 7422 2c20 626f 6f6c  ain_reset", bool
+000256f0: 2878 2929 0a0a 2020 2020 2020 2020 2320  (x))..        # 
+00025700: 6578 7065 7269 6d65 6e74 616c 2028 5226  experimental (R&
+00025710: 4429 0a20 2020 2020 2020 2070 726f 6365  D).        proce
+00025720: 7373 5f66 5b22 6772 6170 685f 616c 7465  ss_f["graph_alte
+00025730: 726e 6174 696e 675f 7069 7865 6c73 225d  rnating_pixels"]
+00025740: 2020 2020 2020 2020 2020 203d 206c 616d             = lam
+00025750: 6264 6120 783a 2073 656c 662e 7365 7474  bda x: self.sett
+00025760: 696e 6773 2e73 7461 7465 2e73 6574 2822  ings.state.set("
+00025770: 6772 6170 685f 616c 7465 726e 6174 696e  graph_alternatin
+00025780: 675f 7069 7865 6c73 222c 2062 6f6f 6c28  g_pixels", bool(
+00025790: 7829 290a 2020 2020 2020 2020 7072 6f63  x)).        proc
+000257a0: 6573 735f 665b 2273 7761 705f 616c 7465  ess_f["swap_alte
+000257b0: 726e 6174 696e 675f 7069 7865 6c73 225d  rnating_pixels"]
+000257c0: 2020 2020 2020 2020 2020 2020 3d20 6c61              = la
+000257d0: 6d62 6461 2078 3a20 7365 6c66 2e73 6574  mbda x: self.set
+000257e0: 7469 6e67 732e 7374 6174 652e 7365 7428  tings.state.set(
+000257f0: 2273 7761 705f 616c 7465 726e 6174 696e  "swap_alternatin
+00025800: 675f 7069 7865 6c73 222c 2062 6f6f 6c28  g_pixels", bool(
+00025810: 7829 290a 2020 2020 2020 2020 7072 6f63  x)).        proc
+00025820: 6573 735f 665b 2265 6463 5f65 6e61 626c  ess_f["edc_enabl
+00025830: 6522 5d20 2020 2020 2020 2020 2020 2020  e"]             
+00025840: 2020 2020 2020 2020 2020 2020 3d20 6c61              = la
+00025850: 6d62 6461 2078 3a20 7365 6c66 2e73 6574  mbda x: self.set
+00025860: 7469 6e67 732e 7374 6174 652e 7365 7428  tings.state.set(
+00025870: 2265 6463 5f65 6e61 626c 6564 222c 2062  "edc_enabled", b
+00025880: 6f6f 6c28 7829 290a 2020 2020 2020 2020  ool(x)).        
+00025890: 7072 6f63 6573 735f 665b 2269 6e76 6572  process_f["inver
+000258a0: 745f 785f 6178 6973 225d 2020 2020 2020  t_x_axis"]      
+000258b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000258c0: 3d20 6c61 6d62 6461 2078 3a20 7365 6c66  = lambda x: self
+000258d0: 2e73 6574 7469 6e67 732e 6565 7072 6f6d  .settings.eeprom
+000258e0: 2e73 6574 2822 696e 7665 7274 5f78 5f61  .set("invert_x_a
+000258f0: 7869 7322 2c20 626f 6f6c 2878 2929 0a20  xis", bool(x)). 
+00025900: 2020 2020 2020 2070 726f 6365 7373 5f66         process_f
+00025910: 5b22 6269 6e5f 3278 3222 5d20 2020 2020  ["bin_2x2"]     
+00025920: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00025930: 2020 2020 2020 203d 206c 616d 6264 6120         = lambda 
+00025940: 783a 2073 656c 662e 7365 7474 696e 6773  x: self.settings
+00025950: 2e65 6570 726f 6d2e 7365 7428 2262 696e  .eeprom.set("bin
+00025960: 5f32 7832 222c 2062 6f6f 6c28 7829 290a  _2x2", bool(x)).
+00025970: 2020 2020 2020 2020 7072 6f63 6573 735f          process_
+00025980: 665b 2277 6176 656e 756d 6265 725f 636f  f["wavenumber_co
+00025990: 7272 6563 7469 6f6e 225d 2020 2020 2020  rrection"]      
+000259a0: 2020 2020 2020 2020 3d20 6c61 6d62 6461          = lambda
+000259b0: 2078 3a20 7365 6c66 2e73 6574 7469 6e67   x: self.setting
+000259c0: 732e 7365 745f 7761 7665 6e75 6d62 6572  s.set_wavenumber
+000259d0: 5f63 6f72 7265 6374 696f 6e28 666c 6f61  _correction(floa
+000259e0: 7428 7829 290a 0a20 2020 2020 2020 2023  t(x))..        #
+000259f0: 2068 6561 7274 6265 6174 7320 2620 636f   heartbeats & co
+00025a00: 6e6e 6563 7469 6f6e 2064 6174 610a 2020  nnection data.  
+00025a10: 2020 2020 2020 7072 6f63 6573 735f 665b        process_f[
+00025a20: 2272 6169 7365 5f65 7863 6570 7469 6f6e  "raise_exception
+00025a30: 7322 5d20 2020 2020 2020 2020 2020 2020  s"]             
+00025a40: 2020 2020 2020 3d20 6c61 6d62 6461 2078        = lambda x
+00025a50: 3a20 7365 7461 7474 7228 7365 6c66 2c20  : setattr(self, 
+00025a60: 2272 6169 7365 5f65 7863 6570 7469 6f6e  "raise_exception
+00025a70: 7322 2c20 626f 6f6c 2878 2929 0a20 2020  s", bool(x)).   
+00025a80: 2020 2020 2070 726f 6365 7373 5f66 5b22       process_f["
+00025a90: 6c6f 675f 6c65 7665 6c22 5d20 2020 2020  log_level"]     
+00025aa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00025ab0: 2020 2020 203d 206c 616d 6264 6120 783a       = lambda x:
+00025ac0: 2073 656c 662e 7365 745f 6c6f 675f 6c65   self.set_log_le
+00025ad0: 7665 6c28 7829 0a20 2020 2020 2020 2070  vel(x).        p
+00025ae0: 726f 6365 7373 5f66 5b22 6e75 6d5f 636f  rocess_f["num_co
+00025af0: 6e6e 6563 7465 645f 6465 7669 6365 7322  nnected_devices"
+00025b00: 5d20 2020 2020 2020 2020 2020 2020 203d  ]              =
+00025b10: 206c 616d 6264 6120 783a 2073 656c 662e   lambda x: self.
+00025b20: 7365 7474 696e 6773 2e73 6574 5f6e 756d  settings.set_num
+00025b30: 5f63 6f6e 6e65 6374 6564 5f64 6576 6963  _connected_devic
+00025b40: 6573 2869 6e74 2878 2929 0a20 2020 2020  es(int(x)).     
+00025b50: 2020 2070 726f 6365 7373 5f66 5b22 7375     process_f["su
+00025b60: 6270 726f 6365 7373 5f74 696d 656f 7574  bprocess_timeout
+00025b70: 5f73 6563 225d 2020 2020 2020 2020 2020  _sec"]          
+00025b80: 2020 203d 206c 616d 6264 6120 783a 204e     = lambda x: N
+00025b90: 6f6e 650a 2020 2020 2020 2020 7072 6f63  one.        proc
+00025ba0: 6573 735f 665b 2268 6561 7274 6265 6174  ess_f["heartbeat
+00025bb0: 225d 2020 2020 2020 2020 2020 2020 2020  "]              
+00025bc0: 2020 2020 2020 2020 2020 2020 3d20 6c61              = la
+00025bd0: 6d62 6461 2078 3a20 4e6f 6e65 0a20 2020  mbda x: None.   
+00025be0: 2020 2020 2070 726f 6365 7373 5f66 5b22       process_f["
+00025bf0: 7265 7365 7422 5d20 2020 2020 2020 2020  reset"]         
+00025c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00025c10: 2020 2020 203d 2073 656c 662e 7265 7365       = self.rese
+00025c20: 740a 0a20 2020 2020 2020 2072 6574 7572  t..        retur
+00025c30: 6e20 7072 6f63 6573 735f 660a            n process_f.
```

### Comparing `wasatch-2.1.35/wasatch/HardwareInfo.py` & `wasatch-2.1.64/wasatch/HardwareInfo.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 
 ##
 # This class captures aspects of the hardware which normally ENLIGHTEN can't / 
 # shouldn't see, which isn't otherwise reliably inferred from EEPROM, ModelInfo 
 # etc.
 
-class HardwareInfo(object):
+class HardwareInfo:
 
     def __init__(self, vid=None, pid=None):
         self.vid = vid
         self.pid = pid
     
     def is_ingaas(self): # -> bool 
         return self.pid == 0x2000
```

### Comparing `wasatch-2.1.35/wasatch/InterfaceDevice.py` & `wasatch-2.1.64/wasatch/InterfaceDevice.py`

 * *Files 20% similar despite different names*

```diff
@@ -9,22 +9,23 @@
 class InterfaceDevice:
     def __init__(self): # -> None 
         """
         Any class that communicates to a spectrometer should inherit this class.
         It provides the common functions that avoid repeated code.
         """
         self.process_f = []
+        self.remaining_throwaways = 0
 
     def handle_requests(self, requests: list[SpectrometerRequest]): # -> list[SpectrometerResponse] 
         responses = []
         for request in requests:
             try:
                 cmd = request.cmd
                 proc_func = self.process_f.get(cmd, None)
-                if proc_func == None:
+                if proc_func is None:
                     responses.append(SpectrometerResponse(error_msg=f"unsupported cmd {request.cmd}", error_lvl=ErrorLevel.low))
                 elif request.args == [] and request.kwargs == {}:
                     responses.append(proc_func())
                 else:
                     responses.append(proc_func(*request.args, **request.kwargs))
             except Exception as e:
                 log.error(f"error in handling request {request} of {e}", exc_info=1)
```

### Comparing `wasatch-2.1.35/wasatch/MockUSBDevice.py` & `wasatch-2.1.64/wasatch/MockUSBDevice.py`

 * *Files 2% similar despite different names*

```diff
@@ -87,20 +87,20 @@
         log.info("MockUSBDevice: creating cmd_dict")
         self.cmd_dict = {
             (0xb2,None): self.cmd_set_int_time,
             (0xb6,None): self.cmd_set_offset,
             (0xb7,None): self.cmd_set_gain,
             (0xbe,None): self.cmd_set_laser_enable,
             (0xd6,None): self.cmd_set_detector_tec_enable,
-            (0xd7,None): self.cmd_get_detector_temp,
+           #(0xd7,None): self.cmd_get_detector_temp,
             (0xd8,None): self.cmd_set_setpoint,
             (0xda,None): self.cmd_get_tec_enable,
             (0x34,None): self.cmd_get_raw_ambient_temp,
             (0xd5,None): self.cmd_get_laser_temp,
-            (0xd7,None): self.cmd_get_detect_temp,
+           #(0xd7,None): self.cmd_get_detect_temp,
             (0xe2,None): self.cmd_get_laser_enabled,
             (0xff,1): self.cmd_read_eeprom,
             }
         self.reading_cycles = {}
         # turn readings arrays into cycles so 
         # we have an infinite loop of spectra to go through
         for key,value in self.spec_readings.items():
@@ -147,17 +147,17 @@
         # disconnecting
         return True
 
     def ctrl_transfer(self, *args, **kwargs):
         device, host, bRequest, wValue, wIndex, wLength = args
         log.info(f"Mock spec received ctrl transfer of host {host}, request {bRequest}, wValue {wValue}, wIndex {wIndex}, len {wLength}")
         if bRequest == 255:
-            cmd_func = self.cmd_dict.get((bRequest,wValue),None)
+            cmd_func = self.cmd_dict.get((bRequest, wValue), None)
         else:
-            cmd_func = self.cmd_dict.get((bRequest,None),None)
+            cmd_func = self.cmd_dict.get((bRequest, None), None)
         if cmd_func:
             return cmd_func(*args)
         else:
             return self.default_ctrl_return
 
     def cmd_read_eeprom(self, *args):
         device, host, bRequest, wValue, wIndex, wLength = args
@@ -191,15 +191,14 @@
 
     def cmd_set_gain(self, *args):
         device, host, bRequest, wValue, wIndex, wLength = args
         if not self.got_start_detector_gain: self.got_start_detector_gain = True
         wValB = wValue.to_bytes(2,byteorder='little')#struct.unpack('f',bytearray(wValue))
         lsb = wValB[0] # LSB-MSB
         msb = wValB[1]
-        raw = (msb << 8) | lsb
 
         gain = msb + lsb / 256.0
         self.detector_gain = gain
         return [1]
 
     def cmd_set_offset(self, *args):
         device, host, bRequest, wValue, wIndex, wLength = args
@@ -311,15 +310,15 @@
         parse_objects = [CSVLoader(file) for file in reading_files]
         self.spec_readings["default"] = []
         for object in parse_objects:
             object.load_data()
             object.processed_reading.processed = [int(val) if val > 0 else 0 for val in object.processed_reading.processed]
         self.spec_readings["default"].extend([struct.pack('H' * len(object.processed_reading.processed),*object.processed_reading.processed) for object in parse_objects])
 
-    def to_dict():
+    def to_dict(self):
         return str(self)
 
     def __str__(self):
         return "<MockUSBDevice 0x%04x:0x%04x:%d:%d>" % (self.vid, self.pid, self.bus, self.address)
 
     def __hash__(self):
         return hash(str(self))
```

### Comparing `wasatch-2.1.35/wasatch/OceanDevice.py` & `wasatch-2.1.64/wasatch/OceanDevice.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,26 +1,19 @@
-import re
 import os
 import usb
-import time
-import queue
 import logging
 import datetime
-from typing import TypeVar, Any, Callable
 
 import seabreeze
 seabreeze.use("pyseabreeze")
 import seabreeze.spectrometers as sb
 from seabreeze.spectrometers import Spectrometer, list_devices
 
 from .SpectrometerSettings        import SpectrometerSettings
-from .SpectrometerRequest         import SpectrometerRequest
 from .SpectrometerResponse        import SpectrometerResponse
-from .SpectrometerResponse        import ErrorLevel
-from .SpectrometerState           import SpectrometerState
 from .InterfaceDevice             import InterfaceDevice
 from .DeviceID                    import DeviceID
 from .Reading                     import Reading
 
 log = logging.getLogger(__name__)
 
 class OceanDevice(InterfaceDevice):
@@ -116,15 +109,15 @@
             # we're in free-running mode
             loop_count = 1
 
         log.debug("take_one_averaged_reading: loop_count = %d", loop_count)
 
         # either take one measurement (normal), or a bunch (blocking averaging)
         reading = None
-        for loop_index in range(0, loop_count):
+        for _ in range(0, loop_count):
 
             # start a new reading
             # NOTE: reading.timestamp is when reading STARTED, not FINISHED!
             reading = Reading(self.device_id)
 
             # TODO...just include a copy of SpectrometerState? something to think
             # about. That would actually provide a reason to roll all the
@@ -214,8 +207,8 @@
         self.settings.wavelengths = self.spec.wavelengths()# setting wavelengths one init doesn't work for some reaons
         reading = self._take_one_averaged_reading()
         return reading
 
     def scans_to_average(self, value: int): # -> SpectrometerResponse 
         self.sum_count = 0
         self.settings.state.scans_to_average = int(value)
-        return SpectrometerResponse(True)
+        return SpectrometerResponse(True)
```

### Comparing `wasatch-2.1.35/wasatch/Reading.py` & `wasatch-2.1.64/wasatch/Reading.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 
 log = logging.getLogger(__name__)
 
 ## 
 # A single set of data read from a device. This includes spectrum,
 # temperature, gain, offset, etc. Essentially a snapshot of the device
 # state in time. 
-class Reading(object):
+class Reading:
 
     def clear(self):
         self.device_id                 = None
         self.timestamp                 = None
         self.timestamp_complete        = None
         self.spectrum                  = None
         self.laser_enabled             = None
@@ -23,37 +23,42 @@
         self.secondary_adc_raw         = None
         self.secondary_adc_calibrated  = None
         self.laser_status              = None   # MZ: sim-only?
         self.laser_power_perc          = 0      
         self.laser_power_mW            = 0
         self.failure                   = None
         self.averaged                  = False
-        self.session_count             = 0
+        self.session_count             = 0      # can treat as reading_id
         self.area_scan_row_count       = -1
         self.area_scan_data            = None
         self.battery_raw               = None
         self.battery_percentage        = None
         self.battery_charging          = None
         self.laser_can_fire            = False  # per interlock board
         self.laser_is_firing           = False  # per interlock board, not laser_enable
+        self.laser_tec_enabled         = False
+        self.take_one_request          = None
 
         # for the rare case (BatchCollection with LaserMode "Spectrum") where the 
         # driver is asked to collect a dark just before enabling the laser
         self.dark                      = None
 
     def __str__(self):
-        return "wasatch.Reading {device_id %s, spectrum %s, averaged %s, session_count %d, area_scan_row_count %d, timestamp %s, timestamp_complete %s, failure %s}" % (
+        return "wasatch.Reading {device_id %s, spectrum %s, averaged %s, session_count %d, area_scan_row_count %d, timestamp %s, timestamp_complete %s, failure %s, laser_enabled %s, ambient %s, take_one_request %s }" % (
             self.device_id, 
             "None" if self.spectrum is None else ("%d values" % len(self.spectrum)),
             self.averaged, 
-            self.session_count, 
+            self.session_count,
             self.area_scan_row_count,
             self.timestamp, 
             self.timestamp_complete, 
-            self.failure)
+            self.failure,
+            self.laser_enabled,
+            self.ambient_temperature_degC,
+            self.take_one_request)
 
     def __init__(self, device_id=None):
         self.clear()
 
         self.device_id = str(device_id)
 
         # NOTE: this will generally indicate when the acquisition STARTS, not ENDS
```

### Comparing `wasatch-2.1.35/wasatch/RealUSBDevice.py` & `wasatch-2.1.64/wasatch/RealUSBDevice.py`

 * *Files 4% similar despite different names*

```diff
@@ -38,15 +38,15 @@
         device =  args[0]
         read_args = args[1:]
         return device.read(*read_args, **kwargs)
 
     def send_code(self):
         pass
 
-    def to_dict():
+    def to_dict(self):
         return str(self)
 
     def __str__(self):
         return "<RealUSBDevice 0x%04x:0x%04x:%d:%d>" % (self.vid, self.pid, self.bus, self.address)
 
     def __hash__(self):
         return hash(str(self))
```

### Comparing `wasatch-2.1.35/wasatch/SPIDevice.py` & `wasatch-2.1.64/wasatch/SPIDevice.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,628 +1,627 @@
-import re
-import os
-import usb
-import time
-import logging
-import datetime
-import threading
-
-from queue import Queue
-from typing import Callable, Any
-
-# Needed for Mac side
-# Device Finder should already have done this
-# For thoroughness though doing here anyway
-# This is required for finding the usb <-> serial board
-#
-# MZ: I don't remember anything about this, but SPI is not a priority at
-#     this time and this broke under Python 3.11
-#
-import usb.core
-# usb.core.find()
-
-from .SpectrometerSettings        import SpectrometerSettings
-from .SpectrometerState           import SpectrometerState
-from .SpectrometerResponse        import SpectrometerResponse
-from .SpectrometerRequest         import SpectrometerRequest
-from .SpectrometerResponse        import ErrorLevel
-from .ControlObject               import ControlObject
-from .DeviceID                    import DeviceID
-from .InterfaceDevice             import InterfaceDevice
-from .Reading                     import Reading
-from .EEPROM                      import EEPROM
-
-import crcmod.predefined
-
-log = logging.getLogger(__name__)
-
-##
-# @note write_len includes the opcode (address) itself, so a 1-byte value like
-#       PixelMode has write_len 2, and a 24-bit value like Integration Time has
-#       write_len 4.
-class CommandTuple:
-    def __init__(self, address, value, write_len, name):
-        self.address   = address
-        self.value     = value
-        self.write_len = write_len
-        self.name      = name
-
-    def __str__(self):
-        return f"CommandTuple <name {self.name}, address 0x{self.address:02x}, value {self.value}, write_len {self.write_len}>"
-
-class SPIDevice(InterfaceDevice):
-    """
-    This implements SPI communication via the FT232H usb converter.
-
-    This class adopts the external device interface structure.
-    This involves receiving a request through the handle_request function.
-    A request is processed based on the key in the request.
-    The processing function passes the commands to the requested device.
-    Once it receives a response from the connected device it then passes that
-    back up the chain.
-
-    @verbatim
-                               Enlighten Request
-                                       |
-                                handle_requests
-                                       |
-                                 ------------
-                                /   /  |  \  \
-             { get_laser status, acquire, set_laser_watchdog, etc....}
-                                \   \  |  /  /
-                                 ------------
-                                       |
-                         {self.driver.some_spi_call}
-    @endverbatim
-
-    @see https://github.com/WasatchPhotonics/Python-USB-WP-Raman-Examples/blob/master/SPI/spi_console.py
-    """
-
-    READ_RESPONSE_OVERHEAD  = 5 # <, LEN_MSB, LEN_LSB, CRC, >  # does NOT include ADDR
-    WRITE_RESPONSE_OVERHEAD = 2 # <, >
-    READY_POLL_LEN = 2          # 1 seems to work
-    START = 0x3c                # <
-    END   = 0x3e                # >
-    WRITE = 0x80                # bit changing opcodes from 'getter' to 'setter'
-    CRC   = 0xff                # for readability
-
-    lock = threading.Lock()
-
-    def __init__(self, device_id: DeviceID, message_queue: Queue): # -> None 
-        super().__init__()
-
-        ########################################################################
-        # Attempt to import dependencies (connects to FT232H)
-        ########################################################################
-
-        import_successful = False
-        try:
-            os.environ["BLINKA_FT232H"] = "1"
-            import board
-            import digitalio
-            import busio
-            import_successful = True
-        except RuntimeError as ex:
-            log.error("No FT232H connected.", exc_info=1)
-            if platform.system() == "Windows":
-                log.error("Ensure you've followed the Zadig process in README_SPI.md")
-        except ValueError as ex:
-            log.error("If you are receiving 'no backend available' errors, try the following:")
-            log.error("MacOS:  $ export DYLD_LIBRARY_PATH=/usr/local/lib")
-            log.error("Linux:  $ export LD_LIBRARY_PATH=/usr/local/lib")
-        except FtdiError as ex:
-            log.error("No FT232H connected.", exc_info=1)
-            if platform.system() == "Windows":
-                log.error("Ensure you've followed the Zadig process in README_SPI.md")
-            log.error("SPIDevice is not usable")
-        if not import_successful:
-            return
-
-        self.crc8 = crcmod.predefined.mkPredefinedCrcFun('crc-8-maxim')
-
-        ########################################################################
-        # Proceed with initialization
-        ########################################################################
-
-        # if passed a string representation of a DeviceID, deserialize it
-        if type(device_id) is str:
-            device_id = DeviceID(label=device_id)
-
-        self.device_id      = device_id
-        self.message_queue  = message_queue
-
-        self.connected = False
-        self.disconnect = False
-        self.acquiring = False
-
-        # Receives ENLIGHTEN's 'change settings' commands in the spectrometer
-        # process. Although a logical queue, has nothing to do with multiprocessing.
-        self.command_queue = []
-
-        self.immediate_mode = False
-
-        self.settings = SpectrometerSettings(self.device_id)
-        self.summed_spectra         = None
-        self.sum_count              = 0
-        self.session_reading_count  = 0
-        self.take_one               = False
-        self.failure_count          = 0
-
-        self.process_id = os.getpid()
-        self.last_memory_check = datetime.datetime.now()
-        self.last_battery_percentage = 0
-        self.lambdas = None
-        self.spec_index = 0
-        self._scan_averaging = 1
-        self.dark = None
-        self.boxcar_half_width = 0
-
-        # Initialize the SPI bus on the FT232H
-        self.SPI = busio.SPI(clock=board.SCK, MISO=board.MISO, MOSI=board.MOSI)
-
-        # Initialize D5 as the ready signal (allow override)
-        self.ready = digitalio.DigitalInOut(getattr(board, os.getenv("SPI_PIN_READY", default="D5")))
-        self.ready.direction = digitalio.Direction.INPUT
-
-        # Initialize D6 as the trigger (allow override)
-        self.trigger = digitalio.DigitalInOut(getattr(board, os.getenv("SPI_PIN_TRIGGER", default="D6")))
-        self.trigger.direction = digitalio.Direction.OUTPUT
-        self.trigger.value = False
-
-        # Take control of the SPI Bus
-        while not self.SPI.try_lock():
-            pass
-
-        # Configure the SPI bus (allow override)
-        self.baud_mhz = int(os.getenv("SPI_BAUD_MHZ", default="10"))
-        log.debug(f"using baud rate {self.baud_mhz}MHz")
-        self.SPI.configure(baudrate=self.baud_mhz * 1e6, phase=0, polarity=0, bits=8)
-
-        # for kicks, let block size be overridden by the environment
-        self.block_size = int(os.getenv("SPI_BLOCK_SIZE", default="256"))
-        log.debug(f"using SPI block size {self.block_size}")
-
-        self.process_f = self._init_process_funcs()
-
-        ########################################################################
-        # Store SPI command table in a lookup
-        ########################################################################
-
-        self.cmds = {}
-        for  addr, value, len_, name in [
-           # ---- ------ ----- -----------
-            (0x11,    3,     4, "Integration Time"),
-            (0x13,    0,     3, "Black Level"),
-            (0x14,   24,     3, "Gain dB"),
-            (0x2B,    3,     2, "Pixel Mode"),
-            (0x50,  250,     3, "Start Line 0"),
-            (0x51,  750,     3, "Stop Line 0"),
-            (0x52,   12,     3, "Start Column 0"),
-            (0x53, 1932,     3, "Stop Column 0"),
-            (0x54,    0,     3, "Start Line 1"),
-            (0x55,    0,     3, "Stop Line 1"),
-            (0x56,    0,     3, "Start Column 1"),
-            (0x57,    0,     3, "Stop Column 1"),
-            (0x58,    0,     3, "Desmile") ]:
-            self.cmds[name] = CommandTuple(addr, value, len_, name)
-
-        # patch gain
-        cmd = self.cmds["Gain dB"]
-        cmd.value = self.gain_to_ff(cmd.value)
-
-    def connect(self): # -> SpectrometerResponse 
-        log.debug("initializing EEPROM")
-        if not self.init_eeprom():
-            log.critical("failed to initialize EEPROM, giving up")
-            return SpectrometerResponse(False, error_msg="EEPROM initialization failure", error_lvl=ErrorLevel.high, poison_pill=True)
-
-        # initialize all settings -- this ensures no setting is uninitialized
-        log.debug("initializing all commands")
-        for key in self.cmds:
-            cmd = self.cmds[key]
-            log.debug(f"initializing {cmd}")
-            self.send_command(cmd)
-
-        self.settings.state.integration_time_ms = self.settings.eeprom.startup_integration_time_ms
-        self.settings.state.gain_db = self.settings.eeprom.detector_gain
-
-        log.info("SPI connect done, returning True")
-        return SpectrometerResponse(True)
-
-    ## @returns True on success
-    def init_eeprom(self): # -> bool 
-        eeprom = self.settings.eeprom
-
-        pages = []
-        for i in range(EEPROM.MAX_PAGES):
-            log.debug(f"flushing buffer before page {i}")
-            if not self.flush_input_buffer():
-                log.error("unable to read EEPROM")
-                return False
-            pages.append(self.read_page(i))
-
-        if not eeprom.parse(pages):
-            log.error(f"failed to parse EEPROM")
-            return False
-
-        self.settings.update_wavecal()
-        self.settings.update_raman_intensity_factors()
-
-        # copy startup values from EEPROM into our local command table so they
-        # get initialized properly
-
-        self.cmds["Integration Time"].value = eeprom.startup_integration_time_ms
-        self.cmds["Gain dB"         ].value = self.gain_to_ff(eeprom.detector_gain)
-        self.cmds["Start Line 0"    ].value = eeprom.roi_vertical_region_1_start
-        self.cmds["Stop Line 0"     ].value = eeprom.roi_vertical_region_1_end
-        self.cmds["Start Column 0"  ].value = eeprom.roi_horizontal_start
-        self.cmds["Stop Column 0"   ].value = eeprom.roi_horizontal_end
-
-        return True
-
-    def disconnect(self): # -> SpectrometerResponse 
-        self.disconnect = True
-        return SpectrometerResponse(True)
-
-    def acquire_data(self): # -> SpectrometerResponse 
-        log.debug("spi starts reading")
-        if self.disconnect:
-            log.debug("disconnecting, returning False for the spectrum")
-            return False
-        averaging_enabled = (self.settings.state.scans_to_average > 1)
-        reading = Reading(self.device_id)
-
-        try:
-            reading.integration_time_ms = self.settings.state.integration_time_ms
-            reading.laser_power_perc    = self.settings.state.laser_power_perc
-            reading.laser_power_mW      = self.settings.state.laser_power_mW
-            reading.laser_enabled       = self.settings.state.laser_enabled
-            reading.spectrum            = self.get_spectrum()
-            if reading.spectrum == False:
-                return False
-        except usb.USBError:
-            self.failure_count += 1
-            log.error(f"SPI Device: encountered USB error in reading for device {self.device}")
-
-        if not reading.failure:
-            if averaging_enabled:
-                if self.sum_count == 0:
-                    self.summed_spectra = [float(i) for i in reading.spectrum]
-                else:
-                    log.debug("device.take_one_averaged_reading: summing spectra")
-                    for i in range(len(self.summed_spectra)):
-                        self.summed_spectra[i] += reading.spectrum[i]
-                self.sum_count += 1
-                log.debug("device.take_one_averaged_reading: summed_spectra : %s ...", self.summed_spectra[0:9])
-
-        if self.settings.eeprom.bin_2x2:
-            # perform the 2x2 bin software side
-            next_idx_values = reading.spectrum[1:]
-            # average all except the last value, which is just appended as is
-            binned = [(value + next_value)/2 for value, next_value in zip(reading.spectrum[:-1], next_idx_values)]
-            binned.append(reading.spectrum[-1])
-            reading.spectrum = binned
-
-        self.session_reading_count += 1
-        reading.session_count = self.session_reading_count
-        reading.sum_count = self.sum_count
-
-        if averaging_enabled:
-            if self.sum_count >= self.settings.state.scans_to_average:
-                reading.spectrum = [ x / self.sum_count for x in self.summed_spectra ]
-                log.debug("spi device acquire data: averaged_spectrum : %s ...", reading.spectrum[0:9])
-                reading.averaged = True
-
-                # reset for next average
-                self.summed_spectra = None
-                self.sum_count = 0
-        else:
-            # if averaging isn't enabled...then a single reading is the
-            # "averaged" final measurement (check reading.sum_count to confirm)
-            reading.averaged = True
-
-        return SpectrometerResponse(reading)
-
-    def set_integration_time_ms(self, value: int): # -> SpectrometerResponse 
-        cmd = self.cmds["Integration Time"]
-        cmd.value = value
-        self.send_command(cmd)
-        self.settings.state.integration_time_ms = value
-        return SpectrometerResponse()
-
-    def set_gain(self, value: float): # -> SpectrometerResponse 
-        cmd = self.cmds["Gain dB"]
-        cmd.value = self.gain_to_ff(value)
-        self.send_command(cmd)
-        self.settings.state.gain_db = value
-        return SpectrometerResponse()
-
-    def change_setting(self,setting,value):
-        log.info(f"spi being told to change setting {setting} to {value}")
-        f = self.lambdas.get(setting,None)
-        if f is not None:
-            f(value)
-        return True
-
-    def _init_process_funcs(self): # -> dict[str, Callable[..., Any]] 
-        process_f = {}
-
-        process_f["connect"] = self.connect
-        process_f["disconnect"] = self.disconnect
-        process_f["acquire_data"] = self.acquire_data
-        process_f["set_integration_time_ms"] = self.set_integration_time_ms
-        process_f["detector_gain"] = self.set_gain
-        ##################################################################
-        # What follows is the old init-lambdas that are squashed into process_f
-        # Long term, the upstream requests should be changed to match the new format
-        # This is an easy fix for the time being to make things behave
-        ##################################################################
-       #process_f["write_eeprom"]                       = lambda x: self.write_eeprom()
-       #process_f["replace_eeprom"]                     = lambda x: self.write_eeprom()
-        process_f["integration_time_ms"]                = lambda x: self.set_integration_time_ms(x)
-
-        return process_f
-
-    ############################################################################
-    #                                                                          #
-    #                               Utility Methods                            #
-    #                                                                          #
-    ############################################################################
-
-    ## format a list or bytearray as "[ 0x00, 0x0a, 0xff ]"
-    def to_hex(self, values):
-        return "[ " + ", ".join([ f"0x{v:02x}" for v in values ]) + " ]"
-
-    ## confirm the received CRC matches our computed CRC for the list or bytearray "data"
-    def check_crc(self, crc_received, data):
-        crc_computed = self.crc8(data)
-        if crc_computed != crc_received:
-            log.error(f"CRC mismatch: received 0x{crc_received:02x}, computed 0x{crc_computed:02x}")
-
-    ## given a list or bytearray of data elements, return the checksum
-    def compute_crc(self, data):
-        return self.crc8(bytearray(data))
-
-    ##
-    # given a formatted SPI command of the form [START, L0, L1, ADDR, ...DATA..., CRC, END],
-    # return command with CRC replaced with the computed checksum of [L0..DATA] as bytearray
-    def fix_crc(self, cmd):
-        if cmd is None or len(cmd) < 6 or cmd[0] != self.START or cmd[-1] != self.END:
-            log.error(f"fix_crc expects well-formatted SPI 'write' command: {cmd}")
-            return
-
-        index = len(cmd) - 2
-        checksum = self.compute_crc(bytearray(cmd[1:index]))
-        result = cmd[:index]
-        result.extend([checksum, cmd[-1]])
-        # log.debug(f"fix_crc: cmd {self.to_hex(cmd)} -> result {self.to_hex(result)}")
-        return bytearray(result)
-
-    ## @see ENG-0150-C section 3.2, "Configuration Set Response Packet"
-    def errorcode_to_string(self, code): # -> str 
-        if   code == 0: return "SUCCESS"
-        elif code == 1: return "ERROR_LENGTH"
-        elif code == 2: return "ERROR_CRC"
-        elif code == 3: return "ERROR_UNRECOGNIZED_COMMAND"
-        else          : return "ERROR_UNDEFINED"
-
-    ## @param response (Input): the last 3 bytes of the device's response to a SPI write command
-    def validate_write_response(self, response): # -> str 
-        if len(response) != 3:
-            return f"invalid response length: {response}"
-        if response[0] != self.START:
-            return f"invalid response START marker: {response}"
-        if response[2] != self.END:
-            return f"invalid response END marker: {response}"
-        return self.errorcode_to_string(response[1])
-
-    ##
-    # Given an existing list or bytearray, copy the contents into a new bytearray of
-    # the specified size. This is used to generate the "command" argument of a
-    # SPI.write_readinto(cmd, response) call, as both buffers are expected to be of
-    # the same size.
-    #
-    # @see https://docs.circuitpython.org/en/latest/shared-bindings/busio/#busio.SPI.write_readinto
-    def buffer_bytearray(self, orig, size):
-        new = bytearray(size)
-        new[:len(orig)] = orig[:]
-        return new
-
-    ##
-    # Given an unbuffered "read" command (just the bytes we wanted to write, without
-    # trailing zeros for the read response), and the complete (buffered) response
-    # read back (including leading junk from the command/write phase), parse out the
-    # actual response data and validate checksum.
-    #
-    # @para Example (reading FPGA version number)
-    # @verbatim
-    #              offset:    0     1     2     3     4     5     6     7     8     9    10    11    12    13    14    15    16    17
-    #         explanation:    <    (_length_)  ADDR   >     <    (_length_)  ADDR  '0'   '2'   '.'   '1'   '.'   '2'   '3'   CRC    >
-    #  unbuffered_command: [ 0x3c, 0x00, 0x01, 0x10, 0x3e ]
-    #    buffered_command: [ 0x3c, 0x00, 0x01, 0x10, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ]
-    #   buffered_response: [  ?? ,  ?? ,  ?? ,  ?? ,  ?? , 0x3c, 0x00, 0x08, 0x10, 0x30, 0x32, 0x2e, 0x31, 0x2e, 0x32, 0x33, 0x83, 0x3e ]
-    # unbuffered_response:                               [ 0x3c, 0x00, 0x08, 0x10, 0x30, 0x32, 0x2e, 0x31, 0x2e, 0x32, 0x33, 0x83, 0x3e ]
-    #            crc_data:                                     [ 0x00, 0x08, 0x10, 0x30, 0x32, 0x2e, 0x31, 0x2e, 0x32, 0x33 ]
-    #       response_data:                                                       [ 0x30, 0x32, 0x2e, 0x31, 0x2e, 0x32, 0x33 ]
-    # @endverbatim
-    #
-    # @returns array of response payload bytes (everything after ADDR but before CRC)
-    # @note only used for SPI "read" commands ("write" commands are much simpler)
-    #
-    # @param unbuffered_cmd: the START..END read command sent to the device (but
-    #        not the empty "buffer" bytes at the end, written while reading the response)
-    # @param buffered_response: the complete sequence of bytes read from the
-    #        device, including the echoed unbuffered command
-    # @param name: for debugging
-    # @param missing_echo_len: in proper SPI, if I write 5 bytes, with an
-    #        expected response of 13 bytes, then I should actually read 18 bytes:
-    #        the "echoes" of the 5 written bytes, then the 13 actual response
-    #        bytes. Buggy FW may lead to some "echo" bytes missing from the
-    #        response stream; this value can allow the client to stay in sync.
-    #        In the current design, this occurs when reading EEPROM pages.
-    def decode_read_response(self, unbuffered_cmd, buffered_response, name=None, missing_echo_len=0):
-        cmd_len = len(unbuffered_cmd)
-        unbuffered_response = buffered_response[len(unbuffered_cmd) - missing_echo_len:]
-        response_data_len = (unbuffered_response[1] << 8) | unbuffered_response[2]
-        response_data = unbuffered_response[4 : 4 + response_data_len - 1]
-        crc_received = unbuffered_response[-2]
-        crc_data = unbuffered_response[1 : -2]
-        self.check_crc(crc_received, crc_data)
-
-        if True:
-            log.debug(f"decode_read_response({name}, missing={missing_echo_len}):")
-            log.debug(f"  unbuffered_cmd:      {self.to_hex(unbuffered_cmd)}")
-            log.debug(f"  buffered_response:   {self.to_hex(buffered_response)}")
-            log.debug(f"  cmd_len:             {cmd_len}")
-            log.debug(f"  unbuffered_response: {self.to_hex(unbuffered_response)}")
-            log.debug(f"  response_data_len:   {response_data_len}")
-            log.debug(f"  response_data:       {self.to_hex(response_data)}")
-            log.debug(f"  crc_received:        {hex(crc_received)}")
-            log.debug(f"  crc_data:            {self.to_hex(crc_data)}")
-
-        return response_data
-
-    def send_command(self, cmd: CommandTuple):
-        txData = []
-        txData    .append( cmd.value        & 0xff) # LSB
-        if cmd.write_len > 2:
-            txData.append((cmd.value >>  8) & 0xff)
-        if cmd.write_len > 3:
-            txData.append((cmd.value >> 16) & 0xff) # MSB
-
-        unbuffered_cmd = [self.START, 0x00, cmd.write_len, cmd.address | self.WRITE]
-        unbuffered_cmd.extend(txData)
-        unbuffered_cmd.extend([self.compute_crc(unbuffered_cmd[1:]), self.END])
-
-        # MZ: the -1 at the end was added as a kludge, because otherwise we find
-        #     a redundant '>' in the last byte.  This seems a bug, due to the
-        #     fact that only 7 of the 8 unbuffered_cmd bytes are echoed back into
-        #     the read buffer.
-        buffered_response = bytearray(len(unbuffered_cmd) + self.WRITE_RESPONSE_OVERHEAD + 1 - 1)
-        buffered_cmd = self.buffer_bytearray(unbuffered_cmd, len(buffered_response))
-
-        with self.lock:
-            if not self.flush_input_buffer():
-                log.critical(f"failed to send command {cmd}")
-                return
-            self.SPI.write_readinto(buffered_cmd, buffered_response)
-
-        error_msg = self.validate_write_response(buffered_response[-3:])
-        log.debug(f"send_command[{cmd.name}]: {self.to_hex(buffered_cmd)} -> {self.to_hex(buffered_response)} ({error_msg})")
-
-    ## @returns False if SPI communication hosed. This can happen for instance if your SPI_PIN_READY isn't set.
-    def flush_input_buffer(self): # -> bool 
-        count = 0
-        junk = bytearray(self.READY_POLL_LEN)
-
-        MAX_READ = 4096 # something is plainly wrong
-
-        try:
-            while self.ready.value:
-                self.SPI.readinto(junk)
-                count += self.READY_POLL_LEN
-                if count > MAX_READ:
-                    log.critical(f"flush_input_buffer: giving up after flushing {count} bytes")
-                    return False
-        except OSError:
-            log.critical("flush_input_buffer: OSError", exc_info=1)
-            return False
-        except pyftdi.ftdi.FtdiError:
-            log.critical("flush_input_buffer: FtdiError", exc_info=1)
-            return False
-
-        if count > 0:
-            log.debug(f"flushed {count} bytes from input buffer")
-        return True
-
-    def wait_for_data_ready(self):
-        while not self.ready.value:
-            pass
-
-    ##
-    # Convert a (potentially) floating-point value into the big-endian 16-bit "Funky
-    # Float" used for detector gain in the FPGA on both Hamamatsu and IMX sensors.
-    #
-    # @see https://wasatchphotonics.com/api/Wasatch.NET/class_wasatch_n_e_t_1_1_funky_float.html
-    def gain_to_ff(self, gain):
-        msb = int(round(gain, 5)) & 0xff
-        lsb = int((gain - msb) * 256) & 0xff
-        raw = (msb << 8) | lsb
-        log.debug(f"gain_to_ff: {gain:0.3f} -> dec {raw} (0x{raw:04x})")
-        return raw
-
-    def read_page(self, page: int): # -> list[bytes] 
-        with self.lock:
-            # send 0xb0 command to tell FPGA to load EEPROM page into FPGA buffer
-            unbuffered_cmd = self.fix_crc([self.START, 0, 2, 0xb0, 0x40 + page, self.CRC, self.END])
-            buffered_response = bytearray(len(unbuffered_cmd) + self.READ_RESPONSE_OVERHEAD + 1)
-            buffered_cmd = self.buffer_bytearray(unbuffered_cmd, len(buffered_response))
-            self.SPI.write_readinto(buffered_cmd, buffered_response)
-            log.debug(f">> read_page: {self.to_hex(buffered_cmd)} -> {self.to_hex(buffered_response)}")
-
-            # MZ: API says "wait for SPEC_BUSY to be deasserted...why aren't we doing that?
-            time.sleep(0.01) # empirically determined 10ms delay
-
-            # send 0x31 command to read the buffered page from the FPGA
-            unbuffered_cmd = self.fix_crc([self.START, 0, 65, 0x31, self.CRC, self.END])
-            buffered_response = bytearray(len(unbuffered_cmd) + self.READ_RESPONSE_OVERHEAD + 64) # MZ: including kludged -1
-            buffered_cmd = self.buffer_bytearray(unbuffered_cmd, len(buffered_response))
-            self.SPI.write_readinto(buffered_cmd, buffered_response)
-
-        buf = self.decode_read_response(unbuffered_cmd, buffered_response, "read_eeprom_page", missing_echo_len=1)
-        log.debug(f"decoded {len(buf)} values from EEPROM")
-        return buf
-
-    def get_spectrum(self): # -> list[int] 
-        with self.lock:
-
-            ####################################################################
-            # Trigger Acquisition
-            ####################################################################
-
-            if self.settings.state.trigger_source == SpectrometerState.TRIGGER_SOURCE_EXTERNAL:
-                log.debug("waiting on external trigger...")
-                self.wait_for_data_ready()
-            else:
-                # send trigger via the FT232H
-                self.trigger.value = True
-                self.wait_for_data_ready()
-                self.trigger.value = False
-
-            ####################################################################
-            # Read the spectrum (MZ: big-endian, seriously?)
-            ####################################################################
-
-            spectrum = []
-            pixels = self.settings.pixels()
-            bytes_remaining = pixels * 2
-
-            log.debug(f"get_spectrum: reading spectrum of {pixels} pixels")
-            raw = []
-            while self.ready.value:
-                if bytes_remaining > 0:
-                    bytes_this_read = min(self.block_size, bytes_remaining)
-
-                    # log.debug(f"get_spectrum: reading block of {bytes_this_read} bytes")
-                    buf = bytearray(bytes_this_read)
-
-                    # There is latency associated with this call, so call it as
-                    # few times as possible (with the largest possible block
-                    # size).  Basically, I'm assuming each call requires a full
-                    # 64-byte USB control packet to the FT232H (and response).
-                    self.SPI.readinto(buf)
-
-                    # log.debug(f"get_spectrum: read block of {len(buf)} bytes")
-                    raw.extend(list(buf))
-
-                    bytes_remaining -= len(buf)
-
-        ########################################################################
-        # post-process spectrum
-        ########################################################################
-
-        # demarshall big-endian
-        for i in range(0, len(raw)-1, 2):
-            spectrum.append((raw[i] << 8) | raw[i+1])
-        log.debug(f"get_spectrum: {len(spectrum)} pixels read ({spectrum[:3]} .. {spectrum[-3:]})")
-
-        return spectrum
+import os
+import usb
+import time
+import logging
+import datetime
+import platform
+import threading
+
+from queue import Queue
+
+from pyftdi.ftdi import FtdiError
+
+# Needed for Mac side
+# Device Finder should already have done this
+# For thoroughness though doing here anyway
+# This is required for finding the usb <-> serial board
+#
+# MZ: I don't remember anything about this, but SPI is not a priority at
+#     this time and this broke under Python 3.11
+#
+import usb.core
+# usb.core.find()
+
+from .SpectrometerSettings        import SpectrometerSettings
+from .SpectrometerState           import SpectrometerState
+from .SpectrometerResponse        import SpectrometerResponse
+from .SpectrometerResponse        import ErrorLevel
+from .DeviceID                    import DeviceID
+from .InterfaceDevice             import InterfaceDevice
+from .Reading                     import Reading
+from .EEPROM                      import EEPROM
+
+import crcmod.predefined
+
+log = logging.getLogger(__name__)
+
+##
+# @note write_len includes the opcode (address) itself, so a 1-byte value like
+#       PixelMode has write_len 2, and a 24-bit value like Integration Time has
+#       write_len 4.
+class CommandTuple:
+    def __init__(self, address, value, write_len, name):
+        self.address   = address
+        self.value     = value
+        self.write_len = write_len
+        self.name      = name
+
+    def __str__(self):
+        return f"CommandTuple <name {self.name}, address 0x{self.address:02x}, value {self.value}, write_len {self.write_len}>"
+
+class SPIDevice(InterfaceDevice):
+    """
+    This implements SPI communication via the FT232H usb converter.
+
+    This class adopts the external device interface structure.
+    This involves receiving a request through the handle_request function.
+    A request is processed based on the key in the request.
+    The processing function passes the commands to the requested device.
+    Once it receives a response from the connected device it then passes that
+    back up the chain.
+
+    @verbatim
+                               Enlighten Request
+                                       |
+                                handle_requests
+                                       |
+                                 ------------
+                                /   /  |  \  \ 
+             { get_laser status, acquire, set_laser_watchdog, etc....}
+                                \   \  |  /  /
+                                 ------------
+                                       |
+                         {self.driver.some_spi_call}
+    @endverbatim
+
+    @see https://github.com/WasatchPhotonics/Python-USB-WP-Raman-Examples/blob/master/SPI/spi_console.py
+    """
+
+    READ_RESPONSE_OVERHEAD  = 5 # <, LEN_MSB, LEN_LSB, CRC, >  # does NOT include ADDR
+    WRITE_RESPONSE_OVERHEAD = 2 # <, >
+    READY_POLL_LEN = 2          # 1 seems to work
+    START = 0x3c                # <
+    END   = 0x3e                # >
+    WRITE = 0x80                # bit changing opcodes from 'getter' to 'setter'
+    CRC   = 0xff                # for readability
+
+    lock = threading.Lock()
+
+    def __init__(self, device_id: DeviceID, message_queue: Queue): # -> None 
+        super().__init__()
+
+        ########################################################################
+        # Attempt to import dependencies (connects to FT232H)
+        ########################################################################
+
+        import_successful = False
+        try:
+            os.environ["BLINKA_FT232H"] = "1"
+            import board
+            import digitalio
+            import busio
+            import_successful = True
+        except RuntimeError:
+            log.error("No FT232H connected.", exc_info=1)
+            if platform.system() == "Windows":
+                log.error("Ensure you've followed the Zadig process in README_SPI.md")
+        except ValueError:
+            log.error("If you are receiving 'no backend available' errors, try the following:")
+            log.error("MacOS:  $ export DYLD_LIBRARY_PATH=/usr/local/lib")
+            log.error("Linux:  $ export LD_LIBRARY_PATH=/usr/local/lib")
+        except FtdiError:
+            log.error("No FT232H connected.", exc_info=1)
+            if platform.system() == "Windows":
+                log.error("Ensure you've followed the Zadig process in README_SPI.md")
+            log.error("SPIDevice is not usable")
+        if not import_successful:
+            return
+
+        self.crc8 = crcmod.predefined.mkPredefinedCrcFun('crc-8-maxim')
+
+        ########################################################################
+        # Proceed with initialization
+        ########################################################################
+
+        # if passed a string representation of a DeviceID, deserialize it
+        if type(device_id) is str:
+            device_id = DeviceID(label=device_id)
+
+        self.device_id      = device_id
+        self.message_queue  = message_queue
+
+        self.connected = False
+        self.disconnect = False
+        self.acquiring = False
+
+        # Receives ENLIGHTEN's 'change settings' commands in the spectrometer
+        # process. Although a logical queue, has nothing to do with multiprocessing.
+        self.command_queue = []
+
+        self.immediate_mode = False
+
+        self.settings = SpectrometerSettings(self.device_id)
+        self.summed_spectra         = None
+        self.sum_count              = 0
+        self.session_reading_count  = 0
+        self.take_one               = False
+        self.failure_count          = 0
+
+        self.process_id = os.getpid()
+        self.last_memory_check = datetime.datetime.now()
+        self.last_battery_percentage = 0
+        self.lambdas = None
+        self.spec_index = 0
+        self._scan_averaging = 1
+        self.dark = None
+        self.boxcar_half_width = 0
+
+        # Initialize the SPI bus on the FT232H
+        self.SPI = busio.SPI(clock=board.SCK, MISO=board.MISO, MOSI=board.MOSI)
+
+        # Initialize D5 as the ready signal (allow override)
+        self.ready = digitalio.DigitalInOut(getattr(board, os.getenv("SPI_PIN_READY", default="D5")))
+        self.ready.direction = digitalio.Direction.INPUT
+
+        # Initialize D6 as the trigger (allow override)
+        self.trigger = digitalio.DigitalInOut(getattr(board, os.getenv("SPI_PIN_TRIGGER", default="D6")))
+        self.trigger.direction = digitalio.Direction.OUTPUT
+        self.trigger.value = False
+
+        # Take control of the SPI Bus
+        while not self.SPI.try_lock():
+            pass
+
+        # Configure the SPI bus (allow override)
+        self.baud_mhz = int(os.getenv("SPI_BAUD_MHZ", default="10"))
+        log.debug(f"using baud rate {self.baud_mhz}MHz")
+        self.SPI.configure(baudrate=self.baud_mhz * 1e6, phase=0, polarity=0, bits=8)
+
+        # for kicks, let block size be overridden by the environment
+        self.block_size = int(os.getenv("SPI_BLOCK_SIZE", default="256"))
+        log.debug(f"using SPI block size {self.block_size}")
+
+        self.process_f = self._init_process_funcs()
+
+        ########################################################################
+        # Store SPI command table in a lookup
+        ########################################################################
+
+        self.cmds = {}
+        for      addr, value, len_, name in [
+                #----  -----  ----  -----------
+                (0x11,    3,     4, "Integration Time"),
+                (0x13,    0,     3, "Black Level"),
+                (0x14,   24,     3, "Gain dB"),
+                (0x2B,    3,     2, "Pixel Mode"),
+                (0x50,  250,     3, "Start Line 0"),
+                (0x51,  750,     3, "Stop Line 0"),
+                (0x52,   12,     3, "Start Column 0"),
+                (0x53, 1932,     3, "Stop Column 0"),
+                (0x54,    0,     3, "Start Line 1"),
+                (0x55,    0,     3, "Stop Line 1"),
+                (0x56,    0,     3, "Start Column 1"),
+                (0x57,    0,     3, "Stop Column 1"),
+                (0x58,    0,     3, "Desmile") ]:
+            self.cmds[name] = CommandTuple(addr, value, len_, name)
+
+        # patch gain
+        cmd = self.cmds["Gain dB"]
+        cmd.value = self.gain_to_ff(cmd.value)
+
+    def connect(self): # -> SpectrometerResponse 
+        log.debug("initializing EEPROM")
+        if not self.init_eeprom():
+            log.critical("failed to initialize EEPROM, giving up")
+            return SpectrometerResponse(False, error_msg="EEPROM initialization failure", error_lvl=ErrorLevel.high, poison_pill=True)
+
+        # initialize all settings -- this ensures no setting is uninitialized
+        log.debug("initializing all commands")
+        for key in self.cmds:
+            cmd = self.cmds[key]
+            log.debug(f"initializing {cmd}")
+            self.send_command(cmd)
+
+        self.settings.state.integration_time_ms = self.settings.eeprom.startup_integration_time_ms
+        self.settings.state.gain_db = self.settings.eeprom.detector_gain
+
+        log.info("SPI connect done, returning True")
+        return SpectrometerResponse(True)
+
+    ## @returns True on success
+    def init_eeprom(self): # -> bool 
+        eeprom = self.settings.eeprom
+
+        pages = []
+        for i in range(EEPROM.MAX_PAGES):
+            log.debug(f"flushing buffer before page {i}")
+            if not self.flush_input_buffer():
+                log.error("unable to read EEPROM")
+                return False
+            pages.append(self.read_page(i))
+
+        if not eeprom.parse(pages):
+            log.error(f"failed to parse EEPROM")
+            return False
+
+        self.settings.update_wavecal()
+        self.settings.update_raman_intensity_factors()
+
+        # copy startup values from EEPROM into our local command table so they
+        # get initialized properly
+
+        self.cmds["Integration Time"].value = eeprom.startup_integration_time_ms
+        self.cmds["Gain dB"         ].value = self.gain_to_ff(eeprom.detector_gain)
+        self.cmds["Start Line 0"    ].value = eeprom.roi_vertical_region_1_start
+        self.cmds["Stop Line 0"     ].value = eeprom.roi_vertical_region_1_end
+        self.cmds["Start Column 0"  ].value = eeprom.roi_horizontal_start
+        self.cmds["Stop Column 0"   ].value = eeprom.roi_horizontal_end
+
+        return True
+
+    def disconnect(self): # -> SpectrometerResponse 
+        self.disconnect = True
+        return SpectrometerResponse(True)
+
+    def acquire_data(self): # -> SpectrometerResponse 
+        log.debug("spi starts reading")
+        if self.disconnect:
+            log.debug("disconnecting, returning False for the spectrum")
+            return False
+        averaging_enabled = (self.settings.state.scans_to_average > 1)
+        reading = Reading(self.device_id)
+
+        try:
+            reading.integration_time_ms = self.settings.state.integration_time_ms
+            reading.laser_power_perc    = self.settings.state.laser_power_perc
+            reading.laser_power_mW      = self.settings.state.laser_power_mW
+            reading.laser_enabled       = self.settings.state.laser_enabled
+            reading.spectrum            = self.get_spectrum()
+            if not reading.spectrum:
+                return False
+        except usb.USBError:
+            self.failure_count += 1
+            log.error(f"SPI Device: encountered USB error in reading for device {self.device}")
+
+        if not reading.failure:
+            if averaging_enabled:
+                if self.sum_count == 0:
+                    self.summed_spectra = [float(i) for i in reading.spectrum]
+                else:
+                    log.debug("device.take_one_averaged_reading: summing spectra")
+                    for i in range(len(self.summed_spectra)):
+                        self.summed_spectra[i] += reading.spectrum[i]
+                self.sum_count += 1
+                log.debug("device.take_one_averaged_reading: summed_spectra : %s ...", self.summed_spectra[0:9])
+
+        if self.settings.eeprom.bin_2x2:
+            # perform the 2x2 bin software side
+            next_idx_values = reading.spectrum[1:]
+            # average all except the last value, which is just appended as is
+            binned = [(value + next_value)/2 for value, next_value in zip(reading.spectrum[:-1], next_idx_values)]
+            binned.append(reading.spectrum[-1])
+            reading.spectrum = binned
+
+        self.session_reading_count += 1
+        reading.session_count = self.session_reading_count
+        reading.sum_count = self.sum_count
+
+        if averaging_enabled:
+            if self.sum_count >= self.settings.state.scans_to_average:
+                reading.spectrum = [ x / self.sum_count for x in self.summed_spectra ]
+                log.debug("spi device acquire data: averaged_spectrum : %s ...", reading.spectrum[0:9])
+                reading.averaged = True
+
+                # reset for next average
+                self.summed_spectra = None
+                self.sum_count = 0
+        else:
+            # if averaging isn't enabled...then a single reading is the
+            # "averaged" final measurement (check reading.sum_count to confirm)
+            reading.averaged = True
+
+        return SpectrometerResponse(reading)
+
+    def set_integration_time_ms(self, value: int): # -> SpectrometerResponse 
+        cmd = self.cmds["Integration Time"]
+        cmd.value = value
+        self.send_command(cmd)
+        self.settings.state.integration_time_ms = value
+        return SpectrometerResponse()
+
+    def set_gain(self, value: float): # -> SpectrometerResponse 
+        cmd = self.cmds["Gain dB"]
+        cmd.value = self.gain_to_ff(value)
+        self.send_command(cmd)
+        self.settings.state.gain_db = value
+        return SpectrometerResponse()
+
+    def change_setting(self,setting,value):
+        log.info(f"spi being told to change setting {setting} to {value}")
+        f = self.lambdas.get(setting,None)
+        if f is not None:
+            f(value)
+        return True
+
+    def _init_process_funcs(self): # -> dict[str, Callable[..., Any]] 
+        process_f = {}
+
+        process_f["connect"] = self.connect
+        process_f["disconnect"] = self.disconnect
+        process_f["acquire_data"] = self.acquire_data
+        process_f["set_integration_time_ms"] = self.set_integration_time_ms
+        process_f["detector_gain"] = self.set_gain
+        ##################################################################
+        # What follows is the old init-lambdas that are squashed into process_f
+        # Long term, the upstream requests should be changed to match the new format
+        # This is an easy fix for the time being to make things behave
+        ##################################################################
+       #process_f["write_eeprom"]                       = lambda x: self.write_eeprom()
+       #process_f["replace_eeprom"]                     = lambda x: self.write_eeprom()
+        process_f["integration_time_ms"]                = lambda x: self.set_integration_time_ms(x)
+
+        return process_f
+
+    ############################################################################
+    #                                                                          #
+    #                               Utility Methods                            #
+    #                                                                          #
+    ############################################################################
+
+    ## format a list or bytearray as "[ 0x00, 0x0a, 0xff ]"
+    def to_hex(self, values):
+        return "[ " + ", ".join([ f"0x{v:02x}" for v in values ]) + " ]"
+
+    ## confirm the received CRC matches our computed CRC for the list or bytearray "data"
+    def check_crc(self, crc_received, data):
+        crc_computed = self.crc8(data)
+        if crc_computed != crc_received:
+            log.error(f"CRC mismatch: received 0x{crc_received:02x}, computed 0x{crc_computed:02x}")
+
+    ## given a list or bytearray of data elements, return the checksum
+    def compute_crc(self, data):
+        return self.crc8(bytearray(data))
+
+    ##
+    # given a formatted SPI command of the form [START, L0, L1, ADDR, ...DATA..., CRC, END],
+    # return command with CRC replaced with the computed checksum of [L0..DATA] as bytearray
+    def fix_crc(self, cmd):
+        if cmd is None or len(cmd) < 6 or cmd[0] != self.START or cmd[-1] != self.END:
+            log.error(f"fix_crc expects well-formatted SPI 'write' command: {cmd}")
+            return
+
+        index = len(cmd) - 2
+        checksum = self.compute_crc(bytearray(cmd[1:index]))
+        result = cmd[:index]
+        result.extend([checksum, cmd[-1]])
+        # log.debug(f"fix_crc: cmd {self.to_hex(cmd)} -> result {self.to_hex(result)}")
+        return bytearray(result)
+
+    ## @see ENG-0150-C section 3.2, "Configuration Set Response Packet"
+    def errorcode_to_string(self, code): # -> str 
+        if   code == 0: return "SUCCESS"
+        elif code == 1: return "ERROR_LENGTH"
+        elif code == 2: return "ERROR_CRC"
+        elif code == 3: return "ERROR_UNRECOGNIZED_COMMAND"
+        else          : return "ERROR_UNDEFINED"
+
+    ## @param response (Input): the last 3 bytes of the device's response to a SPI write command
+    def validate_write_response(self, response): # -> str 
+        if len(response) != 3:
+            return f"invalid response length: {response}"
+        if response[0] != self.START:
+            return f"invalid response START marker: {response}"
+        if response[2] != self.END:
+            return f"invalid response END marker: {response}"
+        return self.errorcode_to_string(response[1])
+
+    ##
+    # Given an existing list or bytearray, copy the contents into a new bytearray of
+    # the specified size. This is used to generate the "command" argument of a
+    # SPI.write_readinto(cmd, response) call, as both buffers are expected to be of
+    # the same size.
+    #
+    # @see https://docs.circuitpython.org/en/latest/shared-bindings/busio/#busio.SPI.write_readinto
+    def buffer_bytearray(self, orig, size):
+        new = bytearray(size)
+        new[:len(orig)] = orig[:]
+        return new
+
+    ##
+    # Given an unbuffered "read" command (just the bytes we wanted to write, without
+    # trailing zeros for the read response), and the complete (buffered) response
+    # read back (including leading junk from the command/write phase), parse out the
+    # actual response data and validate checksum.
+    #
+    # @par Example (reading FPGA version number)
+    # @verbatim
+    #              offset:    0     1     2     3     4     5     6     7     8     9    10    11    12    13    14    15    16    17
+    #         explanation:    <    (_length_)  ADDR   >     <    (_length_)  ADDR  '0'   '2'   '.'   '1'   '.'   '2'   '3'   CRC    >
+    #  unbuffered_command: [ 0x3c, 0x00, 0x01, 0x10, 0x3e ]
+    #    buffered_command: [ 0x3c, 0x00, 0x01, 0x10, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ]
+    #   buffered_response: [  ?? ,  ?? ,  ?? ,  ?? ,  ?? , 0x3c, 0x00, 0x08, 0x10, 0x30, 0x32, 0x2e, 0x31, 0x2e, 0x32, 0x33, 0x83, 0x3e ]
+    # unbuffered_response:                               [ 0x3c, 0x00, 0x08, 0x10, 0x30, 0x32, 0x2e, 0x31, 0x2e, 0x32, 0x33, 0x83, 0x3e ]
+    #            crc_data:                                     [ 0x00, 0x08, 0x10, 0x30, 0x32, 0x2e, 0x31, 0x2e, 0x32, 0x33 ]
+    #       response_data:                                                       [ 0x30, 0x32, 0x2e, 0x31, 0x2e, 0x32, 0x33 ]
+    # @endverbatim
+    #
+    # @returns array of response payload bytes (everything after ADDR but before CRC)
+    # @note only used for SPI "read" commands ("write" commands are much simpler)
+    #
+    # @param unbuffered_cmd: the START..END read command sent to the device (but
+    #        not the empty "buffer" bytes at the end, written while reading the response)
+    # @param buffered_response: the complete sequence of bytes read from the
+    #        device, including the echoed unbuffered command
+    # @param name: for debugging
+    # @param missing_echo_len: in proper SPI, if I write 5 bytes, with an
+    #        expected response of 13 bytes, then I should actually read 18 bytes:
+    #        the "echoes" of the 5 written bytes, then the 13 actual response
+    #        bytes. Buggy FW may lead to some "echo" bytes missing from the
+    #        response stream; this value can allow the client to stay in sync.
+    #        In the current design, this occurs when reading EEPROM pages.
+    def decode_read_response(self, unbuffered_cmd, buffered_response, name=None, missing_echo_len=0):
+        cmd_len = len(unbuffered_cmd)
+        unbuffered_response = buffered_response[len(unbuffered_cmd) - missing_echo_len:]
+        response_data_len = (unbuffered_response[1] << 8) | unbuffered_response[2]
+        response_data = unbuffered_response[4 : 4 + response_data_len - 1]
+        crc_received = unbuffered_response[-2]
+        crc_data = unbuffered_response[1 : -2]
+        self.check_crc(crc_received, crc_data)
+
+        if True:
+            log.debug(f"decode_read_response({name}, missing={missing_echo_len}):")
+            log.debug(f"  unbuffered_cmd:      {self.to_hex(unbuffered_cmd)}")
+            log.debug(f"  buffered_response:   {self.to_hex(buffered_response)}")
+            log.debug(f"  cmd_len:             {cmd_len}")
+            log.debug(f"  unbuffered_response: {self.to_hex(unbuffered_response)}")
+            log.debug(f"  response_data_len:   {response_data_len}")
+            log.debug(f"  response_data:       {self.to_hex(response_data)}")
+            log.debug(f"  crc_received:        {hex(crc_received)}")
+            log.debug(f"  crc_data:            {self.to_hex(crc_data)}")
+
+        return response_data
+
+    def send_command(self, cmd: CommandTuple):
+        txData = []
+        txData    .append( cmd.value        & 0xff) # LSB
+        if cmd.write_len > 2:
+            txData.append((cmd.value >>  8) & 0xff)
+        if cmd.write_len > 3:
+            txData.append((cmd.value >> 16) & 0xff) # MSB
+
+        unbuffered_cmd = [self.START, 0x00, cmd.write_len, cmd.address | self.WRITE]
+        unbuffered_cmd.extend(txData)
+        unbuffered_cmd.extend([self.compute_crc(unbuffered_cmd[1:]), self.END])
+
+        # MZ: the -1 at the end was added as a kludge, because otherwise we find
+        #     a redundant '>' in the last byte.  This seems a bug, due to the
+        #     fact that only 7 of the 8 unbuffered_cmd bytes are echoed back into
+        #     the read buffer.
+        buffered_response = bytearray(len(unbuffered_cmd) + self.WRITE_RESPONSE_OVERHEAD + 1 - 1)
+        buffered_cmd = self.buffer_bytearray(unbuffered_cmd, len(buffered_response))
+
+        with self.lock:
+            if not self.flush_input_buffer():
+                log.critical(f"failed to send command {cmd}")
+                return
+            self.SPI.write_readinto(buffered_cmd, buffered_response)
+
+        error_msg = self.validate_write_response(buffered_response[-3:])
+        log.debug(f"send_command[{cmd.name}]: {self.to_hex(buffered_cmd)} -> {self.to_hex(buffered_response)} ({error_msg})")
+
+    ## @returns False if SPI communication hosed. This can happen for instance if your SPI_PIN_READY isn't set.
+    def flush_input_buffer(self): # -> bool 
+        count = 0
+        junk = bytearray(self.READY_POLL_LEN)
+
+        MAX_READ = 4096 # something is plainly wrong
+
+        try:
+            while self.ready.value:
+                self.SPI.readinto(junk)
+                count += self.READY_POLL_LEN
+                if count > MAX_READ:
+                    log.critical(f"flush_input_buffer: giving up after flushing {count} bytes")
+                    return False
+        except OSError:
+            log.critical("flush_input_buffer: OSError", exc_info=1)
+            return False
+        except FtdiError:
+            log.critical("flush_input_buffer: FtdiError", exc_info=1)
+            return False
+
+        if count > 0:
+            log.debug(f"flushed {count} bytes from input buffer")
+        return True
+
+    def wait_for_data_ready(self):
+        while not self.ready.value:
+            pass
+
+    ##
+    # Convert a (potentially) floating-point value into the big-endian 16-bit "Funky
+    # Float" used for detector gain in the FPGA on both Hamamatsu and IMX sensors.
+    #
+    # @see https://wasatchphotonics.com/api/Wasatch.NET/class_wasatch_n_e_t_1_1_funky_float.html
+    def gain_to_ff(self, gain):
+        msb = int(round(gain, 5)) & 0xff
+        lsb = int((gain - msb) * 256) & 0xff
+        raw = (msb << 8) | lsb
+        log.debug(f"gain_to_ff: {gain:0.3f} -> dec {raw} (0x{raw:04x})")
+        return raw
+
+    def read_page(self, page: int): # -> list[bytes] 
+        with self.lock:
+            # send 0xb0 command to tell FPGA to load EEPROM page into FPGA buffer
+            unbuffered_cmd = self.fix_crc([self.START, 0, 2, 0xb0, 0x40 + page, self.CRC, self.END])
+            buffered_response = bytearray(len(unbuffered_cmd) + self.READ_RESPONSE_OVERHEAD + 1)
+            buffered_cmd = self.buffer_bytearray(unbuffered_cmd, len(buffered_response))
+            self.SPI.write_readinto(buffered_cmd, buffered_response)
+            log.debug(f">> read_page: {self.to_hex(buffered_cmd)} -> {self.to_hex(buffered_response)}")
+
+            # MZ: API says "wait for SPEC_BUSY to be deasserted...why aren't we doing that?
+            time.sleep(0.01) # empirically determined 10ms delay
+
+            # send 0x31 command to read the buffered page from the FPGA
+            unbuffered_cmd = self.fix_crc([self.START, 0, 65, 0x31, self.CRC, self.END])
+            buffered_response = bytearray(len(unbuffered_cmd) + self.READ_RESPONSE_OVERHEAD + 64) # MZ: including kludged -1
+            buffered_cmd = self.buffer_bytearray(unbuffered_cmd, len(buffered_response))
+            self.SPI.write_readinto(buffered_cmd, buffered_response)
+
+        buf = self.decode_read_response(unbuffered_cmd, buffered_response, "read_eeprom_page", missing_echo_len=1)
+        log.debug(f"decoded {len(buf)} values from EEPROM")
+        return buf
+
+    def get_spectrum(self): # -> list[int] 
+        with self.lock:
+
+            ####################################################################
+            # Trigger Acquisition
+            ####################################################################
+
+            if self.settings.state.trigger_source == SpectrometerState.TRIGGER_SOURCE_EXTERNAL:
+                log.debug("waiting on external trigger...")
+                self.wait_for_data_ready()
+            else:
+                # send trigger via the FT232H
+                self.trigger.value = True
+                self.wait_for_data_ready()
+                self.trigger.value = False
+
+            ####################################################################
+            # Read the spectrum (MZ: big-endian, seriously?)
+            ####################################################################
+
+            spectrum = []
+            pixels = self.settings.pixels()
+            bytes_remaining = pixels * 2
+
+            log.debug(f"get_spectrum: reading spectrum of {pixels} pixels")
+            raw = []
+            while self.ready.value:
+                if bytes_remaining > 0:
+                    bytes_this_read = min(self.block_size, bytes_remaining)
+
+                    # log.debug(f"get_spectrum: reading block of {bytes_this_read} bytes")
+                    buf = bytearray(bytes_this_read)
+
+                    # There is latency associated with this call, so call it as
+                    # few times as possible (with the largest possible block
+                    # size).  Basically, I'm assuming each call requires a full
+                    # 64-byte USB control packet to the FT232H (and response).
+                    self.SPI.readinto(buf)
+
+                    # log.debug(f"get_spectrum: read block of {len(buf)} bytes")
+                    raw.extend(list(buf))
+
+                    bytes_remaining -= len(buf)
+
+        ########################################################################
+        # post-process spectrum
+        ########################################################################
+
+        # demarshall big-endian
+        for i in range(0, len(raw)-1, 2):
+            spectrum.append((raw[i] << 8) | raw[i+1])
+        log.debug(f"get_spectrum: {len(spectrum)} pixels read ({spectrum[:3]} .. {spectrum[-3:]})")
+
+        return spectrum
```

### Comparing `wasatch-2.1.35/wasatch/SpectrometerResponse.py` & `wasatch-2.1.64/wasatch/SpectrometerResponse.py`

 * *Files identical despite different names*

### Comparing `wasatch-2.1.35/wasatch/SpectrometerSettings.py` & `wasatch-2.1.64/wasatch/SpectrometerSettings.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,538 +1,550 @@
-import logging
-import numpy as np
-import json
-import math
-import re
-import os
-
-from datetime import datetime
-from . import utils
-
-from .SpectrometerState import SpectrometerState
-from .DetectorRegions   import DetectorRegions
-from .MockUSBDevice     import MockUSBDevice
-from .RealUSBDevice     import RealUSBDevice
-from .HardwareInfo      import HardwareInfo
-from .DetectorROI       import DetectorROI
-from .FPGAOptions       import FPGAOptions
-from .DeviceID          import DeviceID
-from .EEPROM            import EEPROM
-
-log = logging.getLogger(__name__)
-
-##
-# Encapsulate a spectrometer's state, including compiled firmware (FPGAOptions),
-# non-volatile configuration (EEPROM) and volatile state (SpectrometerState).
-#
-# This class serves two goals:
-#
-# 1. A picklable object that can be passed between the spectrometer process and
-#    the GUI, containing everything the GUI might need to know in convenient
-#    form.
-#
-# 2. A place where the GUI can store settings of MANY different connected
-#    spectrometers, and quickly switch between them.
-#
-class SpectrometerSettings(object):
-
-    ##
-    # @param device_id (Input) where the spectrometer was found (optional)
-    # @param d         (Input) input dictionary (optional)
-    def __init__(self, device_id=None, d=None):
-        # populate this if the settings came from a real device
-        self.device_id = device_id
-
-        # volatile state
-        self.state = SpectrometerState()
-
-        # permanent attributes
-        self.microcontroller_firmware_version = None
-        self.fpga_firmware_version = None
-        self.fpga_options = FPGAOptions()
-
-        # semi-permanent attributes
-        self.eeprom = EEPROM()
-
-        # expose some hardware attributes upstream (let ENLIGHTEN know if device
-        # supports triggering etc)
-        self.hardware_info = None
-        if self.device_id is not None:
-            if self.device_id.is_usb():
-                self.hardware_info = HardwareInfo(vid = self.device_id.vid,
-                                                  pid = self.device_id.pid)
-        # derived attributes
-        self.wavelengths = None
-        self.wavenumbers = None
-        self.raman_intensity_factors = None
-
-        self.lock_wavecal = False
-
-        self.update_wavecal()
-        self.update_raman_intensity_factors()
-
-        # ENLIGHTEN sends this so individual driver processes can adaptively scale USB timeouts
-        self.num_connected_devices = 1
-
-        if d is not None:
-            self.load_from_dict(d)
-
-    def set_num_connected_devices(self, n):
-        self.num_connected_devices = n
-
-    # given a JSON-formatted string, parse and apply FPGAOptions and EEPROM
-    # sections if available
-    def update_from_json(self, s):
-        log.debug("updating SpectrometerSettings from JSON: %s", s)
-        d = json.loads(s)
-        self.load_from_dict(d)
-
-    ##
-    # Assuming that we've loaded a Measurement from JSON, or received a
-    # Measurement-like structure externally via JSON, update whatever we can
-    # from it.
-    def load_from_dict(self, d):
-        utils.update_obj_from_dict(self.fpga_options, utils.dict_get_norm(d, "FPGAOptions"))
-        utils.update_obj_from_dict(self.state,        utils.dict_get_norm(d, ["SpectrometerState", "State"]))
-
-        d2 = utils.dict_get_norm(d, "EEPROM")
-        if d2 is not None:
-            utils.update_obj_from_dict(self.eeprom, d2)
-            self.update_wavecal()
-            self.update_raman_intensity_factors()
-
-        a = utils.dict_get_norm(d, "wavelengths")
-        if a is not None:
-            self.wavelengths = a
-            log.debug("SS.load_from_dict: assigned wavelengths")
-
-        a = utils.dict_get_norm(d, "wavenumbers")
-        if a is not None:
-            self.wavenumbers = a
-            log.debug("SS.load_from_dict: assigned wavenumbers")
-
-    # ##########################################################################
-    # accessors
-    # ##########################################################################
-
-    ##
-    # Originally model names fit within the 16-char EEPROM field of that name.
-    # Now that we're extending model names to 30 characters, append the value
-    # of EEPROM.productConfiguration if non-empty.
-    def full_model(self):
-        if self.eeprom.model is None:
-            return ''
-        a = self.eeprom.model.strip()
-        b = self.eeprom.product_configuration
-
-        if b is None:
-            return a
-        else:
-            return a + b.strip()
-
-    def pixels(self):
-        if self.state.detector_regions is None:
-            return self.eeprom.active_pixels_horizontal
-        else:
-            return self.state.detector_regions.total_pixels()
-
-    def excitation(self):
-        old = float(self.eeprom.excitation_nm)
-        new = self.eeprom.excitation_nm_float
-
-        # if 'new' looks corrupt or not populated, use old
-        if new is None or math.isnan(new):
-            return old
-
-        # if 'new' looks like a reasonable value, use it
-        if 200 <= new and new <= 2500:
-            return new
-
-        # if 'new' value is unreasonable AND NON-ZERO, complain
-        if new != 0.0:
-            log.debug(f"excitation wavelength {new} outside (200, 2500) - suspect corrupt EEPROM, using {old}")
-            return old
-
-        return old
-
-    def is_mml(self): # -> bool 
-        if not self.eeprom.has_laser:
-            return False
-        if self.eeprom.has_laser and not self.is_sml():
-            return True
-
-    def is_sml(self): # -> bool 
-        if not self.eeprom.has_laser:
-            return False
-        elif self.eeprom.has_laser and \
-            self.eeprom.max_laser_power_mW >= 95 and \
-            self.eeprom.max_laser_power_mW <= 120:
-            return True
-        else:
-            return False
-
-    def has_excitation(self): # -> bool 
-        return self.excitation() > 0
-
-    def has_vertical_roi(self): # -> bool 
-        start = self.eeprom.roi_vertical_region_1_start
-        stop  = self.eeprom.roi_vertical_region_1_end
-        height = self.eeprom.active_pixels_vertical
-        return start < stop and start >= 0 and stop < height
-
-    ## @todo return ROI
-    def get_vertical_roi(self):
-        if self.has_vertical_roi():
-            return (self.eeprom.roi_vertical_region_1_start,
-                    self.eeprom.roi_vertical_region_1_end)
-
-    def default_detector_setpoint_degC(self):
-        
-        # newer units should specify this via EEPROM
-        if self.eeprom.format >= 4:
-            log.debug("default_detector_setpoint_degC: eeprom.format %d so using startup_temp_degC %d",
-                self.eeprom.format, self.eeprom.startup_temp_degC)
-            return self.eeprom.startup_temp_degC
-
-        # otherwise infer from detector
-        det = self.eeprom.detector.upper()
-        degC = None
-        if   "11511" in det: degC =  10
-        elif "16011" in det: degC =  10
-        elif "13971" in det: degC =  10
-        elif "10141" in det: degC = -15
-        elif "9214"  in det: degC = -15
-        elif "7031"  in det: degC = -15
-
-        if degC is not None:
-            log.debug("default_detector_setpoint_degC: defaulting to %d per supported detector %s", degC, det)
-            return degC
-
-        log.error("default_detector_setpoint_degC: serial %s has unknown detector %s",
-            self.eeprom.serial_number, det)
-        return None
-
-    # ##########################################################################
-    # methods
-    # ##########################################################################
-
-    def update_raman_intensity_factors(self):
-        """
-        @todo Note that WasatchNET.Util.applyRamanCorrection() only generates 
-              factors from (roiStart, roiEnd), whereas this function generates
-              them for the whole detector. They're only valid within the ROI,
-              and should only be applied within the ROI, so this is generating
-              more than we need (wasting memory and risking bugs).
-        """
-        self.raman_intensity_factors = None
-        if not self.eeprom.has_raman_intensity_calibration():
-            return
-        if 1 <= self.eeprom.raman_intensity_calibration_order <= EEPROM.MAX_RAMAN_INTENSITY_CALIBRATION_ORDER:
-            log.debug("updating raman intensity factors")
-            coeffs = self.eeprom.raman_intensity_coeffs
-            log.debug("coeffs = %s", coeffs)
-            if coeffs is not None:
-                try:
-                    # probably faster numpy way to do this
-                    factors = []
-                    for pixel in range(self.pixels()):
-                        log10_factor = 0.0
-                        for i in range(len(coeffs)):
-                            x_to_i = math.pow(pixel, i)
-                            scaled = coeffs[i] * x_to_i
-                            log10_factor += scaled
-                            #log.debug("pixel %4d: px_to_i %e, coeff[%d] %e, scaled %e, log10_factor %e", pixel, x_to_i, i, coeffs[i], scaled, log10_factor)
-                        expanded = math.pow(10, log10_factor)
-                        #log.debug("pixel %4d: expanded = %e", pixel, expanded)
-                        factors.append(expanded)
-                    self.raman_intensity_factors = np.array(factors, dtype=np.float64)
-                except:
-                    log.error("exception generating Raman intensity factors (coeffs %s)", coeffs, exc_info=1)
-                    self.raman_intensity_factors = None
-        log.debug("factors = %s", self.raman_intensity_factors)
-
-    def set_wavenumber_correction(self, cm):
-        self.state.wavenumber_correction = cm
-        self.update_wavecal()
-
-    ##
-    # called by FID.post_connect
-    def init_regions(self):
-        ee = self.eeprom
-        if ee.region_count == 0 or ee.region_count > 4:
-            log.debug(f"detector regions not configured (subformat {ee.subformat}, region_count {ee.region_count})")
-            return
-
-        log.debug("initializing detector regions")
-        self.state.detector_regions = DetectorRegions()
-        for region in range(self.eeprom.region_count):
-            y0, y1, x0, x1 = (None, None, None, None)
-            if region == 0:
-                x0 = ee.roi_horizontal_start
-                x1 = ee.roi_horizontal_end
-                y0 = ee.roi_vertical_region_1_start
-                y1 = ee.roi_vertical_region_1_end
-            elif region == 1:
-                x0 = ee.roi_horiz_region_2_start
-                x1 = ee.roi_horiz_region_2_end
-                y0 = ee.roi_vertical_region_2_start
-                y1 = ee.roi_vertical_region_2_end
-            elif region == 2:
-                x0 = ee.roi_horiz_region_3_start
-                x1 = ee.roi_horiz_region_3_end
-                y0 = ee.roi_vertical_region_3_start
-                y1 = ee.roi_vertical_region_3_end
-            elif region == 3:
-                x0 = ee.roi_horiz_region_4_start
-                x1 = ee.roi_horiz_region_4_end
-                y0 = ee.roi_vertical_region_4_start
-                y1 = ee.roi_vertical_region_4_end
-            else:
-                log.error(f"invalid region {region}")
-
-            roi = DetectorROI(region, y0, y1, x0, x1)
-            log.debug(f"adding roi: {roi}")
-            self.state.detector_regions.add(roi)
-
-            if region == 0:
-                log.debug("kludge: only enabling the first for now")
-                roi.enabled = True
-
-    ##
-    # Note regions are internally 0-indexed (0-3), although EEPROM fields are 1-indexed.
-    #
-    # If you want to actually send the ROI downstream to the spectrometer, call
-    # this method on FeatureIdentificationDevice.
-    def set_single_region(self, n):
-        roi = self.state.detector_regions.get_roi(n)
-        if roi is None:
-            log.error(f"unconfigured region {n}")
-            return
-
-        log.debug(f"set region to {n}")
-        self.state.region = n
-
-        self.update_wavecal()
-
-    def get_wavecal_coeffs(self):
-        """
-        Return a list of coefficients from EEPROM that define the mapping from pixels to wavelengths.
-
-        The coefficients are returned in ascending degree.
-
-        [A, B, C, D] <--> W(x) = A + B*x + C*x**2 + D*x**3
-        """
-
-        n = self.state.region
-
-        if   n == 1: return self.eeprom.roi_wavecal_region_2_coeffs
-        elif n == 2: return self.eeprom.roi_wavecal_region_3_coeffs
-        elif n == 3: return self.eeprom.roi_wavecal_region_4_coeffs
-
-        # if n is None or n == 0:
-        return self.eeprom.wavelength_coeffs
-
-    def set_wavecal_coeffs(self, coeffs):
-        n = self.state.region
-
-        if n is None or n == 0:
-            self.eeprom.wavelength_coeffs = coeffs
-        elif n == 1: self.eeprom.roi_wavecal_region_2_coeffs = coeffs
-        elif n == 2: self.eeprom.roi_wavecal_region_3_coeffs = coeffs
-        elif n == 3: self.eeprom.roi_wavecal_region_4_coeffs = coeffs
-
-        log.debug(f"stored new coeffs for region {n}: {coeffs}")
-
-    ##
-    # @par Discussion re: SPI models
-    #
-    # (We don't currently have any software issues in this respect, but
-    # retaining this discussion in case it again becomes useful.)
-    #
-    # All of our silicon-based spectrometers output a cropped set of "active"
-    # pixels, omitting any "optically-masked / dark" pixels at the ends.
-    # (Theoretically we could output those as well, allowing an EDC feature,
-    # but that's another discussion).
-    #
-    # The point is, it's not "unusual" that our new SiG spectrometer is only
-    # outputting 1920 active of 1952 physical pixels, nor is it unusual that
-    # the wavecal is based on all active output pixels.  That's in fact the
-    # norm.
-    #
-    # What's unusual is that this spectrometer uses the horizontal ROI fields
-    # on the EEPROM to TELL the spectrometer where the active region (or
-    # ROI of interest) lies.
-    #
-    # Therefore, while most of our spectrometers assume the horizontal ROI is
-    # zero-indexed at the beginning of the ACTIVE region, and therefore used
-    # to crop the array of ACTIVE pixels being output, in this case
-    # the horizontal ROI is zero-indexed at the beginning of the PHYSICAL
-    # region, and therefore HAS ALREADY been used to crop the
-    # spectrum down to the active region.
-    #
-    # (The current unit uses EEPROM subformat 1, meaning region_count remains
-    # 0 and pixels() will always return active_pixels_horizontal (1920).
-    # Even if we were in subformat 4, detector_regions.total_pixels() should
-    # still sum to 1920.)
-    #
-    # Conclusion: testing confirms the wavecal is correctly generated and
-    # applied in both wavelength and wavenumber space on both USB and SPI
-    # interfaces.
-    #
-    # @todo update for DetectorRegions
-    def update_wavecal(self, coeffs=None):
-        log.debug(f"updating wavecal")
-        if self.lock_wavecal:
-            log.debug("wavecal is locked")
-            return
-
-        self.wavelengths = None
-        self.wavenumbers = None
-
-        if self.pixels() < 1:
-            log.error("no pixels defined, cannot generate wavecal")
-            return
-
-        if coeffs is None:
-            coeffs = self.get_wavecal_coeffs()
-        else:
-            log.debug("update_wavecal: passed coeffs, so storing to region {self.state.region}")
-            self.set_wavecal_coeffs(coeffs)
-
-
-        self.wavelengths = utils.generate_wavelengths(self.pixels(), coeffs)
-
-        if self.wavelengths is None:
-            # this can happen on Stroker Protocol before/without .ini file,
-            # or SiG with bad battery / corrupt EEPROM
-            log.debug("no wavecal found - using pixel space")
-            self.wavelengths = list(range(self.pixels()))
-
-        log.debug("generated %d wavelengths from %.2f to %.2f",
-            len(self.wavelengths), self.wavelengths[0], self.wavelengths[-1])
-
-        if self.has_excitation():
-            excitation = self.excitation()
-            self.eeprom.excitation_nm = float(round(excitation, 0)) # keep legacy excitation in sync with floating-point
-            self.wavenumbers = utils.generate_wavenumbers(excitation, self.wavelengths,
-                wavenumber_correction=self.state.wavenumber_correction)
-            log.debug("generated %d wavenumbers from %.2f to %.2f (after correction %.2f) using excitation %.3f",
-                len(self.wavenumbers), self.wavenumbers[0], self.wavenumbers[-1], self.state.wavenumber_correction, excitation)
-
-    # ##########################################################################
-    #
-    # We're kind of using SpectrometerSettings as a "universal interface" for
-    # applications to query for things, so let's just consolidate some obvious
-    # and common checks here (even if wrapping calls elsewhere).
-    #
-    # ##########################################################################
-
-    def is_arm(self): # -> bool 
-        return self.hardware_info is not None and self.hardware_info.is_arm()
-
-    def is_ingaas(self): # -> bool 
-        if self.hardware_info is not None and self.hardware_info.is_ingaas():
-            log.debug("is_ingaas TRUE because hardware_info")
-            return True
-        elif self.eeprom is None or self.eeprom.detector is None:
-            log.debug("is_ingaas FALSE because missing EEPROM or detector")
-            return False
-        elif re.match(r'ingaas|g9214|g9206|g14237|du490', self.eeprom.detector.lower()):
-            log.debug("is_ingaas TRUE because detector")
-            return True
-        elif self.fpga_options is not None and self.fpga_options.has_cf_select:
-            log.debug("is_ingaas TRUE because has_cf_select")
-            return True
-        # log.debug("is_ingaas FALSE by default")
-        return False
-
-    def is_imx(self): # -> bool 
-        return self.eeprom is not None and \
-               self.eeprom.detector is not None and \
-               "imx" in self.eeprom.detector.lower()
-
-    def is_imx392(self): # -> bool 
-        return self.is_imx() and "imx392" in self.eeprom.detector.lower()
-
-    def is_spi(self): # -> bool 
-        return self.hardware_info is not None and \
-               self.hardware_info.pid == 0x6014
-
-    def is_micro(self): # -> bool 
-        return ( self.is_arm() and ( \
-                   self.is_imx() or \
-                   "micro" in self.full_model().lower() or \
-                   "sig"   in self.full_model().lower() or \
-                   "xs"    in self.full_model().lower() \
-                 ) \
-               ) \
-               or self.is_spi()
-
-    def is_non_raman(self): # -> bool 
-        return not self.has_excitation()
-
-    def is_gen15(self): # -> bool 
-        if "DISABLE_GEN15" in os.environ:
-            return False
-        return self.eeprom.gen15
-
-    def is_gen2(self): # -> bool 
-        return False
-
-    ## @todo add this to EEPROM.feature_mask if we decide to keep the feature
-    def has_marker(self): # -> bool 
-        return self.eeprom.model == "WPX-8CHANNEL"
-
-    def is_andor(self): # -> bool 
-        return '0x136e' in str(self.device_id)
-
-    def is_sig(self): # -> bool 
-        return self.is_micro()
-
-    def is_xs(self): # -> bool 
-        return self.is_micro()
-
-    # probably a simpler way to do this...
-    def to_dict(self):
-        d = {}
-        for k, v in self.__dict__.items():
-            if k in ["eeprom_backup"]:
-                continue # skip these
-
-            if isinstance(v, (DeviceID, EEPROM, FPGAOptions, SpectrometerState, HardwareInfo, RealUSBDevice, MockUSBDevice, datetime)):
-                o = v.to_dict()
-            elif isinstance(v, np.ndarray):
-                o = v.tolist()
-            else:
-                o = v
-
-            d[k] = o
-        return d
-
-    def to_json(self):
-        d = dict(self)
-        return json.dumps(d, indent=4, sort_keys=True, default=str)
-
-    def dump(self):
-        log.debug("SpectrometerSettings:")
-        log.debug("  DeviceID = %s", self.device_id)
-        log.debug("  Microcontroller Firmware Version = %s", self.microcontroller_firmware_version)
-        log.debug("  FPGA Firmware Version = %s", self.fpga_firmware_version)
-
-        if self.wavelengths:
-            log.debug("  Wavelengths = (%.2f, %.2f)", self.wavelengths[0], self.wavelengths[-1])
-        else:
-            log.debug("  Wavelengths = None")
-
-        if self.wavenumbers:
-            log.debug("  Wavenumbers = (%.2f, %.2f)", self.wavenumbers[0], self.wavenumbers[-1])
-        else:
-            log.debug("  Wavenumbers = None")
-
-        if self.state:
-            self.state.dump()
-
-        if self.fpga_options:
-            self.fpga_options.dump()
-
-        if self.eeprom:
-            self.eeprom.dump()
+import logging
+import numpy as np
+import json
+import math
+import re
+import os
+
+from datetime import datetime
+from . import utils
+
+from .FirmwareRequirements import FirmwareRequirements
+from .SpectrometerState    import SpectrometerState
+from .DetectorRegions      import DetectorRegions
+from .MockUSBDevice        import MockUSBDevice
+from .RealUSBDevice        import RealUSBDevice
+from .HardwareInfo         import HardwareInfo
+from .DetectorROI          import DetectorROI
+from .FPGAOptions          import FPGAOptions
+from .DeviceID             import DeviceID
+from .EEPROM               import EEPROM
+
+log = logging.getLogger(__name__)
+
+##
+# Encapsulate a spectrometer's state, including compiled firmware (FPGAOptions),
+# non-volatile configuration (EEPROM) and volatile state (SpectrometerState).
+#
+# This class serves two goals:
+#
+# 1. A picklable object that can be passed between the spectrometer process and
+#    the GUI, containing everything the GUI might need to know in convenient
+#    form.
+#
+# 2. A place where the GUI can store settings of MANY different connected
+#    spectrometers, and quickly switch between them.
+#
+class SpectrometerSettings:
+
+    ##
+    # @param device_id (Input) where the spectrometer was found (optional)
+    # @param d         (Input) input dictionary (optional)
+    def __init__(self, device_id=None, d=None):
+        # populate this if the settings came from a real device
+        self.device_id = device_id
+
+        # volatile state
+        self.state = SpectrometerState()
+
+        # permanent attributes
+        self.microcontroller_firmware_version = None
+        self.fpga_firmware_version = None
+        self.detector_serial_number = None          # Andor
+        self.microcontroller_serial_number = None   # STM32H7
+        self.fpga_options = FPGAOptions()
+
+        # semi-permanent attributes
+        self.eeprom = EEPROM()
+
+        # expose some hardware attributes upstream (let ENLIGHTEN know if device
+        # supports triggering etc)
+        self.hardware_info = None
+        if self.device_id is not None:
+            if self.device_id.is_usb():
+                self.hardware_info = HardwareInfo(vid = self.device_id.vid,
+                                                  pid = self.device_id.pid)
+        # derived attributes
+        self.wavelengths = None
+        self.wavenumbers = None
+        self.raman_intensity_factors = None
+
+        self.lock_wavecal = False
+
+        self.update_wavecal()
+        self.update_raman_intensity_factors()
+
+        # ENLIGHTEN sends this so individual driver processes can adaptively scale USB timeouts
+        self.num_connected_devices = 1
+
+        if d is not None:
+            self.load_from_dict(d)
+
+        self.firmware_requirements = FirmwareRequirements(self)
+
+    def set_num_connected_devices(self, n):
+        self.num_connected_devices = n
+
+    # given a JSON-formatted string, parse and apply FPGAOptions and EEPROM
+    # sections if available
+    def update_from_json(self, s):
+        log.debug("updating SpectrometerSettings from JSON: %s", s)
+        d = json.loads(s)
+        self.load_from_dict(d)
+
+    ##
+    # Assuming that we've loaded a Measurement from JSON, or received a
+    # Measurement-like structure externally via JSON, update whatever we can
+    # from it.
+    def load_from_dict(self, d):
+        utils.update_obj_from_dict(self.fpga_options, utils.dict_get_norm(d, "FPGAOptions"))
+        utils.update_obj_from_dict(self.state,        utils.dict_get_norm(d, ["SpectrometerState", "State"]))
+
+        d2 = utils.dict_get_norm(d, "EEPROM")
+        if d2 is not None:
+            utils.update_obj_from_dict(self.eeprom, d2)
+            self.update_wavecal()
+            self.update_raman_intensity_factors()
+
+        a = utils.dict_get_norm(d, "wavelengths")
+        if a is not None:
+            self.wavelengths = a
+            log.debug("SS.load_from_dict: assigned wavelengths")
+
+        a = utils.dict_get_norm(d, "wavenumbers")
+        if a is not None:
+            self.wavenumbers = a
+            log.debug("SS.load_from_dict: assigned wavenumbers")
+
+    # ##########################################################################
+    # accessors
+    # ##########################################################################
+
+    ##
+    # Originally model names fit within the 16-char EEPROM field of that name.
+    # Now that we're extending model names to 30 characters, append the value
+    # of EEPROM.productConfiguration if non-empty.
+    def full_model(self):
+        if self.eeprom.model is None:
+            return ''
+        a = self.eeprom.model.strip()
+        b = self.eeprom.product_configuration
+
+        if b is None:
+            return a
+        else:
+            return a + b.strip()
+
+    def pixels(self):
+        if self.state.detector_regions is None:
+            return self.eeprom.active_pixels_horizontal
+        else:
+            return self.state.detector_regions.total_pixels()
+
+    def excitation(self):
+        old = float(self.eeprom.excitation_nm)
+        new = self.eeprom.excitation_nm_float
+
+        # if 'new' looks corrupt or not populated, use old
+        if new is None or math.isnan(new):
+            return old
+
+        # if 'new' looks like a reasonable value, use it
+        if 200 <= new and new <= 2500:
+            return new
+
+        # if 'new' value is unreasonable AND NON-ZERO, complain
+        if new != 0.0:
+            log.debug(f"excitation wavelength {new} outside (200, 2500) - suspect corrupt EEPROM, using {old}")
+            return old
+
+        return old
+
+    def is_mml(self): # -> bool 
+        if not self.eeprom.has_laser:
+            return False
+        if self.eeprom.has_laser and not self.is_sml():
+            return True
+
+    def is_sml(self): # -> bool 
+        if not self.eeprom.has_laser:
+            return False
+        elif (self.eeprom.has_laser and 
+              self.eeprom.max_laser_power_mW >= 95 and 
+              self.eeprom.max_laser_power_mW <= 120):
+            return True
+        else:
+            return False
+
+    def has_excitation(self): # -> bool 
+        return self.excitation() > 0
+
+    def has_vertical_roi(self): # -> bool 
+        start = self.eeprom.roi_vertical_region_1_start
+        stop  = self.eeprom.roi_vertical_region_1_end
+        height = self.eeprom.active_pixels_vertical
+        return start < stop and start >= 0 and stop < height
+
+    ## @todo return ROI
+    def get_vertical_roi(self):
+        if self.has_vertical_roi():
+            return (self.eeprom.roi_vertical_region_1_start,
+                    self.eeprom.roi_vertical_region_1_end)
+
+    def default_detector_setpoint_degC(self):
+        
+        # newer units should specify this via EEPROM
+        if self.eeprom.format >= 4:
+            log.debug("default_detector_setpoint_degC: eeprom.format %d so using startup_temp_degC %d",
+                self.eeprom.format, self.eeprom.startup_temp_degC)
+            return self.eeprom.startup_temp_degC
+
+        # otherwise infer from detector
+        det = self.eeprom.detector.upper()
+        degC = None
+        if   "11511" in det: degC =  10
+        elif "16011" in det: degC =  10
+        elif "13971" in det: degC =  10
+        elif "10141" in det: degC = -15
+        elif "9214"  in det: degC = -15
+        elif "7031"  in det: degC = -15
+
+        if degC is not None:
+            log.debug("default_detector_setpoint_degC: defaulting to %d per supported detector %s", degC, det)
+            return degC
+
+        log.error("default_detector_setpoint_degC: serial %s has unknown detector %s",
+            self.eeprom.serial_number, det)
+        return None
+
+    # ##########################################################################
+    # methods
+    # ##########################################################################
+
+    def update_raman_intensity_factors(self):
+        """
+        @todo Note that WasatchNET.Util.applyRamanCorrection() only generates 
+              factors from (roiStart, roiEnd), whereas this function generates
+              them for the whole detector. They're only valid within the ROI,
+              and should only be applied within the ROI, so this is generating
+              more than we need (wasting memory and risking bugs).
+        """
+        self.raman_intensity_factors = None
+        if not self.eeprom.has_raman_intensity_calibration():
+            return
+        if 1 <= self.eeprom.raman_intensity_calibration_order <= EEPROM.MAX_RAMAN_INTENSITY_CALIBRATION_ORDER:
+            log.debug("updating raman intensity factors")
+            coeffs = self.eeprom.raman_intensity_coeffs
+            log.debug("coeffs = %s", coeffs)
+            if coeffs is not None:
+                try:
+                    # probably faster numpy way to do this
+                    factors = []
+                    for pixel in range(self.pixels()):
+                        log10_factor = 0.0
+                        for i in range(len(coeffs)):
+                            x_to_i = math.pow(pixel, i)
+                            scaled = coeffs[i] * x_to_i
+                            log10_factor += scaled
+                            #log.debug("pixel %4d: px_to_i %e, coeff[%d] %e, scaled %e, log10_factor %e", pixel, x_to_i, i, coeffs[i], scaled, log10_factor)
+                        expanded = math.pow(10, log10_factor)
+                        #log.debug("pixel %4d: expanded = %e", pixel, expanded)
+                        factors.append(expanded)
+                    self.raman_intensity_factors = np.array(factors, dtype=np.float64)
+                except:
+                    log.error("exception generating Raman intensity factors (coeffs %s)", coeffs, exc_info=1)
+                    self.raman_intensity_factors = None
+        log.debug("factors = %s", self.raman_intensity_factors)
+
+    def set_wavenumber_correction(self, cm):
+        self.state.wavenumber_correction = cm
+        self.update_wavecal()
+
+    ##
+    # called by FID.post_connect
+    def init_regions(self):
+        ee = self.eeprom
+        if ee.region_count == 0 or ee.region_count > 4:
+            log.debug(f"detector regions not configured (subformat {ee.subformat}, region_count {ee.region_count})")
+            return
+
+        log.debug("initializing detector regions")
+        self.state.detector_regions = DetectorRegions()
+        for region in range(self.eeprom.region_count):
+            y0, y1, x0, x1 = (None, None, None, None)
+            if region == 0:
+                x0 = ee.roi_horizontal_start
+                x1 = ee.roi_horizontal_end
+                y0 = ee.roi_vertical_region_1_start
+                y1 = ee.roi_vertical_region_1_end
+            elif region == 1:
+                x0 = ee.roi_horiz_region_2_start
+                x1 = ee.roi_horiz_region_2_end
+                y0 = ee.roi_vertical_region_2_start
+                y1 = ee.roi_vertical_region_2_end
+            elif region == 2:
+                x0 = ee.roi_horiz_region_3_start
+                x1 = ee.roi_horiz_region_3_end
+                y0 = ee.roi_vertical_region_3_start
+                y1 = ee.roi_vertical_region_3_end
+            elif region == 3:
+                x0 = ee.roi_horiz_region_4_start
+                x1 = ee.roi_horiz_region_4_end
+                y0 = ee.roi_vertical_region_4_start
+                y1 = ee.roi_vertical_region_4_end
+            else:
+                log.error(f"invalid region {region}")
+
+            roi = DetectorROI(region, y0, y1, x0, x1)
+            log.debug(f"adding roi: {roi}")
+            self.state.detector_regions.add(roi)
+
+            if region == 0:
+                log.debug("kludge: only enabling the first for now")
+                roi.enabled = True
+
+    ##
+    # Note regions are internally 0-indexed (0-3), although EEPROM fields are 1-indexed.
+    #
+    # If you want to actually send the ROI downstream to the spectrometer, call
+    # this method on FeatureIdentificationDevice.
+    def set_single_region(self, n):
+        roi = self.state.detector_regions.get_roi(n)
+        if roi is None:
+            log.error(f"unconfigured region {n}")
+            return
+
+        log.debug(f"set region to {n}")
+        self.state.region = n
+
+        self.update_wavecal()
+
+    def get_wavecal_coeffs(self):
+        """
+        Return a list of coefficients from EEPROM that define the mapping from pixels to wavelengths.
+
+        The coefficients are returned in ascending degree.
+
+        [A, B, C, D] <--> W(x) = A + B*x + C*x**2 + D*x**3
+        """
+
+        n = self.state.region
+
+        if   n == 1: return self.eeprom.roi_wavecal_region_2_coeffs
+        elif n == 2: return self.eeprom.roi_wavecal_region_3_coeffs
+        elif n == 3: return self.eeprom.roi_wavecal_region_4_coeffs
+
+        # if n is None or n == 0:
+        return self.eeprom.wavelength_coeffs
+
+    def set_wavecal_coeffs(self, coeffs):
+        n = self.state.region
+
+        if n is None or n == 0:
+            self.eeprom.wavelength_coeffs = coeffs
+        elif n == 1: self.eeprom.roi_wavecal_region_2_coeffs = coeffs
+        elif n == 2: self.eeprom.roi_wavecal_region_3_coeffs = coeffs
+        elif n == 3: self.eeprom.roi_wavecal_region_4_coeffs = coeffs
+
+        log.debug(f"stored new coeffs for region {n}: {coeffs}")
+
+    ##
+    # @par Discussion re: SPI models
+    #
+    # (We don't currently have any software issues in this respect, but
+    # retaining this discussion in case it again becomes useful.)
+    #
+    # All of our silicon-based spectrometers output a cropped set of "active"
+    # pixels, omitting any "optically-masked / dark" pixels at the ends.
+    # (Theoretically we could output those as well, allowing an EDC feature,
+    # but that's another discussion).
+    #
+    # The point is, it's not "unusual" that our new SiG spectrometer is only
+    # outputting 1920 active of 1952 physical pixels, nor is it unusual that
+    # the wavecal is based on all active output pixels.  That's in fact the
+    # norm.
+    #
+    # What's unusual is that this spectrometer uses the horizontal ROI fields
+    # on the EEPROM to TELL the spectrometer where the active region (or
+    # ROI of interest) lies.
+    #
+    # Therefore, while most of our spectrometers assume the horizontal ROI is
+    # zero-indexed at the beginning of the ACTIVE region, and therefore used
+    # to crop the array of ACTIVE pixels being output, in this case
+    # the horizontal ROI is zero-indexed at the beginning of the PHYSICAL
+    # region, and therefore HAS ALREADY been used to crop the
+    # spectrum down to the active region.
+    #
+    # (The current unit uses EEPROM subformat 1, meaning region_count remains
+    # 0 and pixels() will always return active_pixels_horizontal (1920).
+    # Even if we were in subformat 4, detector_regions.total_pixels() should
+    # still sum to 1920.)
+    #
+    # Conclusion: testing confirms the wavecal is correctly generated and
+    # applied in both wavelength and wavenumber space on both USB and SPI
+    # interfaces.
+    #
+    # @todo update for DetectorRegions
+    def update_wavecal(self, coeffs=None):
+        log.debug(f"updating wavecal")
+        if self.lock_wavecal:
+            log.debug("wavecal is locked")
+            return
+
+        self.wavelengths = None
+        self.wavenumbers = None
+
+        if self.pixels() < 1:
+            log.error("no pixels defined, cannot generate wavecal")
+            return
+
+        if coeffs is None:
+            coeffs = self.get_wavecal_coeffs()
+        else:
+            log.debug("update_wavecal: passed coeffs, so storing to region {self.state.region}")
+            self.set_wavecal_coeffs(coeffs)
+
+
+        self.wavelengths = utils.generate_wavelengths(self.pixels(), coeffs)
+
+        if self.wavelengths is None:
+            # this can happen on Stroker Protocol before/without .ini file,
+            # or SiG with bad battery / corrupt EEPROM
+            log.debug("no wavecal found - using pixel space")
+            self.wavelengths = list(range(self.pixels()))
+
+        log.debug("generated %d wavelengths from %.2f to %.2f",
+            len(self.wavelengths), self.wavelengths[0], self.wavelengths[-1])
+
+        if self.has_excitation():
+            excitation = self.excitation()
+            self.eeprom.excitation_nm = float(round(excitation, 0)) # keep legacy excitation in sync with floating-point
+            self.wavenumbers = utils.generate_wavenumbers(excitation, self.wavelengths,
+                wavenumber_correction=self.state.wavenumber_correction)
+            log.debug("generated %d wavenumbers from %.2f to %.2f (after correction %.2f) using excitation %.3f",
+                len(self.wavenumbers), self.wavenumbers[0], self.wavenumbers[-1], self.state.wavenumber_correction, excitation)
+
+    # ##########################################################################
+    #
+    # We're kind of using SpectrometerSettings as a "universal interface" for
+    # applications to query for things, so let's just consolidate some obvious
+    # and common checks here (even if wrapping calls elsewhere).
+    #
+    # ##########################################################################
+
+    def is_arm(self): # -> bool 
+        return self.hardware_info is not None and self.hardware_info.is_arm()
+
+    def is_ingaas(self): # -> bool 
+        if self.hardware_info is not None and self.hardware_info.is_ingaas():
+            log.debug("is_ingaas TRUE because hardware_info")
+            return True
+        elif self.eeprom is None or self.eeprom.detector is None:
+            log.debug("is_ingaas FALSE because missing EEPROM or detector")
+            return False
+        elif re.match(r'ingaas|g9214|g9206|g14237|du490', self.eeprom.detector.lower()):
+            log.debug("is_ingaas TRUE because detector")
+            return True
+        elif not self.is_arm() and (self.fpga_options is not None and self.fpga_options.has_cf_select):
+            # new SiG ARM code removes GET_FPGA_COMPILATION_OPTIONS and therefore returns all 0xff for unsupported register
+            log.debug("is_ingaas TRUE because has_cf_select")
+            return True
+        log.debug("is_ingaas FALSE by default")
+        return False
+
+    def is_imx(self):
+        return self.eeprom is not None and \
+               self.eeprom.detector is not None and \
+               "imx" in self.eeprom.detector.lower()
+
+    def is_imx392(self): # -> bool 
+        return self.is_imx() and "imx392" in self.eeprom.detector.lower()
+
+    def is_spi(self): # -> bool 
+        return self.hardware_info is not None and \
+               self.hardware_info.pid == 0x6014
+
+    def is_micro(self): # -> bool 
+        return ( self.is_arm() and (
+                   self.is_imx() or
+                   "micro" in self.full_model().lower() or
+                   "sig"   in self.full_model().lower() or
+                   "xs"    in self.full_model().lower()
+                 )
+               ) or self.is_spi()
+
+    def is_non_raman(self): # -> bool 
+        return not self.has_excitation()
+
+    def is_gen15(self): # -> bool 
+        if "DISABLE_GEN15" in os.environ:
+            return False
+        return self.eeprom.gen15
+
+    def is_gen2(self): # -> bool 
+        return False
+
+    ## @todo add this to EEPROM.feature_mask if we decide to keep the feature
+    def has_marker(self): # -> bool 
+        return self.eeprom.model == "WPX-8CHANNEL"
+
+    def is_andor(self): # -> bool 
+        return '0x136e' in str(self.device_id)
+
+    def is_sig(self): # -> bool 
+        return self.is_micro()
+
+    def is_xs(self): # -> bool 
+        return self.is_micro()
+
+    def supports_feature(self, feature):
+        return self.firmware_requirements.supports(feature)
+
+    # ##########################################################################
+    # serialization
+    # ##########################################################################
+
+    # probably a simpler way to do this...
+    def to_dict(self):
+        d = {}
+        for k, v in self.__dict__.items():
+            if k in ["eeprom_backup"]:
+                continue # skip these
+
+            if isinstance(v, (DeviceID, EEPROM, FPGAOptions, SpectrometerState, HardwareInfo, RealUSBDevice, MockUSBDevice, datetime)):
+                o = v.to_dict()
+            elif isinstance(v, np.ndarray):
+                o = v.tolist()
+            else:
+                o = v
+
+            d[k] = o
+        return d
+
+    def to_json(self):
+        d = dict(self)
+        return json.dumps(d, indent=4, sort_keys=True, default=str)
+
+    def dump(self):
+        log.debug("SpectrometerSettings:")
+        log.debug("  DeviceID = %s", self.device_id)
+        log.debug("  Microcontroller Firmware Version = %s", self.microcontroller_firmware_version)
+        log.debug("  FPGA Firmware Version = %s", self.fpga_firmware_version)
+
+        if self.wavelengths:
+            log.debug("  Wavelengths = (%.2f, %.2f)", self.wavelengths[0], self.wavelengths[-1])
+        else:
+            log.debug("  Wavelengths = None")
+
+        if self.wavenumbers:
+            log.debug("  Wavenumbers = (%.2f, %.2f)", self.wavenumbers[0], self.wavenumbers[-1])
+        else:
+            log.debug("  Wavenumbers = None")
+
+        if self.state:
+            self.state.dump()
+
+        if self.fpga_options:
+            self.fpga_options.dump()
+
+        if self.eeprom:
+            self.eeprom.dump()
```

### Comparing `wasatch-2.1.35/wasatch/SpectrometerState.py` & `wasatch-2.1.64/wasatch/SpectrometerState.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,33 +1,35 @@
 import datetime
 import logging
 
+from wasatch.PollStatus import PollStatus
+
 log = logging.getLogger(__name__)
 
-##
-# volatile attributes (must persist here for multi-spectrometers)
-#
-# Note that these should generally not include READOUTS from the 
-# spectrometer like temperature, ADC etc...unless that proves convenient.
-#
-class SpectrometerState(object):
+class SpectrometerState:
+    """
+    Volatile attributes (must persist here for multi-spectrometers).
+    
+    Note that these should generally not include READOUTS from the 
+    spectrometer like temperature, ADC etc...unless that proves convenient.
+    """
 
     TRIGGER_SOURCE_INTERNAL = 0
     TRIGGER_SOURCE_EXTERNAL = 1
 
     BAD_PIXEL_MODE_NONE     = 0
     BAD_PIXEL_MODE_AVERAGE  = 1
 
     def __init__(self):
 
         # detector
         self.integration_time_ms = 0
         self.ignore_timeouts_until = None
 
-        # TEC
+        # TEC       @todo rename detector_tec...
         self.tec_setpoint_degC = 15 # that's a very strange default...
         self.tec_enabled = False
 
         # high gain mode (InGaAs only)
         self.high_gain_mode_enabled = False
 
         # laser
@@ -39,14 +41,17 @@
         self.selected_adc = None
         self.selected_laser = 0
         self.laser_power_high_resolution = True
         self.laser_power_require_modulation = False
         self.raman_mode_enabled = False
         self.raman_delay_ms = 0
         self.laser_watchdog_sec = 0 
+        self.laser_tec_mode = 0  # 0 off, 1 on, 2 auto, 3 auto-on
+        self.laser_tec_enabled = False
+        self.laser_tec_setpoint = 800
 
         # triggering
         self.trigger_source = self.TRIGGER_SOURCE_INTERNAL
 
         # area scan mode
         self.area_scan_enabled = False
         self.area_scan_fast = True # now the default
@@ -57,14 +62,17 @@
         self.battery_timestamp = None
         self.battery_raw = None        
 
         # wasatch.DetectorRegions
         self.detector_regions = None
         self.region = None
 
+        # wasatch.PollStatus
+        self.poll_status = PollStatus.UNDEFINED
+
         # ######################################################################
         # accessory connector
         # ######################################################################
 
         self.fan_enabled = False
         self.lamp_enabled = False
         self.shutter_enabled = False
@@ -106,36 +114,30 @@
         # USB comms
         self.min_usb_interval_ms = 0
         self.max_usb_interval_ms = 0
 
         # secondary ADC
         self.secondary_adc_enabled = False
 
-        # laser power ramping
-        self.laser_power_ramping_enabled = False
-        self.laser_power_ramp_increments = 100
-
         # pixel binning
         self.graph_alternating_pixels = False
         self.swap_alternating_pixels = False
 
-        # Batch Collection
-        self.free_running_mode = True
-        self.acquisition_laser_trigger_enable = False
-        self.acquisition_laser_trigger_delay_ms = 0
-        self.acquisition_take_dark_enable = False
-
         # mechanical articulation (e.g. Sandbox optics); this is currently 
         # treated as an integer with discrete steps
         self.position = 0
 
         # wavenumber correction (ADDED to the default wavenumber axis generated
         # from the wavelength calibration at the specified excitation wavelength)
         self.wavenumber_correction = 0
 
+        # EDC
+        self.edc_enabled = False
+        self.edc_buffer = []
+
         # ######################################################################
         # gain (dB) (IMX only)
         # ######################################################################
 
         # "Detector Gain" is confusing, because Hamamatsu silicon, Hamamatsu 
         # InGaAs, and Sony IMX detectors all treat it differently.  
         #
@@ -198,16 +200,16 @@
         if self.bad_pixel_mode == self.BAD_PIXEL_MODE_AVERAGE:
             return "AVERAGE"
         elif self.bad_pixel_mode == self.BAD_PIXEL_MODE_NONE:
             return "NONE"
         else:
             return "ERROR"
 
-    def dump(self):
-        log.debug("SpectrometerState:")
+    def dump(self, label=None):
+        log.debug(f"SpectrometerState: {label}")
         log.debug(f"  Integration Time:       {self.integration_time_ms}")
         log.debug("  TEC Setpoint:           %.2f degC", self.tec_setpoint_degC)
         log.debug("  TEC Enabled:            %s", self.tec_enabled)
         log.debug("  High Gain Mode Enabled: %s", self.high_gain_mode_enabled)
         log.debug("  Gain (dB):              %d", self.gain_db)
         log.debug("  Laser Enabled:          %s", self.laser_enabled)
         log.debug("  Laser Power %%:          %.2f", self.laser_power_perc)
@@ -219,22 +221,27 @@
         log.debug("  Area Scan Enabled:      %s", self.area_scan_enabled)
         log.debug("  Scans to Average:       %d", self.scans_to_average)
         log.debug("  Boxcar Half-Width:      %d", self.boxcar_half_width)
         log.debug("  Background Subtraction: %d", self.background_subtraction_half_width)
         log.debug("  Bad Pixel Mode:         %s", self.stringify_bad_pixel_mode())
         log.debug("  USB Interval:           (%d, %dms)", self.min_usb_interval_ms, self.max_usb_interval_ms)
         log.debug("  Secondary ADC Enabled:  %s", self.secondary_adc_enabled)
-        log.debug("  Laser Power Ramping:    %s", self.laser_power_ramping_enabled)
-        log.debug("  Laser Power Ramp Incr:  %d", self.laser_power_ramp_increments)
         log.debug("  Position:               %s", self.position)
         log.debug("  Wavenumber Correction:  %d", self.wavenumber_correction)
+        log.debug("  Laser Watchdog Sec:     %d", self.laser_watchdog_sec)
+        log.debug("  Laser TEC Mode:         %d", self.laser_tec_mode)
+        log.debug("  Laser TEC Setpoint:     %d", self.laser_tec_setpoint)
 
     def to_dict(self):
-        dict = self.__dict__
-        dict["battery_timestamp"] = str(dict["battery_timestamp"])
-        return dict
+        d = self.__dict__
+
+        # stringify some
+        for k in ["battery_timestamp"]:
+            d[k] = str(d[k])
+
+        return d
 
     def set(self, name, value):
         setattr(self, name, value)
 
     def ignore_timeouts_for(self, sec):
         self.ignore_timeouts_until = datetime.datetime.now() + datetime.timedelta(seconds=sec)
```

### Comparing `wasatch-2.1.35/wasatch/WasatchBus.py` & `wasatch-2.1.64/wasatch/WasatchBus.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,63 +1,62 @@
-import logging
-import os
-
-from .DeviceFinderUSB import DeviceFinderUSB
-
-from usb import USBError
-
-log = logging.getLogger(__name__)
-
-##
-# The different bus classes don't use inheritance and don't follow a common ABC
-# or interface, but each should have an update() method, and each should have a 
-# 'device_ids' array.
-#
-# @param use_sim not used, left to avoid breaking old code
-# @param monitor_dir not used, left to avoid breaking old code
-class WasatchBus(object):
-    def __init__(self, use_sim=False, monitor_dir=None):
-        self.device_ids = []
-
-        # update buses on creation
-        self.usb_bus = USBBus()
-        self.update()
-
-    ## called by enlighten.Controller.tick_bus_listener()
-    def update(self, poll = False):
-        if self.usb_bus:
-            # MZ: if we call .extend here...when are devices ever purged from the stateful list?
-            # self.device_ids.extend(self.usb_bus.update(poll)) 
-            self.device_ids = self.usb_bus.update(poll)
-            self.device_ids = list(set(self.device_ids)) # used in case of poll if same device is present before connection finishes
-
-    def is_empty(self): # -> bool 
-        return 0 == len(self.device_ids)
-
-    ## called by Controller.update_connections
-    def dump(self):
-        log.debug("WasatchBus.dump: %s", self.device_ids)
-
-class USBBus:
-    finder = DeviceFinderUSB() # note: static attribute
-
-    def __init__(self):
-        self.backend_error_raised = False
-        self.update()
-
-    ## Return a list of DeviceIDs on the USB bus
-    def update(self, poll = False):
-        device_ids = []
-        try:
-            log.debug("USBBus.update: instantiating DeviceFinderUSB")
-            device_ids = self.finder.find_usb_devices(poll=True)
-        except USBError:
-            # MZ: this seems to happen when I run from Git Bash shell
-            #     (resolved on MacOS with 'brew install libusb')
-            if not self.backend_error_raised:
-                log.warn("No libusb backend", exc_info=1)
-                self.backend_error_raised = True
-        except Exception:
-            log.critical("LIBUSB error", exc_info=1)
-
-        log.debug(f"USBBus.update: found {len(device_ids)}")
-        return device_ids
+import logging
+
+from .DeviceFinderUSB import DeviceFinderUSB
+
+from usb import USBError
+
+log = logging.getLogger(__name__)
+
+##
+# The different bus classes don't use inheritance and don't follow a common ABC
+# or interface, but each should have an update() method, and each should have a 
+# 'device_ids' array.
+#
+# @param use_sim not used, left to avoid breaking old code
+# @param monitor_dir not used, left to avoid breaking old code
+class WasatchBus:
+    def __init__(self, use_sim=False, monitor_dir=None):
+        self.device_ids = []
+
+        # update buses on creation
+        self.usb_bus = USBBus()
+        self.update()
+
+    ## called by enlighten.Controller.tick_bus_listener()
+    def update(self, poll = False):
+        if self.usb_bus:
+            # MZ: if we call .extend here...when are devices ever purged from the stateful list?
+            # self.device_ids.extend(self.usb_bus.update(poll)) 
+            self.device_ids = self.usb_bus.update(poll)
+            self.device_ids = list(set(self.device_ids)) # used in case of poll if same device is present before connection finishes
+
+    def is_empty(self): # -> bool 
+        return 0 == len(self.device_ids)
+
+    ## called by Controller.update_connections
+    def dump(self):
+        log.debug("WasatchBus.dump: %s", self.device_ids)
+
+class USBBus:
+    finder = DeviceFinderUSB() # note: static attribute
+
+    def __init__(self):
+        self.backend_error_raised = False
+        self.update()
+
+    ## Return a list of DeviceIDs on the USB bus
+    def update(self, poll = False):
+        device_ids = []
+        try:
+            log.debug("USBBus.update: instantiating DeviceFinderUSB")
+            device_ids = self.finder.find_usb_devices(poll=True)
+        except USBError:
+            # MZ: this seems to happen when I run from Git Bash shell
+            #     (resolved on MacOS with 'brew install libusb')
+            if not self.backend_error_raised:
+                log.warn("No libusb backend", exc_info=1)
+                self.backend_error_raised = True
+        except Exception:
+            log.critical("LIBUSB error", exc_info=1)
+
+        log.debug(f"USBBus.update: found {len(device_ids)}")
+        return device_ids
```

### Comparing `wasatch-2.1.35/wasatch/WasatchDevice.py` & `wasatch-2.1.64/wasatch/WasatchDevice.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,987 +1,1028 @@
-import re
-import os
-import time
-import psutil
-import logging
-import datetime
-import threading
-from queue import Queue
-from typing import TypeVar, Any, Callable
-
-from configparser import ConfigParser
-
-from . import utils
-
-from .FeatureIdentificationDevice import FeatureIdentificationDevice
-from .SpectrometerSettings        import SpectrometerSettings
-from .SpectrometerResponse        import SpectrometerResponse
-from .SpectrometerRequest         import SpectrometerRequest
-from .SpectrometerResponse        import ErrorLevel
-from .InterfaceDevice             import InterfaceDevice
-from .BalanceAcquisition          import BalanceAcquisition
-from .SpectrometerState           import SpectrometerState
-from .ControlObject               import ControlObject
-from .WasatchBus                  import WasatchBus
-from .DeviceID                    import DeviceID
-from .Reading                     import Reading
-
-log = logging.getLogger(__name__)
-
-##
-# A WasatchDevice encapsulates and wraps a Wasatch spectrometer in a blocking
-# interface.  It will normally wrap one of the following:
-#
-# - a FeatureIdentificationDevice (modern FID spectrometer)
-#
-# ENLIGHTEN does not instantiate WasatchDevices directly, but instead uses
-# a WasatchDeviceWrapper to access a single WasatchDevice in a dedicated child 
-# thread.  Other users of Wasatch.PY may of course instantiate a WasatchDevice 
-# directly.
-class WasatchDevice(InterfaceDevice):
-
-    # While this is not the main interface device, it wraps FID
-    # It is also what is called by WrapperWorker and because of this
-    # I chose to implement the minimum formatting for interface device
-    # so that it can match the other calls in WrapperWorker
-
-    ##
-    # @param device_id      a DeviceID instance OR string label thereof
-    # @param message_queue  if provided, used to send status back to caller
-    def __init__(self, device_id: DeviceID, message_queue: Queue = None): # -> None 
-
-        # if passed a string representation of a DeviceID, deserialize it
-        if type(device_id) is str:
-            device_id = DeviceID(label=device_id)
-
-        self.device_id      = device_id
-        self.message_queue  = message_queue
-
-        self.lock = threading.Lock()
-
-        self.connected = False
-        self.hardware = None
-
-        # Receives ENLIGHTEN's 'change settings' commands in the spectrometer
-        # process. Although a logical queue, has nothing to do with multiprocessing.
-        self.command_queue = []
-
-        # Enable for "immediate mode" by clients like WasatchShell (by default,
-        # inbound commands are queued and executed at beginning of next acquire_data;
-        # this runs them as they arrive).
-        self.immediate_mode = False
-
-        self.settings = SpectrometerSettings()
-
-        # Any particular reason these aren't in FeatureIdentificationDevice?
-        self.summed_spectra         = None
-        self.sum_count              = 0
-        self.session_reading_count  = 0
-        self.take_one               = False
-        self.last_complete_acquisition = None
-
-        self.process_id = os.getpid()
-        self.last_memory_check = datetime.datetime.now()
-        self.last_battery_percentage = 0
-
-        self.process_f = self._init_process_funcs()
-
-    # ######################################################################## #
-    #                                                                          #
-    #                               Connection                                 #
-    #                                                                          #
-    # ######################################################################## #
-
-    ## Attempt low level connection to the specified DeviceID
-    def connect(self): # -> SpectrometerResponse 
-        if self.device_id.is_usb() or self.device_id.is_mock():
-            log.debug("trying to connect to %s device" % ("USB" if self.device_id.is_usb() else "Mock"))
-            result = self.connect_feature_identification()
-            if result.data:
-                log.debug("Connected to FeatureIdentificationDevice")
-                self.connected = True
-                self.initialize_settings()
-                return SpectrometerResponse(True)
-            else:
-
-                log.debug("Failed to connect to FeatureIdentificationDevice")
-                return result
-
-        else:
-            log.critical("unsupported DeviceID protocol: %s", self.device_id)
-
-        log.debug("Can't connect to %s", self.device_id)
-        return SpectrometerResponse(False)
-
-    def disconnect(self):
-        log.debug("WasatchDevice.disconnect: calling hardware disconnect")
-        try:
-            req = SpectrometerRequest("disconnect")
-            self.hardware.handle_requests([req])
-        except Exception as exc:
-            log.critical("Issue disconnecting hardware", exc_info=1)
-
-        time.sleep(0.1)
-
-        self.connected = False
-        return True
-
-    ## Given a specified universal identifier, attempt to connect to the device using FID protocol.
-    # @todo merge with the hardcoded list in DeviceFinderUSB
-    def connect_feature_identification(self): # -> SpectrometerResponse 
-        FID_list = ["1000", "2000", "4000"] # hex
-
-        # check to see if valid FID PID
-        pid_hex = self.device_id.get_pid_hex()
-        if not pid_hex in FID_list:
-            log.debug("connect_feature_identification: device_id %s PID %s not in FID list %s", self.device_id, pid_hex, FID_list)
-            return SpectrometerResponse(False)
-
-        dev = None
-        try:
-            log.debug("connect_fid: instantiating FID with device_id %s pid %s", self.device_id, pid_hex)
-            dev = FeatureIdentificationDevice(device_id=self.device_id, message_queue=self.message_queue)
-            log.debug("connect_fid: instantiated")
-
-            try:
-                log.debug("connect_fid: calling dev.connect")
-                response = dev.connect()
-                log.debug("connect_fid: back from dev.connect")
-            except Exception as exc:
-                log.critical("connect_feature_identification: %s", exc, exc_info=1)
-                return SpectrometerResponse(False)
-
-            if not response.data:
-                log.critical("Low level failure in device connect")
-                return response
-
-            self.hardware = dev
-
-        except Exception as exc:
-            log.critical("Problem connecting to: %s", self.device_id, exc_info=1)
-            return SpectrometerResponse(False)
-
-        log.debug("Connected to FeatureIdentificationDevice %s", self.device_id)
-        return SpectrometerResponse(True)
-
-    def initialize_settings(self):
-        if not self.connected:
-            return
-
-        self.settings = self.hardware.settings
-
-        # generic post-initialization stuff 
-        req_fw_v = SpectrometerRequest('get_microcontroller_firmware_version')
-        req_fpga_v = SpectrometerRequest('get_fpga_firmware_version')
-        req_int = SpectrometerRequest('get_integration_time_ms')
-        req_gain = SpectrometerRequest('get_detector_gain')# note we don't pass update_session_eeprom, so this doesn't really do anything
-        reqs = [req_fw_v, req_fpga_v, req_int, req_gain]
-        self.hardware.handle_requests(reqs) 
-        # could read the defaults for these ss.state volatiles from FID too:
-        #
-        # self.tec_setpoint_degC
-        # self.high_gain_mode_enabled
-        # self.triggering_enabled
-        # self.laser_enabled
-        # self.laser_power
-        # self.ccd_offset
-
-        self.settings.update_wavecal()
-        self.settings.update_raman_intensity_factors()
-        self.settings.dump()
-
-    # ######################################################################## #
-    #                                                                          #
-    #                               Acquisition                                #
-    #                                                                          #
-    # ######################################################################## #
-
-    def acquire_data(self): # -> SpectrometerResponse 
-        """
-        Process all enqueued settings, then read actual data (spectrum and
-        temperatures) from the device.
-
-        @see Controller.acquire_reading
-        """
-        log.debug("acquire_data: start")
-
-        self.monitor_memory()
-
-        if self.hardware.shutdown_requested:
-            log.critical("acquire_data: hardware shutdown requested")
-            return SpectrometerResponse(False, poison_pill=True)
-
-        # process queued commands, and find out if we've been asked to read a
-        # spectrum
-        needs_acquisition = self.process_commands()
-        if not (needs_acquisition or self.settings.state.free_running_mode):
-            return SpectrometerResponse(None)
-
-        # if we don't yet have an integration time, nothing to do
-        if self.settings.state.integration_time_ms <= 0:
-            log.debug("skipping acquire_data because no integration_time_ms")
-            return SpectrometerResponse(None)
-
-        # note that right now, all we return are Readings (encapsulating both
-        # spectra and temperatures).  If we disable spectra (turn off
-        # free_running_mode), then ENLIGHTEN stops receiving temperatures as
-        # well.  In the future perhaps we should return multiple object types
-        # (Acquisitions, Temperatures, etc)
-        return self.acquire_spectrum()
-
-    ##
-    # Generate one Reading from the spectrometer, including one
-    # optionally-averaged spectrum, device temperatures and other hardware
-    # status.
-    #
-    # This is normally called by acquire_data when that function decides it is
-    # time to perform an acquisition.
-    #
-    # @par Scan Averaging
-    #
-    # IF the driver is in free-running mode, AND performing scan averaging,
-    # THEN scan averaging is NOT encapsulated within a single call to this
-    # function.  Instead, we let ths spectrometer run in free-running mode,
-    # collecting individual spectra as per normal, and returning each "partial"
-    # readings while "building up" to the final averaged measurement.
-    #
-    # That is to say, if scan averaging is set to 10, then this function will
-    # get called 10 times, as ticked by the regular free-running timers, before
-    # the fully averaged spectrum is returned.  A total of 10 (not 11) spectra
-    # will be generated and sent upstream: the first 9 "partial" (unaveraged)
-    # reads, and the final 10th spectrum which will contain the average of all
-    # 10 measurements.
-    #
-    # This gives the user-facing GUI an opportunity to update the "collected
-    # X-of-Y" readout on-screen, and potentially even graph the traces of
-    # in-process partial readings.
-    #
-    # HOWEVER, this doesn't make as much sense if we're not in free-running mode,
-    # i.e. the subprocess has been slaved to explicit control by the Controller
-    # (likely a feature object like BatchCollection), and is collecting exactly
-    # those measurements we're being commanded, as they're commanded.
-    #
-    # THEREFORE, if the driver IS NOT in free-running mode, then we ONLY return
-    # the final averaged spectrum as one atomic operation.
-    #
-    # In this case, if scan averaging is set to 10, then A SINGLE CALL to this
-    # function will "block" while the full 10 measurements are made, and then
-    # a single, fully-averaged spectrum will be returned upstream.
-    #
-    # @return a Reading object
-    #
-    def acquire_spectrum(self):
-        averaging_enabled = (self.settings.state.scans_to_average > 1)
-        acquire_response = SpectrometerResponse()
-
-        ########################################################################
-        # Batch Collection silliness
-        ########################################################################
-
-        # We could move this up into ENLIGHTEN.BatchCollection: have it enable
-        # the laser, wait a bit, and then send the "acquire" command.  But since
-        # WasatchDeviceWrapper.continuous_poll ticks at its own interval, that
-        # would introduce timing interference, and different acquisitions would
-        # realistically end up with different warm-up times for lasers (all "at
-        # least" the configured time, but some longer than others).  Instead,
-        # for now I'm putting this delay here, so it will be exactly the same
-        # (given sleep()'s precision) for each acquisition.  For true precision
-        # this should all go into the firmware anyway.
-
-        dark_reading = SpectrometerResponse()
-        if self.settings.state.acquisition_take_dark_enable:
-            log.debug("taking internal dark")
-            dark_reading = self.take_one_averaged_reading()
-            if dark_reading.poison_pill or dark_reading.error_msg:
-                log.debug(f"dark reading was bool {dark_reading}")
-                return dark_reading
-            log.debug("done taking internal dark")
-
-        auto_enable_laser = self.settings.state.acquisition_laser_trigger_enable # and not self.settings.state.free_running_mode
-        log.debug("acquire_spectrum: auto_enable_laser = %s", auto_enable_laser)
-        if auto_enable_laser:
-            log.debug("acquire_spectum: enabling laser, then sleeping %d ms", self.settings.state.acquisition_laser_trigger_delay_ms)
-            req = SpectrometerRequest('set_laser_enable', args=[True])
-            self.hardware.handle_requests([req])
-            if self.hardware.shutdown_requested:
-                log.debug(f"auto_enable_laser shutdown requested")
-                acquire_response.poison_pill = True
-                return acquire_response
-
-            time.sleep(self.settings.state.acquisition_laser_trigger_delay_ms / 1000.0)
-
-        ########################################################################
-        # Take a Reading (possibly averaged)
-        ########################################################################
-
-        # IMX sensors are free-running, so make sure we collect one full
-        # integration after turning on the laser
-        self.perform_optional_throwaways()
-
-        log.debug("taking averaged reading")
-        take_one_response = self.take_one_averaged_reading()
-        reading = take_one_response.data
-        if take_one_response.poison_pill:
-            log.debug(f"take_one_averaged_reading floating poison pill {take_one_response}")
-            return take_one_response
-        if take_one_response.keep_alive:
-            log.debug(f"floating up keep alive")
-            return take_one_response
-        if take_one_response.data == None:
-            log.debug(f"Received a none reading, floating it up {take_one_response}")
-            return take_one_response
-
-        # don't perform dark subtraction, but pass the dark measurement along
-        # with the averaged reading
-        if dark_reading.data is not None:
-            log.debug("attaching dark to reading")
-            reading.dark = dark_reading.data.spectrum
-
-        ########################################################################
-        # provide early exit-ramp if we've been asked to return bare Readings
-        # (just averaged spectra with corrected bad pixels, no metadata)
-        ########################################################################
-
-        def disable_laser(force=False):
-            if force or auto_enable_laser:
-                log.debug("acquire_spectrum: disabling laser post-acquisition")
-                req = SpectrometerRequest('set_laser_enable', args=[False])
-                self.hardware.handle_requests([req])
-                acquire_response.poison_pill = True
-            return acquire_response # for convenience
-
-        ########################################################################
-        # We're done with the (possibly-averaged) spectrum, so we'd like to now
-        # disable the automatically-enabled laser, if it was engaged; but before
-        # we can do that that, we should take any requested measurements of the
-        # laser temperature and photodiode, as those would obviously be invalid-
-        # ated if we took them AFTER the laser was off.
-        ########################################################################
-
-        # only read laser temperature if we have a laser
-        if self.settings.eeprom.has_laser:
-            try:
-                count = 2 if self.settings.state.secondary_adc_enabled else 1
-                for throwaway in range(count):
-                    req = SpectrometerRequest('get_laser_temperature_raw')
-                    res = self.hardware.handle_requests([req])[0]
-                    if res.error_msg != '':
-                        return res
-                    reading.laser_temperature_raw  = res.data
-                    if self.hardware.shutdown_requested:
-                        return disable_laser(force=True)
-
-
-                req = SpectrometerRequest('get_laser_temperature_degC', args=[reading.laser_temperature_raw])
-                res = self.hardware.handle_requests([req])[0]
-                if res.error_msg != '':
-                    return res
-                reading.laser_temperature_degC = res.data
-                if self.hardware.shutdown_requested:
-                    return disable_laser(force=True)
-
-                if not auto_enable_laser:
-                    for (func, attr) in [ ('get_laser_enabled', 'laser_enabled'),
-                                          ('can_laser_fire',    'laser_can_fire'),
-                                          ('is_laser_firing',   'laser_is_firing') ]:
-                        req = SpectrometerRequest(func)
-                        res = self.hardware.handle_requests([req])[0]
-                        if res.error_msg != '':
-                            return res
-                        setattr(reading, attr, res.data)
-
-                if self.hardware.shutdown_requested:
-                    return disable_laser(force=True)
-
-            except Exception as exc:
-                log.debug("Error reading laser temperature", exc_info=1)
-
-        # read secondary ADC if requested
-        if self.settings.state.secondary_adc_enabled:
-            try:
-                req = SpectrometerRequest("select_adc", args=[1])
-                self.hardware.handle_requests([req])
-                if self.hardware.shutdown_requested:
-                    return disable_laser(force=True)
-
-                for throwaway in range(2):
-                    req = SpectrometerRequest("get_secondary_adc_raw")
-                    res = self.hardware.handle_requests([req])[0]
-                    if res.error_msg != '':
-                        return res
-                    reading.secondary_adc_raw = res.data
-                    if self.hardware.shutdown_requested:
-                        return disable_laser(force=True)
-
-                req = SpectrometerRequest("get_secondary_adc_calibrated", args =[reading.secondary_adc_raw])
-                res = self.hardware.handle_requests([req])[0]
-                if res.error_msg != '':
-                    return res
-                reading.secondary_adc_calibrated = res.data 
-                req = SpectrometerRequest("select_adc", args=[0])
-                res = self.hardware.handle_requests([req])[0]
-                if res.error_msg != '':
-                    return res
-                if self.hardware.shutdown_requested:
-                    return disable_laser(force=True)
-
-            except Exception as exc:
-                log.debug("Error reading secondary ADC", exc_info=1)
-
-        ########################################################################
-        # we've read the laser temperature and photodiode, so we can now safely
-        # disable the laser (if we're the one who enabled it)
-        ########################################################################
-
-        disable_laser()
-
-        ########################################################################
-        # finish collecting any metadata that doesn't require the laser
-        ########################################################################
-
-        # read detector temperature if applicable
-        if self.settings.eeprom.has_cooling:
-            try:
-                req = SpectrometerRequest("get_detector_temperature_raw")
-                res = self.hardware.handle_requests([req])[0]
-                if res.error_msg != '':
-                    return res
-                reading.detector_temperature_raw  = res.data
-                if self.hardware.shutdown_requested:
-                    log.debug("detector_temperature_raw shutdown")
-                    acquire_response.poison_pill = True
-                    return acquire_response
-
-                req = SpectrometerRequest("get_detector_temperature_degC", args=[reading.detector_temperature_raw])
-                res = self.hardware.handle_requests([req])[0]
-                if res.error_msg != '':
-                    return res
-                reading.detector_temperature_degC = res.data
-                if self.hardware.shutdown_requested:
-                    log.debug("detector_temperature_degC shutdown")
-                    acquire_response.poison_pill = True
-                    return acquire_response
-
-            except Exception as exc:
-                log.debug("Error reading detector temperature", exc_info=1)
-
-        # read ambient temperature if applicable
-        if self.settings.is_gen15():
-            try:
-                # reading.ambient_temperature_degC = self.hardware.get_ambient_temperature_degC()
-                pass
-            except Exception as exc:
-                log.debug("Error reading ambient temperature", exc_info=1)
-
-        # read battery every 5sec
-        if self.settings.eeprom.has_battery:
-            if self.settings.state.battery_timestamp is None or (datetime.datetime.now() - self.settings.state.battery_timestamp).total_seconds() > 5:
-
-                # note that the following 3 requests should actually only generate 
-                # one USB transaction as raw is cached internally
-                req = SpectrometerRequest("get_battery_state_raw")
-                res = self.hardware.handle_requests([req])[0]
-                if res.error_msg != '':
-                   return res
-                reading.battery_raw = res.data
-                if self.hardware.shutdown_requested:
-                    log.debug("battery_raw shutdown")
-                    acquire_response.poison_pill = True
-                    return acquire_response
-
-                req = SpectrometerRequest("get_battery_percentage")
-                res = self.hardware.handle_requests([req])[0]
-                if res.error_msg != '':
-                   return res
-                reading.battery_percentage = res.data
-                if self.hardware.shutdown_requested:
-                    log.debug("battery_perc shutdown")
-                    acquire_response.poison_pill = True
-                    return acquire_response
-                self.last_battery_percentage = reading.battery_percentage
-
-                req = SpectrometerRequest("get_battery_percentage")
-                res = self.hardware.handle_requests([req])[0]
-                if res.error_msg != '':
-                    return res
-                reading.battery_charging = res.data
-                if self.hardware.shutdown_requested:
-                    log.debug("battery_charging shutdown")
-                    acquire_response.poison_pill = True
-                    return acquire_response
-
-                log.debug("battery: %.2f%% (%s)", reading.battery_percentage, "charging" if reading.battery_charging else "discharging")
-            else:
-                if reading is not None:
-                    reading.battery_percentage = self.last_battery_percentage
-
-        # log.debug("device.acquire_spectrum: returning %s", reading)
-        acquire_response.data = reading
-        self.last_complete_acquisition = datetime.datetime.now()
-        return acquire_response
-
-    ##
-    # It's unclear how many throwaways are really needed for a stable Raman spectrum, and whether they're
-    # really based on number of integrations (sensor stabilization) or time (laser warmup); I suspect
-    # both.  Also note the potential need for sensor warm-up, but I think that's handled inside FW.
-    #
-    # Optimal would probably be something like "As many integrations as it takes to span 2sec, but not
-    # fewer than two."
-    #
-    # @todo This shouldn't be required at all if we're in free-running mode, or 
-    #       if it's been less than a second since the last acquisition.
-    def perform_optional_throwaways(self):
-        if self.settings.is_micro() and self.take_one:
-            count = 2
-            readout_ms = 5
-
-            # MZ: this was forcing me to take 250 throwaways for each 3ms measurement 
-            #     in BatchCollection with a SiG :-(
-            #
-            # For now, assume that if we FINISHED the last measurement less than
-            # a second ago, the sensor probably has not gone to sleep and doesn't
-            # need SW-driven warmups.
-            if self.last_complete_acquisition is None or \
-                    (datetime.datetime.now() - self.last_complete_acquisition).total_seconds() > 1.0:
-                while count * (self.settings.state.integration_time_ms + readout_ms) < 2000:
-                    count += 1
-
-            for i in range(count):
-                log.debug("performing optional throwaway %d of %d before ramanMicro TakeOne", i, count)
-                req = SpectrometerRequest("get_line")
-                res = self.hardware.handle_requests([req])[0]
-                if res.error_msg != '':
-                    return res
-                spectrum_and_row = res.data
-    ##
-    # @returns Reading on success, true or false on "stop processing" conditions
-    def take_one_averaged_reading(self):
-        take_one_response = SpectrometerResponse()
-
-        # Okay, let's talk about averaging.  Normally we don't perform averaging
-        # as a blocking batch process inside Wasatch.PY.  However, ENLIGHTEN's
-        # BatchCollection requirements pulled this architecture in weird
-        # directions and we tried to accommodate responsively rather than refactor
-        # each time requirements changed...hence the current strangeness.
-        #
-        # Normally this process (the background process dedicated to a forked
-        # WasatchDeviceWrapper object) is in "free-running" mode, taking spectra
-        # just as fast as it can in an endless loop, feeding them back to the
-        # consumer (ENLIGHTEN) over a multiprocess pipe.  To keep that pipeline
-        # "moving," generally we don't do heavy blocking operations down here
-        # in the background thread.
-        #
-        # However, the use-case for BatchCollection was very specific: to
-        # take an averaged series of darks, then enable the laser, wait for the
-        # laser to warmup, take an averaged series of dark-corrected measurements,
-        # and return the average as one spectrum.
-        #
-        # That is VERY different from what this code was originally written to
-        # do.  There are cleaner ways to do this, but I haven't gone back to
-        # tidy things up.
-
-        averaging_enabled = (self.settings.state.scans_to_average > 1)
-
-        if averaging_enabled and not self.settings.state.free_running_mode:
-            # collect the entire averaged spectrum at once (added for
-            # BatchCollection with laser delay)
-            #
-            # So: we're NOT in "free-running" mode, so we're basically being
-            # slaved to parent process and doing exactly what is requested
-            # "on command."  That means we can perform a big, heavy blocking
-            # scan average all at once, because they requested it.
-            self.sum_count = 0
-            loop_count = self.settings.state.scans_to_average
-        else:
-            # we're in free-running mode
-            loop_count = 1
-
-        log.debug("take_one_averaged_reading: loop_count = %d", loop_count)
-
-        # either take one measurement (normal), or a bunch (blocking averaging)
-        reading = None
-        for loop_index in range(0, loop_count):
-
-            # start a new reading
-            # NOTE: reading.timestamp is when reading STARTED, not FINISHED!
-            reading = Reading(self.device_id)
-
-            # TODO...just include a copy of SpectrometerState? something to think
-            # about. That would actually provide a reason to roll all the
-            # temperature etc readouts into the SpectrometerState class...
-            reading.integration_time_ms = self.settings.state.integration_time_ms
-            reading.laser_power_perc    = self.settings.state.laser_power_perc
-            reading.laser_power_mW      = self.settings.state.laser_power_mW
-            reading.laser_enabled       = self.settings.state.laser_enabled
-
-            # Are we reading one spectrum (normal mode, or "slow" area scan), or
-            # doing a batch-read of a whole frame ("fast" area scan)?
-            #
-            # It's a bit confusing that this is INSIDE the scan averaging loop...
-            # there is NO use-case for "averaged" area scan.  We should move this
-            # up and out of take_one_averaged_reading().
-            if self.settings.state.area_scan_enabled and self.settings.state.area_scan_fast:
-
-                # collect a whole frame of area scan data
-                with self.lock:
-                    reading.area_scan_data = []
-                    try:
-                        rows = self.settings.eeprom.active_pixels_vertical
-                        first = True
-                        log.debug("trying to read a fast area scan frame of %d rows", rows)
-                        #for i in range(rows):
-                        row_data = {}
-                        while True:
-                            log.debug(f"trying to read fast area scan row")
-                            req = SpectrometerRequest("get_line",kwargs={"trigger":first})
-                            response = self.hardware.handle_requests([req])[0]
-                            if response.error_msg != '':
-                                return response
-                            spectrum_and_row = response.data
-                            first = False
-                            if response.poison_pill:
-                                # get_line returned a poison-pill, so we're not 
-                                # getting any more in this frame...give up and move on
-                                # return False
-                                take_one_response.transfer_response(response)
-                                log.debug(f"get_line returned {spectrum_and_row}, breaking")
-                                break
-                            elif response.keep_alive:
-                                take_one_response.transfer_response(response)
-                                log.debug(f"get_line returned keep alive, passing up")
-                                return take_one_response
-                            elif self.hardware.shutdown_requested:
-                                take_one_response.transfer_response(response)
-                                return take_one_response
-                            elif spectrum_and_row.spectrum is None:
-                                log.debug("device.take_one_averaged_spectrum: get_line None, sending keepalive for now (area scan fast)")
-                                take_one_response.transfer_response(response)
-                                return take_one_response
-
-                            # mimic "slow" results to minimize downstream fuss
-                            spectrum = spectrum_and_row.spectrum
-                            row = spectrum_and_row.row
-
-                            reading.spectrum = spectrum
-                            row_data[row] = spectrum
-                            reading.timestamp_complete  = datetime.datetime.now()
-                            log.debug("device.take_one_averaged_reading(area scan fast): got %s ... (row %d) (min %d)",
-                                spectrum[0:9], row, min(reading.spectrum))
-
-                        reading.area_scan_data = []
-                        reading.area_scan_row_count = -1
-                        for row in sorted(row_data.keys()):
-                            reading.area_scan_data.append(row_data[row])
-                            reading.area_scan_row_count = row
-
-                    except Exception as exc:
-                        log.critical("Error reading hardware data", exc_info=1)
-                        reading.spectrum = None
-                        reading.failure = str(exc)
-                        take_one_response.error_msg = exc
-                        take_one_response.error_lvl = ErrorLevel.medium
-                        take_one_response.keep_alive = True
-                        return take_one_response
-
-            else:
-
-                # collect ONE spectrum (it's in a while loop because we may have
-                # to wait for an external trigger, and must wait through a series
-                # of timeouts)
-                externally_triggered = self.settings.state.trigger_source == SpectrometerState.TRIGGER_SOURCE_EXTERNAL
-                try:
-                    while True:
-                        req = SpectrometerRequest("get_line")
-                        res = self.hardware.handle_requests([req])[0]
-                        if res.error_msg != '':
-                            return res
-                        spectrum_and_row = res.data
-                        if res.poison_pill:
-                            # float up poison
-                            take_one_response.transfer_response(res)
-                            return take_one_response
-                        if res.keep_alive:
-                            # float up keep alive
-                            take_one_response.transfer_response(res)
-                            return take_one_response
-                        if isinstance(spectrum_and_row, bool):
-                            # get_line returned a poison-pill, so flow it upstream
-                            take_one_response.poison_pill = True
-                            return take_one_response
-
-                        if self.hardware.shutdown_requested:
-                            take_one_response.poison_pill = True
-                            return take_one_response
-
-                        if spectrum_and_row is None or spectrum_and_row.spectrum is None:
-                            # FeatureIdentificationDevice can return None when waiting
-                            # on an external trigger.  
-                            log.debug("device.take_one_averaged_spectrum: get_line None, sending keepalive for now")
-                            take_one_response.transfer_response(res)
-                            return take_one_response
-                        else:
-                            break
-
-                    reading.spectrum            = spectrum_and_row.spectrum
-                    reading.area_scan_row_count = spectrum_and_row.row
-                    reading.timestamp_complete  = datetime.datetime.now()
-
-                    log.debug("device.take_one_averaged_reading: got %s ... (row %d)", reading.spectrum[0:9], reading.area_scan_row_count)
-                except Exception as exc:
-                    # if we got the timeout after switching from externally triggered back to internal, let it ride
-                    take_one_response.error_msg = exc
-                    take_one_response.error_lvl = ErrorLevel.medium
-                    take_one_response.keep_alive = True
-                    if externally_triggered:
-                        log.debug("caught exception from get_line while externally triggered...sending keepalive")
-                        return take_one_response
-
-                    log.critical("Error reading hardware data", exc_info=1)
-                    reading.spectrum = None
-                    reading.failure = str(exc)
-
-            ####################################################################
-            # Aggregate scan averaging
-            ####################################################################
-
-            # It's important to note here that the scan averaging "sum" buffer
-            # here (self.summed_spectra) and counter (self.sum_count) are
-            # attributes of this WasatchDevice object: they are not part of the
-            # Reading being sent back to the caller.
-            #
-            # The current architecture in Wasatch.PY, which is a little different
-            # than other Wasatch drivers, is that even when scan averaging is
-            # enabled, EVERY SPECTRUM will be flowed back to the caller.
-            #
-            # This is because early versions of ENLIGHTEN showed the "individual"
-            # (pre-averaged) spectra as a faint grey trace in the background,
-            # updating with each integration, showing the higher noise level of
-            # "raw" spectra while an on-screen counter showed the incrementing
-            # tally of summed spectra in the buffer.
-            #
-            # Then, when the FINAL raw spectrum had been read and the complete
-            # average could be computed, that averaged spectrum was returned
-            # with a special flag in the Reading object to indicate "fully
-            # averaged."
-            #
-            # We no longer show the "background" spectral trace in ENLIGHTEN,
-            # so this is kind of wasting some intra-process bandwidth, but we
-            # do still increment the on-screen tally as feedback while the
-            # averaging is taking place, so the in-process Reading messages
-            # sent during an averaged collection are not entirely wasted.
-            #
-            # Still, this is not the way we would have designed a Python driver
-            # "from a blank sheet," and our other driver architectures show that.
-
-            if not reading.failure:
-                if averaging_enabled:
-                    if self.sum_count == 0:
-                        self.summed_spectra = [float(i) for i in reading.spectrum]
-                    else:
-                        log.debug("device.take_one_averaged_reading: summing spectra")
-                        for i in range(len(self.summed_spectra)):
-                            self.summed_spectra[i] += reading.spectrum[i]
-                    self.sum_count += 1
-                    log.debug("device.take_one_averaged_reading: summed_spectra : %s ...", self.summed_spectra[0:9])
-
-            # count spectra
-            self.session_reading_count += 1
-            reading.session_count = self.session_reading_count
-            reading.sum_count = self.sum_count
-
-            # have we completed the averaged reading?
-            if averaging_enabled:
-                if self.sum_count >= self.settings.state.scans_to_average:
-                    reading.spectrum = [ x / self.sum_count for x in self.summed_spectra ]
-                    log.debug("device.take_one_averaged_reading: averaged_spectrum : %s ...", reading.spectrum[0:9])
-                    reading.averaged = True
-
-                    # reset for next average
-                    self.summed_spectra = None
-                    self.sum_count = 0
-            else:
-                # if averaging isn't enabled...then a single reading is the
-                # "averaged" final measurement (check reading.sum_count to confirm)
-                reading.averaged = True
-
-            # were we told to only take one (potentially averaged) measurement?
-            if self.take_one and reading.averaged:
-                log.debug("completed take_one")
-                self.change_setting("cancel_take_one", True)
-
-        log.debug("device.take_one_averaged_reading: returning %s", reading)
-        # reading.dump_area_scan()
-        take_one_response.data = reading
-        return take_one_response
-
-    def monitor_memory(self):
-        now = datetime.datetime.now()
-        if (now - self.last_memory_check).total_seconds() < 5:
-            return
-
-        self.last_memory_check = now
-        size_in_bytes = psutil.Process(self.process_id).memory_info().rss
-        log.info("monitor_memory: PID %d memory = %d bytes", self.process_id, size_in_bytes)
-
-    ##
-    # Process every entry on the incoming command (settings) queue, writing each
-    # to the device.
-    #
-    # Essentially this iterates through all the (setting, value) pairs we've
-    # received through change_setting() which have not yet been processed, and
-    #
-    #
-    # Note that WasatchDeviceWrapper.continuous_poll "de-dupes" commands on
-    # receipt from ENLIGHTEN, so the command stream arising from that source
-    # should already be optimized and minimal.  Commands injected manually by
-    # calling WasatchDevice.change_setting() do not receive this treatment.
-    #
-    # In the normal multi-process (ENLIGHTEN) workflow, this function is called
-    # at the beginning of acquire_data, itself ticked regularly by
-    # WasatchDeviceWrapper.continuous_poll.
-    def process_commands(self):
-        control_object = "throwaway"
-        retval = False
-        log.debug("process_commands: processing")
-        # while control_object != None:
-        while len(self.command_queue) > 0:
-            # try:
-            # control_object = self.command_queue.get_nowait()
-
-            control_object = self.command_queue.pop(0)
-            log.debug("process_commands: %s", control_object)
-
-            # is this a command used by WasatchDevice itself, and not
-            # passed down to FeatureIdentificationDevice?
-            if control_object.setting.lower() == "acquire":
-                log.debug("process_commands: acquire found")
-                retval = True
-            else:
-                # send setting downstream to be processed by the spectrometer HAL
-                # (probably FeatureIdentificationDevice)
-                req = SpectrometerRequest(control_object.setting, args=[control_object.value])
-                self.hardware.handle_requests([req])
-
-            if control_object.setting == "free_running_mode" and not self.hardware.settings.state.free_running_mode:
-                # we just LEFT free-running mode (went on "pause"), so toss any
-                # queued for the caller (ENLIGHTEN)
-                log.debug("exited free-running mode")
-
-        return retval
-
-    def _init_process_funcs(self): # -> dict[str, Callable[..., Any]] 
-        process_f = {}
-
-        process_f["connect"] = self.connect
-        process_f["disconnect"] = self.disconnect
-        process_f["acquire_data"] = self.acquire_data
-
-        return process_f
-
-    # ######################################################################## #
-    #                                                                          #
-    #                             BalanceAcquisition                           #
-    #                                                                          #
-    # ######################################################################## #
-
-    def balance_acquisition(self,
-            device                  = None,
-            mode                    = None,
-            intensity               = 45000,
-            threshold               = 2500,
-            pixel                   = None,
-            max_integration_time_ms = 5000,
-            max_tries               = 20):
-        balancer = BalanceAcquisition(
-            device                  = self,
-            mode                    = mode,
-            intensity               = intensity,
-            threshold               = threshold,
-            pixel                   = pixel,
-            max_integration_time_ms = max_integration_time_ms,
-            max_tries               = max_tries)
-        return balancer.balance()
-
-    # ######################################################################## #
-    #                                                                          #
-    #                             Hardware Control                             #
-    #                                                                          #
-    # ######################################################################## #
-
-    ##
-    # Processes an incoming (setting, value) pair.
-    #
-    # Some settings are processed internally within this function, if the
-    # functionality they are controlling is implemented by WasatchDevice.
-    # This includes scan averaging, and anything related to scan averaging
-    # (such as "take one" behavior).
-    #
-    # Most tuples are queued to be sent downstream to the connected hardware
-    # (usually FeatureIdentificationDevice) at the start of the next
-    # acquisition.
-    #
-    # Some hardware settings (those involving triggering or the laser) are
-    # sent downstream immediately, rather than waiting for the next "scheduled"
-    # settings update.
-    #
-    # ENLIGHTEN commands to WasatchDeviceWrapper are sent here by
-    # WasatchDeviceWrapper.continuous_poll.
-    #
-    # @param setting (Input) which setting to change
-    # @param value   (Input) the new value of the setting (required, but can
-    #                be None or "anything" for commands like "acquire" which
-    #                don't use the argument).
-    # @param allow_immediate
-    def change_setting(self, setting: str, value: Any, allow_immediate: bool = True): # -> None 
-        control_object = ControlObject(setting, value)
-        log.debug("WasatchDevice.change_setting: %s", control_object)
-
-        # Since scan averaging lives in WasatchDevice, handle commands which affect
-        # averaging at this level
-        if control_object.setting == "scans_to_average":
-            self.sum_count = 0
-            self.settings.state.scans_to_average = int(value)
-            return
-        elif control_object.setting == "reset_scan_averaging":
-            self.sum_count = 0
-            return
-        elif control_object.setting == "take_one":
-            self.take_one = True
-            self.change_setting("free_running_mode", True)
-            return
-        elif control_object.setting == "cancel_take_one":
-            self.sum_count = 0
-            self.take_one = False
-            self.change_setting("free_running_mode", False)
-            return
-
-        self.command_queue.append(control_object)
-        log.debug("change_setting: queued %s", control_object)
-
-        # always process trigger_source commands promptly (can't wait for end of
-        # acquisition which may never come)
-        if (allow_immediate and self.immediate_mode) or re.search(r"trigger|laser", setting):
-            log.debug("immediately processing %s", control_object)
-            self.process_commands()
-
-    # override handle_requests. I didn't see a good way to overwrite change_setting without
-    # having to redo that pass through.
-    def handle_requests(self, requests: list[SpectrometerRequest]): # -> list[SpectrometerResponse] 
-        responses = []
-        for request in requests:
-            try:
-                cmd = request.cmd
-                proc_func = self.process_f.get(cmd, None)
-                if proc_func == None:
-                    try:
-                        self.change_setting(cmd, *request.args, **request.kwargs)
-                    except Exception as e:
-                        log.error(f"error {e} with trying to set setting {cmd} with args and kwargs {request.args} and {request.kwargs}")
-                        return []
-                elif request.args == [] and request.kwargs == {}:
-                    responses.append(proc_func())
-                else:
-                    responses.append(proc_func(*request.args, **request.kwargs))
-            except Exception as e:
-                log.error(f"error in handling request {request} of {e}")
-                responses.append(SpectrometerResponse(error_msg="error processing cmd", error_lvl=ErrorLevel.medium))
-        return responses
+import re
+import os
+import time
+import numpy as np
+import psutil
+import logging
+import datetime
+import threading
+from queue import Queue
+from typing import Any
+
+from .FeatureIdentificationDevice import FeatureIdentificationDevice
+from .SpectrometerSettings        import SpectrometerSettings
+from .SpectrometerResponse        import SpectrometerResponse
+from .SpectrometerRequest         import SpectrometerRequest
+from .SpectrometerResponse        import ErrorLevel
+from .InterfaceDevice             import InterfaceDevice
+from .BalanceAcquisition          import BalanceAcquisition
+from .SpectrometerState           import SpectrometerState
+from .ControlObject               import ControlObject
+from .DeviceID                    import DeviceID
+from .Reading                     import Reading
+
+log = logging.getLogger(__name__)
+
+##
+# A WasatchDevice encapsulates and wraps a Wasatch spectrometer in a blocking
+# interface.  It will normally wrap one of the following:
+#
+# - a FeatureIdentificationDevice (modern FID spectrometer)
+#
+# ENLIGHTEN does not instantiate WasatchDevices directly, but instead uses
+# a WasatchDeviceWrapper to access a single WasatchDevice in a dedicated child 
+# thread.  Other users of Wasatch.PY may of course instantiate a WasatchDevice 
+# directly.
+class WasatchDevice(InterfaceDevice):
+
+    # While this is not the main interface device, it wraps FID
+    # It is also what is called by WrapperWorker and because of this
+    # I chose to implement the minimum formatting for interface device
+    # so that it can match the other calls in WrapperWorker
+
+    ##
+    # @param device_id      a DeviceID instance OR string label thereof
+    # @param message_queue  if provided, used to send status back to caller
+    def __init__(self, device_id: DeviceID, message_queue: Queue = None): # -> None 
+
+        # if passed a string representation of a DeviceID, deserialize it
+        if type(device_id) is str:
+            device_id = DeviceID(label=device_id)
+
+        self.device_id      = device_id
+        self.message_queue  = message_queue
+
+        self.lock = threading.Lock()
+
+        self.connected = False
+        self.hardware = None
+
+        # Receives ENLIGHTEN's 'change settings' commands in the spectrometer
+        # process. Although a logical queue, has nothing to do with multiprocessing.
+        self.command_queue = []
+
+        # Enable for "immediate mode" by clients like WasatchShell (by default,
+        # inbound commands are queued and executed at beginning of next acquire_data;
+        # this runs them as they arrive).
+        self.immediate_mode = False
+
+        self.settings = SpectrometerSettings()
+
+        # Any particular reason these aren't in FeatureIdentificationDevice?
+        self.summed_spectra         = None
+        self.sum_count              = 0
+        self.session_reading_count  = 0
+        self.take_one_request       = None
+        self.last_complete_acquisition = None
+
+        self.process_id = os.getpid()
+        self.last_memory_check = datetime.datetime.now()
+        self.last_battery_percentage = 0
+
+        self.process_f = self._init_process_funcs()
+
+    # ######################################################################## #
+    #                                                                          #
+    #                               Connection                                 #
+    #                                                                          #
+    # ######################################################################## #
+
+    ## Attempt low level connection to the specified DeviceID
+    def connect(self): # -> SpectrometerResponse 
+        if self.device_id.is_usb() or self.device_id.is_mock():
+            log.debug("trying to connect to %s device" % ("USB" if self.device_id.is_usb() else "Mock"))
+            result = self.connect_feature_identification()
+            if result.data:
+                log.debug("Connected to FeatureIdentificationDevice")
+                self.connected = True
+                self.initialize_settings()
+                return SpectrometerResponse(True)
+            else:
+
+                log.debug("Failed to connect to FeatureIdentificationDevice")
+                return result
+
+        else:
+            log.critical("unsupported DeviceID protocol: %s", self.device_id)
+
+        log.debug("Can't connect to %s", self.device_id)
+        return SpectrometerResponse(False)
+
+    def disconnect(self):
+        log.debug("WasatchDevice.disconnect: calling hardware disconnect")
+        try:
+            req = SpectrometerRequest("disconnect")
+            self.hardware.handle_requests([req])
+        except:
+            log.critical("Issue disconnecting hardware", exc_info=1)
+
+        time.sleep(0.1)
+
+        self.connected = False
+        return True
+
+    ## Given a specified universal identifier, attempt to connect to the device using FID protocol.
+    # @todo merge with the hardcoded list in DeviceFinderUSB
+    def connect_feature_identification(self): # -> SpectrometerResponse 
+        FID_list = ["1000", "2000", "4000"] # hex
+
+        # check to see if valid FID PID
+        pid_hex = self.device_id.get_pid_hex()
+        if pid_hex not in FID_list:
+            log.debug("connect_feature_identification: device_id %s PID %s not in FID list %s", self.device_id, pid_hex, FID_list)
+            return SpectrometerResponse(False)
+
+        dev = None
+        try:
+            log.debug("connect_fid: instantiating FID with device_id %s pid %s", self.device_id, pid_hex)
+            dev = FeatureIdentificationDevice(device_id=self.device_id, message_queue=self.message_queue)
+            log.debug("connect_fid: instantiated")
+
+            try:
+                log.debug("connect_fid: calling dev.connect")
+                response = dev.connect()
+                log.debug("connect_fid: back from dev.connect")
+            except Exception as exc:
+                log.critical("connect_feature_identification: %s", exc, exc_info=1)
+                return SpectrometerResponse(False)
+
+            if not response.data:
+                log.critical("Low level failure in device connect")
+                return response
+
+            self.hardware = dev
+
+        except:
+            log.critical("Problem connecting to: %s", self.device_id, exc_info=1)
+            return SpectrometerResponse(False)
+
+        log.debug("Connected to FeatureIdentificationDevice %s", self.device_id)
+        return SpectrometerResponse(True)
+
+    def initialize_settings(self):
+        if not self.connected:
+            return
+
+        self.settings = self.hardware.settings
+
+        # generic post-initialization stuff 
+
+        req_int = SpectrometerRequest('get_integration_time_ms')
+        req_gain = SpectrometerRequest('get_detector_gain')# note we don't pass update_session_eeprom, so this doesn't really do anything
+        reqs = [req_int, req_gain]
+        self.hardware.handle_requests(reqs) 
+        # could read the defaults for these ss.state volatiles from FID too:
+        #
+        # self.tec_setpoint_degC
+        # self.high_gain_mode_enabled
+        # self.triggering_enabled
+        # self.laser_enabled
+        # self.laser_power
+        # self.ccd_offset
+
+        self.settings.update_wavecal()
+        self.settings.update_raman_intensity_factors()
+        self.settings.dump()
+
+    # ######################################################################## #
+    #                                                                          #
+    #                               Acquisition                                #
+    #                                                                          #
+    # ######################################################################## #
+
+    def acquire_data(self): # -> SpectrometerResponse 
+        """
+        Process all enqueued settings, then read actual data (spectrum and
+        temperatures) from the device.
+
+        ENLIGHTEN calls this function via WrapperWorker.run().
+
+        @see Controller.acquire_reading
+        """
+        log.debug("acquire_data: start")
+
+        if self.hardware.shutdown_requested:
+            log.critical("acquire_data: hardware shutdown requested")
+            return SpectrometerResponse(False, poison_pill=True)
+
+        # process queued commands, and find out if we've been asked to read a
+        # spectrum
+        self.process_commands()
+
+        # if we don't yet have an integration time, nothing to do
+        if self.settings.state.integration_time_ms <= 0:
+            log.debug("skipping acquire_data because no integration_time_ms")
+            return SpectrometerResponse(None)
+
+        # if not self.hardware.is_sensor_stable():
+        #     # technically, we could do all the other stuff in acquire_spectrum 
+        #     # (read battery, laser temperature, ambient temperature, detector 
+        #     # temperature etc), not bothering for now
+        #     log.debug("declining to read spectra while stabilizing") 
+        #     return SpectrometerResponse(None)
+
+        # note that right now, all we return are Readings (encapsulating both
+        # spectra and temperatures).  If we disable spectra, ENLIGHTEN stops 
+        # receiving temperatures as well.  In the future perhaps we should return
+        # multiple object types (Acquisitions, Temperatures, etc)
+        return self.acquire_spectrum()
+
+    ##
+    # Generate one Reading from the spectrometer, including one
+    # optionally-averaged spectrum, device temperatures and other hardware
+    # status.
+    #
+    # This is normally called by self.acquire_data when that function decides it
+    # is time to perform an acquisition.
+    #
+    # @par Scan Averaging
+    #
+    # IF the driver is in free-running mode, AND performing scan averaging,
+    # THEN scan averaging is NOT encapsulated within a single call to this
+    # function.  Instead, we let ths spectrometer run in free-running mode,
+    # collecting individual spectra as per normal, and returning each "partial"
+    # readings while "building up" to the final averaged measurement.
+    #
+    # That is to say, if scan averaging is set to 10, then this function will
+    # get called 10 times, as ticked by the regular free-running timers, before
+    # the fully averaged spectrum is returned.  A total of 10 (not 11) spectra
+    # will be generated and sent upstream: the first 9 "partial" (unaveraged)
+    # reads, and the final 10th spectrum which will contain the average of all
+    # 10 measurements.
+    #
+    # This gives the user-facing GUI an opportunity to update the "collected
+    # X-of-Y" readout on-screen, and potentially even graph the traces of
+    # in-process partial readings.
+    #
+    # HOWEVER, this doesn't make as much sense if we're not in free-running mode,
+    # i.e. the subprocess has been slaved to explicit control by the Controller
+    # (likely a feature object like BatchCollection), and is collecting exactly
+    # those measurements we're being commanded, as they're commanded.
+    #
+    # THEREFORE, if the driver IS NOT in free-running mode, then we ONLY return
+    # the final averaged spectrum as one atomic operation.
+    #
+    # In this case, if scan averaging is set to 10, then A SINGLE CALL to this
+    # function will "block" while the full 10 measurements are made, and then
+    # a single, fully-averaged spectrum will be returned upstream.
+    #
+    # @return a Reading object
+    #
+    def acquire_spectrum(self):
+        acquire_response = SpectrometerResponse()
+
+        tor = self.take_one_request
+        if tor:
+            log.debug(f"WasatchDevice.acquire_spectrum: attempting to fulfill {tor}")
+        else:
+            log.debug(f"WasatchDevice.acquire_spectrum: no TakeOneRequest in effect")
+
+        self.perform_optional_throwaways()
+
+        ########################################################################
+        # Batch Collection and Auto-Raman silliness
+        ########################################################################
+
+        # We could move this up into ENLIGHTEN.BatchCollection: have it enable
+        # the laser, wait a bit, and then send the "acquire" command.  But since
+        # WasatchDeviceWrapper.continuous_poll ticks at its own interval, that
+        # would introduce timing interference, and different acquisitions would
+        # realistically end up with different warm-up times for lasers (all "at
+        # least" the configured time, but some longer than others).  Instead,
+        # for now I'm putting this delay here, so it will be exactly the same
+        # (given sleep()'s precision) for each acquisition.  For true precision
+        # this should all go into the firmware anyway.
+
+        auto_enable_laser = tor and tor.enable_laser_before 
+        log.debug("acquire_spectrum: auto_enable_laser = %s", auto_enable_laser)
+
+        dark_reading = SpectrometerResponse()
+        if auto_enable_laser and tor.take_dark:
+            log.debug(f"AUTO-RAMAN ==> taking internal dark")
+
+            # disable laser if it was on
+            if self.settings.state.laser_enabled:
+                log.debug("AUTO-RAMAN ==> disabling laser for internal dark")
+                self.hardware.handle_requests([SpectrometerRequest('set_laser_enable', args=[False])])
+                time.sleep(1) 
+
+            dark_reading = self.take_one_averaged_reading(label="internal dark")
+            if dark_reading.poison_pill or dark_reading.error_msg:
+                log.debug(f"internal dark error {dark_reading}")
+                acquire_response.poison_pill = True
+                return acquire_response
+
+        if auto_enable_laser:
+            log.debug(f"AUTO-RAMAN ==> acquire_spectum: enabling laser")
+            req = SpectrometerRequest('set_laser_enable', args=[True])
+            self.hardware.handle_requests([req])
+            if self.hardware.shutdown_requested:
+                log.debug(f"auto_enable_laser shutdown requested")
+                acquire_response.poison_pill = True
+                return acquire_response
+
+            if tor:
+                log.debug(f"AUTO-RAMAN ==> acquire_spectum: sleeping {tor.laser_warmup_ms}ms for laser to warmup")
+                time.sleep(tor.laser_warmup_ms / 1000.0)
+
+            self.perform_optional_throwaways()
+
+        ########################################################################
+        # Take a Reading (possibly averaged)
+        ########################################################################
+
+        log.debug("taking averaged reading")
+        take_one_response = self.take_one_averaged_reading(label="sample (possibly Raman)")
+        reading = take_one_response.data
+        if take_one_response.poison_pill:
+            log.debug(f"floating up take_one_averaged_reading poison pill {take_one_response}")
+            return take_one_response
+        if take_one_response.keep_alive:
+            log.debug(f"floating up keep alive")
+            return take_one_response
+        if take_one_response.data is None:
+            log.debug(f"Received a none reading, floating it up {take_one_response}")
+            return take_one_response
+
+        # don't perform dark subtraction, but pass the dark measurement along
+        # with the averaged reading
+        if dark_reading.data is not None:
+            reading.dark = dark_reading.data.spectrum
+            log.debug(f"attaching dark to reading (mean {np.mean(reading.dark)}, min {min(reading.dark)}, max {max(reading.dark)})")
+            log.debug(f"reading spectrum          (mean {np.mean(reading.spectrum)}, min {min(reading.spectrum)}, max {max(reading.spectrum)})")
+
+        ########################################################################
+        # provide early exit-ramp if we've been asked to return bare Readings
+        # (just averaged spectra with corrected bad pixels, no metadata)
+        ########################################################################
+
+        def disable_laser(shutdown=False, label=None):
+            if shutdown or auto_enable_laser:
+                log.debug(f"acquire_spectrum.disable_laser: shutdown {shutdown}, auto_enable_laser {auto_enable_laser}, label {label}")
+                req = SpectrometerRequest('set_laser_enable', args=[False])
+                self.hardware.handle_requests([req])
+                acquire_response.poison_pill = shutdown
+            return acquire_response # for convenience
+
+        ########################################################################
+        # We're done with the (possibly-averaged) spectrum, so we'd like to now
+        # disable the automatically-enabled laser, if it was engaged; but before
+        # we can do that that, we should take any requested measurements of the
+        # laser temperature and photodiode, as those would obviously be invalid-
+        # ated if we took them AFTER the laser was off.
+        ########################################################################
+
+        # only read laser temperature if we have a laser
+        if self.settings.eeprom.has_laser:
+            try:
+                # MZ: we might want to do these for auto_enable_laser as well...
+                func_attr = [ ('get_laser_enabled', 'laser_enabled'),
+                              ('can_laser_fire',    'laser_can_fire'),
+                              ('is_laser_firing',   'laser_is_firing') ]
+                if self.settings.is_xs() and self.settings.eeprom.sig_laser_tec:
+                    func_attr.append( ('get_laser_tec_mode', 'laser_tec_enabled') )
+                    func_attr.append( ('get_ambient_temperature_degC', 'ambient_temperature_degC') )
+
+                for (func, attr) in func_attr:
+                    req = SpectrometerRequest(func)
+                    res = self.hardware.handle_requests([req])[0]
+                    if res is None:
+                        log.debug(f"WasatchDevice.acquire_spectrum: ignoring None {func} response")
+                    else:
+                        if res.error_msg != '':
+                            return res
+                        value = res.data
+                        log.debug(f"WasatchDevice.acquire_spectrum: storing {attr} = {value}")
+                        setattr(reading, attr, value)
+
+                if self.hardware.shutdown_requested:
+                    return disable_laser(shutdown=True, label=f"loading laser attributes")
+
+                # laser temperature
+                count = 2 if self.settings.state.secondary_adc_enabled else 1
+                for throwaway in range(count):
+                    req = SpectrometerRequest('get_laser_temperature_raw')
+                    res = self.hardware.handle_requests([req])[0]
+                    if res.error_msg != '':
+                        return res
+                    reading.laser_temperature_raw  = res.data
+                    if self.hardware.shutdown_requested:
+                        return disable_laser(shuttdown=True, label=f"reading laser temperature (throwaway {throwaway} of {count})")
+
+                req = SpectrometerRequest('get_laser_temperature_degC', args=[reading.laser_temperature_raw])
+                res = self.hardware.handle_requests([req])[0]
+                if res.error_msg != '':
+                    return res
+                reading.laser_temperature_degC = res.data
+                if self.hardware.shutdown_requested:
+                    return disable_laser(shutdown=True, label=f"reading laser temperature")
+
+            except:
+                log.debug("Error reading laser temperature", exc_info=1)
+
+        # read secondary ADC if requested
+        if self.settings.state.secondary_adc_enabled:
+            try:
+                req = SpectrometerRequest("select_adc", args=[1])
+                self.hardware.handle_requests([req])
+                if self.hardware.shutdown_requested:
+                    return disable_laser(shutdown=True, label="select_adc[1]")
+
+                for throwaway in range(2):
+                    req = SpectrometerRequest("get_secondary_adc_raw")
+                    res = self.hardware.handle_requests([req])[0]
+                    if res.error_msg != '':
+                        return res
+                    reading.secondary_adc_raw = res.data
+                    if self.hardware.shutdown_requested:
+                        return disable_laser(shutdown=True, label="get_secondary_adc_raw")
+
+                req = SpectrometerRequest("get_secondary_adc_calibrated", args =[reading.secondary_adc_raw])
+                res = self.hardware.handle_requests([req])[0]
+                if res.error_msg != '':
+                    return res
+                reading.secondary_adc_calibrated = res.data 
+                req = SpectrometerRequest("select_adc", args=[0])
+                res = self.hardware.handle_requests([req])[0]
+                if res.error_msg != '':
+                    return res
+                if self.hardware.shutdown_requested:
+                    return disable_laser(shutdown=True, label="select_adc[0]")
+
+            except:
+                log.debug("Error reading secondary ADC", exc_info=1)
+
+        ########################################################################
+        # we've read the laser temperature and photodiode, so we can now safely
+        # disable the laser (if we're the one who enabled it)
+        ########################################################################
+
+        disable_laser(label="clean exit")
+
+        ########################################################################
+        # finish collecting any metadata that doesn't require the laser
+        ########################################################################
+
+        # read detector temperature if applicable
+        if self.settings.eeprom.has_cooling:
+            try:
+                req = SpectrometerRequest("get_detector_temperature_raw")
+                res = self.hardware.handle_requests([req])[0]
+                if res.error_msg != '':
+                    return res
+                reading.detector_temperature_raw  = res.data
+                if self.hardware.shutdown_requested:
+                    log.debug("detector_temperature_raw shutdown")
+                    acquire_response.poison_pill = True
+                    return acquire_response
+
+                req = SpectrometerRequest("get_detector_temperature_degC", args=[reading.detector_temperature_raw])
+                res = self.hardware.handle_requests([req])[0]
+                if res.error_msg != '':
+                    return res
+                reading.detector_temperature_degC = res.data
+                if self.hardware.shutdown_requested:
+                    log.debug("detector_temperature_degC shutdown")
+                    acquire_response.poison_pill = True
+                    return acquire_response
+
+            except:
+                log.debug("Error reading detector temperature", exc_info=1)
+
+        # read ambient temperature if applicable
+        if self.settings.is_gen15():
+            try:
+                # reading.ambient_temperature_degC = self.hardware.get_ambient_temperature_degC()
+                pass
+            except:
+                log.debug("Error reading ambient temperature", exc_info=1)
+
+        # read battery every 5sec
+        if self.settings.eeprom.has_battery:
+            if self.settings.state.battery_timestamp is None or (datetime.datetime.now() - self.settings.state.battery_timestamp).total_seconds() > 5:
+
+                # note that the following 3 requests should actually only generate 
+                # one USB transaction as raw is cached internally
+                req = SpectrometerRequest("get_battery_state_raw")
+                res = self.hardware.handle_requests([req])[0]
+                if res.error_msg != '':
+                   return res
+                reading.battery_raw = res.data
+                if self.hardware.shutdown_requested:
+                    log.debug("battery_raw shutdown")
+                    acquire_response.poison_pill = True
+                    return acquire_response
+
+                req = SpectrometerRequest("get_battery_percentage")
+                res = self.hardware.handle_requests([req])[0]
+                if res.error_msg != '':
+                   return res
+                reading.battery_percentage = res.data
+                if self.hardware.shutdown_requested:
+                    log.debug("battery_perc shutdown")
+                    acquire_response.poison_pill = True
+                    return acquire_response
+                self.last_battery_percentage = reading.battery_percentage
+
+                req = SpectrometerRequest("get_battery_percentage")
+                res = self.hardware.handle_requests([req])[0]
+                if res.error_msg != '':
+                    return res
+                reading.battery_charging = res.data
+                if self.hardware.shutdown_requested:
+                    log.debug("battery_charging shutdown")
+                    acquire_response.poison_pill = True
+                    return acquire_response
+
+                log.debug("battery: %.2f%% (%s)", reading.battery_percentage, "charging" if reading.battery_charging else "discharging")
+            else:
+                if reading is not None:
+                    reading.battery_percentage = self.last_battery_percentage
+
+        if auto_enable_laser:
+            log.debug(f"AUTO-RAMAN ==> done")
+
+        if tor:
+            log.debug(f"completed {tor}")
+            reading.take_one_request = tor
+            self.take_one_request = None
+
+        log.debug("device.acquire_spectrum: returning %s", reading)
+        acquire_response.data = reading
+        self.last_complete_acquisition = datetime.datetime.now()
+        return acquire_response
+
+    ##
+    # It's unclear how many throwaways are really needed for a stable Raman 
+    # spectrum, and whether they're really based on number of integrations 
+    # (sensor stabilization) or time (laser warmup); I suspect both.  Also note 
+    # the potential need for sensor warm-up, but I think that's handled inside FW.
+    #
+    # Optimal would probably be something like "As many integrations as it takes
+    # to span 2sec, but not fewer than two."
+    #
+    # These are NOT the same throwaways added to smooth spectra over changes to
+    # integration time and gain. These are separate throwaways potentially 
+    # required when waking the sensor from sleep. However, I'm using the same
+    # mechanism for tracking (self.remaining_throwaways) for commonality.
+    #
+    # @todo This shouldn't be required at all if we're in free-running mode, or 
+    #       if it's been less than a second since the last acquisition.
+    # @returns SpectrometerResponse IFF error occurred (normally None)
+    def perform_optional_throwaways(self):
+        if self.settings.is_micro() and self.take_one_request:
+            count = 2
+            readout_ms = 5
+
+            # Assume that if we FINISHED the last measurement less than a second 
+            # ago, the sensor probably has not gone to sleep and doesn't need SW-
+            # driven warmups.
+            elapsed_sec_since_last_acquisition = (datetime.datetime.now() - self.last_complete_acquisition).total_seconds()
+            if self.last_complete_acquisition is None or elapsed_sec_since_last_acquisition > 1:
+                # for now, default to 2sec worth of acquisitions
+                while count * (self.settings.state.integration_time_ms + readout_ms) < 2000:
+                    count += 1
+
+            self.hardware.remaining_throwaways = count
+            while self.hardware.remaining_throwaways > 0:
+                log.debug(f"more than a second since last measurement, so performing wake-up throwaways ({self.hardware.remaining_throwaways - 1} remaining)")
+                req = SpectrometerRequest("get_line")
+                res = self.hardware.handle_requests([req])[0]
+                if res.error_msg != '':
+                    return res
+
+    def take_one_averaged_reading(self, label=None):
+        """
+        Okay, let's talk about averaging.  We only perform averaging as a 
+        blocking call in Wasatch.PY when given a TakeOneRequest with non-zero 
+        scans_to_average, typically from ENLIGHTEN's TakeOneFeature (perhaps via
+        VCRControls.step, possibly with AutoRaman, or BatchCollection).
+
+        Otherwise, normally this thread (the background thread owned by a 
+        WasatchDeviceWrapper object and running WrapperWorker.run) is in "free-
+        running" mode, taking spectra just as fast as it can in an endless loop,
+        feeding them back to the consumer (ENLIGHTEN) over a queue. To keep that 
+        pipeline "moving," generally we don't do heavy blocking operations down 
+        here in the background thread.
+        
+        The new AutoRaman feature makes increased using of scan averaging,
+        and again kind of wants to be encapsulated down here. And by implication,
+        all TakeOneRequests should really support encapsulated, atomic averaging.
+        So the current design is that ATOMIC scans_to_average comes from 
+        TakeOneRequest, ENLIGHTEN-based averaging in SpectrometerState.
+
+        @returns Reading on success, true or false on "stop processing" conditions
+        """
+        take_one_response = SpectrometerResponse()
+
+        if self.take_one_request:
+            scans_to_average = self.take_one_request.scans_to_average   # how many (for completion test / division)
+            loop_count = scans_to_average                               # how many to take NOW
+            sum_locally = scans_to_average > 1                          # whether we should be summing at all
+            self.sum_count = 0                                          # whether we should reset previous sums
+        else:
+            scans_to_average = self.settings.state.scans_to_average     # how many (for completion test / division)
+            sum_locally = scans_to_average > 1                          # whether we should be summing at all
+            loop_count = 1                                              # how many to take NOW
+
+        if False:
+            log.debug(f"take_one_averaged_reading[{label}]:")
+            log.debug(f"  self.sum_count        = {self.sum_count}")
+            log.debug(f"  scans_to_average      = {scans_to_average}")
+            log.debug(f"  loop_count            = {loop_count}")
+            log.debug(f"  sum_locally           = {sum_locally}")
+            log.debug(f"  remaining_throwaways  = {self.hardware.remaining_throwaways}")
+
+        # clear any pending throwaways
+        while self.hardware.remaining_throwaways > 0:
+            log.debug(f"clearing stabilization throwaway ({self.hardware.remaining_throwaways - 1} remaining)")
+            req = SpectrometerRequest("get_line")
+            res = self.hardware.handle_requests([req])[0]
+            if res.error_msg != '':
+                return res
+
+        # either take one measurement (normal), or a bunch (sum_locally)
+        reading = None
+        for loop_index in range(loop_count):
+
+            log.debug(f"take_one_averaged_reading: loop_index {loop_index+1} of {loop_count}")
+
+            # start a new reading
+            # NOTE: reading.timestamp is when reading STARTED, not FINISHED!
+            reading = Reading(self.device_id)
+
+            # TODO...just include a copy of SpectrometerState? something to think
+            # about. That would actually provide a reason to roll all the
+            # temperature etc readouts into the SpectrometerState class...
+            reading.integration_time_ms = self.settings.state.integration_time_ms
+            reading.laser_power_perc    = self.settings.state.laser_power_perc
+            reading.laser_power_mW      = self.settings.state.laser_power_mW
+            reading.laser_enabled       = self.settings.state.laser_enabled
+
+            # Are we reading one spectrum (normal mode, or "slow" area scan), or
+            # doing a batch-read of a whole frame ("fast" area scan)?
+            #
+            # It's a bit confusing that this is INSIDE the scan averaging loop...
+            # there is NO use-case for "averaged" area scan.  We should move this
+            # up and out of take_one_averaged_reading().
+            if self.settings.state.area_scan_enabled and self.settings.state.area_scan_fast:
+
+                # collect a whole frame of area scan data
+                with self.lock:
+                    reading.area_scan_data = []
+                    try:
+                        rows = self.settings.eeprom.active_pixels_vertical
+                        first = True
+                        log.debug("trying to read a fast area scan frame of %d rows", rows)
+                        #for i in range(rows):
+                        row_data = {}
+                        while True:
+                            log.debug(f"trying to read fast area scan row")
+                            req = SpectrometerRequest("get_line",kwargs={"trigger":first})
+                            response = self.hardware.handle_requests([req])[0]
+                            if response.error_msg != '':
+                                return response
+                            spectrum_and_row = response.data
+                            first = False
+                            if response.poison_pill:
+                                # get_line returned a poison-pill, so we're not 
+                                # getting any more in this frame...give up and move on
+                                # return False
+                                take_one_response.transfer_response(response)
+                                log.debug(f"get_line returned {spectrum_and_row}, breaking")
+                                break
+                            elif response.keep_alive:
+                                take_one_response.transfer_response(response)
+                                log.debug(f"get_line returned keep alive, passing up")
+                                return take_one_response
+                            elif self.hardware.shutdown_requested:
+                                take_one_response.transfer_response(response)
+                                return take_one_response
+                            elif spectrum_and_row.spectrum is None:
+                                log.debug("take_one_averaged_reading: get_line None, sending keepalive for now (area scan fast)")
+                                take_one_response.transfer_response(response)
+                                return take_one_response
+
+                            # mimic "slow" results to minimize downstream fuss
+                            spectrum = spectrum_and_row.spectrum
+                            row = spectrum_and_row.row
+
+                            reading.spectrum = spectrum
+                            row_data[row] = spectrum
+                            reading.timestamp_complete  = datetime.datetime.now()
+                            log.debug("device.take_one_averaged_reading(area scan fast): got %s ... (row %d) (min %d)",
+                                spectrum[0:9], row, min(reading.spectrum))
+
+                        reading.area_scan_data = []
+                        reading.area_scan_row_count = -1
+                        for row in sorted(row_data.keys()):
+                            reading.area_scan_data.append(row_data[row])
+                            reading.area_scan_row_count = row
+
+                    except Exception as exc:
+                        log.critical("Error reading hardware data", exc_info=1)
+                        reading.spectrum = None
+                        reading.failure = str(exc)
+                        take_one_response.error_msg = exc
+                        take_one_response.error_lvl = ErrorLevel.medium
+                        take_one_response.keep_alive = True
+                        return take_one_response
+
+            else:
+
+                # collect ONE spectrum (it's in a while loop because we may have
+                # to wait for an external trigger, and must wait through a series
+                # of timeouts)
+                externally_triggered = self.settings.state.trigger_source == SpectrometerState.TRIGGER_SOURCE_EXTERNAL
+                try:
+                    while True:
+                        req = SpectrometerRequest("get_line")
+                        res = self.hardware.handle_requests([req])[0]
+                        if res.error_msg != '':
+                            return res
+                        spectrum_and_row = res.data
+                        if res.poison_pill:
+                            # float up poison
+                            take_one_response.transfer_response(res)
+                            return take_one_response
+                        if res.keep_alive:
+                            # float up keep alive
+                            take_one_response.transfer_response(res)
+                            return take_one_response
+                        if isinstance(spectrum_and_row, bool):
+                            # get_line returned a poison-pill, so flow it upstream
+                            take_one_response.poison_pill = True
+                            return take_one_response
+
+                        if self.hardware.shutdown_requested:
+                            take_one_response.poison_pill = True
+                            return take_one_response
+
+                        if spectrum_and_row is None or spectrum_and_row.spectrum is None:
+                            # FeatureIdentificationDevice can return None when waiting
+                            # on an external trigger.  
+                            log.debug("take_one_averaged_reading: get_line None, sending keepalive for now")
+                            take_one_response.transfer_response(res)
+                            return take_one_response
+                        else:
+                            break
+
+                    reading.spectrum            = spectrum_and_row.spectrum
+                    reading.area_scan_row_count = spectrum_and_row.row
+                    reading.timestamp_complete  = datetime.datetime.now()
+
+                    log.debug("device.take_one_averaged_reading: got %s ... (row %d)", reading.spectrum[0:9], reading.area_scan_row_count)
+                except Exception as exc:
+                    # if we got the timeout after switching from externally triggered back to internal, let it ride
+                    take_one_response.error_msg = exc
+                    take_one_response.error_lvl = ErrorLevel.medium
+                    take_one_response.keep_alive = True
+                    if externally_triggered:
+                        log.debug("caught exception from get_line while externally triggered...sending keepalive")
+                        return take_one_response
+
+                    log.critical("Error reading hardware data", exc_info=1)
+                    reading.spectrum = None
+                    reading.failure = str(exc)
+
+            ####################################################################
+            # Aggregate scan averaging
+            ####################################################################
+
+            # It's important to note here that the scan averaging "sum" buffer
+            # here (self.summed_spectra) and counter (self.sum_count) are
+            # attributes of this WasatchDevice object: they are not part of the
+            # Reading being sent back to the caller.
+            #
+            # The current architecture in Wasatch.PY, which is a little different
+            # than other Wasatch drivers, is that even when scan averaging is
+            # enabled, EVERY SPECTRUM will be flowed back to the caller.
+            #
+            # This is because early versions of ENLIGHTEN showed the "individual"
+            # (pre-averaged) spectra as a faint grey trace in the background,
+            # updating with each integration, showing the higher noise level of
+            # "raw" spectra while an on-screen counter showed the incrementing
+            # tally of summed spectra in the buffer.
+            #
+            # Then, when the FINAL raw spectrum had been read and the complete
+            # average could be computed, that averaged spectrum was returned
+            # with a special flag in the Reading object to indicate "fully
+            # averaged."
+            #
+            # We no longer show the "background" spectral trace in ENLIGHTEN,
+            # so this is kind of wasting some intra-process bandwidth, but we
+            # do still increment the on-screen tally as feedback while the
+            # averaging is taking place, so the in-process Reading messages
+            # sent during an averaged collection are not entirely wasted.
+            #
+            # Still, this is not the way we would have designed a Python driver
+            # "from a blank sheet," and our other driver architectures show that.
+            #
+            # @todo: since we're actually passing every pre-averaged spectrum
+            # back to ENLIGHTEN, for non-TakeOneRequest averaging, I feel like
+            # we should probably perform the summation in ENLIGHTEN too (for
+            # non-TakeOneRequest averages).
+
+            if not reading.failure:
+                log.debug("take_one_averaged_reading: not failure")
+                if sum_locally:
+                    log.debug("take_one_averaged_reading: summing locally")
+                    if self.sum_count == 0:
+                        log.debug("take_one_averaged_reading: first spectrum (initializing)")
+                        self.summed_spectra = [float(i) for i in reading.spectrum]
+                    else:
+                        log.debug("take_one_averaged_reading: adding to previous")
+                        for i in range(len(self.summed_spectra)):
+                            self.summed_spectra[i] += reading.spectrum[i]
+                    self.sum_count += 1
+                    log.debug("take_one_averaged_reading: summed_spectra : %s ...", self.summed_spectra[0:9])
+
+            # count spectra
+            self.session_reading_count += 1
+            reading.session_count = self.session_reading_count
+            reading.sum_count = self.sum_count
+            log.debug(f"take_one_averaged_reading: reading.sum_count now {reading.sum_count}")
+
+            # have we completed the averaged reading?
+            if sum_locally: 
+                log.debug(f"take_one_averaged_reading: checking for completion self.sum_count {self.sum_count} >?= scans_to_average {scans_to_average}")
+                if self.sum_count >= scans_to_average:
+                    reading.spectrum = [ x / self.sum_count for x in self.summed_spectra ]
+                    log.debug("take_one_averaged_reading: averaged_spectrum : %s ...", reading.spectrum[0:9])
+                    reading.averaged = True
+
+                    # reset for next average
+                    self.summed_spectra = None
+                    self.sum_count = 0
+            else:
+                # if averaging isn't enabled...then a single reading is the
+                # "averaged" final measurement (check reading.sum_count to confirm)
+                reading.averaged = True
+
+        log.debug("device.take_one_averaged_reading: returning %s", reading)
+        # reading.dump_area_scan()
+        take_one_response.data = reading
+        return take_one_response
+
+    def monitor_memory(self):
+        now = datetime.datetime.now()
+        if (now - self.last_memory_check).total_seconds() < 5:
+            return
+
+        self.last_memory_check = now
+        size_in_bytes = psutil.Process(self.process_id).memory_info().rss
+        log.info("monitor_memory: PID %d memory = %d bytes", self.process_id, size_in_bytes)
+
+    ##
+    # Process every entry on the incoming command (settings) queue, writing each
+    # to the device.
+    #
+    # Essentially this iterates through all the (setting, value) pairs we've
+    # received through change_setting() which have not yet been processed, and
+    #
+    #
+    # Note that WasatchDeviceWrapper.continuous_poll "de-dupes" commands on
+    # receipt from ENLIGHTEN, so the command stream arising from that source
+    # should already be optimized and minimal.  Commands injected manually by
+    # calling WasatchDevice.change_setting() do not receive this treatment.
+    #
+    # In the normal multi-process (ENLIGHTEN) workflow, this function is called
+    # at the beginning of acquire_data, itself ticked regularly by
+    # WasatchDeviceWrapper.continuous_poll.
+    def process_commands(self):
+        control_object = "throwaway"
+        retval = False
+        log.debug("process_commands: processing")
+        while len(self.command_queue) > 0:
+            control_object = self.command_queue.pop(0)
+            log.debug("process_commands: %s", control_object)
+
+            # is this a command used by WasatchDevice itself, and not
+            # passed down to FeatureIdentificationDevice?
+            if control_object.setting.lower() == "acquire":
+                log.debug("process_commands: acquire found")
+                retval = True
+            else:
+                # send setting downstream to be processed by the spectrometer HAL
+                # (probably FeatureIdentificationDevice)
+                req = SpectrometerRequest(control_object.setting, args=[control_object.value])
+                self.hardware.handle_requests([req])
+
+        return retval
+
+    def _init_process_funcs(self): # -> dict[str, Callable[..., Any]] 
+        process_f = {}
+
+        process_f["connect"] = self.connect
+        process_f["disconnect"] = self.disconnect
+        process_f["acquire_data"] = self.acquire_data
+
+        return process_f
+
+    # ######################################################################## #
+    #                                                                          #
+    #                             BalanceAcquisition                           #
+    #                                                                          #
+    # ######################################################################## #
+
+    def balance_acquisition(self,
+            device                  = None,
+            mode                    = None,
+            intensity               = 45000,
+            threshold               = 2500,
+            pixel                   = None,
+            max_integration_time_ms = 5000,
+            max_tries               = 20):
+        balancer = BalanceAcquisition(
+            device                  = self,
+            mode                    = mode,
+            intensity               = intensity,
+            threshold               = threshold,
+            pixel                   = pixel,
+            max_integration_time_ms = max_integration_time_ms,
+            max_tries               = max_tries)
+        return balancer.balance()
+
+    # ######################################################################## #
+    #                                                                          #
+    #                             Hardware Control                             #
+    #                                                                          #
+    # ######################################################################## #
+
+    ##
+    # Processes an incoming (setting, value) pair.
+    #
+    # Some settings are processed internally within this function, if the
+    # functionality they are controlling is implemented by WasatchDevice.
+    # This includes scan averaging, and anything related to scan averaging
+    # (such as "take one" behavior).
+    #
+    # Most tuples are queued to be sent downstream to the connected hardware
+    # (usually FeatureIdentificationDevice) at the start of the next
+    # acquisition.
+    #
+    # Some hardware settings (those involving triggering or the laser) are
+    # sent downstream immediately, rather than waiting for the next "scheduled"
+    # settings update.
+    #
+    # ENLIGHTEN commands to WasatchDeviceWrapper are sent here by
+    # WasatchDeviceWrapper.continuous_poll.
+    #
+    # @param setting (Input) which setting to change
+    # @param value   (Input) the new value of the setting (required, but can
+    #                be None or "anything" for commands like "acquire" which
+    #                don't use the argument).
+    # @param allow_immediate
+    def change_setting(self, setting: str, value: Any, allow_immediate: bool = True): # -> None 
+        log.debug(f"WasatchDevice.change_setting: {setting} -> {value}")
+
+        # Since scan averaging lives in WasatchDevice, handle commands which affect
+        # averaging at this level
+        if setting == "scans_to_average":
+            self.sum_count = 0
+            self.settings.state.scans_to_average = int(value)
+            return
+        elif setting == "reset_scan_averaging":
+            self.sum_count = 0
+            return
+        elif setting == "take_one_request":
+            self.sum_count = 0
+            self.take_one_request = value
+            return
+        elif setting == "cancel_take_one":
+            self.sum_count = 0
+            self.take_one_request = None
+            return
+
+        control_object = ControlObject(setting, value)
+        self.command_queue.append(control_object)
+        log.debug("change_setting: queued %s", control_object)
+
+        # always process trigger_source commands promptly (can't wait for end of
+        # acquisition which may never come)
+        if (allow_immediate and self.immediate_mode) or re.search(r"trigger|laser", setting):
+            log.debug("immediately processing %s", control_object)
+            self.process_commands()
+
+    # override handle_requests. I didn't see a good way to overwrite change_setting without
+    # having to redo that pass through.
+    def handle_requests(self, requests: list[SpectrometerRequest]): # -> list[SpectrometerResponse] 
+        responses = []
+        for request in requests:
+            try:
+                cmd = request.cmd
+                proc_func = self.process_f.get(cmd, None)
+                if proc_func is None:
+                    try:
+                        self.change_setting(cmd, *request.args, **request.kwargs)
+                    except Exception as e:
+                        log.error(f"error {e} with trying to set setting {cmd} with args and kwargs {request.args} and {request.kwargs}")
+                        return []
+                elif request.args == [] and request.kwargs == {}:
+                    responses.append(proc_func())
+                else:
+                    responses.append(proc_func(*request.args, **request.kwargs))
+            except Exception as e:
+                log.error(f"error in handling request {request} of {e}")
+                responses.append(SpectrometerResponse(error_msg="error processing cmd", error_lvl=ErrorLevel.medium))
+        return responses
```

### Comparing `wasatch-2.1.35/wasatch/WasatchDeviceWrapper.py` & `wasatch-2.1.64/wasatch/WasatchDeviceWrapper.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,27 +1,17 @@
-import sys
-import pdb
 import time
 import random
 import logging
 import datetime
-import threading
 
 from queue import Queue
 
-from . import applog
-from . import utils
-
-from .SpectrometerSettings import SpectrometerSettings
 from .SpectrometerResponse import SpectrometerResponse
-from .SpectrometerResponse import ErrorLevel
 from .ControlObject        import ControlObject
 from .WrapperWorker        import WrapperWorker
-from .BLEDevice            import BLEDevice
-from .Reading              import Reading
 
 log = logging.getLogger(__name__)
 
 ##
 # Wrap WasatchDevice in a non-blocking interface run in a separate
 # thread, using multiprocess.pipes to exchange data (SpectrometerSettings,
 # Readings and StatusMessages) for multiprocessing-safe device communications
@@ -224,39 +214,30 @@
 
         # instantiate thread
         self.closing = False # needed if doing reset and closing previously was True
         self.wrapper_worker = WrapperWorker(
             device_id      = self.device_id,
             command_queue  = self.command_queue,  # Main --> child
             response_queue = self.response_queue, # Main <-- child \
-            settings_queue = self.settings_queue, # Main <-- child / consolidate into SpectrometerMessage?
-            message_queue  = self.message_queue,
+            settings_queue = self.settings_queue, # Main <-- child  | consolidate into 
+            message_queue  = self.message_queue,  # Main <-- child /  SpectrometerMessage?
             is_ocean       = self.is_ocean,
             is_andor       = self.is_andor,
             is_spi         = self.is_spi,
             is_ble         = self.is_ble)
         log.debug("device wrapper: Instance created for worker")
 
         self.wrapper_worker.daemon = True
         log.debug("deivce wrapper: Initiating wrapper thread")
 
         self.wrapper_worker.start()
 
-        # If something goes wrong, we won't want to kill the current thread (this
-        # function runs within MainProcess), but we will want to kill the spawned 
-        # child, and ensure 'self' (the current WasatchDeviceWrapper instance) is 
-        # ready for clean destruction (otherwise we'd be leaking resources 
-        # continuously).
-        kill_myself = False
-
         # expect to read a single post-initialization SpectrometerSettings object off the queue
         self.connect_start_time = datetime.datetime.now()
         self.settings = None
-        log.debug("connect: blocking on settings_queue (waiting on child thread to send SpectrometerSettings)")
-
         log.debug("connect: setup connection, returning to controller for settings polling")
 
         return True
 
     def poll_settings(self): # -> SpectrometerResponse 
         """ @returns SpectrometerResponse(True) on success, (False) otherwise """
         log.debug("polling device settings")
@@ -267,14 +248,15 @@
                 return SpectrometerResponse(False, error_msg="Failed to retrieve device settings")
 
             if result.data:
                 log.info(f"got spectrometer settings for device")
                 self.connected = True
                 self.settings = result.data
                 self.connect_start_time = datetime.datetime(year=datetime.MAXYEAR, month=1, day=1)
+                self.settings.state.dump("WasatchDeviceWrapper.poll_settings")
                 return SpectrometerResponse(True)
             else:
                 log.critical("got error response instead of settings from connection request")
                 return result
         else:
             log.debug("settings still not obtained, returning")
             return None
@@ -314,22 +296,22 @@
         if self.closing or not self.connected:
             return None
 
         if not self.message_queue.empty():
             return self.message_queue.get_nowait()
 
     ##
-    # This method is called by the Controller in MainProcess.  It checks
-    # the response_queue it shares with the child thread to see if any
-    # Reading objects have been queued from the spectrometer to the GUI.
-    #
-    # It is the upstream interface's job to decide how to process the
-    # potentially voluminous amount of data returned from the device.
-    # get_last by default will make sure the queue is cleared, then
-    # return the most recent reading from the device.
+    # This method is called by the Controller.  It checks the response_queue it 
+    # shares with the child thread to see if any Reading objects have been queued
+    # from the spectrometer to the GUI.
+    #
+    # It is the upstream interface's job to decide how to process the potentially
+    # voluminous amount of data returned from the device. get_last by default 
+    # will make sure the queue is cleared, then return the most recent reading 
+    # from the device.
     #
     # @note it is not clear that measurement modes other than
     #       ACQUISITION_MODE_KEEP_COMPLETE have been well-tested,
     #       especially in the context of multiple spectrometers,
     #       BatchCollection etc.
     def acquire_data(self, mode=None): # -> SpectrometerResponse 
         if self.closing or not self.connected:
@@ -459,8 +441,7 @@
             control_object = ControlObject(setting, value)
 
             self.command_queue.put(control_object)
 
             return
         except Exception as e:
             log.error(f"found an error of {e}")
-
```

### Comparing `wasatch-2.1.35/wasatch/WrapperWorker.py` & `wasatch-2.1.64/wasatch/WrapperWorker.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,18 +1,15 @@
 import threading
-import datetime
 import logging
 import time
 from queue import Queue
 
 from .SpectrometerResponse import SpectrometerResponse
 from .SpectrometerRequest  import SpectrometerRequest
-from .SpectrometerResponse import ErrorLevel
 from .WasatchDevice        import WasatchDevice
-from .ControlObject        import ControlObject
 from .AndorDevice          import AndorDevice
 from .OceanDevice          import OceanDevice
 from .SPIDevice            import SPIDevice
 from .BLEDevice            import BLEDevice
 from .Reading              import Reading
 
 log = logging.getLogger(__name__)
@@ -80,16 +77,16 @@
                     message_queue = self.message_queue)
             else:
                 log.debug(f"Couldn't recognize device of {self.device_id} {is_options}, trying to instantiate as WasatchDevice")
                 self.connected_device = device_classes[device_classes.index(WasatchDevice)](
                     device_id = self.device_id,
                     message_queue = self.message_queue)
         except:
-                log.critical("exception instantiating device", exc_info=1)
-                return self.settings_queue.put(None) 
+            log.critical("exception instantiating device", exc_info=1)
+            return self.settings_queue.put(None) 
 
         log.debug("calling connect")
         ok = False
         req = SpectrometerRequest("connect")
         try:
             (ok,) = self.connected_device.handle_requests([req])
         except:
@@ -105,24 +102,18 @@
         log.debug("successfully connected")
 
         # send the SpectrometerSettings back to the GUI thread
         log.debug("returning SpectrometerSettings to parent via SpectrometerResponse")
         self.settings_queue.put_nowait(SpectrometerResponse(self.connected_device.settings))
 
         log.debug("entering loop")
-        last_command = datetime.datetime.now()
-        min_thread_timeout_sec = 10
-        thread_timeout_sec = min_thread_timeout_sec
-
         received_poison_pill_command  = False # from ENLIGHTEN
-        received_poison_pill_response = False # from WasatchDevice
 
         num_connected_devices = 1
         while True:
-            now = datetime.datetime.now()
             dedupped = self.dedupe(self.command_queue)
 
             # apply dedupped commands
             if dedupped:
                 for record in dedupped:
                     if record is None:
                         # We have received a "poison pill" (shutdown command) 
@@ -136,30 +127,26 @@
                         # Do NOT put a 'break' here just yet -- if caller is in process of
                         # cleaning shutting things down, let them switch off the
                         # laser etc in due sequence.  We can break AFTER relaying
                         # applying the queued settings.
                     else:
                         log.debug("processing command queue: %s", record.setting)
 
-                        last_command = now
-
                         # basically, this simply moves each de-dupped command from
                         # WasatchDeviceWrapper.command_queue to WasatchDevice.command_queue,
                         # where it gets read during the next call to
                         # WasatchDevice.acquire_data.
                         if record.setting == "reset":
                             log.debug(f"calling reset from command queue")
                         req = SpectrometerRequest(record.setting, args=[record.value])
                         self.connected_device.handle_requests([req])
  
                         # peek in some settings locally
                         if record.setting == "num_connected_devices":
                             num_connected_devices = record.value
-                        elif record.setting == "subprocess_timeout_sec":
-                            thread_timeout_sec = record.value
 
             else:
                 log.debug("command queue empty")
 
             if received_poison_pill_command:
                 # ...NOW we can break
                 log.critical("exiting per command queue (poison pill received)")
@@ -177,35 +164,35 @@
                 # Note: this is a BLOCKING CALL.  If integration time is longer
                 # than subprocess_timeout_sec, this call itself will trigger
                 # shutdown.
                 log.debug("acquiring data")
                 req = SpectrometerRequest("acquire_data")
                 (reading_response,) = self.connected_device.handle_requests([req])
                 #log.debug("continuous_poll: acquire_data returned %s", str(reading))
-            except Exception as exc:
+            except:
                 log.critical("exception calling WasatchDevice.acquire_data", exc_info=1)
                 continue
             if not isinstance(reading_response, SpectrometerResponse):
                 log.error(f"Reading is not type ReadingResponse. Should not get naked responses. Happened with request {req}")
                 continue
             log.debug(f"response {reading_response} data is {reading_response.data}")
 
-            if reading_response.keep_alive == True:
+            if reading_response.keep_alive:
                 log.debug("worker is flowing up keep_alive")
                 self.response_queue.put(reading_response) 
 
             elif reading_response.error_msg != "":
-                if reading_response.data == None:
+                if reading_response.data is None:
                     reading_response.data = Reading()
                 self.response_queue.put(reading_response)
 
             elif reading_response.data is None:
                 log.debug("worker saw no reading (but not error, either)")
 
-            elif reading_response.data == False:
+            elif not reading_response.data:
                 log.critical(f"hardware level error...exiting because data False")
                 reading_response.poison_pill = True
                 self.response_queue.put(reading_response)
 
             elif reading_response.data.failure is not None:
                 log.critical(f"hardware level error...exiting because failure {reading_response.data.failure}")
                 reading_response.poison_pill = True
@@ -244,20 +231,15 @@
     def dedupe(self, q: Queue): # -> list[ControlObject] 
         keep = [] # list, not a set, because we want to keep it ordered
         while True:
             if not q.empty():
                 control_object = q.get_nowait() 
 
                 # treat None elements (poison pills) same as everything else
-                if control_object is None:
-                    setting = None
-                    value = None
-                else:
-                    setting = control_object.setting
-                    value = control_object.value
+                setting = None if control_object is None else control_object.setting
 
                 # remove previous setting if duplicate
                 new_keep = []
                 for co in keep:
                     if co.setting != setting:
                         new_keep.append(co)
                 keep = new_keep
```

### Comparing `wasatch-2.1.35/wasatch/applog.py` & `wasatch-2.1.64/wasatch/applog.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,179 +1,177 @@
-##
-# Custom logging setup and helper functions. 
-#
-# The general approach is that the control portion of the application 
-# instantiates a MainLogger object. This will create a separate process 
-# that looks for log events on a queue. Each process of the application then 
-# registers a queue handler, and writes its log events. The MainLogger loop 
-# will collect and write these log events to file and any other defined 
-# logging location.
-#
-# @see http://plumberjack.blogspot.com/2010/09/using-logging-with-multiprocessing.html
-#
-# The overall level of support for this file is basically "someone borrowed and
-# modified it from an open-source example on the internet, and it basically works
-# so I haven't putzed with it much" (except to try to understand when it breaks).
-#
-# @note on Windows, define PYTHONUTF8 environment variable to avoid error messages
-#       when log messages contain Unicode (default stdout/stderr streams are cp1252)
-
-import os
-import sys
-import queue            # for exception
-import logging
-import platform
-import traceback
-import multiprocessing
-from . import utils
-from queue import Queue
-
-# ##############################################################################
-#                                                                              #
-#                    Semi-static, module-level functions                       #
-#                                                                              #
-# ##############################################################################
-
-explicit_path = None     
-
-def set_location(path):
-    global explicit_path
-    explicit_path = path
-
-def get_location():
-    global explicit_path
-    if explicit_path is not None:
-        return explicit_path
-
-    module_name = __name__.replace(".", "_") # "wasatch.applog" -> "wasatch_applog"
-    filename = "%s.txt" % module_name        # "wasatch_applog.txt"
-
-    if "Linux" in platform.platform():
-        return filename
-
-    if "Darwin" in platform.system():
-        return filename
-
-    if "macOS" in platform.platform():
-        return filename
-
-    pathname = os.path.join("C:\\ProgramData", filename)
-    return pathname
-
-##
-# Called at the beginning of every subprocess, to tie into the existing
-# root logger (owned and created by the MainProcess).
-#
-# Adds a queue handler object to the root logger to be processed in the 
-# main listener.
-# 
-# Only on Windows though. Apparently Linux will pass the root logger 
-# amongst processes as expected, so if you add another queue handler you 
-# will get double log prints.
-#
-# Mimic the capturelog style of just slurping the entire log file contents.
-#
-# MZ: if we're just interested in the 'tail' of the log, this will be horribly
-# inefficient for memory as the log file grows!
-def get_text_from_log():
-    log_text = ""
-    with open(get_location()) as log_file:
-        # MZ: why not just 'return log_file.read()'?
-        for line_read in log_file:
-            log_text += line_read
-    return log_text
-
-def log_file_created():
-    return os.path.exists(get_location())
-
-## Remove the specified log file and return True if succesful.
-def delete_log_file_if_exists():
-    pathname = get_location()
-    if os.path.exists(pathname):
-        os.remove(pathname)
-    return not os.path.exists(pathname)
-
-def explicit_log_close():
-    root_log = logging.getLogger()
-    root_log.debug("applog.explicit_log_close: closing and removing all handlers")
-    handlers = root_log.handlers[:]
-    for handler in handlers:
-        handler.close()
-        root_log.removeHandler(handler)
-
-# ##############################################################################
-#                                                                              #
-#                                MainLogger                                    #
-#                                                                              #
-# ##############################################################################
-
-class MainLogger(object):
-    FORMAT = u'%(asctime)s [0x%(thread)08x] %(name)s %(levelname)-8s %(message)s'
-
-    def __init__(self, 
-            log_level=logging.DEBUG, 
-            enable_stdout=True,
-            logfile=None,
-            timeout_sec=5,
-            append_arg="True"):
-        self.log_queue     = Queue() 
-        self.log_level     = log_level
-        self.enable_stdout = enable_stdout
-        self.logfile       = logfile            
-        self.timeout_sec   = timeout_sec
-
-        if self.logfile is not None:
-            set_location(self.logfile)
-
-        # append file size limits are enforced upon program restart
-        if append_arg.lower() == "true":
-            # limit to 300mb if --log-append is explicitly set to "True"
-            append = True
-        if append_arg.lower() == "false":
-            # when append is a falsy value, the log file is always reset on reboot
-            append = False
-        if append_arg.lower() == "limit":
-            # the default --log-append keeps up to 2mb between sessions
-            append = 2*1024*1024
-
-        root_log = logging.getLogger()
-        self.log_configurer(self.logfile, append)
-        root_log.setLevel(self.log_level)
-        root_log.warning("Top level log configuration (%d handlers, get_location %s)", len(root_log.handlers), get_location())
-
-    ## Setup file handler and command window stream handlers. Every log
-    #  message received on the queue handler will use these log configurers. 
-    def log_configurer(self, logfile=None, append=False):
-        if logfile is not None:
-            pathname = logfile
-        elif self.logfile is not None:
-            pathname = self.logfile
-        else:
-            pathname = get_location()
-
-        try:
-            if type(append) == int:
-                utils.resize_file(path=pathname, nbytes=append)
-        except (IOError, FileNotFoundError):
-            print("Unable to truncate log file.")
-
-        root_logger = logging.getLogger()
-        fh = logging.FileHandler(pathname, mode='a' if append else 'w', encoding='utf-8') 
-        formatter = logging.Formatter(self.FORMAT)
-        fh.setFormatter(formatter)
-        root_logger.addHandler(fh) 
-
-        if self.enable_stdout:
-            stream_handler = logging.StreamHandler(sys.stdout)
-            stream_handler.setFormatter(formatter)
-            root_logger.addHandler(stream_handler)
-
-        self.root = root_logger
-
-    ## Wrapper to add a None poison pill to the listener process queue to
-    #  ensure it exits. 
-    def close(self):
-        self.log_queue.put_nowait(None)
-        try:
-            self.listener.join()
-        except:
-            pass
+##
+# Custom logging setup and helper functions. 
+#
+# The general approach is that the control portion of the application 
+# instantiates a MainLogger object. This will create a separate process 
+# that looks for log events on a queue. Each process of the application then 
+# registers a queue handler, and writes its log events. The MainLogger loop 
+# will collect and write these log events to file and any other defined 
+# logging location.
+#
+# @see http://plumberjack.blogspot.com/2010/09/using-logging-with-multiprocessing.html
+#
+# The overall level of support for this file is basically "someone borrowed and
+# modified it from an open-source example on the internet, and it basically works
+# so I haven't putzed with it much" (except to try to understand when it breaks).
+#
+# @note on Windows, define PYTHONUTF8 environment variable to avoid error messages
+#       when log messages contain Unicode (default stdout/stderr streams are cp1252)
+
+import os
+import sys
+import logging
+import platform
+from . import utils
+from queue import Queue
+
+# ##############################################################################
+#                                                                              #
+#                    Semi-static, module-level functions                       #
+#                                                                              #
+# ##############################################################################
+
+explicit_path = None     
+
+def set_location(path):
+    global explicit_path
+    explicit_path = path
+
+def get_location():
+    global explicit_path
+    if explicit_path is not None:
+        return explicit_path
+
+    module_name = __name__.replace(".", "_") # "wasatch.applog" -> "wasatch_applog"
+    filename = "%s.txt" % module_name        # "wasatch_applog.txt"
+
+    if "Linux" in platform.platform():
+        return filename
+
+    if "Darwin" in platform.system():
+        return filename
+
+    if "macOS" in platform.platform():
+        return filename
+
+    pathname = os.path.join("C:\\ProgramData", filename)
+    return pathname
+
+##
+# Called at the beginning of every subprocess, to tie into the existing
+# root logger (owned and created by the MainProcess).
+#
+# Adds a queue handler object to the root logger to be processed in the 
+# main listener.
+# 
+# Only on Windows though. Apparently Linux will pass the root logger 
+# amongst processes as expected, so if you add another queue handler you 
+# will get double log prints.
+#
+# Mimic the capturelog style of just slurping the entire log file contents.
+#
+# MZ: if we're just interested in the 'tail' of the log, this will be horribly
+# inefficient for memory as the log file grows!
+def get_text_from_log():
+    log_text = ""
+    with open(get_location()) as log_file:
+        # MZ: why not just 'return log_file.read()'?
+        for line_read in log_file:
+            log_text += line_read
+    return log_text
+
+def log_file_created():
+    return os.path.exists(get_location())
+
+## Remove the specified log file and return True if succesful.
+def delete_log_file_if_exists():
+    pathname = get_location()
+    if os.path.exists(pathname):
+        os.remove(pathname)
+    return not os.path.exists(pathname)
+
+def explicit_log_close():
+    root_log = logging.getLogger()
+    root_log.debug("applog.explicit_log_close: closing and removing all handlers")
+    handlers = root_log.handlers[:]
+    for handler in handlers:
+        handler.close()
+        root_log.removeHandler(handler)
+
+# ##############################################################################
+#                                                                              #
+#                                MainLogger                                    #
+#                                                                              #
+# ##############################################################################
+
+class MainLogger:
+    FORMAT = u'%(asctime)s [0x%(thread)08x] %(name)s %(levelname)-8s %(message)s'
+
+    def __init__(self, 
+            log_level=logging.DEBUG, 
+            enable_stdout=True,
+            logfile=None,
+            timeout_sec=5,
+            append_arg="True"):
+        self.log_queue     = Queue() 
+        self.log_level     = log_level
+        self.enable_stdout = enable_stdout
+        self.logfile       = logfile            
+        self.timeout_sec   = timeout_sec
+
+        if self.logfile is not None:
+            set_location(self.logfile)
+
+        # append file size limits are enforced upon program restart
+        if append_arg.lower() == "true":
+            # limit to 300mb if --log-append is explicitly set to "True"
+            append = True
+        if append_arg.lower() == "false":
+            # when append is a falsy value, the log file is always reset on reboot
+            append = False
+        if append_arg.lower() == "limit":
+            # the default --log-append keeps up to 2mb between sessions
+            append = 2*1024*1024
+
+        root_log = logging.getLogger()
+        self.log_configurer(self.logfile, append)
+        root_log.setLevel(self.log_level)
+        root_log.warning("Top level log configuration (%d handlers, get_location %s)", len(root_log.handlers), get_location())
+
+    ## Setup file handler and command window stream handlers. Every log
+    #  message received on the queue handler will use these log configurers. 
+    def log_configurer(self, logfile=None, append=False):
+        if logfile is not None:
+            pathname = logfile
+        elif self.logfile is not None:
+            pathname = self.logfile
+        else:
+            pathname = get_location()
+
+        try:
+            if isinstance(append, int):
+                utils.resize_file(path=pathname, nbytes=append)
+        except (IOError, FileNotFoundError):
+            print("Unable to truncate log file.")
+
+        root_logger = logging.getLogger()
+        fh = logging.FileHandler(pathname, mode='a' if append else 'w', encoding='utf-8') 
+        formatter = logging.Formatter(self.FORMAT)
+        fh.setFormatter(formatter)
+        root_logger.addHandler(fh) 
+
+        if self.enable_stdout:
+            sys.stdout.reconfigure(encoding='utf-8')
+            stream_handler = logging.StreamHandler(sys.stdout)
+            stream_handler.setFormatter(formatter)
+            root_logger.addHandler(stream_handler)
+
+        self.root = root_logger
+
+    ## Wrapper to add a None poison pill to the listener process queue to
+    #  ensure it exits. 
+    def close(self):
+        self.log_queue.put_nowait(None)
+        try:
+            self.listener.join()
+        except:
+            pass
```

### Comparing `wasatch-2.1.35/wasatch/simulation_protocol.py` & `wasatch-2.1.64/wasatch/simulation_protocol.py`

 * *Files 1% similar despite different names*

```diff
@@ -16,15 +16,15 @@
 # Read recorded spectrum from file, respond with noise on the
 # baseline read from file. Default spectrum is pure noise from numpy.
 # When the laser is on, it's the IPA csv entry (0). This is designed
 # to simulate a vial of IPA in a holder. Changing the integration time
 # scales just the noise on the spectrum. A integration time of 1 has
 # 1-10k counts of noise. An integration time of 10k has 0-1 counts of
 # noise. 
-class SimulateMaterial(object):
+class SimulateMaterial:
 
     def __init__(self):
         super(SimulateMaterial, self).__init__()
         log.debug("%s setup", self.__class__.__name__)
 
         self.serial_number = "SIM-512"
         self.software_code = "SIM.0.0.1"
@@ -69,15 +69,15 @@
         self.degC_to_dac_coeff_1 = self.original_degC_to_dac_coeff_1
         self.degC_to_dac_coeff_2 = self.original_degC_to_dac_coeff_2
 
         self.model = "785"
         # Set default to zero bad pixels which is a list of -1's of
         # length 15
         self.bad_pixels = []
-        for pixel in range(15):
+        for _ in range(15):
             self.bad_pixels.append(-1)
 
     ## Return the spectrum read from file. Add the noise. 
     def read(self):
         randint = numpy.random.randint
         temp_data = randint(low=0, high=self.noise_level, size=self.pixels)
 
@@ -149,34 +149,31 @@
     ##
     # Apparently MS windows keeps some portion of the dictreader
     # in place that prevents a clean exit in multiprocessing
     # applications. This will only manifest when attempting to close
     # the enlighten software. The temporary fix here is to load the
     # file directly from disk, and manually slice the data required. 
     def load_raw_data(self, filename=None):
-        if filename == None:
+        if filename is None:
             filename = "enlighten/assets/example_data/"
             filename += "Spectra_093016_785L_192.csv"
 
         log.info("Raw data load file: %s", filename)
-
-    csv_data = []
-    line_count = 0
-    with open(filename, "r") as csv_file:
-        for line_data in csv_file:
-
-            if line_count > 1:
-            line_data = line_data.replace('"','')
-                commas = [x.strip() for x in line_data.split(",")]
-                ints = [int(x.strip()) for x in commas[17:]]
-                csv_data.append(ints)
-                #log.info("Strip: %s", csv_data)
-        line_count += 1
-
-    return csv_data
+        csv_data = []
+        line_count = 0
+        with open(filename, "r") as csv_file:
+            for line_data in csv_file:
+                if line_count > 1:
+                    line_data = line_data.replace('"','')
+                    commas = [x.strip() for x in line_data.split(",")]
+                    ints = [int(x.strip()) for x in commas[17:]]
+                    csv_data.append(ints)
+                    #log.info("Strip: %s", csv_data)
+            line_count += 1
+        return csv_data
 
     ## Placeholder to log disconnect event. 
     def disconnect(self):
         log.info("Disconnect")
         return True
 
     def get_serial_number(self):
```

### Comparing `wasatch-2.1.35/wasatch/utils.py` & `wasatch-2.1.64/wasatch/utils.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,675 +1,700 @@
-# ##############################################################################
-#                                                                              #
-#                                   utils.py                                   #
-#                                                                              #
-# ##############################################################################
-
-import numpy
-import math
-
-import json
-import re
-
-import os
-import shutil
-import logging
-
-import datetime
-import ctypes
-
-log = logging.getLogger(__name__)
-
-# see https://stackoverflow.com/questions/1026431/cross-platform-way-to-check-admin-rights-in-a-python-script-under-windows
-def check_admin():
-    try:
-        is_admin = os.getuid() == 0
-    except AttributeError:
-        is_admin = ctypes.windll.shell32.IsUserAnAdmin() != 0
-    return is_admin
-
-## convert unicode string to ascii
-def remove_unicode(s):
-    if isinstance(s, str):
-        return s.encode('ascii', 'ignore')
-    return s
-
-def pixel_to_wavelength(x: int, coeffs: list[float]): # -> float 
-    wavelength = 0.0
-    log.debug(f"converting pixel {x} to wavelen with coeffs {coeffs}")
-    for i in range(len(coeffs)):
-        wavelength += coeffs[i] * pow(x, i)
-    return wavelength
-
-## expand 3rd-order wavelength polynomial into array of wavelengths
-def generate_wavelengths(pixels, coeffs):
-    if coeffs is None or pixels == 0:
-        return None
-
-    wavelengths = []
-    for x in range(pixels):
-        wavelength = 0.0
-        for i in range(len(coeffs)):
-            wavelength += coeffs[i] * pow(x, i)
-        wavelengths.append(wavelength)
-    return wavelengths            
-
-def generate_wavelengths_from_wavenumbers(excitation, wavenumbers):
-    return [1.0 / ((1.0 / excitation) - (wavenumber * 1e-7)) for wavenumber in wavenumbers]
-
-## convert wavelengths into Raman shifts in 1/cm wavenumbers from the given 
-#  excitation wavelength
-def generate_wavenumbers(excitation, wavelengths, wavenumber_correction=0):
-    wavenumbers = []
-    if not wavelengths or excitation < 1:
-        return wavenumbers
-
-    base = 1e7 / float(excitation)
-    for i in range(len(wavelengths)):
-        wavenumber = 0
-        if wavelengths[i] != 0:
-            wavenumber = base - 1e7 / wavelengths[i]
-        wavenumbers.append(wavenumber + wavenumber_correction)
-    return wavenumbers
-
-## convert a single wavelength to wavenumber
-def wavelength_to_wavenumber(wavelength, excitation):
-    return 1e7 / float(excitation) - 1e7 / wavelength
-
-## convert a single (uncorrected) wavenumber to wavelength
-def wavenumber_to_wavelength(excitation, wavenumber):
-    return 1.0 / ((1.0 / excitation) - (wavenumber * 1e-7)) 
-
-##
-# If we've loaded a CSV that had wavelength and wavenumber columns, but no
-# metadata, use this to infer the excitation wavelength.  Useful for 
-# interpolation.
-def generate_excitation(wavelengths, wavenumbers):
-    if wavelengths is None or wavenumbers is None or len(wavelengths) != len(wavenumbers) or len(wavelengths) < 1:
-        return None
-
-    total = 0.0
-    count = len(wavelengths)
-    for i in range(count):
-        excitation = 1e7 / (wavenumbers[i] + 1e7/wavelength[i])
-        total += excitation
-    return total / count
-
-##
-# apply a boxcar convolution of the given half_width to input array 'a'
-def apply_boxcar(a, half_width):
-    out = []
-    for i in range(len(a)):
-        # hw is smaller than half_width near the fringes
-        hw = min(i, half_width, len(a)-1-i)
-        # each pixel is the mean of itself and `hw` pixels to the left and right
-        out.append(sum(a[i-hw:i+hw+1]) / (2*hw+1))
-    return out
-
-## similar to Perl's Data::Dumper
-def dump(foo, indent=0):
-    spc  = '  ' * indent
-    spc1 = '  ' * (indent + 1)
-    s = ""
-
-    if isinstance(foo, dict):
-        s += spc + '{\n'
-        for key,val in foo.items():
-            if isinstance(val, (dict, list, tuple)):
-                s += spc1 + str(key) + '=>\n'
-                s += dump(val, indent+2)
-            else:
-                s += spc1 + str(key) + '=> ' + str(val)
-        s += spc + '}\n'
-
-    elif isinstance(foo, list):
-        s += spc + '[\n'
-        for item in foo:
-            s += dump(item, indent+1)
-        s += spc + ']\n'
-
-    elif isinstance(foo, tuple):
-        s += spc + '(\n'
-        for item in foo:
-            s += dump(item, indent+1)
-        s += spc + ')\n'
-
-    else: 
-        s += spc + str(foo)
-
-    return s
-
-## given a destination object and a source dictionary, update any existing 
-#  attributes of the destination object from like-named keys in the source 
-#  dictionary
-#
-# @param obj (In/Out) the object whose attributes to update
-# @param d   (Input)  the dictionary whose keys should be treated as attributes
-def update_obj_from_dict(obj, d):
-    if obj is None or d is None:
-        return
-    for k in sorted(obj.__dict__.keys()):
-        v = dict_get_norm(d, k)
-        if v is not None:
-            # log.debug("%s -> %s", k, v)
-            setattr(obj, k, v)
-
-##
-# Similar to dict.get(), but case-insensitive and normalizes-out spaces, 
-# underscores, periods and hyphens.
-#
-# @param d (input) dictionary
-# @param k (input) case-insensitive key (can be prioritized list)
-#
-# Note that this function does not distiguish between the dictionary not having
-# a key, and the value of the key being None.
-def dict_get_norm(d, keys):
-
-    # if we weren't passed a list, make it one
-    if not isinstance(keys, list):
-        keys = [ keys ]
-
-    try:
-        pat = r"[ ._-]"
-        for key in keys:
-            key = re.sub(pat, "", key).lower()
-            for k, v in d.items():
-                k = re.sub(pat, "", k).lower()
-                if k == key:
-                    return v
-    except:
-        log.error("dict_get_norm: %s", keys, exc_info=1)
-        return
-
-##
-# Similar to dict.get(), but takes a list of keys to be traversed in sequence.
-#
-# @param d    (input) dictionary
-# @param keys (input) list of case-insensitive keys
-def dict_get_path(d, keys):
-    try:
-        while len(keys) > 0:
-            k = keys.pop(0)
-            v = dict_get_norm(d, k)
-            if v is None:
-                return
-            elif len(keys) == 0:
-                return v
-            else:
-                d = v
-    except:
-        return
-
-## convenience wrapper to load a JSON file
-def load_json(pathname):
-    try:
-        with open(pathname) as infile:
-            return json.load(infile)
-    except:
-        log.error("unable to load %s", pathname, exc_info=1)
-
-## iterate down a directory, returning pathnames that match the given pattern
-def get_pathnames_from_directory(rootdir, pattern=None, recursive=False):
-    pathnames = []
-    # log.debug("searching %s matching %s with recursive %s", rootdir, pattern, recursive)
-    if recursive:
-        for (directory, dirnames, filenames) in walk(rootdir):
-            for filename in filenames:
-                pathname = os.path.join(directory, filename)
-                if pattern:
-                    if re.search(pattern, filename):
-                        pathnames.append(pathname)
-                    else:
-                        # log.debug("%s does not match %s", pathname, pattern)
-                        pass
-                else:
-                    pathnames.append(pathname)
-    elif os.path.isdir(rootdir):
-        for filename in os.listdir(rootdir):
-            pathname = os.path.join(rootdir, filename)
-            if os.path.isfile(pathname):
-                if pattern:
-                    if re.search(pattern, filename):
-                        pathnames.append(pathname)
-                    else:
-                        # log.debug("%s does not match %s", pathname, pattern)
-                        pass
-                else:
-                    pathnames.append(pathname)
-    # log.debug("returning %s", pathnames)
-    return pathnames
-
-##
-# Given a spectrum (array 'a'), with an x_axis, a 'center' along that x_axis, and
-# an allowed 'tolerance' (in same units as the x_axis), find the local maxima
-# within 'tolerance' of 'center'.
-#
-# @note probably a numpy shortcut for this
-def find_local_maxima(a, x_axis, center, tolerance=0):
-    # log.debug("find_local_maxima: center %.2f (tolerance %.2f)", center, tolerance)
-    # generate subset of array within tolerance of center
-    x = []
-    y = []
-    indices = []
-    for i in range(len(x_axis)):
-        x_value = x_axis[i]
-        if center - tolerance <= x_value <= center + tolerance:
-            indices.append(i)
-            x.append(x_value)
-            y.append(a[i])
-
-    # log.debug("  range x: %s", x)
-    # log.debug("  range y: %s", y)
-    
-    if not x:
-        raise "no points within %s of %s"
-
-    # find maxima within subset
-    best_x_index = indices[0]
-    best_x_value = x_axis[0]
-    best_y_value = y[0]
-    for i in range(len(x)):
-        if best_y_value < y[i]:
-            best_x_index = indices[i]
-            best_x_value = x_axis[best_x_index]
-            best_y_value = y[i]
-
-    # no point with linear interpolation, as it would only go "down"
-    # (could do Gaussian / polynomial fit)
-
-    # log.debug("  best_x_index: %d", best_x_index)
-    # log.debug("  best_x_value: %.2f", best_x_value)
-    # log.debug("  best_y_value: %.2f", best_y_value)
-
-    return (best_y_value, best_x_value, best_x_index)
-
-##
-# Given a spectrum and an x_axis, find the indexes of the left and right
-# 'feet' of the peak centered on x_index.  Internally apply then given boxcar
-# for added smoothing.
-def find_peak_feet_indices(spectrum, x_axis, x_index, boxcar_half_width=0):
-    if boxcar_half_width:
-        smoothed = apply_boxcar(spectrum, boxcar_half_width)
-    else:
-        smoothed = spectrum
-
-    left_index = x_index
-    for i in range(x_index - (boxcar_half_width + 1), -1, -1):
-        if i == 0 or smoothed[i] > smoothed[left_index]:
-            break
-        left_index = i
-
-    right_index = x_index
-    for i in range(x_index + (boxcar_half_width + 1), len(spectrum)):
-        if i + 1 == len(spectrum) or smoothed[i] > smoothed[right_index]:
-            break
-        right_index = i
-
-    return (left_index, right_index)
-
-## integrate the 'area under the curve' for the given spectrum and x_axis,
-#  using the peak centered on x_axis, with optional smoothing given the
-#  boxcar width.
-def area_under_peak(spectrum, x_axis, x_index, boxcar_half_width=0):
-    # find left and right "feet" of the peak
-    (left_index, right_index) = find_peak_feet_indices(
-        spectrum, x_axis, x_index, boxcar_half_width)
-
-    # generate baseline-subtracted subspectrum of just the peak, considering
-    #    the baseline to be a straight line between the two feet
-    slope = float(spectrum[right_index] - spectrum[left_index]) / \
-                   (x_axis[right_index] - x_axis[left_index])
-    subspectrum = []
-    subaxis = []
-    for i in range (left_index, right_index + 1):
-        baseline = spectrum[left_index] + slope * (x_axis[i] - x_axis[left_index])
-        subspectrum.append(spectrum[i] - baseline)
-        subaxis.append(x_axis[i])
-
-    # 4. integrate subspectrum
-    area = numpy.trapz(subspectrum, subaxis)
-    return area
-
-def peak_height_above_background(spectrum, x_axis, x_index, boxcar_half_width=0):
-    # find left and right "feet" of the peak
-    (left_index, right_index) = find_peak_feet_indices(
-        spectrum, x_axis, x_index, boxcar_half_width)
-
-    width_wn = x_axis[right_index] - x_axis[left_index]
-    width_px = right_index - left_index + 1
-
-    # generate baseline-subtracted subspectrum of just the peak, considering
-    #    the baseline to be a straight line between the two feet
-    slope = float(spectrum[right_index] - spectrum[left_index]) / width_wn
-    baseline = spectrum[left_index] + slope * (x_axis[x_index] - x_axis[left_index])
-    height = spectrum[x_index] - baseline
-
-    log.debug("peak_height_above_background: peak at x_index %d (boxcar %d)", x_index, boxcar_half_width)
-    log.debug("peak_height_above_background:   abs height: %.2f", spectrum[x_index])
-    log.debug("peak_height_above_background:   peak width: (%d px, %.2f cm-1)", width_px, width_wn)
-    log.debug("peak_height_above_background:   feet: (%d, %d)", left_index, right_index)
-    log.debug("peak_height_above_background:   feet height: (%.2f, %.2f)", spectrum[left_index], spectrum[right_index])
-    log.debug("peak_height_above_background:   slope: %.2f", slope)
-    log.debug("peak_height_above_background:   peak baseline: %.2f", baseline)
-    log.debug("peak_height_above_background:   relative height: %.2f", height)
-
-    return (height, width_wn, width_px)
-
-def find_nearest_index(L, value):
-    a = numpy.asarray(L)
-    return (numpy.abs(a - value)).argmin()
-    
-def find_nearest_value(L, value):
-    i = find_nearest_index(L, value)
-    return L[i]
-
-## 
-# Interpolate the passed spectrum over a fixed x-axis (e.g. integral wavelengths
-# or wavenumbers).
-def interpolate_array(spectrum, old_axis, new_axis):
-    if not spectrum or not old_axis or not new_axis or len(spectrum) != len(old_axis) or len(new_axis) < 1:
-        return 
-    return numpy.interp(new_axis, old_axis, spectrum)
-
-## I might be making this more difficult than it needs to be
-def interpolate_value(spectrum, old_axis, x):
-    if not spectrum or not old_axis or not new_axis or len(spectrum) != len(old_axis) or len(new_axis) < 1:
-        return 
-    new_axis = [ x-1, x, x+1 ] 
-    new_y = numpy.interp(new_axis, old_axis, spectrum)
-    if new_y is not None and len(new_y) == len(new_axis):
-        return new_y[1]
-
-## render a spectrum as ASCII-art
-def ascii_spectrum(spectrum, rows, cols, x_axis, x_unit):
-    spectral_min = min(spectrum)
-    spectral_max = max(spectrum)
-    spectral_avg = 1.0 * sum(spectrum) / len(spectrum)
-
-    # histogram into bins
-    bins = [0] * cols
-    for i in range(len(spectrum)):
-        col = int(1.0 * cols * i / len(spectrum))
-        bins[col] += spectrum[i] - spectral_min
-
-    # render histogram
-    lines = []
-    bin_hi = max(bins)
-    for row in range(rows - 1, -1, -1):
-        s = "| "
-        for col in range(cols):
-            s += "*" if bins[col] >= (1.0 * row / rows) * bin_hi else " "
-        lines.append(s)
-
-    # graph footer
-    lines.append("+-" + "-" * cols)
-    lines.append("  Min: %8.2f  Max: %8.2f  Mean: %8.2f  (range %.2f, %.2f%s)" % (
-        spectral_min, spectral_max, spectral_avg, 
-        x_axis[0], x_axis[-1], x_unit))
-
-    return lines
-
-def timestamp():
-    return datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
-
-def truthy(flag):
-    if flag is None:
-        return False
-
-    try:
-        if len(flag) > 0:
-            return True
-    except:
-        pass
-
-    return True if flag else False
-
-def clean_nan(a):
-    for i in range(len(a)):
-        if math.isnan(a[i]):
-            a[i] = 0
-
-## 
-# Can be used as a sanity-check for any set of coefficients.
-#
-# Checks that coeffs:
-#
-# - are not None
-# - have no NaN
-# - are not all the same (zeros, -1 etc)
-# - are not [0, 1, 0, 0]
-# - checks count if provided
-def coeffs_look_valid(coeffs, count=None):
-
-    if coeffs is None:
-        log.debug("no coeffs, returning False")
-        return False
-
-    if count is not None and len(coeffs) != count:
-        log.debug("coeff count is wrong, returning False")
-        return False
-
-    # check for NaN
-    for i in range(len(coeffs)):
-        if math.isnan(coeffs[i]):
-            log.debug("found NaN in coeff, returning False")
-            return False 
-
-    # check for [0, 1, 0...] default pattern
-    all_default = True
-    for i in range(len(coeffs)):
-        if i == 1:
-            if coeffs[i] != 1.0:
-                all_default = False
-        elif coeffs[i] != 0.0:
-            all_default = False
-    if all_default:
-        log.debug("coeffs all default, returning False")
-        return False
-
-    # check for constants (all coefficients the same value)
-    all_const = True
-    log.info(coeffs)
-    for i in range(1, len(coeffs)):
-        if coeffs[0] != coeffs[i]:
-            all_const = False
-    if all_const:
-        log.debug("coeffs all const, returning False")
-        return False
-
-    return True
-
-## 
-# "Stomps" the first "count" elements with the first non-stomped value.
-#
-# @param a     (Input) array to modify
-# @param count (Input) HOW MANY leading elements to stomp, so the index of the
-#              first GOOD pixel should be one more than this
-def stomp_first(a, count):
-    for i in range(count):
-        a[i] = a[count]
-
-## "stomps" the last "count" elements with the last non-stomped value
-def stomp_last(a, count):
-    for i in range(count):
-        a[-(i+1)] = a[-(count+1)]
-
-def clamp_to_int16(n):
-    return max(-32768, min(32767, int(n)))
-
-##
-# Given an array of doubles and a peak index, use the peak and its two
-# neighbors to form a parabola and return the interpolated maximum height of the
-# parabola.
-#
-# "pixel" is ideally the array index of the pinnacle of a previously-
-# identified peak within the spectrum, although though this will 
-# technically generate a parabola through any pixel and its two 
-# neighbors.
-#
-# @param pixel  index of a point on the spectrum
-# @param x      x-axis (wavelengths or wavenumbers)
-# @param y      y-axis (intensity)
-#
-# @see https://stackoverflow.com/a/717833
-#
-# @returns a point representing the interpolated vertex of a parabola drawn 
-#          through the specified pixel and its two neighbors (in x-axis space)
-#
-def parabolic_approximation(pixel, x, y):
-    if len(x) != len(y):
-        log.error("parabolic approximation array lengths differ")
-        return 0, 0
-    if pixel - 1 < 0:
-        return y[0]
-    elif pixel + 1 >= len(y):
-        return y[-1]
-
-    x1 = pixel - 1
-    x2 = pixel
-    x3 = pixel + 1
-
-    y1 = y[x1]
-    y2 = y[x2]
-    y3 = y[x3]
-
-    if y1 >= y2 or y3 >= y2:
-        log.debug("parabolic approximation: peak misformed or saturated")
-
-    denom = (x1 - x2) * (x1 - x3) * (x2 - x3)
-    A = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / denom
-    B = (x3 * x3 * (y1 - y2) + x2 * x2 * (y3 - y1) + x1 * x1 * (y2 - y3)) / denom
-    C = (x2 * x3 * (x2 - x3) * y1 + x3 * x1 * (x3 - x1) * y2 + x1 * x2 * (x1 - x2) * y3) / denom
-
-    vertex_x = -B / (2 * A) # pixel space
-    vertex_y = C - B * B / (4 * A)
-
-    if vertex_x < x1 or vertex_x > x3:
-        log.error("parabolic approximation failed (x exceeded limits)")
-        return (0, 0)
-
-    if vertex_x == x2:
-        return (x[x2], vertex_y)
-    elif vertex_x < x2:
-        left = x1
-        right = x2
-    else:
-        left = x2
-        right = x3
-    x_coord = x[left] + (x[right] - x[left]) * (vertex_x - left)
-
-    log.debug("parabolic approximation: x1 %d, x2 %d, x3 %d", x1, x2, x3)
-    log.debug("parabolic approximation: x.x1 %.2f, x.x2 %.2f, x.x3 %.2f", x[x1], x[x2], x[x3])
-    log.debug("parabolic approximation: y.x1 %.2f, y.x2 %.2f, y.x3 %.2f", y[x1], y[x2], y[x3])
-    log.debug("parabolic approximation: vertex_x %.2f, vertex_y %.2f", vertex_x, vertex_y)
-    log.debug("parabolic approximation: left %d, right %d", left, right)
-    log.debug("parabolic approximation: x.left %.2f, x.right %.2f", x[left], x[right])
-    log.debug("parabolic approximation: x.coord %.2f", x_coord)
-
-    return (x_coord, vertex_y)
-
-##
-# @see https://stackoverflow.com/a/9147327/6436775
-def twos_complement(val, bits):
-    if (val & (1 << (bits - 1))) != 0: # if sign bit is set e.g., 8bit: 128-255
-        val = val - (1 << bits)        # compute negative value
-    return val    
-
-def to_bool(value):
-    if isinstance(value, bool):
-        return value
-    elif isinstance(value, int):
-        return 0 != value
-    elif isinstance(value, float):
-        return 0 != value
-    elif isinstance(value, str):
-        s = value.lower().strip()
-        return s in ['true', 'y', 'yes', 'on', '1']
-    return False
-
-def uint16_to_little_endian(values):
-    a = []
-    for n in values:
-        a.append(n & 0xff)          # lsb
-        a.append((n >> 8) & 0xff)   # msb
-    return a
-
-def resize_file(path, nbytes, ensure_no_overwrite=False):
-    """
-    Keep only the last `nbytes` of a text file specified by `path`.
-
-    This function is encoding (utf-8, utf-16, ascii) agnostic because it uses the line-
-    continuation character '\n' as a boundary. It is system independent because it slices
-    before that character. This was written to keep our default log file within a reasonable
-    filesize, suitable for emailing.
-
-    Call this on a file that is not yet opened. Expect the file to be closed and flushed
-    by the time the function returns.
-
-    returns True if the file was changed.
-    """
-
-    # limit how much memory is used to copy file contents
-    # NOTE: this NOT the filesize limit, that is passed in via nbytes
-    # see applog.py's call of resize_file for the log file limit
-    MAX_BYTES_MEMORY = 2_000_000
-
-    START_OF_STREAM = 0 # seek from start of a file
-    CURRENT_STREAM = 1 # seek from current location in file
-    END_OF_STREAM = 2 # seek from end of file, offset should be negative
-
-    # open file with the intention of reading bytes, preserving what's there
-    f = open(path, "rb")
-
-    # path to temporary file
-    tpath = path+".temp"
-
-    # don't overwrite any local files
-    # defaults to false so we don't err on the side of a bunch of extra .temp files
-    if ensure_no_overwrite:
-        while os.path.exists(tpath):
-            tpath += ".temp"
-
-    f2 = open(tpath, "wb")
-
-    # fast-forward to end of file and keep track of total_bytes
-    tbytes = f.seek(0, END_OF_STREAM)
-
-    if tbytes <= nbytes:
-        # don't do anything if file is already smaller than target size
-        f2.close()
-        os.remove(tpath)
-        return False
-
-    # go to nbytes from the end
-    f.seek(-nbytes, END_OF_STREAM)
-
-    # seek to a newline
-    for i in range(500):
-        if f.read(1) == b'\n':
-            break
-
-    # make sure to land before the newline
-    t_start = f.seek(-1, CURRENT_STREAM)
-
-    # decrease nbytes by the amount we skipped forward (usually small)
-    nbytes = tbytes-t_start
-
-    # copy the end of the file into the beginning of a temporary one
-    f.seek(t_start, START_OF_STREAM)
-    i = nbytes
-    while i:
-        block_size = min(MAX_BYTES_MEMORY, i)
-
-        b = f.read(block_size)
-        f2.write(b)
-        i -= block_size
-
-    # wrap up resource use
-    f.close()
-    f2.flush()
-    f2.close()
-
-    # move temporary file in place
-    shutil.move(tpath, path)
-
-    return True
+# ##############################################################################
+#                                                                              #
+#                                   utils.py                                   #
+#                                                                              #
+# ##############################################################################
+
+import numpy
+import math
+
+import json
+import re
+
+import os
+import shutil
+import logging
+
+import datetime
+import ctypes
+
+log = logging.getLogger(__name__)
+
+# see https://stackoverflow.com/questions/1026431/cross-platform-way-to-check-admin-rights-in-a-python-script-under-windows
+def check_admin():
+    try:
+        is_admin = os.getuid() == 0
+    except AttributeError:
+        is_admin = ctypes.windll.shell32.IsUserAnAdmin() != 0
+    return is_admin
+
+## convert unicode string to ascii
+def remove_unicode(s):
+    if isinstance(s, str):
+        return s.encode('ascii', 'ignore')
+    return s
+
+def pixel_to_wavelength(x: int, coeffs: list[float]): # -> float 
+    wavelength = 0.0
+    log.debug(f"converting pixel {x} to wavelen with coeffs {coeffs}")
+    for i in range(len(coeffs)):
+        wavelength += coeffs[i] * pow(x, i)
+    return wavelength
+
+## expand 3rd-order wavelength polynomial into array of wavelengths
+def generate_wavelengths(pixels, coeffs):
+    if coeffs is None or pixels == 0:
+        return None
+
+    wavelengths = []
+    for x in range(pixels):
+        wavelength = 0.0
+        for i in range(len(coeffs)):
+            wavelength += coeffs[i] * pow(x, i)
+        wavelengths.append(wavelength)
+    return wavelengths            
+
+def generate_wavelengths_from_wavenumbers(excitation, wavenumbers):
+    return [1.0 / ((1.0 / excitation) - (wavenumber * 1e-7)) for wavenumber in wavenumbers]
+
+## convert wavelengths into Raman shifts in 1/cm wavenumbers from the given 
+#  excitation wavelength
+def generate_wavenumbers(excitation, wavelengths, wavenumber_correction=0):
+    wavenumbers = []
+    if not wavelengths or excitation < 1:
+        return wavenumbers
+
+    base = 1e7 / float(excitation)
+    for i in range(len(wavelengths)):
+        wavenumber = 0
+        if wavelengths[i] != 0:
+            wavenumber = base - 1e7 / wavelengths[i]
+        wavenumbers.append(wavenumber + wavenumber_correction)
+    return wavenumbers
+
+## convert a single wavelength to wavenumber
+def wavelength_to_wavenumber(wavelength, excitation):
+    return 1e7 / float(excitation) - 1e7 / wavelength
+
+## convert a single (uncorrected) wavenumber to wavelength
+def wavenumber_to_wavelength(excitation, wavenumber):
+    return 1.0 / ((1.0 / excitation) - (wavenumber * 1e-7)) 
+
+##
+# If we've loaded a CSV that had wavelength and wavenumber columns, but no
+# metadata, use this to infer the excitation wavelength.  Useful for 
+# interpolation.
+def generate_excitation(wavelengths, wavenumbers):
+    if wavelengths is None or wavenumbers is None or len(wavelengths) != len(wavenumbers) or len(wavelengths) < 1:
+        return None
+
+    total = 0.0
+    count = len(wavelengths)
+    for i in range(count):
+        excitation = 1e7 / (wavenumbers[i] + 1e7 / wavelengths[i])
+        total += excitation
+    return total / count
+
+##
+# apply a boxcar convolution of the given half_width to input array 'a'
+def apply_boxcar(a, half_width):
+    out = []
+    for i in range(len(a)):
+        # hw is smaller than half_width near the fringes
+        hw = min(i, half_width, len(a)-1-i)
+        # each pixel is the mean of itself and `hw` pixels to the left and right
+        out.append(sum(a[i-hw:i+hw+1]) / (2*hw+1))
+    return out
+
+## similar to Perl's Data::Dumper
+def dump(foo, indent=0):
+    spc  = '  ' * indent
+    spc1 = '  ' * (indent + 1)
+    s = ""
+
+    if isinstance(foo, dict):
+        s += spc + '{\n'
+        for key,val in foo.items():
+            if isinstance(val, (dict, list, tuple)):
+                s += spc1 + str(key) + '=>\n'
+                s += dump(val, indent+2)
+            else:
+                s += spc1 + str(key) + '=> ' + str(val)
+        s += spc + '}\n'
+
+    elif isinstance(foo, list):
+        s += spc + '[\n'
+        for item in foo:
+            s += dump(item, indent+1)
+        s += spc + ']\n'
+
+    elif isinstance(foo, tuple):
+        s += spc + '(\n'
+        for item in foo:
+            s += dump(item, indent+1)
+        s += spc + ')\n'
+
+    else: 
+        s += spc + str(foo)
+
+    return s
+
+## given a destination object and a source dictionary, update any existing 
+#  attributes of the destination object from like-named keys in the source 
+#  dictionary
+#
+# @param obj (In/Out) the object whose attributes to update
+# @param d   (Input)  the dictionary whose keys should be treated as attributes
+def update_obj_from_dict(obj, d):
+    if obj is None or d is None:
+        return
+    for k in sorted(obj.__dict__.keys()):
+        v = dict_get_norm(d, k)
+        if v is not None:
+            # log.debug("%s -> %s", k, v)
+            setattr(obj, k, v)
+
+##
+# Similar to dict.get(), but case-insensitive and normalizes-out spaces, 
+# underscores, periods and hyphens.
+#
+# @param d (input) dictionary
+# @param k (input) case-insensitive key (can be prioritized list)
+#
+# Note that this function does not distiguish between the dictionary not having
+# a key, and the value of the key being None.
+def dict_get_norm(d, keys):
+
+    # if we weren't passed a list, make it one
+    if not isinstance(keys, list):
+        keys = [ keys ]
+
+    try:
+        pat = r"[ ._-]"
+        for key in keys:
+            key = re.sub(pat, "", key).lower()
+            for k, v in d.items():
+                k = re.sub(pat, "", k).lower()
+                if k == key:
+                    return v
+    except:
+        log.error("dict_get_norm: %s", keys, exc_info=1)
+        return
+
+##
+# Similar to dict.get(), but takes a list of keys to be traversed in sequence.
+#
+# @param d    (input) dictionary
+# @param keys (input) list of case-insensitive keys
+def dict_get_path(d, keys):
+    try:
+        while len(keys) > 0:
+            k = keys.pop(0)
+            v = dict_get_norm(d, k)
+            if v is None:
+                return
+            elif len(keys) == 0:
+                return v
+            else:
+                d = v
+    except:
+        return
+
+## convenience wrapper to load a JSON file
+def load_json(pathname):
+    try:
+        with open(pathname) as infile:
+            return json.load(infile)
+    except:
+        log.error("unable to load %s", pathname, exc_info=1)
+
+## iterate down a directory, returning pathnames that match the given pattern
+def get_pathnames_from_directory(rootdir, pattern=None, recursive=False):
+    pathnames = []
+    # log.debug("searching %s matching %s with recursive %s", rootdir, pattern, recursive)
+    if recursive:
+        for (directory, _, filenames) in os.walk(rootdir):
+            for filename in filenames:
+                pathname = os.path.join(directory, filename)
+                if pattern:
+                    if re.search(pattern, filename):
+                        pathnames.append(pathname)
+                    else:
+                        # log.debug("%s does not match %s", pathname, pattern)
+                        pass
+                else:
+                    pathnames.append(pathname)
+    elif os.path.isdir(rootdir):
+        for filename in os.listdir(rootdir):
+            pathname = os.path.join(rootdir, filename)
+            if os.path.isfile(pathname):
+                if pattern:
+                    if re.search(pattern, filename):
+                        pathnames.append(pathname)
+                    else:
+                        # log.debug("%s does not match %s", pathname, pattern)
+                        pass
+                else:
+                    pathnames.append(pathname)
+    # log.debug("returning %s", pathnames)
+    return pathnames
+
+##
+# Given a spectrum (array 'a'), with an x_axis, a 'center' along that x_axis, and
+# an allowed 'tolerance' (in same units as the x_axis), find the local maxima
+# within 'tolerance' of 'center'.
+#
+# @note probably a numpy shortcut for this
+def find_local_maxima(a, x_axis, center, tolerance=0):
+    # log.debug("find_local_maxima: center %.2f (tolerance %.2f)", center, tolerance)
+    # generate subset of array within tolerance of center
+    x = []
+    y = []
+    indices = []
+    for i in range(len(x_axis)):
+        x_value = x_axis[i]
+        if center - tolerance <= x_value <= center + tolerance:
+            indices.append(i)
+            x.append(x_value)
+            y.append(a[i])
+
+    # log.debug("  range x: %s", x)
+    # log.debug("  range y: %s", y)
+    
+    if not x:
+        raise "no points within %s of %s"
+
+    # find maxima within subset
+    best_x_index = indices[0]
+    best_x_value = x_axis[0]
+    best_y_value = y[0]
+    for i in range(len(x)):
+        if best_y_value < y[i]:
+            best_x_index = indices[i]
+            best_x_value = x_axis[best_x_index]
+            best_y_value = y[i]
+
+    # no point with linear interpolation, as it would only go "down"
+    # (could do Gaussian / polynomial fit)
+
+    # log.debug("  best_x_index: %d", best_x_index)
+    # log.debug("  best_x_value: %.2f", best_x_value)
+    # log.debug("  best_y_value: %.2f", best_y_value)
+
+    return (best_y_value, best_x_value, best_x_index)
+
+##
+# Given a spectrum and an x_axis, find the indexes of the left and right
+# 'feet' of the peak centered on x_index.  Internally apply then given boxcar
+# for added smoothing.
+def find_peak_feet_indices(spectrum, x_axis, x_index, boxcar_half_width=0):
+    if boxcar_half_width:
+        smoothed = apply_boxcar(spectrum, boxcar_half_width)
+    else:
+        smoothed = spectrum
+
+    left_index = x_index
+    for i in range(x_index - (boxcar_half_width + 1), -1, -1):
+        if i == 0 or smoothed[i] > smoothed[left_index]:
+            break
+        left_index = i
+
+    right_index = x_index
+    for i in range(x_index + (boxcar_half_width + 1), len(spectrum)):
+        if i + 1 == len(spectrum) or smoothed[i] > smoothed[right_index]:
+            break
+        right_index = i
+
+    return (left_index, right_index)
+
+## integrate the 'area under the curve' for the given spectrum and x_axis,
+#  using the peak centered on x_axis, with optional smoothing given the
+#  boxcar width.
+def area_under_peak(spectrum, x_axis, x_index, boxcar_half_width=0):
+    # find left and right "feet" of the peak
+    (left_index, right_index) = find_peak_feet_indices(
+        spectrum, x_axis, x_index, boxcar_half_width)
+
+    # generate baseline-subtracted subspectrum of just the peak, considering
+    #    the baseline to be a straight line between the two feet
+    slope = float(spectrum[right_index] - spectrum[left_index]) / \
+                   (x_axis[right_index] - x_axis[left_index])
+    subspectrum = []
+    subaxis = []
+    for i in range (left_index, right_index + 1):
+        baseline = spectrum[left_index] + slope * (x_axis[i] - x_axis[left_index])
+        subspectrum.append(spectrum[i] - baseline)
+        subaxis.append(x_axis[i])
+
+    # 4. integrate subspectrum
+    area = numpy.trapz(subspectrum, subaxis)
+    return area
+
+def peak_height_above_background(spectrum, x_axis, x_index, boxcar_half_width=0):
+    # find left and right "feet" of the peak
+    (left_index, right_index) = find_peak_feet_indices(
+        spectrum, x_axis, x_index, boxcar_half_width)
+
+    width_wn = x_axis[right_index] - x_axis[left_index]
+    width_px = right_index - left_index + 1
+
+    # generate baseline-subtracted subspectrum of just the peak, considering
+    #    the baseline to be a straight line between the two feet
+    slope = float(spectrum[right_index] - spectrum[left_index]) / width_wn
+    baseline = spectrum[left_index] + slope * (x_axis[x_index] - x_axis[left_index])
+    height = spectrum[x_index] - baseline
+
+    log.debug("peak_height_above_background: peak at x_index %d (boxcar %d)", x_index, boxcar_half_width)
+    log.debug("peak_height_above_background:   abs height: %.2f", spectrum[x_index])
+    log.debug("peak_height_above_background:   peak width: (%d px, %.2f cm-1)", width_px, width_wn)
+    log.debug("peak_height_above_background:   feet: (%d, %d)", left_index, right_index)
+    log.debug("peak_height_above_background:   feet height: (%.2f, %.2f)", spectrum[left_index], spectrum[right_index])
+    log.debug("peak_height_above_background:   slope: %.2f", slope)
+    log.debug("peak_height_above_background:   peak baseline: %.2f", baseline)
+    log.debug("peak_height_above_background:   relative height: %.2f", height)
+
+    return (height, width_wn, width_px)
+
+def find_nearest_index(L, value):
+    a = numpy.asarray(L)
+    return (numpy.abs(a - value)).argmin()
+    
+def find_nearest_value(L, value):
+    i = find_nearest_index(L, value)
+    return L[i]
+
+## 
+# Interpolate the passed spectrum over a fixed x-axis (e.g. integral wavelengths
+# or wavenumbers).
+def interpolate_array(spectrum, old_axis, new_axis):
+    if not spectrum or not old_axis or not new_axis or len(spectrum) != len(old_axis) or len(new_axis) < 1:
+        return 
+    return numpy.interp(new_axis, old_axis, spectrum)
+
+## I might be making this more difficult than it needs to be
+def interpolate_value(spectrum, old_axis, x):
+    if not spectrum or not old_axis or len(spectrum) != len(old_axis):
+        return 
+    new_axis = [ x-1, x, x+1 ] 
+    new_y = numpy.interp(new_axis, old_axis, spectrum)
+    if new_y is not None and len(new_y) == len(new_axis):
+        return new_y[1]
+
+## render a spectrum as ASCII-art
+def ascii_spectrum(spectrum, rows, cols, x_axis, x_unit):
+    spectral_min = min(spectrum)
+    spectral_max = max(spectrum)
+    spectral_avg = 1.0 * sum(spectrum) / len(spectrum)
+
+    # histogram into bins
+    bins = [0] * cols
+    for i in range(len(spectrum)):
+        col = int(1.0 * cols * i / len(spectrum))
+        bins[col] += spectrum[i] - spectral_min
+
+    # render histogram
+    lines = []
+    bin_hi = max(bins)
+    for row in range(rows - 1, -1, -1):
+        s = "| "
+        for col in range(cols):
+            s += "*" if bins[col] >= (1.0 * row / rows) * bin_hi else " "
+        lines.append(s)
+
+    # graph footer
+    lines.append("+-" + "-" * cols)
+    lines.append("  Min: %8.2f  Max: %8.2f  Mean: %8.2f  (range %.2f, %.2f%s)" % (
+        spectral_min, spectral_max, spectral_avg, 
+        x_axis[0], x_axis[-1], x_unit))
+
+    return lines
+
+def timestamp():
+    return datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
+
+def truthy(flag):
+    if flag is None:
+        return False
+
+    try:
+        if len(flag) > 0:
+            return True
+    except:
+        pass
+
+    return True if flag else False
+
+def clean_nan(a):
+    for i in range(len(a)):
+        if math.isnan(a[i]):
+            a[i] = 0
+
+## 
+# Can be used as a sanity-check for any set of coefficients.
+#
+# Checks that coeffs:
+#
+# - are not None
+# - have no NaN
+# - are not all the same (zeros, -1 etc)
+# - are not [0, 1, 0, 0]
+# - checks count if provided
+def coeffs_look_valid(coeffs, count=None):
+
+    if coeffs is None:
+        log.debug("no coeffs, returning False")
+        return False
+
+    if count is not None and len(coeffs) != count:
+        log.debug("coeff count is wrong, returning False")
+        return False
+
+    # check for NaN
+    for i in range(len(coeffs)):
+        if math.isnan(coeffs[i]):
+            log.debug("found NaN in coeff, returning False")
+            return False 
+
+    # check for [0, 1, 0...] default pattern
+    all_default = True
+    for i in range(len(coeffs)):
+        if i == 1:
+            if coeffs[i] != 1.0:
+                all_default = False
+        elif coeffs[i] != 0.0:
+            all_default = False
+    if all_default:
+        log.debug("coeffs all default, returning False")
+        return False
+
+    # check for constants (all coefficients the same value)
+    all_const = True
+    log.info(coeffs)
+    for i in range(1, len(coeffs)):
+        if coeffs[0] != coeffs[i]:
+            all_const = False
+    if all_const:
+        log.debug("coeffs all const, returning False")
+        return False
+
+    return True
+
+## 
+# "Stomps" the first "count" elements with the first non-stomped value.
+#
+# @param a     (Input) array to modify
+# @param count (Input) HOW MANY leading elements to stomp, so the index of the
+#              first GOOD pixel should be one more than this
+def stomp_first(a, count):
+    for i in range(count):
+        a[i] = a[count]
+
+## "stomps" the last "count" elements with the last non-stomped value
+def stomp_last(a, count):
+    for i in range(count):
+        a[-(i+1)] = a[-(count+1)]
+
+def clamp_to_int16(n):
+    return max(-32768, min(32767, int(n)))
+
+def all_same(a):
+    for i in range(1, len(a)):
+        if a[0] != a[i]:
+            return False
+    return True
+
+##
+# Given an array of doubles and a peak index, use the peak and its two
+# neighbors to form a parabola and return the interpolated maximum height of the
+# parabola.
+#
+# "pixel" is ideally the array index of the pinnacle of a previously-
+# identified peak within the spectrum, although though this will 
+# technically generate a parabola through any pixel and its two 
+# neighbors.
+#
+# @param pixel  index of a point on the spectrum
+# @param x      x-axis (wavelengths or wavenumbers)
+# @param y      y-axis (intensity)
+#
+# @see https://stackoverflow.com/a/717833
+#
+# @returns a point representing the interpolated vertex of a parabola drawn 
+#          through the specified pixel and its two neighbors (in x-axis space)
+#
+def parabolic_approximation(pixel, x, y):
+    if len(x) != len(y):
+        log.error("parabolic approximation array lengths differ")
+        return 0, 0
+    if pixel - 1 < 0:
+        return y[0]
+    elif pixel + 1 >= len(y):
+        return y[-1]
+
+    x1 = pixel - 1
+    x2 = pixel
+    x3 = pixel + 1
+
+    y1 = y[x1]
+    y2 = y[x2]
+    y3 = y[x3]
+
+    if y1 >= y2 or y3 >= y2:
+        log.debug("parabolic approximation: peak misformed or saturated")
+
+    denom = (x1 - x2) * (x1 - x3) * (x2 - x3)
+    A = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / denom
+    B = (x3 * x3 * (y1 - y2) + x2 * x2 * (y3 - y1) + x1 * x1 * (y2 - y3)) / denom
+    C = (x2 * x3 * (x2 - x3) * y1 + x3 * x1 * (x3 - x1) * y2 + x1 * x2 * (x1 - x2) * y3) / denom
+
+    vertex_x = -B / (2 * A) # pixel space
+    vertex_y = C - B * B / (4 * A)
+
+    if vertex_x < x1 or vertex_x > x3:
+        log.error("parabolic approximation failed (x exceeded limits)")
+        return (0, 0)
+
+    if vertex_x == x2:
+        return (x[x2], vertex_y)
+    elif vertex_x < x2:
+        left = x1
+        right = x2
+    else:
+        left = x2
+        right = x3
+    x_coord = x[left] + (x[right] - x[left]) * (vertex_x - left)
+
+    if False:
+        log.debug("parabolic approximation: x1 %d, x2 %d, x3 %d", x1, x2, x3)
+        log.debug("parabolic approximation: x.x1 %.2f, x.x2 %.2f, x.x3 %.2f", x[x1], x[x2], x[x3])
+        log.debug("parabolic approximation: y.x1 %.2f, y.x2 %.2f, y.x3 %.2f", y[x1], y[x2], y[x3])
+        log.debug("parabolic approximation: vertex_x %.2f, vertex_y %.2f", vertex_x, vertex_y)
+        log.debug("parabolic approximation: left %d, right %d", left, right)
+        log.debug("parabolic approximation: x.left %.2f, x.right %.2f", x[left], x[right])
+        log.debug("parabolic approximation: x.coord %.2f", x_coord)
+
+    return (x_coord, vertex_y)
+
+##
+# @see https://stackoverflow.com/a/9147327/6436775
+def twos_complement(val, bits):
+    if (val & (1 << (bits - 1))) != 0: # if sign bit is set e.g., 8bit: 128-255
+        val = val - (1 << bits)        # compute negative value
+    return val    
+
+def to_bool(value):
+    if isinstance(value, bool):
+        return value
+    elif isinstance(value, int):
+        return 0 != value
+    elif isinstance(value, float):
+        return 0 != value
+    elif isinstance(value, str):
+        s = value.lower().strip()
+        return s in ['true', 'y', 'yes', 'on', '1']
+    return False
+
+def uint16_to_little_endian(values):
+    a = []
+    for n in values:
+        a.append(n & 0xff)          # lsb
+        a.append((n >> 8) & 0xff)   # msb
+    return a
+
+def resize_file(path, nbytes, ensure_no_overwrite=False):
+    """
+    Keep only the last `nbytes` of a text file specified by `path`.
+
+    This function is encoding (utf-8, utf-16, ascii) agnostic because it uses the line-
+    continuation character '\n' as a boundary. It is system independent because it slices
+    before that character. This was written to keep our default log file within a reasonable
+    filesize, suitable for emailing.
+
+    Call this on a file that is not yet opened. Expect the file to be closed and flushed
+    by the time the function returns.
+
+    returns True if the file was changed.
+    """
+
+    # limit how much memory is used to copy file contents
+    # NOTE: this NOT the filesize limit, that is passed in via nbytes
+    # see applog.py's call of resize_file for the log file limit
+    MAX_BYTES_MEMORY = 2_000_000
+
+    START_OF_STREAM = 0 # seek from start of a file
+    CURRENT_STREAM = 1 # seek from current location in file
+    END_OF_STREAM = 2 # seek from end of file, offset should be negative
+
+    # open file with the intention of reading bytes, preserving what's there
+    f = open(path, "rb")
+
+    # path to temporary file
+    tpath = path+".temp"
+
+    # don't overwrite any local files
+    # defaults to false so we don't err on the side of a bunch of extra .temp files
+    if ensure_no_overwrite:
+        while os.path.exists(tpath):
+            tpath += ".temp"
+
+    f2 = open(tpath, "wb")
+
+    # fast-forward to end of file and keep track of total_bytes
+    tbytes = f.seek(0, END_OF_STREAM)
+
+    if tbytes <= nbytes:
+        # don't do anything if file is already smaller than target size
+        f2.close()
+        os.remove(tpath)
+        return False
+
+    # go to nbytes from the end
+    f.seek(-nbytes, END_OF_STREAM)
+
+    # seek to a newline
+    for i in range(500):
+        if f.read(1) == b'\n':
+            break
+
+    # make sure to land before the newline
+    t_start = f.seek(-1, CURRENT_STREAM)
+
+    # decrease nbytes by the amount we skipped forward (usually small)
+    nbytes = tbytes-t_start
+
+    # copy the end of the file into the beginning of a temporary one
+    f.seek(t_start, START_OF_STREAM)
+    i = nbytes
+    while i:
+        block_size = min(MAX_BYTES_MEMORY, i)
+
+        b = f.read(block_size)
+        f2.write(b)
+        i -= block_size
+
+    # wrap up resource use
+    f.close()
+    f2.flush()
+    f2.close()
+
+    # move temporary file in place
+    shutil.move(tpath, path)
+
+    return True
+
+def vercmp(a, b, delim="."):
+    """ vercmp("1.2.3.4", "1.2.4.3") -> -1 """
+    if a is None or b is None:
+        return None
+
+    tok_a = str(a).split(delim)
+    tok_b = str(b).split(delim)
+
+    int_a = int(tok_a[0])
+    int_b = int(tok_b[0])
+
+    if   int_a > int_b: return +1
+    elif int_a < int_b: return -1
+    elif len(tok_a) == 1 and len(tok_b) == 1: return 0
+    elif len(tok_a)  > 1 and len(tok_b)  > 1: return vercmp(delim.join(tok_a[1:]), delim.join(tok_b[1:]))
+    elif len(tok_b)  > 1: return -1
+    else: return +1
```

### Comparing `wasatch-2.1.35/PKG-INFO` & `wasatch-2.1.64/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: wasatch
-Version: 2.1.35
+Version: 2.1.64
 Summary: This package is a driver for Wasatch Photonics spectrometers
 Author-email: Wasatch Photonics <edort@wasatchphotonics.com>
 Description-Content-Type: text/markdown
 Classifier: License :: OSI Approved :: MIT License
 Project-URL: Home, https://github.com/WasatchPhotonics/Wasatch.PY
 
 ![Sample Console Views](https://github.com/WasatchPhotonics/Wasatch.PY/raw/master/screenshots/multiplatform.png)
@@ -324,9 +324,9 @@
 
 # Backlog
 
 - update .inf files to deprecate "Stroker"
 
 # Version History
 
-See [Changelog](README_CHANGELOG.md)
+See [Changelog](CHANGELOG.md)
```

