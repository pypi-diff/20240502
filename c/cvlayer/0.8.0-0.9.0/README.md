# Comparing `tmp/cvlayer-0.8.0-py3-none-any.whl.zip` & `tmp/cvlayer-0.9.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,104 +1,109 @@
-Zip file size: 83657 bytes, number of entries: 102
--rw-r--r--  2.0 unx      132 b- defN 23-Sep-05 01:27 cvlayer/__init__.py
--rw-r--r--  2.0 unx     2844 b- defN 23-Sep-05 01:27 cvlayer/cvlayer.py
--rw-r--r--  2.0 unx        0 b- defN 23-Sep-05 01:27 cvlayer/chrono/__init__.py
--rw-r--r--  2.0 unx     1084 b- defN 23-Sep-05 01:27 cvlayer/chrono/datetime_filename.py
--rw-r--r--  2.0 unx        0 b- defN 23-Sep-05 01:27 cvlayer/cv/__init__.py
--rw-r--r--  2.0 unx     1447 b- defN 23-Sep-05 01:27 cvlayer/cv/angle.py
--rw-r--r--  2.0 unx      502 b- defN 23-Sep-05 01:27 cvlayer/cv/aspect_ratio.py
--rw-r--r--  2.0 unx     1540 b- defN 23-Sep-05 01:27 cvlayer/cv/backend.py
--rw-r--r--  2.0 unx     5815 b- defN 23-Sep-05 01:27 cvlayer/cv/bgsub.py
--rw-r--r--  2.0 unx     1074 b- defN 23-Sep-05 01:27 cvlayer/cv/bitwise.py
--rw-r--r--  2.0 unx      474 b- defN 23-Sep-05 01:27 cvlayer/cv/border.py
--rw-r--r--  2.0 unx      575 b- defN 23-Sep-05 01:27 cvlayer/cv/canny.py
--rw-r--r--  2.0 unx      134 b- defN 23-Sep-05 01:27 cvlayer/cv/color.py
--rw-r--r--  2.0 unx     3483 b- defN 23-Sep-05 01:27 cvlayer/cv/contours.py
--rw-r--r--  2.0 unx     5105 b- defN 23-Sep-05 01:27 cvlayer/cv/contours_edge.py
--rw-r--r--  2.0 unx     2194 b- defN 23-Sep-05 01:27 cvlayer/cv/contours_intersection.py
--rw-r--r--  2.0 unx      607 b- defN 23-Sep-05 01:27 cvlayer/cv/convert_scale_abs.py
--rw-r--r--  2.0 unx     1287 b- defN 23-Sep-05 01:27 cvlayer/cv/cvt_color.py
--rw-r--r--  2.0 unx     3857 b- defN 23-Sep-05 01:27 cvlayer/cv/cvt_shapely.py
--rw-r--r--  2.0 unx     1008 b- defN 23-Sep-05 01:27 cvlayer/cv/data_type.py
--rw-r--r--  2.0 unx     2908 b- defN 23-Sep-05 01:27 cvlayer/cv/dehaze.py
--rw-r--r--  2.0 unx     1171 b- defN 23-Sep-05 01:27 cvlayer/cv/depth.py
--rw-r--r--  2.0 unx     7489 b- defN 23-Sep-05 01:27 cvlayer/cv/drawable.py
--rw-r--r--  2.0 unx     2273 b- defN 23-Sep-05 01:27 cvlayer/cv/drawable_contours.py
--rw-r--r--  2.0 unx     1507 b- defN 23-Sep-05 01:27 cvlayer/cv/fourcc.py
--rw-r--r--  2.0 unx      801 b- defN 23-Sep-05 01:27 cvlayer/cv/fourier_transform.py
--rw-r--r--  2.0 unx     2993 b- defN 23-Sep-05 01:27 cvlayer/cv/histogram.py
--rw-r--r--  2.0 unx      820 b- defN 23-Sep-05 01:27 cvlayer/cv/hough_lines.py
--rw-r--r--  2.0 unx     1128 b- defN 23-Sep-05 01:27 cvlayer/cv/hsv.py
--rw-r--r--  2.0 unx      473 b- defN 23-Sep-05 01:27 cvlayer/cv/image_crop.py
--rw-r--r--  2.0 unx      741 b- defN 23-Sep-05 01:27 cvlayer/cv/image_make.py
--rw-r--r--  2.0 unx      501 b- defN 23-Sep-05 01:27 cvlayer/cv/image_move.py
--rw-r--r--  2.0 unx     1417 b- defN 23-Sep-05 01:27 cvlayer/cv/image_resize.py
--rw-r--r--  2.0 unx     1403 b- defN 23-Sep-05 01:27 cvlayer/cv/in_range.py
--rw-r--r--  2.0 unx     9436 b- defN 23-Sep-05 01:27 cvlayer/cv/intrusion_detection.py
--rw-r--r--  2.0 unx      237 b- defN 23-Sep-05 01:27 cvlayer/cv/iou.py
--rw-r--r--  2.0 unx     2235 b- defN 23-Sep-05 01:27 cvlayer/cv/keymap.py
--rw-r--r--  2.0 unx     1686 b- defN 23-Sep-05 01:27 cvlayer/cv/laplacian.py
--rw-r--r--  2.0 unx     1590 b- defN 23-Sep-05 01:27 cvlayer/cv/match_template.py
--rw-r--r--  2.0 unx      966 b- defN 23-Sep-05 01:27 cvlayer/cv/matcher.py
--rw-r--r--  2.0 unx     1780 b- defN 23-Sep-05 01:27 cvlayer/cv/morphology.py
--rw-r--r--  2.0 unx     1009 b- defN 23-Sep-05 01:27 cvlayer/cv/mouse.py
--rw-r--r--  2.0 unx      528 b- defN 23-Sep-05 01:27 cvlayer/cv/norm.py
--rw-r--r--  2.0 unx     2505 b- defN 23-Sep-05 01:27 cvlayer/cv/orb.py
--rw-r--r--  2.0 unx      670 b- defN 23-Sep-05 01:27 cvlayer/cv/palette.py
--rw-r--r--  2.0 unx     4028 b- defN 23-Sep-05 01:27 cvlayer/cv/perspective.py
--rw-r--r--  2.0 unx     5253 b- defN 23-Sep-05 01:27 cvlayer/cv/rotate_tracer.py
--rw-r--r--  2.0 unx     1689 b- defN 23-Sep-05 01:27 cvlayer/cv/sobel.py
--rw-r--r--  2.0 unx      475 b- defN 23-Sep-05 01:27 cvlayer/cv/stabilizer.py
--rw-r--r--  2.0 unx     2054 b- defN 23-Sep-05 01:27 cvlayer/cv/threshold.py
--rw-r--r--  2.0 unx     2769 b- defN 23-Sep-05 01:27 cvlayer/cv/tracker.py
--rw-r--r--  2.0 unx     2131 b- defN 23-Sep-05 01:27 cvlayer/cv/tracking.py
--rw-r--r--  2.0 unx     9578 b- defN 23-Sep-05 01:27 cvlayer/cv/video_capture.py
--rw-r--r--  2.0 unx     6571 b- defN 23-Sep-05 01:27 cvlayer/cv/video_writer.py
--rw-r--r--  2.0 unx     6505 b- defN 23-Sep-05 01:27 cvlayer/cv/window.py
--rw-r--r--  2.0 unx        0 b- defN 23-Sep-05 01:27 cvlayer/geometry/__init__.py
--rw-r--r--  2.0 unx      401 b- defN 23-Sep-05 01:27 cvlayer/geometry/find_nearset_point.py
--rw-r--r--  2.0 unx      167 b- defN 23-Sep-05 01:27 cvlayer/geometry/flatten.py
--rw-r--r--  2.0 unx      862 b- defN 23-Sep-05 01:27 cvlayer/geometry/iou.py
--rw-r--r--  2.0 unx        0 b- defN 23-Sep-05 01:27 cvlayer/inspect/__init__.py
--rw-r--r--  2.0 unx      979 b- defN 23-Sep-05 01:27 cvlayer/inspect/member.py
--rw-r--r--  2.0 unx        0 b- defN 23-Sep-05 01:27 cvlayer/keymap/__init__.py
--rw-r--r--  2.0 unx     1006 b- defN 23-Sep-05 01:27 cvlayer/keymap/create.py
--rw-r--r--  2.0 unx        0 b- defN 23-Sep-05 01:27 cvlayer/layers/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Sep-05 01:27 cvlayer/layers/base/__init__.py
--rw-r--r--  2.0 unx     5650 b- defN 23-Sep-05 01:27 cvlayer/layers/base/layer_base.py
--rw-r--r--  2.0 unx     5949 b- defN 23-Sep-05 01:27 cvlayer/layers/base/layer_manager.py
--rw-r--r--  2.0 unx     5102 b- defN 23-Sep-05 01:27 cvlayer/layers/base/layer_parameter.py
--rw-r--r--  2.0 unx        0 b- defN 23-Sep-05 01:27 cvlayer/math/__init__.py
--rw-r--r--  2.0 unx     1740 b- defN 23-Sep-05 01:27 cvlayer/math/angle.py
--rw-r--r--  2.0 unx      690 b- defN 23-Sep-05 01:27 cvlayer/math/aspect_ratio.py
--rw-r--r--  2.0 unx      126 b- defN 23-Sep-05 01:27 cvlayer/math/constant.py
--rw-r--r--  2.0 unx      451 b- defN 23-Sep-05 01:27 cvlayer/math/norm.py
--rw-r--r--  2.0 unx        0 b- defN 23-Sep-05 01:27 cvlayer/math/equation/__init__.py
--rw-r--r--  2.0 unx     1160 b- defN 23-Sep-05 01:27 cvlayer/math/equation/linear.py
--rw-r--r--  2.0 unx        0 b- defN 23-Sep-05 01:27 cvlayer/np/__init__.py
--rw-r--r--  2.0 unx      607 b- defN 23-Sep-05 01:27 cvlayer/np/image.py
--rw-r--r--  2.0 unx     1547 b- defN 23-Sep-05 01:27 cvlayer/np/mask.py
--rw-r--r--  2.0 unx     1663 b- defN 23-Sep-05 01:27 cvlayer/palette/__init__.py
--rw-r--r--  2.0 unx      511 b- defN 23-Sep-05 01:27 cvlayer/palette/basic.py
--rw-r--r--  2.0 unx     4656 b- defN 23-Sep-05 01:27 cvlayer/palette/css4.py
--rw-r--r--  2.0 unx     4612 b- defN 23-Sep-05 01:27 cvlayer/palette/extended.py
--rw-r--r--  2.0 unx     8449 b- defN 23-Sep-05 01:27 cvlayer/palette/flat.py
--rw-r--r--  2.0 unx      291 b- defN 23-Sep-05 01:27 cvlayer/palette/tableau.py
--rw-r--r--  2.0 unx    32876 b- defN 23-Sep-05 01:27 cvlayer/palette/xkcd.py
--rw-r--r--  2.0 unx        0 b- defN 23-Sep-05 01:27 cvlayer/shape/__init__.py
--rw-r--r--  2.0 unx     1654 b- defN 23-Sep-05 01:27 cvlayer/shape/points.py
--rw-r--r--  2.0 unx     1509 b- defN 23-Sep-05 01:27 cvlayer/shape/polygons.py
--rw-r--r--  2.0 unx        0 b- defN 23-Sep-05 01:27 cvlayer/tk/__init__.py
--rw-r--r--  2.0 unx     4334 b- defN 23-Sep-05 01:27 cvlayer/tk/tk_window.py
--rw-r--r--  2.0 unx      663 b- defN 23-Sep-05 01:27 cvlayer/typing/__init__.py
--rw-r--r--  2.0 unx      123 b- defN 23-Sep-05 01:27 cvlayer/typing/color.py
--rw-r--r--  2.0 unx      697 b- defN 23-Sep-05 01:27 cvlayer/typing/geomerty.py
--rw-r--r--  2.0 unx      240 b- defN 23-Sep-05 01:27 cvlayer/typing/np.py
--rw-r--r--  2.0 unx        0 b- defN 23-Sep-05 01:27 cvlayer/vio/__init__.py
--rw-r--r--  2.0 unx    20246 b- defN 23-Sep-05 01:27 cvlayer/vio/vio.py
--rw-r--r--  2.0 unx      719 b- defN 23-Sep-05 01:27 cvlayer/vio/vio_interface.py
--rw-r--r--  2.0 unx     1065 b- defN 23-Sep-05 01:28 cvlayer-0.8.0.dist-info/LICENSE
--rw-r--r--  2.0 unx     1941 b- defN 23-Sep-05 01:28 cvlayer-0.8.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Sep-05 01:28 cvlayer-0.8.0.dist-info/WHEEL
--rw-r--r--  2.0 unx        8 b- defN 23-Sep-05 01:28 cvlayer-0.8.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     8196 b- defN 23-Sep-05 01:28 cvlayer-0.8.0.dist-info/RECORD
-102 files, 243464 bytes uncompressed, 70865 bytes compressed:  70.9%
+Zip file size: 100928 bytes, number of entries: 107
+-rw-r--r--  2.0 unx      186 b- defN 23-Sep-22 00:29 cvlayer/__init__.py
+-rw-r--r--  2.0 unx     3121 b- defN 23-Sep-22 00:29 cvlayer/cvlayer.py
+-rw-r--r--  2.0 unx    23548 b- defN 23-Sep-22 00:29 cvlayer/cvwindow.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Sep-22 00:29 cvlayer/chrono/__init__.py
+-rw-r--r--  2.0 unx     1084 b- defN 23-Sep-22 00:29 cvlayer/chrono/datetime_filename.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Sep-22 00:29 cvlayer/cv/__init__.py
+-rw-r--r--  2.0 unx     1447 b- defN 23-Sep-22 00:29 cvlayer/cv/angle.py
+-rw-r--r--  2.0 unx      502 b- defN 23-Sep-22 00:29 cvlayer/cv/aspect_ratio.py
+-rw-r--r--  2.0 unx     1540 b- defN 23-Sep-22 00:29 cvlayer/cv/backend.py
+-rw-r--r--  2.0 unx     1763 b- defN 23-Sep-22 00:29 cvlayer/cv/basic.py
+-rw-r--r--  2.0 unx    13945 b- defN 23-Sep-22 00:29 cvlayer/cv/bgsub.py
+-rw-r--r--  2.0 unx     1074 b- defN 23-Sep-22 00:29 cvlayer/cv/bitwise.py
+-rw-r--r--  2.0 unx      474 b- defN 23-Sep-22 00:29 cvlayer/cv/border.py
+-rw-r--r--  2.0 unx      575 b- defN 23-Sep-22 00:29 cvlayer/cv/canny.py
+-rw-r--r--  2.0 unx      134 b- defN 23-Sep-22 00:29 cvlayer/cv/color.py
+-rw-r--r--  2.0 unx     3483 b- defN 23-Sep-22 00:29 cvlayer/cv/contours.py
+-rw-r--r--  2.0 unx     5511 b- defN 23-Sep-22 00:29 cvlayer/cv/contours_edge.py
+-rw-r--r--  2.0 unx     2194 b- defN 23-Sep-22 00:29 cvlayer/cv/contours_intersection.py
+-rw-r--r--  2.0 unx      607 b- defN 23-Sep-22 00:29 cvlayer/cv/convert_scale_abs.py
+-rw-r--r--  2.0 unx    16007 b- defN 23-Sep-22 00:29 cvlayer/cv/cvt_color.py
+-rw-r--r--  2.0 unx     3857 b- defN 23-Sep-22 00:29 cvlayer/cv/cvt_shapely.py
+-rw-r--r--  2.0 unx     1008 b- defN 23-Sep-22 00:29 cvlayer/cv/data_type.py
+-rw-r--r--  2.0 unx     2908 b- defN 23-Sep-22 00:29 cvlayer/cv/dehaze.py
+-rw-r--r--  2.0 unx     1181 b- defN 23-Sep-22 00:29 cvlayer/cv/depth.py
+-rw-r--r--  2.0 unx    18870 b- defN 23-Sep-22 00:29 cvlayer/cv/drawable.py
+-rw-r--r--  2.0 unx     2273 b- defN 23-Sep-22 00:29 cvlayer/cv/drawable_contours.py
+-rw-r--r--  2.0 unx     1507 b- defN 23-Sep-22 00:29 cvlayer/cv/fourcc.py
+-rw-r--r--  2.0 unx      801 b- defN 23-Sep-22 00:29 cvlayer/cv/fourier_transform.py
+-rw-r--r--  2.0 unx     5669 b- defN 23-Sep-22 00:29 cvlayer/cv/histogram.py
+-rw-r--r--  2.0 unx      820 b- defN 23-Sep-22 00:29 cvlayer/cv/hough_lines.py
+-rw-r--r--  2.0 unx     1128 b- defN 23-Sep-22 00:29 cvlayer/cv/hsv.py
+-rw-r--r--  2.0 unx     3502 b- defN 23-Sep-22 00:29 cvlayer/cv/image_crop.py
+-rw-r--r--  2.0 unx     1017 b- defN 23-Sep-22 00:29 cvlayer/cv/image_flip.py
+-rw-r--r--  2.0 unx    13747 b- defN 23-Sep-22 00:29 cvlayer/cv/image_io.py
+-rw-r--r--  2.0 unx      887 b- defN 23-Sep-22 00:29 cvlayer/cv/image_make.py
+-rw-r--r--  2.0 unx      501 b- defN 23-Sep-22 00:29 cvlayer/cv/image_move.py
+-rw-r--r--  2.0 unx     1417 b- defN 23-Sep-22 00:29 cvlayer/cv/image_resize.py
+-rw-r--r--  2.0 unx     1403 b- defN 23-Sep-22 00:29 cvlayer/cv/in_range.py
+-rw-r--r--  2.0 unx     9436 b- defN 23-Sep-22 00:29 cvlayer/cv/intrusion_detection.py
+-rw-r--r--  2.0 unx      237 b- defN 23-Sep-22 00:29 cvlayer/cv/iou.py
+-rw-r--r--  2.0 unx     2267 b- defN 23-Sep-22 00:29 cvlayer/cv/keymap.py
+-rw-r--r--  2.0 unx     1686 b- defN 23-Sep-22 00:29 cvlayer/cv/laplacian.py
+-rw-r--r--  2.0 unx     1590 b- defN 23-Sep-22 00:29 cvlayer/cv/match_template.py
+-rw-r--r--  2.0 unx      966 b- defN 23-Sep-22 00:29 cvlayer/cv/matcher.py
+-rw-r--r--  2.0 unx     1780 b- defN 23-Sep-22 00:29 cvlayer/cv/morphology.py
+-rw-r--r--  2.0 unx     1009 b- defN 23-Sep-22 00:29 cvlayer/cv/mouse.py
+-rw-r--r--  2.0 unx      528 b- defN 23-Sep-22 00:29 cvlayer/cv/norm.py
+-rw-r--r--  2.0 unx     2509 b- defN 23-Sep-22 00:29 cvlayer/cv/orb.py
+-rw-r--r--  2.0 unx      670 b- defN 23-Sep-22 00:29 cvlayer/cv/palette.py
+-rw-r--r--  2.0 unx     5102 b- defN 23-Sep-22 00:29 cvlayer/cv/perspective.py
+-rw-r--r--  2.0 unx     5339 b- defN 23-Sep-22 00:29 cvlayer/cv/plot.py
+-rw-r--r--  2.0 unx     5253 b- defN 23-Sep-22 00:29 cvlayer/cv/rotate_tracer.py
+-rw-r--r--  2.0 unx     1695 b- defN 23-Sep-22 00:29 cvlayer/cv/sobel.py
+-rw-r--r--  2.0 unx      475 b- defN 23-Sep-22 00:29 cvlayer/cv/stabilizer.py
+-rw-r--r--  2.0 unx      476 b- defN 23-Sep-22 00:29 cvlayer/cv/stack.py
+-rw-r--r--  2.0 unx     3139 b- defN 23-Sep-22 00:29 cvlayer/cv/threshold.py
+-rw-r--r--  2.0 unx     2769 b- defN 23-Sep-22 00:29 cvlayer/cv/tracker.py
+-rw-r--r--  2.0 unx     2131 b- defN 23-Sep-22 00:29 cvlayer/cv/tracking.py
+-rw-r--r--  2.0 unx     9578 b- defN 23-Sep-22 00:29 cvlayer/cv/video_capture.py
+-rw-r--r--  2.0 unx     6571 b- defN 23-Sep-22 00:29 cvlayer/cv/video_writer.py
+-rw-r--r--  2.0 unx     7276 b- defN 23-Sep-22 00:29 cvlayer/cv/window.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Sep-22 00:29 cvlayer/debug/__init__.py
+-rw-r--r--  2.0 unx     3367 b- defN 23-Sep-22 00:29 cvlayer/debug/avg_stat.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Sep-22 00:29 cvlayer/geometry/__init__.py
+-rw-r--r--  2.0 unx      401 b- defN 23-Sep-22 00:29 cvlayer/geometry/find_nearset_point.py
+-rw-r--r--  2.0 unx      167 b- defN 23-Sep-22 00:29 cvlayer/geometry/flatten.py
+-rw-r--r--  2.0 unx      862 b- defN 23-Sep-22 00:29 cvlayer/geometry/iou.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Sep-22 00:29 cvlayer/inspect/__init__.py
+-rw-r--r--  2.0 unx      979 b- defN 23-Sep-22 00:29 cvlayer/inspect/member.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Sep-22 00:29 cvlayer/keymap/__init__.py
+-rw-r--r--  2.0 unx     1006 b- defN 23-Sep-22 00:29 cvlayer/keymap/create.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Sep-22 00:29 cvlayer/layers/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Sep-22 00:29 cvlayer/layers/base/__init__.py
+-rw-r--r--  2.0 unx     7180 b- defN 23-Sep-22 00:29 cvlayer/layers/base/layer_base.py
+-rw-r--r--  2.0 unx     7385 b- defN 23-Sep-22 00:29 cvlayer/layers/base/layer_manager.py
+-rw-r--r--  2.0 unx    14650 b- defN 23-Sep-22 00:29 cvlayer/layers/base/layer_parameter.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Sep-22 00:29 cvlayer/math/__init__.py
+-rw-r--r--  2.0 unx     1740 b- defN 23-Sep-22 00:29 cvlayer/math/angle.py
+-rw-r--r--  2.0 unx      690 b- defN 23-Sep-22 00:29 cvlayer/math/aspect_ratio.py
+-rw-r--r--  2.0 unx      126 b- defN 23-Sep-22 00:29 cvlayer/math/constant.py
+-rw-r--r--  2.0 unx      451 b- defN 23-Sep-22 00:29 cvlayer/math/norm.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Sep-22 00:29 cvlayer/math/equation/__init__.py
+-rw-r--r--  2.0 unx     1160 b- defN 23-Sep-22 00:29 cvlayer/math/equation/linear.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Sep-22 00:29 cvlayer/np/__init__.py
+-rw-r--r--  2.0 unx      773 b- defN 23-Sep-22 00:29 cvlayer/np/image.py
+-rw-r--r--  2.0 unx     1547 b- defN 23-Sep-22 00:29 cvlayer/np/mask.py
+-rw-r--r--  2.0 unx     1663 b- defN 23-Sep-22 00:29 cvlayer/palette/__init__.py
+-rw-r--r--  2.0 unx      511 b- defN 23-Sep-22 00:29 cvlayer/palette/basic.py
+-rw-r--r--  2.0 unx     4656 b- defN 23-Sep-22 00:29 cvlayer/palette/css4.py
+-rw-r--r--  2.0 unx     4612 b- defN 23-Sep-22 00:29 cvlayer/palette/extended.py
+-rw-r--r--  2.0 unx     8449 b- defN 23-Sep-22 00:29 cvlayer/palette/flat.py
+-rw-r--r--  2.0 unx      291 b- defN 23-Sep-22 00:29 cvlayer/palette/tableau.py
+-rw-r--r--  2.0 unx    32876 b- defN 23-Sep-22 00:29 cvlayer/palette/xkcd.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Sep-22 00:29 cvlayer/shape/__init__.py
+-rw-r--r--  2.0 unx     1654 b- defN 23-Sep-22 00:29 cvlayer/shape/points.py
+-rw-r--r--  2.0 unx     1509 b- defN 23-Sep-22 00:29 cvlayer/shape/polygons.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Sep-22 00:29 cvlayer/tk/__init__.py
+-rw-r--r--  2.0 unx     4334 b- defN 23-Sep-22 00:29 cvlayer/tk/tk_window.py
+-rw-r--r--  2.0 unx      825 b- defN 23-Sep-22 00:29 cvlayer/typing/__init__.py
+-rw-r--r--  2.0 unx      123 b- defN 23-Sep-22 00:29 cvlayer/typing/color.py
+-rw-r--r--  2.0 unx      905 b- defN 23-Sep-22 00:29 cvlayer/typing/geomerty.py
+-rw-r--r--  2.0 unx      240 b- defN 23-Sep-22 00:29 cvlayer/typing/np.py
+-rw-r--r--  2.0 unx     1065 b- defN 23-Sep-22 00:29 cvlayer-0.9.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     4650 b- defN 23-Sep-22 00:29 cvlayer-0.9.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Sep-22 00:29 cvlayer-0.9.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        8 b- defN 23-Sep-22 00:29 cvlayer-0.9.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     8589 b- defN 23-Sep-22 00:29 cvlayer-0.9.0.dist-info/RECORD
+107 files, 331709 bytes uncompressed, 87552 bytes compressed:  73.6%
```

## zipnote {}

```diff
@@ -1,13 +1,16 @@
 Filename: cvlayer/__init__.py
 Comment: 
 
 Filename: cvlayer/cvlayer.py
 Comment: 
 
+Filename: cvlayer/cvwindow.py
+Comment: 
+
 Filename: cvlayer/chrono/__init__.py
 Comment: 
 
 Filename: cvlayer/chrono/datetime_filename.py
 Comment: 
 
 Filename: cvlayer/cv/__init__.py
@@ -18,14 +21,17 @@
 
 Filename: cvlayer/cv/aspect_ratio.py
 Comment: 
 
 Filename: cvlayer/cv/backend.py
 Comment: 
 
+Filename: cvlayer/cv/basic.py
+Comment: 
+
 Filename: cvlayer/cv/bgsub.py
 Comment: 
 
 Filename: cvlayer/cv/bitwise.py
 Comment: 
 
 Filename: cvlayer/cv/border.py
@@ -84,14 +90,20 @@
 
 Filename: cvlayer/cv/hsv.py
 Comment: 
 
 Filename: cvlayer/cv/image_crop.py
 Comment: 
 
+Filename: cvlayer/cv/image_flip.py
+Comment: 
+
+Filename: cvlayer/cv/image_io.py
+Comment: 
+
 Filename: cvlayer/cv/image_make.py
 Comment: 
 
 Filename: cvlayer/cv/image_move.py
 Comment: 
 
 Filename: cvlayer/cv/image_resize.py
@@ -132,23 +144,29 @@
 
 Filename: cvlayer/cv/palette.py
 Comment: 
 
 Filename: cvlayer/cv/perspective.py
 Comment: 
 
+Filename: cvlayer/cv/plot.py
+Comment: 
+
 Filename: cvlayer/cv/rotate_tracer.py
 Comment: 
 
 Filename: cvlayer/cv/sobel.py
 Comment: 
 
 Filename: cvlayer/cv/stabilizer.py
 Comment: 
 
+Filename: cvlayer/cv/stack.py
+Comment: 
+
 Filename: cvlayer/cv/threshold.py
 Comment: 
 
 Filename: cvlayer/cv/tracker.py
 Comment: 
 
 Filename: cvlayer/cv/tracking.py
@@ -159,14 +177,20 @@
 
 Filename: cvlayer/cv/video_writer.py
 Comment: 
 
 Filename: cvlayer/cv/window.py
 Comment: 
 
+Filename: cvlayer/debug/__init__.py
+Comment: 
+
+Filename: cvlayer/debug/avg_stat.py
+Comment: 
+
 Filename: cvlayer/geometry/__init__.py
 Comment: 
 
 Filename: cvlayer/geometry/find_nearset_point.py
 Comment: 
 
 Filename: cvlayer/geometry/flatten.py
@@ -276,32 +300,23 @@
 
 Filename: cvlayer/typing/geomerty.py
 Comment: 
 
 Filename: cvlayer/typing/np.py
 Comment: 
 
-Filename: cvlayer/vio/__init__.py
-Comment: 
-
-Filename: cvlayer/vio/vio.py
-Comment: 
-
-Filename: cvlayer/vio/vio_interface.py
-Comment: 
-
-Filename: cvlayer-0.8.0.dist-info/LICENSE
+Filename: cvlayer-0.9.0.dist-info/LICENSE
 Comment: 
 
-Filename: cvlayer-0.8.0.dist-info/METADATA
+Filename: cvlayer-0.9.0.dist-info/METADATA
 Comment: 
 
-Filename: cvlayer-0.8.0.dist-info/WHEEL
+Filename: cvlayer-0.9.0.dist-info/WHEEL
 Comment: 
 
-Filename: cvlayer-0.8.0.dist-info/top_level.txt
+Filename: cvlayer-0.9.0.dist-info/top_level.txt
 Comment: 
 
-Filename: cvlayer-0.8.0.dist-info/RECORD
+Filename: cvlayer-0.9.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## cvlayer/__init__.py

```diff
@@ -1,9 +1,11 @@
 # -*- coding: utf-8 -*-
 
 from cvlayer.cvlayer import CvLayer
+from cvlayer.cvwindow import CvWindow
 
-__version__ = "0.8.0"
+__version__ = "0.9.0"
 __all__ = [
     "__version__",
     "CvLayer",
+    "CvWindow",
 ]
```

## cvlayer/cvlayer.py

```diff
@@ -1,12 +1,13 @@
 # -*- coding: utf-8 -*-
 
 from cvlayer.cv.angle import CvlAngle
 from cvlayer.cv.aspect_ratio import CvlAspectRatio
 from cvlayer.cv.backend import CvlBackend
+from cvlayer.cv.basic import CvlBasic
 from cvlayer.cv.bgsub import CvlBackgroundSubtractor
 from cvlayer.cv.bitwise import CvlBitwise
 from cvlayer.cv.canny import CvlCanny
 from cvlayer.cv.contours import CvlContours
 from cvlayer.cv.contours_edge import CvlContoursEdge
 from cvlayer.cv.contours_intersection import CvlContoursIntersection
 from cvlayer.cv.convert_scale_abs import CvlConvertScaleAbs
@@ -17,14 +18,16 @@
 from cvlayer.cv.drawable_contours import CvlDrawableContours
 from cvlayer.cv.fourcc import CvlFourcc
 from cvlayer.cv.fourier_transform import CvlFourierTransform
 from cvlayer.cv.histogram import CvlHistogram
 from cvlayer.cv.hough_lines import CvlHoughLines
 from cvlayer.cv.hsv import CvlHsv
 from cvlayer.cv.image_crop import CvlImageCrop
+from cvlayer.cv.image_flip import CvlImageFlip
+from cvlayer.cv.image_io import CvlImageIo
 from cvlayer.cv.image_make import CvlImageMake
 from cvlayer.cv.image_move import CvlImageMove
 from cvlayer.cv.image_resize import CvlImageResize
 from cvlayer.cv.in_range import CvlInRange
 from cvlayer.cv.intrusion_detection import CvlIntrusionDetection
 from cvlayer.cv.iou import CvlIou
 from cvlayer.cv.keymap import CvlKeymap
@@ -32,27 +35,30 @@
 from cvlayer.cv.match_template import CvlMatchTemplate
 from cvlayer.cv.matcher import CvlMatcher
 from cvlayer.cv.morphology import CvlMorphology
 from cvlayer.cv.norm import CvlNorm
 from cvlayer.cv.orb import CvlOrb
 from cvlayer.cv.palette import CvlPalette
 from cvlayer.cv.perspective import CvlPerspective
+from cvlayer.cv.plot import CvlPlot
 from cvlayer.cv.rotate_tracer import CvlRotateTracer
 from cvlayer.cv.sobel import CvlSobel
+from cvlayer.cv.stack import CvlStack
 from cvlayer.cv.threshold import CvlThreshold
 from cvlayer.cv.tracker import CvlTracker
 from cvlayer.cv.video_capture import CvlVideoCapture
 from cvlayer.cv.video_writer import CvlVideoWriter
 from cvlayer.cv.window import CvlWindow
 
 
 class CvLayer(
     CvlAngle,
     CvlAspectRatio,
     CvlBackend,
+    CvlBasic,
     CvlBackgroundSubtractor,
     CvlBitwise,
     CvlCanny,
     CvlContours,
     CvlContoursEdge,
     CvlContoursIntersection,
     CvlConvertScaleAbs,
@@ -62,14 +68,16 @@
     CvlDrawableContours,
     CvlFourcc,
     CvlFourierTransform,
     CvlHistogram,
     CvlHoughLines,
     CvlHsv,
     CvlImageCrop,
+    CvlImageFlip,
+    CvlImageIo,
     CvlImageMake,
     CvlImageMove,
     CvlImageResize,
     CvlInRange,
     CvlIntrusionDetection,
     CvlIou,
     CvlKeymap,
@@ -77,17 +85,19 @@
     CvlMatchTemplate,
     CvlMatcher,
     CvlMorphology,
     CvlNorm,
     CvlOrb,
     CvlPalette,
     CvlPerspective,
+    CvlPlot,
     CvlRotateTracer,
     CvlShapely,
     CvlSobel,
+    CvlStack,
     CvlThreshold,
     CvlTracker,
     CvlVideoCapture,
     CvlVideoWriter,
     CvlWindow,
 ):
     pass
```

## cvlayer/cv/bgsub.py

```diff
@@ -1,11 +1,12 @@
 # -*- coding: utf-8 -*-
 
 from enum import Enum, auto, unique
-from typing import Any, Final, Optional
+from os import path
+from typing import Any, Final, List, Optional
 
 import cv2
 from numpy import zeros
 from numpy.typing import NDArray
 
 
 @unique
@@ -18,20 +19,26 @@
     # bgsegm_LSBP = auto()
     # bgsegm_MOG = auto()
     # cuda_FGD = auto()
     # cuda_GMG = auto()
     # cuda_MOG = auto()
 
 
-DEFAULT_METHOD: Final[BackgroundSubtractorMethod] = BackgroundSubtractorMethod.MOG2
 DEFAULT_HISTORY: Final[int] = 500
 DEFAULT_MOG2_THRESHOLD: Final[float] = 16.0
 DEFAULT_KNN_THRESHOLD: Final[float] = 400.0
 DEFAULT_DETECT_SHADOWS: Final[bool] = True
 
+BGSUB_CREATE_METHOD_PREFIX: Final[str] = "createBackgroundSubtractor"
+BGSUB_CREATE_METHOD_SUFFIX: Final[str] = ""
+
+
+def find_background_subtractor() -> List[str]:
+    return list(filter(lambda x: x.startswith(BGSUB_CREATE_METHOD_PREFIX), dir(cv2)))
+
 
 def create_background_subtractor(
     method: BackgroundSubtractorMethod,
     history: int,
     threshold: float,
     shadow: bool,
 ) -> Any:
@@ -57,106 +64,362 @@
     else:
         assert False, "Inaccessible section"
 
 
 class BackgroundSubtractor:
     def __init__(
         self,
-        method=DEFAULT_METHOD,
+        method: BackgroundSubtractorMethod,
         history=DEFAULT_HISTORY,
         threshold: Optional[float] = None,
         shadow=DEFAULT_DETECT_SHADOWS,
     ):
-        self._method = method
-        self._foreground_mask = zeros(0)
-        self._background_subtractor = create_background_subtractor(
-            self._method,
-            history,
-            default_threshold(method, threshold),
-            shadow,
+        self._fgmask = zeros([])
+        self._bgsub = create_background_subtractor(
+            method, history, default_threshold(method, threshold), shadow
         )
 
-        assert hasattr(self._background_subtractor, "apply")
-        assert hasattr(self._background_subtractor, "clear")
-        assert hasattr(self._background_subtractor, "empty")
-        assert hasattr(self._background_subtractor, "getBackgroundImage")
-        assert hasattr(self._background_subtractor, "getBackgroundRatio")
-        assert hasattr(self._background_subtractor, "getComplexityReductionThreshold")
-        assert hasattr(self._background_subtractor, "getDefaultName")
-        assert hasattr(self._background_subtractor, "getDetectShadows")
-        assert hasattr(self._background_subtractor, "getHistory")
-        assert hasattr(self._background_subtractor, "getNMixtures")
-        assert hasattr(self._background_subtractor, "getShadowThreshold")
-        assert hasattr(self._background_subtractor, "getShadowValue")
-        assert hasattr(self._background_subtractor, "getVarInit")
-        assert hasattr(self._background_subtractor, "getVarMax")
-        assert hasattr(self._background_subtractor, "getVarMin")
-        assert hasattr(self._background_subtractor, "getVarThreshold")
-        assert hasattr(self._background_subtractor, "getVarThresholdGen")
-        assert hasattr(self._background_subtractor, "read")
-        assert hasattr(self._background_subtractor, "save")
-        assert hasattr(self._background_subtractor, "setBackgroundRatio")
-        assert hasattr(self._background_subtractor, "setComplexityReductionThreshold")
-        assert hasattr(self._background_subtractor, "setDetectShadows")
-        assert hasattr(self._background_subtractor, "setHistory")
-        assert hasattr(self._background_subtractor, "setNMixtures")
-        assert hasattr(self._background_subtractor, "setShadowThreshold")
-        assert hasattr(self._background_subtractor, "setShadowValue")
-        assert hasattr(self._background_subtractor, "setVarInit")
-        assert hasattr(self._background_subtractor, "setVarMax")
-        assert hasattr(self._background_subtractor, "setVarMin")
-        assert hasattr(self._background_subtractor, "setVarThreshold")
-        assert hasattr(self._background_subtractor, "setVarThresholdGen")
-        assert hasattr(self._background_subtractor, "write")
-        # print(dir(self._background_subtractor))
+        # Algorithm
+        assert hasattr(self._bgsub, "clear")
+        assert hasattr(self._bgsub, "empty")
+        assert hasattr(self._bgsub, "getDefaultName")
+        assert hasattr(self._bgsub, "read")
+        assert hasattr(self._bgsub, "save")
+        assert hasattr(self._bgsub, "write")
+
+        # BackgroundSubtractor
+        assert hasattr(self._bgsub, "apply")
+        assert hasattr(self._bgsub, "getBackgroundImage")
+
+    @property
+    def foreground_mask(self) -> NDArray:
+        """Foreground mask as an 8-bit binary image"""
+        return self._fgmask
+
+    def clear(self) -> None:
+        """Clears the algorithm state"""
+        assert isinstance(self._bgsub, cv2.Algorithm)
+        self._bgsub.clear()
+
+    @property
+    def empty(self) -> bool:
+        """
+        Returns true if the Algorithm is empty.
+        e.g. in the very beginning or after unsuccessful read.
+        """
+        assert isinstance(self._bgsub, cv2.Algorithm)
+        return self._bgsub.empty()
+
+    @property
+    def default_name(self) -> str:
+        assert isinstance(self._bgsub, cv2.Algorithm)
+        return self._bgsub.getDefaultName()
+
+    def read(self, node: cv2.FileNode) -> None:
+        assert isinstance(self._bgsub, cv2.Algorithm)
+        self._bgsub.read(node)
+
+    def write(self, storage: cv2.FileStorage, name: Optional[str] = None) -> None:
+        assert isinstance(self._bgsub, cv2.Algorithm)
+        if name is not None:
+            self._bgsub.write(storage, name)
+        else:
+            self._bgsub.write(storage)
+
+    def save(self, filename: str) -> None:
+        assert isinstance(self._bgsub, cv2.Algorithm)
+        self._bgsub.save(filename)
+
+    def load(self, filename: str, name: Optional[str] = None) -> None:
+        assert isinstance(self._bgsub, cv2.Algorithm)
+        if not path.isfile(filename):
+            raise FileNotFoundError(f"File not found error: '{filename}'")
+
+        storage = cv2.FileStorage(filename, cv2.FILE_STORAGE_READ)
+        if not storage.isOpened():
+            raise EOFError("File is not opened error")
+
+        try:
+            node = storage.getNode(name) if name else storage.getFirstTopLevelNode()
+            self._bgsub.read(node)
+        finally:
+            storage.release()
+
+    def apply(self, image: NDArray, learning_rate=-1) -> NDArray:
+        """
+        Computes a foreground mask.
+
+        :param image: Next video frame.
+        :param learning_rate: The value between 0 and 1 that indicates
+            how fast the background model is learnt. Negative parameter value makes
+            the algorithm to use some automatically chosen learning rate.
+            0 means that the background model is not updated at all,
+            1 means that the background model is completely reinitialized from the
+            last frame.
+        """
+        assert isinstance(self._bgsub, cv2.BackgroundSubtractor)
+        self._fgmask = self._bgsub.apply(image, None, learning_rate)
+        return self._fgmask
+
+    @property
+    def background(self) -> NDArray:
+        """Computes a background image"""
+        assert isinstance(self._bgsub, cv2.BackgroundSubtractor)
+        return self._bgsub.getBackgroundImage()
+
+
+class BackgroundSubtractorKNN(BackgroundSubtractor):
+    def __init__(
+        self,
+        history=DEFAULT_HISTORY,
+        threshold=DEFAULT_KNN_THRESHOLD,
+        shadow=DEFAULT_DETECT_SHADOWS,
+    ):
+        super().__init__(BackgroundSubtractorMethod.KNN, history, threshold, shadow)
+
+        assert hasattr(self._bgsub, "getDetectShadows")
+        assert hasattr(self._bgsub, "getDist2Threshold")
+        assert hasattr(self._bgsub, "getHistory")
+        assert hasattr(self._bgsub, "getkNNSamples")
+        assert hasattr(self._bgsub, "getNSamples")
+        assert hasattr(self._bgsub, "getShadowThreshold")
+        assert hasattr(self._bgsub, "getShadowValue")
+
+        assert hasattr(self._bgsub, "setDetectShadows")
+        assert hasattr(self._bgsub, "setDist2Threshold")
+        assert hasattr(self._bgsub, "setHistory")
+        assert hasattr(self._bgsub, "setkNNSamples")
+        assert hasattr(self._bgsub, "setNSamples")
+        assert hasattr(self._bgsub, "setShadowThreshold")
+        assert hasattr(self._bgsub, "setShadowValue")
+
+    @property
+    def detect_shadows(self) -> bool:
+        """Returns the shadow detection flag"""
+        return self._bgsub.getDetectShadows()
+
+    @detect_shadows.setter
+    def detect_shadows(self, value: bool) -> None:
+        self._bgsub.setDetectShadows(value)
+
+    @property
+    def dist2_threshold(self) -> float:
+        """
+        Returns the threshold on the squared distance between the pixel and the sample.
+        """
+        return self._bgsub.getDist2Threshold()
+
+    @dist2_threshold.setter
+    def dist2_threshold(self, value: float) -> None:
+        self._bgsub.setDist2Threshold(value)
+
+    @property
+    def history(self) -> int:
+        """Returns the number of last frames that affect the background model"""
+        return self._bgsub.getHistory()
+
+    @history.setter
+    def history(self, value: int) -> None:
+        self._bgsub.setHistory(value)
+
+    @property
+    def knn_samples(self) -> int:
+        """Returns the number of neighbours, the k in the kNN"""
+        return self._bgsub.getkNNSamples()
+
+    @knn_samples.setter
+    def knn_samples(self, value: int) -> None:
+        self._bgsub.setkNNSamples(value)
+
+    @property
+    def number_samples(self) -> int:
+        """Returns the number of data samples in the background model"""
+        return self._bgsub.getNSamples()
+
+    @number_samples.setter
+    def number_samples(self, value: int) -> None:
+        self._bgsub.setNSamples(value)
+
+    @property
+    def shadow_threshold(self) -> float:
+        """Returns the shadow threshold"""
+        return self._bgsub.getShadowThreshold()
+
+    @shadow_threshold.setter
+    def shadow_threshold(self, value: float) -> None:
+        self._bgsub.setShadowThreshold(value)
+
+    @property
+    def shadow_value(self) -> int:
+        """Returns the shadow value"""
+        return self._bgsub.getShadowValue()
+
+    @shadow_value.setter
+    def shadow_value(self, value: int) -> None:
+        self._bgsub.setShadowValue(value)
+
+
+class BackgroundSubtractorMOG2(BackgroundSubtractor):
+    def __init__(
+        self,
+        history=DEFAULT_HISTORY,
+        threshold=DEFAULT_MOG2_THRESHOLD,
+        shadow=DEFAULT_DETECT_SHADOWS,
+    ):
+        super().__init__(BackgroundSubtractorMethod.MOG2, history, threshold, shadow)
+
+        assert hasattr(self._bgsub, "getBackgroundRatio")
+        assert hasattr(self._bgsub, "getComplexityReductionThreshold")
+        assert hasattr(self._bgsub, "getDetectShadows")
+        assert hasattr(self._bgsub, "getHistory")
+        assert hasattr(self._bgsub, "getNMixtures")
+        assert hasattr(self._bgsub, "getShadowThreshold")
+        assert hasattr(self._bgsub, "getShadowValue")
+        assert hasattr(self._bgsub, "getVarInit")
+        assert hasattr(self._bgsub, "getVarMax")
+        assert hasattr(self._bgsub, "getVarMin")
+        assert hasattr(self._bgsub, "getVarThreshold")
+        assert hasattr(self._bgsub, "getVarThresholdGen")
+
+        assert hasattr(self._bgsub, "setBackgroundRatio")
+        assert hasattr(self._bgsub, "setComplexityReductionThreshold")
+        assert hasattr(self._bgsub, "setDetectShadows")
+        assert hasattr(self._bgsub, "setHistory")
+        assert hasattr(self._bgsub, "setNMixtures")
+        assert hasattr(self._bgsub, "setShadowThreshold")
+        assert hasattr(self._bgsub, "setShadowValue")
+        assert hasattr(self._bgsub, "setVarInit")
+        assert hasattr(self._bgsub, "setVarMax")
+        assert hasattr(self._bgsub, "setVarMin")
+        assert hasattr(self._bgsub, "setVarThreshold")
+        assert hasattr(self._bgsub, "setVarThresholdGen")
+
+    @property
+    def background_ratio(self) -> float:
+        """Returns the "background ratio" parameter of the algorithm"""
+        return self._bgsub.getBackgroundRatio()
+
+    @background_ratio.setter
+    def background_ratio(self, value: float) -> None:
+        self._bgsub.setBackgroundRatio(value)
+
+    @property
+    def complexity_reduction_threshold(self) -> float:
+        """Returns the complexity reduction threshold"""
+        return self._bgsub.getComplexityReductionThreshold()
+
+    @complexity_reduction_threshold.setter
+    def complexity_reduction_threshold(self, value: float) -> None:
+        self._bgsub.setComplexityReductionThreshold(value)
 
     @property
-    def method(self) -> BackgroundSubtractorMethod:
-        return self._method
+    def detect_shadows(self) -> bool:
+        """Returns the shadow detection flag"""
+        return self._bgsub.getDetectShadows()
+
+    @detect_shadows.setter
+    def detect_shadows(self, value: bool) -> None:
+        self._bgsub.setDetectShadows(value)
 
     @property
     def history(self) -> int:
-        return self._background_subtractor.getHistory()
+        """Returns the number of last frames that affect the background model"""
+        return self._bgsub.getHistory()
 
     @history.setter
     def history(self, value: int) -> None:
-        self._background_subtractor.setHistory(value)
+        self._bgsub.setHistory(value)
 
     @property
-    def threshold(self) -> float:
-        return self._background_subtractor.getVarThreshold()
+    def number_mixtures(self) -> int:
+        """Returns the number of gaussian components in the background model"""
+        return self._bgsub.getNMixtures()
+
+    @number_mixtures.setter
+    def number_mixtures(self, value: int) -> None:
+        self._bgsub.setNMixtures(value)
 
-    @threshold.setter
-    def threshold(self, value: float) -> None:
-        self._background_subtractor.setVarThreshold(value)
+    @property
+    def shadow_threshold(self) -> float:
+        """Returns the shadow threshold"""
+        return self._bgsub.getShadowThreshold()
+
+    @shadow_threshold.setter
+    def shadow_threshold(self, value: float) -> None:
+        self._bgsub.setShadowThreshold(value)
 
     @property
-    def shadow(self) -> bool:
-        return self._background_subtractor.getShadowValue()
+    def shadow_value(self) -> int:
+        """Returns the shadow value"""
+        return self._bgsub.getShadowValue()
+
+    @shadow_value.setter
+    def shadow_value(self, value: int) -> None:
+        self._bgsub.setShadowValue(value)
 
-    @shadow.setter
-    def shadow(self, value: bool) -> None:
-        self._background_subtractor.setShadowValue(value)
+    @property
+    def var_init(self) -> float:
+        """Returns the initial variance of each gaussian component"""
+        return self._bgsub.getVarInit()
+
+    @var_init.setter
+    def var_init(self, value: float) -> None:
+        self._bgsub.setVarInit(value)
 
     @property
-    def background(self) -> NDArray:
-        return self._background_subtractor.getBackgroundImage()
+    def var_max(self) -> float:
+        return self._bgsub.getVarMax()
+
+    @var_max.setter
+    def var_max(self, value: float) -> None:
+        self._bgsub.setVarMax(value)
 
     @property
-    def foreground_mask(self) -> NDArray:
-        return self._foreground_mask
+    def var_min(self) -> float:
+        return self._bgsub.getVarMin()
 
-    def apply(self, frame: NDArray) -> NDArray:
-        self._foreground_mask = self._background_subtractor.apply(frame)
-        assert self._foreground_mask is not None
-        return self._foreground_mask
+    @var_min.setter
+    def var_min(self, value: float) -> None:
+        self._bgsub.setVarMin(value)
+
+    @property
+    def var_threshold(self) -> float:
+        """Returns the variance threshold for the pixel-model match"""
+        return self._bgsub.getVarThreshold()
+
+    @var_threshold.setter
+    def var_threshold(self, value: float) -> None:
+        self._bgsub.setVarThreshold(value)
+
+    @property
+    def var_threshold_gen(self) -> float:
+        """
+        Returns the variance threshold for the pixel-model match used
+        for new mixture component generation.
+        """
+        return self._bgsub.getVarThresholdGen()
+
+    @var_threshold_gen.setter
+    def var_threshold_gen(self, value: float) -> None:
+        self._bgsub.setVarThresholdGen(value)
 
 
 class CvlBackgroundSubtractor:
     @staticmethod
-    def cvl_create_background_subtractor(
-        method=DEFAULT_METHOD,
+    def cvl_create_background_subtractor_knn(
         history=DEFAULT_HISTORY,
-        threshold: Optional[float] = None,
+        threshold=DEFAULT_KNN_THRESHOLD,
+        shadow=DEFAULT_DETECT_SHADOWS,
+    ):
+        return BackgroundSubtractorKNN(history, threshold, shadow)
+
+    @staticmethod
+    def cvl_create_background_subtractor_mog2(
+        history=DEFAULT_HISTORY,
+        threshold=DEFAULT_MOG2_THRESHOLD,
         shadow=DEFAULT_DETECT_SHADOWS,
     ):
-        return BackgroundSubtractor(method, history, threshold, shadow)
+        return BackgroundSubtractorMOG2(history, threshold, shadow)
+
+
+if __name__ == "__main__":
+    print(f"Available background subtractor: {find_background_subtractor()}")
```

## cvlayer/cv/contours_edge.py

```diff
@@ -28,14 +28,30 @@
     contour: NDArray,
 ) -> PolygonT:
     points = filter_callable(contour)[:, 0, :].tolist()
     assert isinstance(points, list)
     return [(p[0], p[1]) for p in points] if points else []
 
 
+def find_leftmost_point(contour: NDArray):
+    return tuple(contour[contour[:, :, 0].argmin()][0])
+
+
+def find_rightmost_point(contour: NDArray):
+    return tuple(contour[contour[:, :, 0].argmax()][0])
+
+
+def find_topmost_point(contour: NDArray):
+    return tuple(contour[contour[:, :, 1].argmin()][0])
+
+
+def find_bottommost_point(contour: NDArray):
+    return tuple(contour[contour[:, :, 1].argmax()][0])
+
+
 def _left_edge_filter(contour: NDArray) -> NDArray:
     value = contour[:, 0, 0].min()  # noqa
     return contour[contour[:, 0, 0] == value]
 
 
 def _right_edge_filter(contour: NDArray) -> NDArray:
     value = contour[:, 0, 0].max()  # noqa
```

## cvlayer/cv/cvt_color.py

```diff
@@ -1,53 +1,400 @@
 # -*- coding: utf-8 -*-
 
-from enum import Enum, unique
+from enum import Enum
 
 import cv2
+from numpy.typing import NDArray
 
-from cvlayer.typing.np import Image
 
-
-@unique
 class CvtColorCode(Enum):
+    BGR2BGRA = cv2.COLOR_BGR2BGRA
+    RGB2RGBA = cv2.COLOR_RGB2RGBA
+    BGRA2BGR = cv2.COLOR_BGRA2BGR
+    RGBA2RGB = cv2.COLOR_RGBA2RGB
+    BGR2RGBA = cv2.COLOR_BGR2RGBA
+    RGB2BGRA = cv2.COLOR_RGB2BGRA
+    RGBA2BGR = cv2.COLOR_RGBA2BGR
+    BGRA2RGB = cv2.COLOR_BGRA2RGB
+    BGR2RGB = cv2.COLOR_BGR2RGB
+    RGB2BGR = cv2.COLOR_RGB2BGR
+    BGRA2RGBA = cv2.COLOR_BGRA2RGBA
+    RGBA2BGRA = cv2.COLOR_RGBA2BGRA
     BGR2GRAY = cv2.COLOR_BGR2GRAY
+    RGB2GRAY = cv2.COLOR_RGB2GRAY
     GRAY2BGR = cv2.COLOR_GRAY2BGR
-
+    GRAY2RGB = cv2.COLOR_GRAY2RGB
+    GRAY2BGRA = cv2.COLOR_GRAY2BGRA
+    GRAY2RGBA = cv2.COLOR_GRAY2RGBA
+    BGRA2GRAY = cv2.COLOR_BGRA2GRAY
+    RGBA2GRAY = cv2.COLOR_RGBA2GRAY
+    BGR2BGR565 = cv2.COLOR_BGR2BGR565
+    RGB2BGR565 = cv2.COLOR_RGB2BGR565
+    BGR5652BGR = cv2.COLOR_BGR5652BGR
+    BGR5652RGB = cv2.COLOR_BGR5652RGB
+    BGRA2BGR565 = cv2.COLOR_BGRA2BGR565
+    RGBA2BGR565 = cv2.COLOR_RGBA2BGR565
+    BGR5652BGRA = cv2.COLOR_BGR5652BGRA
+    BGR5652RGBA = cv2.COLOR_BGR5652RGBA
+    GRAY2BGR565 = cv2.COLOR_GRAY2BGR565
+    BGR5652GRAY = cv2.COLOR_BGR5652GRAY
+    BGR2BGR555 = cv2.COLOR_BGR2BGR555
+    RGB2BGR555 = cv2.COLOR_RGB2BGR555
+    BGR5552BGR = cv2.COLOR_BGR5552BGR
+    BGR5552RGB = cv2.COLOR_BGR5552RGB
+    BGRA2BGR555 = cv2.COLOR_BGRA2BGR555
+    RGBA2BGR555 = cv2.COLOR_RGBA2BGR555
+    BGR5552BGRA = cv2.COLOR_BGR5552BGRA
+    BGR5552RGBA = cv2.COLOR_BGR5552RGBA
+    GRAY2BGR555 = cv2.COLOR_GRAY2BGR555
+    BGR5552GRAY = cv2.COLOR_BGR5552GRAY
+    BGR2XYZ = cv2.COLOR_BGR2XYZ
+    RGB2XYZ = cv2.COLOR_RGB2XYZ
+    XYZ2BGR = cv2.COLOR_XYZ2BGR
+    XYZ2RGB = cv2.COLOR_XYZ2RGB
+    BGR2YCrCb = cv2.COLOR_BGR2YCrCb
+    BGR2YCR_CB = cv2.COLOR_BGR2YCR_CB
+    RGB2YCrCb = cv2.COLOR_RGB2YCrCb
+    RGB2YCR_CB = cv2.COLOR_RGB2YCR_CB
+    YCrCb2BGR = cv2.COLOR_YCrCb2BGR
+    YCR_CB2BGR = cv2.COLOR_YCR_CB2BGR
+    YCrCb2RGB = cv2.COLOR_YCrCb2RGB
+    YCR_CB2RGB = cv2.COLOR_YCR_CB2RGB
     BGR2HSV = cv2.COLOR_BGR2HSV
+    RGB2HSV = cv2.COLOR_RGB2HSV
+    BGR2Lab = cv2.COLOR_BGR2Lab
+    BGR2LAB = cv2.COLOR_BGR2LAB
+    RGB2Lab = cv2.COLOR_RGB2Lab
+    RGB2LAB = cv2.COLOR_RGB2LAB
+    BGR2Luv = cv2.COLOR_BGR2Luv
+    BGR2LUV = cv2.COLOR_BGR2LUV
+    RGB2Luv = cv2.COLOR_RGB2Luv
+    RGB2LUV = cv2.COLOR_RGB2LUV
+    BGR2HLS = cv2.COLOR_BGR2HLS
+    RGB2HLS = cv2.COLOR_RGB2HLS
     HSV2BGR = cv2.COLOR_HSV2BGR
-
+    HSV2RGB = cv2.COLOR_HSV2RGB
+    Lab2BGR = cv2.COLOR_Lab2BGR
+    LAB2BGR = cv2.COLOR_LAB2BGR
+    Lab2RGB = cv2.COLOR_Lab2RGB
+    LAB2RGB = cv2.COLOR_LAB2RGB
+    Luv2BGR = cv2.COLOR_Luv2BGR
+    LUV2BGR = cv2.COLOR_LUV2BGR
+    Luv2RGB = cv2.COLOR_Luv2RGB
+    LUV2RGB = cv2.COLOR_LUV2RGB
+    HLS2BGR = cv2.COLOR_HLS2BGR
+    HLS2RGB = cv2.COLOR_HLS2RGB
+    BGR2HSV_FULL = cv2.COLOR_BGR2HSV_FULL
+    RGB2HSV_FULL = cv2.COLOR_RGB2HSV_FULL
+    BGR2HLS_FULL = cv2.COLOR_BGR2HLS_FULL
+    RGB2HLS_FULL = cv2.COLOR_RGB2HLS_FULL
+    HSV2BGR_FULL = cv2.COLOR_HSV2BGR_FULL
+    HSV2RGB_FULL = cv2.COLOR_HSV2RGB_FULL
+    HLS2BGR_FULL = cv2.COLOR_HLS2BGR_FULL
+    HLS2RGB_FULL = cv2.COLOR_HLS2RGB_FULL
+    LBGR2Lab = cv2.COLOR_LBGR2Lab
+    LBGR2LAB = cv2.COLOR_LBGR2LAB
+    LRGB2Lab = cv2.COLOR_LRGB2Lab
+    LRGB2LAB = cv2.COLOR_LRGB2LAB
+    LBGR2Luv = cv2.COLOR_LBGR2Luv
+    LBGR2LUV = cv2.COLOR_LBGR2LUV
+    LRGB2Luv = cv2.COLOR_LRGB2Luv
+    LRGB2LUV = cv2.COLOR_LRGB2LUV
+    Lab2LBGR = cv2.COLOR_Lab2LBGR
+    LAB2LBGR = cv2.COLOR_LAB2LBGR
+    Lab2LRGB = cv2.COLOR_Lab2LRGB
+    LAB2LRGB = cv2.COLOR_LAB2LRGB
+    Luv2LBGR = cv2.COLOR_Luv2LBGR
+    LUV2LBGR = cv2.COLOR_LUV2LBGR
+    Luv2LRGB = cv2.COLOR_Luv2LRGB
+    LUV2LRGB = cv2.COLOR_LUV2LRGB
     BGR2YUV = cv2.COLOR_BGR2YUV
+    RGB2YUV = cv2.COLOR_RGB2YUV
     YUV2BGR = cv2.COLOR_YUV2BGR
+    YUV2RGB = cv2.COLOR_YUV2RGB
+    YUV2RGB_NV12 = cv2.COLOR_YUV2RGB_NV12
+    YUV2BGR_NV12 = cv2.COLOR_YUV2BGR_NV12
+    YUV2RGB_NV21 = cv2.COLOR_YUV2RGB_NV21
+    YUV2BGR_NV21 = cv2.COLOR_YUV2BGR_NV21
+    YUV420sp2RGB = cv2.COLOR_YUV420sp2RGB
+    YUV420SP2RGB = cv2.COLOR_YUV420SP2RGB
+    YUV420sp2BGR = cv2.COLOR_YUV420sp2BGR
+    YUV420SP2BGR = cv2.COLOR_YUV420SP2BGR
+    YUV2RGBA_NV12 = cv2.COLOR_YUV2RGBA_NV12
+    YUV2BGRA_NV12 = cv2.COLOR_YUV2BGRA_NV12
+    YUV2RGBA_NV21 = cv2.COLOR_YUV2RGBA_NV21
+    YUV2BGRA_NV21 = cv2.COLOR_YUV2BGRA_NV21
+    YUV420sp2RGBA = cv2.COLOR_YUV420sp2RGBA
+    YUV420SP2RGBA = cv2.COLOR_YUV420SP2RGBA
+    YUV420sp2BGRA = cv2.COLOR_YUV420sp2BGRA
+    YUV420SP2BGRA = cv2.COLOR_YUV420SP2BGRA
+    YUV2RGB_YV12 = cv2.COLOR_YUV2RGB_YV12
+    YUV2BGR_YV12 = cv2.COLOR_YUV2BGR_YV12
+    YUV2RGB_IYUV = cv2.COLOR_YUV2RGB_IYUV
+    YUV2BGR_IYUV = cv2.COLOR_YUV2BGR_IYUV
+    YUV2RGB_I420 = cv2.COLOR_YUV2RGB_I420
+    YUV2BGR_I420 = cv2.COLOR_YUV2BGR_I420
+    YUV420p2RGB = cv2.COLOR_YUV420p2RGB
+    YUV420P2RGB = cv2.COLOR_YUV420P2RGB
+    YUV420p2BGR = cv2.COLOR_YUV420p2BGR
+    YUV420P2BGR = cv2.COLOR_YUV420P2BGR
+    YUV2RGBA_YV12 = cv2.COLOR_YUV2RGBA_YV12
+    YUV2BGRA_YV12 = cv2.COLOR_YUV2BGRA_YV12
+    YUV2RGBA_IYUV = cv2.COLOR_YUV2RGBA_IYUV
+    YUV2BGRA_IYUV = cv2.COLOR_YUV2BGRA_IYUV
+    YUV2RGBA_I420 = cv2.COLOR_YUV2RGBA_I420
+    YUV2BGRA_I420 = cv2.COLOR_YUV2BGRA_I420
+    YUV420p2RGBA = cv2.COLOR_YUV420p2RGBA
+    YUV420P2RGBA = cv2.COLOR_YUV420P2RGBA
+    YUV420p2BGRA = cv2.COLOR_YUV420p2BGRA
+    YUV420P2BGRA = cv2.COLOR_YUV420P2BGRA
+    YUV2GRAY_420 = cv2.COLOR_YUV2GRAY_420
+    YUV2GRAY_NV21 = cv2.COLOR_YUV2GRAY_NV21
+    YUV2GRAY_NV12 = cv2.COLOR_YUV2GRAY_NV12
+    YUV2GRAY_YV12 = cv2.COLOR_YUV2GRAY_YV12
+    YUV2GRAY_IYUV = cv2.COLOR_YUV2GRAY_IYUV
+    YUV2GRAY_I420 = cv2.COLOR_YUV2GRAY_I420
+    YUV420sp2GRAY = cv2.COLOR_YUV420sp2GRAY
+    YUV420SP2GRAY = cv2.COLOR_YUV420SP2GRAY
+    YUV420p2GRAY = cv2.COLOR_YUV420p2GRAY
+    YUV420P2GRAY = cv2.COLOR_YUV420P2GRAY
+    YUV2RGB_UYVY = cv2.COLOR_YUV2RGB_UYVY
+    YUV2BGR_UYVY = cv2.COLOR_YUV2BGR_UYVY
+    YUV2RGB_Y422 = cv2.COLOR_YUV2RGB_Y422
+    YUV2BGR_Y422 = cv2.COLOR_YUV2BGR_Y422
+    YUV2RGB_UYNV = cv2.COLOR_YUV2RGB_UYNV
+    YUV2BGR_UYNV = cv2.COLOR_YUV2BGR_UYNV
+    YUV2RGBA_UYVY = cv2.COLOR_YUV2RGBA_UYVY
+    YUV2BGRA_UYVY = cv2.COLOR_YUV2BGRA_UYVY
+    YUV2RGBA_Y422 = cv2.COLOR_YUV2RGBA_Y422
+    YUV2BGRA_Y422 = cv2.COLOR_YUV2BGRA_Y422
+    YUV2RGBA_UYNV = cv2.COLOR_YUV2RGBA_UYNV
+    YUV2BGRA_UYNV = cv2.COLOR_YUV2BGRA_UYNV
+    YUV2RGB_YUY2 = cv2.COLOR_YUV2RGB_YUY2
+    YUV2BGR_YUY2 = cv2.COLOR_YUV2BGR_YUY2
+    YUV2RGB_YVYU = cv2.COLOR_YUV2RGB_YVYU
+    YUV2BGR_YVYU = cv2.COLOR_YUV2BGR_YVYU
+    YUV2RGB_YUYV = cv2.COLOR_YUV2RGB_YUYV
+    YUV2BGR_YUYV = cv2.COLOR_YUV2BGR_YUYV
+    YUV2RGB_YUNV = cv2.COLOR_YUV2RGB_YUNV
+    YUV2BGR_YUNV = cv2.COLOR_YUV2BGR_YUNV
+    YUV2RGBA_YUY2 = cv2.COLOR_YUV2RGBA_YUY2
+    YUV2BGRA_YUY2 = cv2.COLOR_YUV2BGRA_YUY2
+    YUV2RGBA_YVYU = cv2.COLOR_YUV2RGBA_YVYU
+    YUV2BGRA_YVYU = cv2.COLOR_YUV2BGRA_YVYU
+    YUV2RGBA_YUYV = cv2.COLOR_YUV2RGBA_YUYV
+    YUV2BGRA_YUYV = cv2.COLOR_YUV2BGRA_YUYV
+    YUV2RGBA_YUNV = cv2.COLOR_YUV2RGBA_YUNV
+    YUV2BGRA_YUNV = cv2.COLOR_YUV2BGRA_YUNV
+    YUV2GRAY_UYVY = cv2.COLOR_YUV2GRAY_UYVY
+    YUV2GRAY_YUY2 = cv2.COLOR_YUV2GRAY_YUY2
+    YUV2GRAY_Y422 = cv2.COLOR_YUV2GRAY_Y422
+    YUV2GRAY_UYNV = cv2.COLOR_YUV2GRAY_UYNV
+    YUV2GRAY_YVYU = cv2.COLOR_YUV2GRAY_YVYU
+    YUV2GRAY_YUYV = cv2.COLOR_YUV2GRAY_YUYV
+    YUV2GRAY_YUNV = cv2.COLOR_YUV2GRAY_YUNV
+    RGBA2mRGBA = cv2.COLOR_RGBA2mRGBA
+    RGBA2M_RGBA = cv2.COLOR_RGBA2M_RGBA
+    mRGBA2RGBA = cv2.COLOR_mRGBA2RGBA
+    M_RGBA2RGBA = cv2.COLOR_M_RGBA2RGBA
+    RGB2YUV_I420 = cv2.COLOR_RGB2YUV_I420
+    BGR2YUV_I420 = cv2.COLOR_BGR2YUV_I420
+    RGB2YUV_IYUV = cv2.COLOR_RGB2YUV_IYUV
+    BGR2YUV_IYUV = cv2.COLOR_BGR2YUV_IYUV
+    RGBA2YUV_I420 = cv2.COLOR_RGBA2YUV_I420
+    BGRA2YUV_I420 = cv2.COLOR_BGRA2YUV_I420
+    RGBA2YUV_IYUV = cv2.COLOR_RGBA2YUV_IYUV
+    BGRA2YUV_IYUV = cv2.COLOR_BGRA2YUV_IYUV
+    RGB2YUV_YV12 = cv2.COLOR_RGB2YUV_YV12
+    BGR2YUV_YV12 = cv2.COLOR_BGR2YUV_YV12
+    RGBA2YUV_YV12 = cv2.COLOR_RGBA2YUV_YV12
+    BGRA2YUV_YV12 = cv2.COLOR_BGRA2YUV_YV12
+    BayerBG2BGR = cv2.COLOR_BayerBG2BGR
+    BAYER_BG2BGR = cv2.COLOR_BAYER_BG2BGR
+    BayerGB2BGR = cv2.COLOR_BayerGB2BGR
+    BAYER_GB2BGR = cv2.COLOR_BAYER_GB2BGR
+    BayerRG2BGR = cv2.COLOR_BayerRG2BGR
+    BAYER_RG2BGR = cv2.COLOR_BAYER_RG2BGR
+    BayerGR2BGR = cv2.COLOR_BayerGR2BGR
+    BAYER_GR2BGR = cv2.COLOR_BAYER_GR2BGR
+    BayerRGGB2BGR = cv2.COLOR_BayerRGGB2BGR
+    BAYER_RGGB2BGR = cv2.COLOR_BAYER_RGGB2BGR
+    BayerGRBG2BGR = cv2.COLOR_BayerGRBG2BGR
+    BAYER_GRBG2BGR = cv2.COLOR_BAYER_GRBG2BGR
+    BayerBGGR2BGR = cv2.COLOR_BayerBGGR2BGR
+    BAYER_BGGR2BGR = cv2.COLOR_BAYER_BGGR2BGR
+    BayerGBRG2BGR = cv2.COLOR_BayerGBRG2BGR
+    BAYER_GBRG2BGR = cv2.COLOR_BAYER_GBRG2BGR
+    BayerRGGB2RGB = cv2.COLOR_BayerRGGB2RGB
+    BAYER_RGGB2RGB = cv2.COLOR_BAYER_RGGB2RGB
+    BayerGRBG2RGB = cv2.COLOR_BayerGRBG2RGB
+    BAYER_GRBG2RGB = cv2.COLOR_BAYER_GRBG2RGB
+    BayerBGGR2RGB = cv2.COLOR_BayerBGGR2RGB
+    BAYER_BGGR2RGB = cv2.COLOR_BAYER_BGGR2RGB
+    BayerGBRG2RGB = cv2.COLOR_BayerGBRG2RGB
+    BAYER_GBRG2RGB = cv2.COLOR_BAYER_GBRG2RGB
+    BayerBG2RGB = cv2.COLOR_BayerBG2RGB
+    BAYER_BG2RGB = cv2.COLOR_BAYER_BG2RGB
+    BayerGB2RGB = cv2.COLOR_BayerGB2RGB
+    BAYER_GB2RGB = cv2.COLOR_BAYER_GB2RGB
+    BayerRG2RGB = cv2.COLOR_BayerRG2RGB
+    BAYER_RG2RGB = cv2.COLOR_BAYER_RG2RGB
+    BayerGR2RGB = cv2.COLOR_BayerGR2RGB
+    BAYER_GR2RGB = cv2.COLOR_BAYER_GR2RGB
+    BayerBG2GRAY = cv2.COLOR_BayerBG2GRAY
+    BAYER_BG2GRAY = cv2.COLOR_BAYER_BG2GRAY
+    BayerGB2GRAY = cv2.COLOR_BayerGB2GRAY
+    BAYER_GB2GRAY = cv2.COLOR_BAYER_GB2GRAY
+    BayerRG2GRAY = cv2.COLOR_BayerRG2GRAY
+    BAYER_RG2GRAY = cv2.COLOR_BAYER_RG2GRAY
+    BayerGR2GRAY = cv2.COLOR_BayerGR2GRAY
+    BAYER_GR2GRAY = cv2.COLOR_BAYER_GR2GRAY
+    BayerRGGB2GRAY = cv2.COLOR_BayerRGGB2GRAY
+    BAYER_RGGB2GRAY = cv2.COLOR_BAYER_RGGB2GRAY
+    BayerGRBG2GRAY = cv2.COLOR_BayerGRBG2GRAY
+    BAYER_GRBG2GRAY = cv2.COLOR_BAYER_GRBG2GRAY
+    BayerBGGR2GRAY = cv2.COLOR_BayerBGGR2GRAY
+    BAYER_BGGR2GRAY = cv2.COLOR_BAYER_BGGR2GRAY
+    BayerGBRG2GRAY = cv2.COLOR_BayerGBRG2GRAY
+    BAYER_GBRG2GRAY = cv2.COLOR_BAYER_GBRG2GRAY
+    BayerBG2BGR_VNG = cv2.COLOR_BayerBG2BGR_VNG
+    BAYER_BG2BGR_VNG = cv2.COLOR_BAYER_BG2BGR_VNG
+    BayerGB2BGR_VNG = cv2.COLOR_BayerGB2BGR_VNG
+    BAYER_GB2BGR_VNG = cv2.COLOR_BAYER_GB2BGR_VNG
+    BayerRG2BGR_VNG = cv2.COLOR_BayerRG2BGR_VNG
+    BAYER_RG2BGR_VNG = cv2.COLOR_BAYER_RG2BGR_VNG
+    BayerGR2BGR_VNG = cv2.COLOR_BayerGR2BGR_VNG
+    BAYER_GR2BGR_VNG = cv2.COLOR_BAYER_GR2BGR_VNG
+    BayerRGGB2BGR_VNG = cv2.COLOR_BayerRGGB2BGR_VNG
+    BAYER_RGGB2BGR_VNG = cv2.COLOR_BAYER_RGGB2BGR_VNG
+    BayerGRBG2BGR_VNG = cv2.COLOR_BayerGRBG2BGR_VNG
+    BAYER_GRBG2BGR_VNG = cv2.COLOR_BAYER_GRBG2BGR_VNG
+    BayerBGGR2BGR_VNG = cv2.COLOR_BayerBGGR2BGR_VNG
+    BAYER_BGGR2BGR_VNG = cv2.COLOR_BAYER_BGGR2BGR_VNG
+    BayerGBRG2BGR_VNG = cv2.COLOR_BayerGBRG2BGR_VNG
+    BAYER_GBRG2BGR_VNG = cv2.COLOR_BAYER_GBRG2BGR_VNG
+    BayerRGGB2RGB_VNG = cv2.COLOR_BayerRGGB2RGB_VNG
+    BAYER_RGGB2RGB_VNG = cv2.COLOR_BAYER_RGGB2RGB_VNG
+    BayerGRBG2RGB_VNG = cv2.COLOR_BayerGRBG2RGB_VNG
+    BAYER_GRBG2RGB_VNG = cv2.COLOR_BAYER_GRBG2RGB_VNG
+    BayerBGGR2RGB_VNG = cv2.COLOR_BayerBGGR2RGB_VNG
+    BAYER_BGGR2RGB_VNG = cv2.COLOR_BAYER_BGGR2RGB_VNG
+    BayerGBRG2RGB_VNG = cv2.COLOR_BayerGBRG2RGB_VNG
+    BAYER_GBRG2RGB_VNG = cv2.COLOR_BAYER_GBRG2RGB_VNG
+    BayerBG2RGB_VNG = cv2.COLOR_BayerBG2RGB_VNG
+    BAYER_BG2RGB_VNG = cv2.COLOR_BAYER_BG2RGB_VNG
+    BayerGB2RGB_VNG = cv2.COLOR_BayerGB2RGB_VNG
+    BAYER_GB2RGB_VNG = cv2.COLOR_BAYER_GB2RGB_VNG
+    BayerRG2RGB_VNG = cv2.COLOR_BayerRG2RGB_VNG
+    BAYER_RG2RGB_VNG = cv2.COLOR_BAYER_RG2RGB_VNG
+    BayerGR2RGB_VNG = cv2.COLOR_BayerGR2RGB_VNG
+    BAYER_GR2RGB_VNG = cv2.COLOR_BAYER_GR2RGB_VNG
+    BayerBG2BGR_EA = cv2.COLOR_BayerBG2BGR_EA
+    BAYER_BG2BGR_EA = cv2.COLOR_BAYER_BG2BGR_EA
+    BayerGB2BGR_EA = cv2.COLOR_BayerGB2BGR_EA
+    BAYER_GB2BGR_EA = cv2.COLOR_BAYER_GB2BGR_EA
+    BayerRG2BGR_EA = cv2.COLOR_BayerRG2BGR_EA
+    BAYER_RG2BGR_EA = cv2.COLOR_BAYER_RG2BGR_EA
+    BayerGR2BGR_EA = cv2.COLOR_BayerGR2BGR_EA
+    BAYER_GR2BGR_EA = cv2.COLOR_BAYER_GR2BGR_EA
+    BayerRGGB2BGR_EA = cv2.COLOR_BayerRGGB2BGR_EA
+    BAYER_RGGB2BGR_EA = cv2.COLOR_BAYER_RGGB2BGR_EA
+    BayerGRBG2BGR_EA = cv2.COLOR_BayerGRBG2BGR_EA
+    BAYER_GRBG2BGR_EA = cv2.COLOR_BAYER_GRBG2BGR_EA
+    BayerBGGR2BGR_EA = cv2.COLOR_BayerBGGR2BGR_EA
+    BAYER_BGGR2BGR_EA = cv2.COLOR_BAYER_BGGR2BGR_EA
+    BayerGBRG2BGR_EA = cv2.COLOR_BayerGBRG2BGR_EA
+    BAYER_GBRG2BGR_EA = cv2.COLOR_BAYER_GBRG2BGR_EA
+    BayerRGGB2RGB_EA = cv2.COLOR_BayerRGGB2RGB_EA
+    BAYER_RGGB2RGB_EA = cv2.COLOR_BAYER_RGGB2RGB_EA
+    BayerGRBG2RGB_EA = cv2.COLOR_BayerGRBG2RGB_EA
+    BAYER_GRBG2RGB_EA = cv2.COLOR_BAYER_GRBG2RGB_EA
+    BayerBGGR2RGB_EA = cv2.COLOR_BayerBGGR2RGB_EA
+    BAYER_BGGR2RGB_EA = cv2.COLOR_BAYER_BGGR2RGB_EA
+    BayerGBRG2RGB_EA = cv2.COLOR_BayerGBRG2RGB_EA
+    BAYER_GBRG2RGB_EA = cv2.COLOR_BAYER_GBRG2RGB_EA
+    BayerBG2RGB_EA = cv2.COLOR_BayerBG2RGB_EA
+    BAYER_BG2RGB_EA = cv2.COLOR_BAYER_BG2RGB_EA
+    BayerGB2RGB_EA = cv2.COLOR_BayerGB2RGB_EA
+    BAYER_GB2RGB_EA = cv2.COLOR_BAYER_GB2RGB_EA
+    BayerRG2RGB_EA = cv2.COLOR_BayerRG2RGB_EA
+    BAYER_RG2RGB_EA = cv2.COLOR_BAYER_RG2RGB_EA
+    BayerGR2RGB_EA = cv2.COLOR_BayerGR2RGB_EA
+    BAYER_GR2RGB_EA = cv2.COLOR_BAYER_GR2RGB_EA
+    BayerBG2BGRA = cv2.COLOR_BayerBG2BGRA
+    BAYER_BG2BGRA = cv2.COLOR_BAYER_BG2BGRA
+    BayerGB2BGRA = cv2.COLOR_BayerGB2BGRA
+    BAYER_GB2BGRA = cv2.COLOR_BAYER_GB2BGRA
+    BayerRG2BGRA = cv2.COLOR_BayerRG2BGRA
+    BAYER_RG2BGRA = cv2.COLOR_BAYER_RG2BGRA
+    BayerGR2BGRA = cv2.COLOR_BayerGR2BGRA
+    BAYER_GR2BGRA = cv2.COLOR_BAYER_GR2BGRA
+    BayerRGGB2BGRA = cv2.COLOR_BayerRGGB2BGRA
+    BAYER_RGGB2BGRA = cv2.COLOR_BAYER_RGGB2BGRA
+    BayerGRBG2BGRA = cv2.COLOR_BayerGRBG2BGRA
+    BAYER_GRBG2BGRA = cv2.COLOR_BAYER_GRBG2BGRA
+    BayerBGGR2BGRA = cv2.COLOR_BayerBGGR2BGRA
+    BAYER_BGGR2BGRA = cv2.COLOR_BAYER_BGGR2BGRA
+    BayerGBRG2BGRA = cv2.COLOR_BayerGBRG2BGRA
+    BAYER_GBRG2BGRA = cv2.COLOR_BAYER_GBRG2BGRA
+    BayerRGGB2RGBA = cv2.COLOR_BayerRGGB2RGBA
+    BAYER_RGGB2RGBA = cv2.COLOR_BAYER_RGGB2RGBA
+    BayerGRBG2RGBA = cv2.COLOR_BayerGRBG2RGBA
+    BAYER_GRBG2RGBA = cv2.COLOR_BAYER_GRBG2RGBA
+    BayerBGGR2RGBA = cv2.COLOR_BayerBGGR2RGBA
+    BAYER_BGGR2RGBA = cv2.COLOR_BAYER_BGGR2RGBA
+    BayerGBRG2RGBA = cv2.COLOR_BayerGBRG2RGBA
+    BAYER_GBRG2RGBA = cv2.COLOR_BAYER_GBRG2RGBA
+    BayerBG2RGBA = cv2.COLOR_BayerBG2RGBA
+    BAYER_BG2RGBA = cv2.COLOR_BAYER_BG2RGBA
+    BayerGB2RGBA = cv2.COLOR_BayerGB2RGBA
+    BAYER_GB2RGBA = cv2.COLOR_BAYER_GB2RGBA
+    BayerRG2RGBA = cv2.COLOR_BayerRG2RGBA
+    BAYER_RG2RGBA = cv2.COLOR_BAYER_RG2RGBA
+    BayerGR2RGBA = cv2.COLOR_BayerGR2RGBA
+    BAYER_GR2RGBA = cv2.COLOR_BAYER_GR2RGBA
 
 
-def cvt_color(image: Image, code: CvtColorCode) -> Image:
+def cvt_color(image: NDArray, code: CvtColorCode) -> NDArray:
     return cv2.cvtColor(image, code.value)
 
 
 class CvlCvtColor:
     @staticmethod
-    def cvl_cvt_color(image: Image, code: CvtColorCode):
+    def cvl_cvt_color(image: NDArray, code: CvtColorCode):
         return cvt_color(image, code)
 
     @staticmethod
-    def cvl_cvt_color_bgr2gray(image: Image):
+    def cvl_cvt_color_bgr2rgb(image: NDArray):
+        return cvt_color(image, CvtColorCode.BGR2RGB)
+
+    @staticmethod
+    def cvl_cvt_color_rgb2bgr(image: NDArray):
+        return cvt_color(image, CvtColorCode.RGB2BGR)
+
+    @staticmethod
+    def cvl_cvt_color_rgba2bgr(image: NDArray):
+        return cvt_color(image, CvtColorCode.RGBA2BGR)
+
+    @staticmethod
+    def cvl_cvt_color_bgr2gray(image: NDArray):
         return cvt_color(image, CvtColorCode.BGR2GRAY)
 
     @staticmethod
-    def cvl_cvt_color_gray2bgr(image: Image):
+    def cvl_cvt_color_gray2bgr(image: NDArray):
         return cvt_color(image, CvtColorCode.GRAY2BGR)
 
     @staticmethod
-    def cvl_cvt_color_bgr2hsv(image: Image):
+    def cvl_cvt_color_bgr2hsv(image: NDArray):
         return cvt_color(image, CvtColorCode.BGR2HSV)
 
     @staticmethod
-    def cvl_cvt_color_hsv2bgr(image: Image):
+    def cvl_cvt_color_hsv2bgr(image: NDArray):
         return cvt_color(image, CvtColorCode.HSV2BGR)
 
     @staticmethod
-    def cvl_cvt_color_bgr2yuv(image: Image):
+    def cvl_cvt_color_bgr2yuv(image: NDArray):
         return cvt_color(image, CvtColorCode.BGR2YUV)
 
     @staticmethod
-    def cvl_cvt_color_yuv2bgr(image: Image):
+    def cvl_cvt_color_yuv2bgr(image: NDArray):
         return cvt_color(image, CvtColorCode.YUV2BGR)
```

## cvlayer/cv/depth.py

```diff
@@ -19,18 +19,18 @@
 
 
 def validate_depth_combinations(input_dtype, output_depth: int) -> None:
     """
     https://docs.opencv.org/3.4/d4/d86/group__imgproc__filter.html#filter_depths
     """
 
-    if input_dtype not in DEPTH_COMBINATIONS_TABLE:
+    if input_dtype.type not in DEPTH_COMBINATIONS_TABLE:
         raise TypeError(f"Unsupported input data type: {input_dtype}")
 
-    if output_depth not in DEPTH_COMBINATIONS_TABLE[input_dtype]:
+    if output_depth not in DEPTH_COMBINATIONS_TABLE[input_dtype.type]:
         raise TypeError(f"Mismatch depth combination: {input_dtype} -> {output_depth}")
 
 
 @unique
 class OutputDepth(Enum):
     SAME_INPUT = SAME_DEPTH_AS_SOURCE
     INT16 = CV_16S
```

## cvlayer/cv/drawable.py

```diff
@@ -1,20 +1,36 @@
 # -*- coding: utf-8 -*-
 
-from typing import Final, Optional, Tuple
+from enum import Enum, unique
+from typing import Final, List, Tuple
 
 import cv2
+from numpy import full, uint8
 
-from cvlayer.typing import Color, Image, Number, PointT, RectT
+from cvlayer.typing import Color, Image, Number, PointT, RectInt, RectT, SizeInt
 
 FILLED: Final[int] = cv2.FILLED
 
-LINE_4: Final[int] = cv2.LINE_4
-LINE_8: Final[int] = cv2.LINE_8
-LINE_AA: Final[int] = cv2.LINE_AA
+LINE_4: Final[int] = cv2.LINE_4  # Bresenham 4 Connect
+LINE_8: Final[int] = cv2.LINE_8  # Bresenham 8 Connect
+LINE_AA: Final[int] = cv2.LINE_AA  # Anti-Aliasing
+
+MARKER_SIZE: Final[int] = 20
+
+ARROWED_LINE_TIP_LENGTH: Final[float] = 0.1
+
+FONT_HERSHEY_SIMPLEX: Final[int] = cv2.FONT_HERSHEY_SIMPLEX
+FONT_HERSHEY_PLAIN: Final[int] = cv2.FONT_HERSHEY_PLAIN
+FONT_HERSHEY_DUPLEX: Final[int] = cv2.FONT_HERSHEY_DUPLEX
+FONT_HERSHEY_COMPLEX: Final[int] = cv2.FONT_HERSHEY_COMPLEX
+FONT_HERSHEY_TRIPLEX: Final[int] = cv2.FONT_HERSHEY_TRIPLEX
+FONT_HERSHEY_COMPLEX_SMALL: Final[int] = cv2.FONT_HERSHEY_COMPLEX_SMALL
+FONT_HERSHEY_SCRIPT_SIMPLEX: Final[int] = cv2.FONT_HERSHEY_SCRIPT_SIMPLEX
+FONT_HERSHEY_SCRIPT_COMPLEX: Final[int] = cv2.FONT_HERSHEY_SCRIPT_COMPLEX
+FONT_ITALIC: Final[int] = cv2.FONT_ITALIC
 
 RADIUS: Final[int] = 4
 THICKNESS: Final[int] = 2
 COLOR: Final[Color] = (0, 0, 0)
 LINE_TYPE: Final[int] = LINE_AA
 
 FONT: Final[int] = cv2.FONT_HERSHEY_SIMPLEX
@@ -22,17 +38,43 @@
 
 OUTLINE_FILL_COLOR: Final[Color] = (255, 255, 255)
 OUTLINE_COLOR: Final[Color] = (0, 0, 0)
 OUTLINE_THICKNESS: Final[int] = 9
 
 MULTILINE_COLOR: Final[Color] = (220, 220, 220)
 MULTILINE_LINEFEED: Final[str] = "\n"
+MULTILINE_LINE_SPACING: Final[int] = 4
 MULTILINE_BACKGROUND_COLOR: Final[Color] = (0, 0, 0)
 MULTILINE_BACKGROUND_ALPHA: Final[float] = 0.4
-MULTILINE_MARGIN: Final[int] = 8
+MULTILINE_BOX_MARGIN: Final[int] = 8
+MULTILINE_BOX_ANCHOR_X: Final[float] = 0.0
+MULTILINE_BOX_ANCHOR_Y: Final[float] = 0.0
+
+CROSSHAIR_POINT_RADIUS: Final[int] = 6
+CROSSHAIR_POINT_THICKNESS: Final[int] = 1
+CROSSHAIR_POINT_COLOR: Final[Color] = (0, 0, 255)
+CROSSHAIR_POINT_LINE_TYPE: Final[int] = LINE_AA
+CROSSHAIR_POINT_PADDING: Final[int] = 2
+
+
+@unique
+class DrawTextOrigin(Enum):
+    BOTTOM_LEFT = True
+    TOP_LEFT = False
+
+
+@unique
+class MarkerType(Enum):
+    CROSS = cv2.MARKER_CROSS
+    TILTED_CROSS = cv2.MARKER_TILTED_CROSS
+    STAR = cv2.MARKER_STAR
+    DIAMOND = cv2.MARKER_DIAMOND
+    SQUARE = cv2.MARKER_SQUARE
+    TRIANGLE_UP = cv2.MARKER_TRIANGLE_UP
+    TRIANGLE_DOWN = cv2.MARKER_TRIANGLE_DOWN
 
 
 def draw_point(
     image: Image,
     x: Number,
     y: Number,
     radius=RADIUS,
@@ -78,149 +120,526 @@
     thickness=FILLED,
     line_type=LINE_TYPE,
 ) -> None:
     center = int(x), int(y)
     cv2.circle(image, center, radius, color, thickness, line_type)
 
 
+def draw_ellipse(
+    image: Image,
+    center_x: Number,
+    center_y: Number,
+    axes_x: Number,
+    axes_y: Number,
+    angle: float,
+    start_angle: float,
+    end_angle: float,
+    color=COLOR,
+    thickness=FILLED,
+    line_type=LINE_TYPE,
+) -> None:
+    center = int(center_x), int(center_y)
+    axes = int(axes_x), int(axes_y)
+    cv2.ellipse(
+        image,
+        center,
+        axes,
+        angle,
+        start_angle,
+        end_angle,
+        color,
+        thickness,
+        line_type,
+    )
+
+
+def draw_image(
+    canvas: Image,
+    src: Image,
+    x: Number,
+    y: Number,
+) -> None:
+    canvas_height = canvas.shape[0]
+    canvas_width = canvas.shape[1]
+    src_height = src.shape[0]
+    src_width = src.shape[1]
+    x1 = max(int(x), 0)
+    y1 = max(int(y), 0)
+    x2 = min(x1 + src_width, canvas_width)
+    y2 = min(y1 + src_height, canvas_height)
+    canvas[y1:y2, x1:x2] = src
+
+
+def draw_crosshair_point(
+    image: Image,
+    x: Number,
+    y: Number,
+    radius=CROSSHAIR_POINT_RADIUS,
+    thickness=CROSSHAIR_POINT_THICKNESS,
+    color=CROSSHAIR_POINT_COLOR,
+    line_type=CROSSHAIR_POINT_LINE_TYPE,
+    padding=CROSSHAIR_POINT_PADDING,
+    circle=True,
+) -> None:
+    if padding == 0:
+        left = x - radius, y
+        top = x, y - radius
+        right = x + radius, y
+        bottom = x, y + radius
+
+        draw_line(image, left, right, color, thickness, line_type)
+        draw_line(image, top, bottom, color, thickness, line_type)
+    else:
+        left1 = x - radius - padding, y
+        left2 = x - padding, y
+
+        top1 = x, y - radius - padding
+        top2 = x, y - padding
+
+        right1 = x + radius + padding, y
+        right2 = x + padding, y
+
+        bottom1 = x, y + radius + padding
+        bottom2 = x, y + padding
+
+        draw_line(image, left1, left2, color, thickness, line_type)
+        draw_line(image, top1, top2, color, thickness, line_type)
+        draw_line(image, right1, right2, color, thickness, line_type)
+        draw_line(image, bottom1, bottom2, color, thickness, line_type)
+
+    if circle:
+        draw_circle(
+            image=image,
+            x=x,
+            y=y,
+            radius=radius,
+            color=color,
+            thickness=thickness,
+            line_type=line_type,
+        )
+
+
+def draw_marker(
+    image: Image,
+    x: Number,
+    y: Number,
+    marker_size=MARKER_SIZE,
+    marker_type=MarkerType.CROSS,
+    color=COLOR,
+    thickness=THICKNESS,
+    line_type=LINE_TYPE,
+) -> None:
+    position = int(x), int(y)
+    cv2.drawMarker(
+        image,
+        position,
+        color,
+        marker_type.value,
+        marker_size,
+        thickness,
+        line_type,
+    )
+
+
+def draw_arrowed(
+    image: Image,
+    point1: PointT,
+    point2: PointT,
+    tip_length=ARROWED_LINE_TIP_LENGTH,
+    color=COLOR,
+    thickness=THICKNESS,
+    line_type=LINE_TYPE,
+) -> None:
+    x1, y1 = int(point1[0]), int(point1[1])
+    x2, y2 = int(point2[0]), int(point2[1])
+    cv2.arrowedLine(
+        image,
+        (x1, y1),
+        (x2, y2),
+        color,
+        thickness,
+        line_type,
+        tipLength=tip_length,
+    )
+
+
+def draw_text(
+    image: Image,
+    text: str,
+    x: Number,
+    y: Number,
+    font=FONT,
+    scale=FONT_SCALE,
+    color=COLOR,
+    thickness=THICKNESS,
+    line_type=LINE_TYPE,
+    origin=DrawTextOrigin.TOP_LEFT,
+) -> None:
+    org = int(x), int(y)
+    cv2.putText(
+        image,
+        text,
+        org,
+        font,
+        scale,
+        color,
+        thickness,
+        line_type,
+        origin.value,
+    )
+
+
 def draw_outline_text(
     image: Image,
     text: str,
     x: Number,
     y: Number,
     font=FONT,
     scale=FONT_SCALE,
     fill_color=OUTLINE_FILL_COLOR,
     outline_color=OUTLINE_COLOR,
     thickness=THICKNESS,
     outline_thickness=OUTLINE_THICKNESS,
     line_type=LINE_TYPE,
+    origin=DrawTextOrigin.TOP_LEFT,
 ) -> None:
-    org = int(x), int(y)
     bg_color = outline_color
     fg_color = fill_color
     bg_thickness = outline_thickness
     fg_thickness = thickness
-    cv2.putText(image, text, org, font, scale, bg_color, bg_thickness, line_type)
-    cv2.putText(image, text, org, font, scale, fg_color, fg_thickness, line_type)
+    draw_text(image, text, x, y, font, scale, bg_color, bg_thickness, line_type, origin)
+    draw_text(image, text, x, y, font, scale, fg_color, fg_thickness, line_type, origin)
+
+
+def get_font_scale_from_height(
+    pixel_height: int,
+    font=FONT,
+    thickness=THICKNESS,
+) -> float:
+    return cv2.getFontScaleFromHeight(font, pixel_height, thickness)
+
+
+def get_text_size(
+    text: str,
+    font=FONT,
+    scale=FONT_SCALE,
+    thickness=THICKNESS,
+) -> Tuple[SizeInt, int]:
+    text_size = cv2.getTextSize(text, font, scale, thickness)
+    text_width, text_height = text_size[0]
+    baseline = text_size[1]
+    return (text_width, text_height), baseline
 
 
 def measure_multiline_text_box_size(
     text: str,
     font=FONT,
     scale=FONT_SCALE,
     thickness=THICKNESS,
     linefeed=MULTILINE_LINEFEED,
-) -> Tuple[int, int]:
-    tws = []
-    ths = []
+    line_spacing=MULTILINE_LINE_SPACING,
+) -> Tuple[int, int, List[Tuple[str, SizeInt, int]]]:
+    tws = list()
+    ths = list()
+    lines = list()
     for line in text.split(linefeed):
         text_size = cv2.getTextSize(line, font, scale, thickness)
-        tw, th = text_size[0]
+        text_width, text_height = text_size[0]
         baseline = text_size[1]
-        tws.append(tw)
-        ths.append(th + baseline + (thickness * 2))
-    return max(tws), sum(ths)
+        line_height = text_height + baseline + line_spacing
+        tws.append(text_width)
+        ths.append(line_height)
+        lines.append((line, (text_width, text_height), baseline))
+    box_width = max(tws)
+    box_height = sum(ths)
+    box_height -= line_spacing  # The last line has no bottom line spacing.
+    return box_width, box_height, lines
+
+
+def draw_multiline_text_with_lines(
+    image: Image,
+    lines: List[Tuple[str, SizeInt, int]],
+    x: Number,
+    y: Number,
+    font=FONT,
+    scale=FONT_SCALE,
+    color=MULTILINE_COLOR,
+    thickness=THICKNESS,
+    line_type=LINE_TYPE,
+    line_spacing=MULTILINE_LINE_SPACING,
+) -> None:
+    for line in lines:
+        text = line[0]
+        width, height = line[1]
+        baseline = line[2]
+        y += height
+        draw_text(
+            image,
+            text,
+            x,
+            y,
+            font,
+            scale,
+            color,
+            thickness,
+            line_type,
+            DrawTextOrigin.TOP_LEFT,
+        )
+        y += baseline + line_spacing
 
 
 def draw_multiline_text(
     image: Image,
     text: str,
     x: Number,
     y: Number,
     font=FONT,
     scale=FONT_SCALE,
     color=MULTILINE_COLOR,
     thickness=THICKNESS,
     line_type=LINE_TYPE,
     linefeed=MULTILINE_LINEFEED,
-    background_color=MULTILINE_BACKGROUND_COLOR,
-    background_alpha=MULTILINE_BACKGROUND_ALPHA,
-    margin=MULTILINE_MARGIN,
-    canvas_width: Optional[int] = None,
-    canvas_height: Optional[int] = None,
+    line_spacing=MULTILINE_LINE_SPACING,
 ) -> None:
-    box_width, box_height = measure_multiline_text_box_size(
-        text, font, scale, thickness, linefeed
+    width, height, lines = measure_multiline_text_box_size(
+        text,
+        font,
+        scale,
+        thickness,
+        linefeed,
+        line_spacing,
+    )
+    draw_multiline_text_with_lines(
+        image,
+        lines,
+        x,
+        y,
+        font,
+        scale,
+        color,
+        thickness,
+        line_type,
+        line_spacing,
     )
 
-    left_offset = canvas_width - box_width + x if canvas_width and x < 0 else x
-    top_offset = canvas_height - box_height + y if canvas_height and y < 0 else y
 
-    overlay = image.copy()
-    x1 = left_offset
-    y1 = top_offset
-    x2 = left_offset + box_width + (margin * 2)
-    y2 = top_offset + box_height + (margin * 2)
-    p1 = (x1, y1)
-    p2 = (x2, y2)
-    cv2.rectangle(overlay, p1, p2, background_color, FILLED)
+def draw_multiline_text_box(
+    image: Image,
+    text: str,
+    x: Number,
+    y: Number,
+    font=FONT,
+    scale=FONT_SCALE,
+    color=MULTILINE_COLOR,
+    thickness=THICKNESS,
+    line_type=LINE_TYPE,
+    linefeed=MULTILINE_LINEFEED,
+    line_spacing=MULTILINE_LINE_SPACING,
+    background_color=MULTILINE_BACKGROUND_COLOR,
+    background_alpha=MULTILINE_BACKGROUND_ALPHA,
+    margin=MULTILINE_BOX_MARGIN,
+    anchor_x=MULTILINE_BOX_ANCHOR_X,
+    anchor_y=MULTILINE_BOX_ANCHOR_Y,
+) -> RectInt:
+    assert 0 <= anchor_x <= 1
+    assert 0 <= anchor_y <= 1
+    assert 0 <= background_alpha <= 1
+
+    ch = image.shape[0]
+    cw = image.shape[1]
+
+    bw, bh, lines = measure_multiline_text_box_size(
+        text, font, scale, thickness, linefeed, line_spacing
+    )
+    bw += margin * 2
+    bh += margin * 2
+    box = full((bh, bw, 3), background_color, dtype=uint8)
+
+    bx = bw * anchor_x
+    by = bh * anchor_y
+    x1 = max(int((x + cw * anchor_x) - bx), 0)
+    y1 = max(int((y + ch * anchor_y) - by), 0)
+    x2 = min(x1 + bw, cw)
+    y2 = min(y1 + bh, ch)
+    w = x2 - x1
+    h = y2 - y1
+
+    assert 0 <= x1 <= cw
+    assert 0 <= y1 <= ch
+    assert 0 <= x2 <= cw
+    assert 0 <= y2 <= ch
+    assert w <= bw
+    assert h <= bh
+
+    img_area = image[y1:y2, x1:x2]
+    box_area = box[0:h, 0:w]
 
     alpha = background_alpha
     beta = 1.0 - background_alpha
-    gamma = 0
-    image[::] = cv2.addWeighted(overlay, alpha, image, beta, gamma)
-
-    next_y = top_offset + margin
-    for line in text.split(linefeed):
-        text_size = cv2.getTextSize(line, font, scale, thickness)
-        tw, th = text_size[0]
-        baseline = text_size[1]  # noqa
-        pos_x = int(left_offset + margin)
-        pos_y = int(next_y + th + thickness + baseline)
-        pos = pos_x, pos_y
-        cv2.putText(image, line, pos, font, scale, color, thickness, line_type)
-        next_y += th + baseline + (thickness * 2)
+    if alpha >= 1:
+        mixed = box_area
+    elif beta >= 1:
+        mixed = img_area
+    else:
+        mixed = cv2.addWeighted(box_area, alpha, img_area, beta, 0)
+
+    draw_multiline_text_with_lines(
+        mixed,
+        lines,
+        x + margin,
+        y + margin,
+        font,
+        scale,
+        color,
+        thickness,
+        line_type,
+        line_spacing,
+    )
+    image[y1:y2, x1:x2] = mixed
+    return x1, y1, x2, y2
 
 
 class CvlDrawable:
     @staticmethod
     def cvl_draw_point(
         image: Image,
         x: Number,
         y: Number,
         radius=RADIUS,
         color=COLOR,
         thickness=FILLED,
         line_type=LINE_AA,
     ):
-        draw_point(image, x, y, radius, color, thickness, line_type)
+        return draw_point(image, x, y, radius, color, thickness, line_type)
 
     @staticmethod
     def cvl_draw_line(
         image: Image,
         point1: PointT,
         point2: PointT,
         color=COLOR,
         thickness=THICKNESS,
         line_type=LINE_TYPE,
     ):
-        draw_line(image, point1, point2, color, thickness, line_type)
+        return draw_line(image, point1, point2, color, thickness, line_type)
 
     @staticmethod
     def cvl_draw_rectangle(
         image: Image,
         roi: RectT,
         color=COLOR,
         thickness=THICKNESS,
         line_type=LINE_TYPE,
     ):
-        draw_rectangle(image, roi, color, thickness, line_type)
+        return draw_rectangle(image, roi, color, thickness, line_type)
 
     @staticmethod
     def cvl_draw_circle(
         image: Image,
         x: Number,
         y: Number,
         radius=RADIUS,
         color=COLOR,
         thickness=FILLED,
         line_type=LINE_TYPE,
     ):
-        draw_circle(image, x, y, radius, color, thickness, line_type)
+        return draw_circle(image, x, y, radius, color, thickness, line_type)
+
+    @staticmethod
+    def cvl_draw_image(
+        canvas: Image,
+        src: Image,
+        x: Number,
+        y: Number,
+    ):
+        return draw_image(canvas, src, x, y)
+
+    @staticmethod
+    def cvl_draw_crosshair_point(
+        image: Image,
+        x: Number,
+        y: Number,
+        radius=CROSSHAIR_POINT_RADIUS,
+        thickness=CROSSHAIR_POINT_THICKNESS,
+        color=CROSSHAIR_POINT_COLOR,
+        line_type=CROSSHAIR_POINT_LINE_TYPE,
+        padding=CROSSHAIR_POINT_PADDING,
+        circle=True,
+    ):
+        return draw_crosshair_point(
+            image, x, y, radius, thickness, color, line_type, padding, circle
+        )
+
+    @staticmethod
+    def cvl_draw_marker(
+        image: Image,
+        x: Number,
+        y: Number,
+        marker_type=MarkerType.CROSS,
+        marker_size=MARKER_SIZE,
+        color=CROSSHAIR_POINT_COLOR,
+        thickness=CROSSHAIR_POINT_THICKNESS,
+        line_type=CROSSHAIR_POINT_LINE_TYPE,
+    ):
+        return draw_marker(
+            image,
+            x,
+            y,
+            marker_size,
+            marker_type,
+            color,
+            thickness,
+            line_type,
+        )
+
+    @staticmethod
+    def cvl_draw_arrowed(
+        image: Image,
+        point1: PointT,
+        point2: PointT,
+        tip_length=ARROWED_LINE_TIP_LENGTH,
+        color=COLOR,
+        thickness=THICKNESS,
+        line_type=LINE_TYPE,
+    ):
+        return draw_arrowed(
+            image,
+            point1,
+            point2,
+            tip_length,
+            color,
+            thickness,
+            line_type,
+        )
+
+    @staticmethod
+    def cvl_draw_text(
+        image: Image,
+        text: str,
+        x: Number,
+        y: Number,
+        font=FONT,
+        scale=FONT_SCALE,
+        color=COLOR,
+        thickness=THICKNESS,
+        line_type=LINE_TYPE,
+        origin=DrawTextOrigin.TOP_LEFT,
+    ):
+        return draw_text(
+            image,
+            text,
+            x,
+            y,
+            font,
+            scale,
+            color,
+            thickness,
+            line_type,
+            origin,
+        )
 
     @staticmethod
     def cvl_draw_outline_text(
         image: Image,
         text: str,
         x: Number,
         y: Number,
@@ -228,66 +647,145 @@
         scale=FONT_SCALE,
         fill_color=OUTLINE_FILL_COLOR,
         outline_color=OUTLINE_COLOR,
         thickness=THICKNESS,
         outline_thickness=OUTLINE_THICKNESS,
         line_type=LINE_TYPE,
     ):
-        draw_outline_text(
+        return draw_outline_text(
             image,
             text,
             x,
             y,
             font,
             scale,
             fill_color,
             outline_color,
             thickness,
             outline_thickness,
             line_type,
         )
 
     @staticmethod
+    def cvl_get_font_scale_from_height(
+        pixel_height: int,
+        font=FONT,
+        thickness=THICKNESS,
+    ):
+        return get_font_scale_from_height(font, pixel_height, thickness)
+
+    @staticmethod
+    def cvl_get_text_size(
+        text: str,
+        font=FONT,
+        scale=FONT_SCALE,
+        thickness=THICKNESS,
+    ):
+        return get_text_size(text, font, scale, thickness)
+
+    @staticmethod
     def cvl_measure_multiline_text_box_size(
         text: str,
         font=FONT,
         scale=FONT_SCALE,
         thickness=THICKNESS,
         linefeed=MULTILINE_LINEFEED,
+        line_spacing=MULTILINE_LINE_SPACING,
     ):
-        return measure_multiline_text_box_size(text, font, scale, thickness, linefeed)
+        return measure_multiline_text_box_size(
+            text,
+            font,
+            scale,
+            thickness,
+            linefeed,
+            line_spacing,
+        )
+
+    @staticmethod
+    def cvl_draw_multiline_text_with_lines(
+        image: Image,
+        lines: List[Tuple[str, SizeInt, int]],
+        x: Number,
+        y: Number,
+        font=FONT,
+        scale=FONT_SCALE,
+        color=MULTILINE_COLOR,
+        thickness=THICKNESS,
+        line_type=LINE_TYPE,
+        line_spacing=MULTILINE_LINE_SPACING,
+    ):
+        return draw_multiline_text_with_lines(
+            image,
+            lines,
+            x,
+            y,
+            font,
+            scale,
+            color,
+            thickness,
+            line_type,
+            line_spacing,
+        )
 
     @staticmethod
     def cvl_draw_multiline_text(
         image: Image,
         text: str,
         x: Number,
         y: Number,
         font=FONT,
         scale=FONT_SCALE,
         color=MULTILINE_COLOR,
         thickness=THICKNESS,
         line_type=LINE_TYPE,
         linefeed=MULTILINE_LINEFEED,
+    ):
+        return draw_multiline_text(
+            image,
+            text,
+            x,
+            y,
+            font,
+            scale,
+            color,
+            thickness,
+            line_type,
+            linefeed,
+        )
+
+    @staticmethod
+    def cvl_draw_multiline_text_box(
+        image: Image,
+        text: str,
+        x: Number,
+        y: Number,
+        font=FONT,
+        scale=FONT_SCALE,
+        color=MULTILINE_COLOR,
+        thickness=THICKNESS,
+        line_type=LINE_TYPE,
+        linefeed=MULTILINE_LINEFEED,
+        line_spacing=MULTILINE_LINE_SPACING,
         background_color=MULTILINE_BACKGROUND_COLOR,
         background_alpha=MULTILINE_BACKGROUND_ALPHA,
-        margin=MULTILINE_MARGIN,
-        canvas_width: Optional[int] = None,
-        canvas_height: Optional[int] = None,
+        margin=MULTILINE_BOX_MARGIN,
+        anchor_x=MULTILINE_BOX_ANCHOR_X,
+        anchor_y=MULTILINE_BOX_ANCHOR_Y,
     ):
-        draw_multiline_text(
+        return draw_multiline_text_box(
             image,
             text,
             x,
             y,
             font,
             scale,
             color,
             thickness,
             line_type,
             linefeed,
+            line_spacing,
             background_color,
             background_alpha,
             margin,
-            canvas_width,
-            canvas_height,
+            anchor_x,
+            anchor_y,
         )
```

## cvlayer/cv/histogram.py

```diff
@@ -1,99 +1,213 @@
 # -*- coding: utf-8 -*-
 
 from typing import Final, List, Optional, Sequence, Tuple
 
 import cv2
-from numpy import float32, uint8, zeros
 from numpy.typing import NDArray
 
 from cvlayer.cv.color import PIXEL_8BIT_MAX
-from cvlayer.palette.basic import BLUE, GREEN, RED
-from cvlayer.typing import Color, RectInt
+from cvlayer.cv.drawable import LINE_AA
+from cvlayer.cv.plot import PlotMode, draw_plot_2d
+from cvlayer.palette.basic import BLUE, GRAY, GREEN, RED
+from cvlayer.typing import Color, PointFloat, RectInt
 
 RANGE_MAX: Final[int] = PIXEL_8BIT_MAX + 1
-DEFAULT_BINS: Final[Sequence[int]] = (RANGE_MAX,)
-DEFAULT_RANGES: Final[Tuple[int, int]] = (0, RANGE_MAX)
+DEFAULT_HIST_SIZE: Final[Sequence[int]] = (RANGE_MAX,)
+DEFAULT_RANGES: Final[Tuple[float, float]] = (0.0, float(RANGE_MAX))
 
-DEFAULT_HISTOGRAM_COLORS = (BLUE, GREEN, RED)
-DEFAULT_THICKNESS: Final[int] = 1
-DEFAULT_LINE_TYPE: Final[int] = cv2.LINE_AA
-
-
-class Histogram:
-    _mask: Optional[NDArray]
-    _histograms: List[NDArray]
-
-    def __init__(
-        self,
-        bins=DEFAULT_BINS,
-        ranges=DEFAULT_RANGES,
-    ):
-        self._bins = bins
-        self._ranges = ranges
-        self._mask = None
-        self._histograms = list()
-
-    @property
-    def histograms(self) -> List[NDArray]:
-        return self._histograms
 
-    def calc_hist(self, frame: NDArray, channel: int) -> NDArray:
-        return cv2.calcHist([frame], [channel], self._mask, self._bins, self._ranges)
+def calc_hist(
+    images: Sequence[NDArray],
+    channels: Sequence[int],
+    mask: Optional[NDArray] = None,
+    hist_size: Sequence[int] = DEFAULT_HIST_SIZE,
+    ranges: Sequence[float] = DEFAULT_RANGES,
+    accumulate=False,
+) -> NDArray:
+    return cv2.calcHist(
+        images=images,
+        channels=channels,
+        mask=mask,
+        histSize=hist_size,
+        ranges=ranges,
+        accumulate=accumulate,
+    )
+
+
+def normalize_drawable_histogram(
+    hist: NDArray,
+    width: int,
+    height: int,
+    hist_size=RANGE_MAX,
+) -> List[PointFloat]:
+    normalized = hist.copy()
+    cv2.normalize(
+        src=hist,
+        dst=normalized,
+        alpha=0.0,
+        beta=float(height),
+        norm_type=cv2.NORM_MINMAX,
+    )
+    width_step = width / hist_size
+    result = list()
+    for i in range(hist_size):
+        x = i * width_step
+        y = height - float(normalized[i])
+        result.append((x, y))
+    return result
+
+
+def draw_histogram_channel(
+    frame: NDArray,
+    roi: RectInt,
+    analysis: NDArray,
+    analysis_roi: Optional[RectInt] = None,
+    index=0,
+    channel_max=float(RANGE_MAX),
+    color=GRAY,
+    thickness=1,
+    line_type=LINE_AA,
+) -> None:
+    width = abs(roi[2] - roi[0])
+    height = abs(roi[3] - roi[1])
+    hist_size = (height,)
+    ranges = 0.0, channel_max
+    if analysis_roi is not None:
+        x1, y1, x2, y2 = analysis_roi
+        left, right = min(x1, x2), max(x1, x2)
+        top, bottom = min(y1, y2), max(y1, y2)
+        if (right - left) * (bottom - top) != 0:
+            analysis = analysis[top:bottom, left:right]
+    hist = calc_hist([analysis], [index], hist_size=hist_size, ranges=ranges)
+    points = normalize_drawable_histogram(hist, width, height)
+    xs = [p[0] for p in points]
+    ys = [p[1] for p in points]
+    draw_plot_2d(
+        frame,
+        xs,
+        ys,
+        roi=roi,
+        color=color,
+        thickness=thickness,
+        line_type=line_type,
+        mode=PlotMode.LINE,
+    )
+
+
+def draw_histogram_channels(
+    frame: NDArray,
+    roi: RectInt,
+    analysis: NDArray,
+    analysis_roi: Optional[RectInt] = None,
+    channels_max: Sequence[float] = (RANGE_MAX, RANGE_MAX, RANGE_MAX),
+    colors: Sequence[Color] = (BLUE, GREEN, RED),
+    thickness=1,
+    line_type=LINE_AA,
+) -> None:
+    if analysis_roi is not None:
+        x1, y1, x2, y2 = analysis_roi
+        left, right = min(x1, x2), max(x1, x2)
+        top, bottom = min(y1, y2), max(y1, y2)
+        if (right - left) * (bottom - top) != 0:
+            analysis = analysis[top:bottom, left:right]
+
+    shape_size = len(analysis.shape)
+    if shape_size == 2:
+        channels = 1
+    elif shape_size == 3:
+        channels = analysis.shape[2]
+    else:
+        raise ValueError(f"Unsupported analysis shape: {shape_size}")
+
+    for i in range(channels):
+        draw_histogram_channel(
+            frame,
+            roi,
+            analysis,
+            None,
+            i,
+            channels_max[i],
+            colors[i],
+            thickness,
+            line_type,
+        )
 
-    def draw(
-        self,
-        frame: NDArray,
-        colors: Sequence[Color] = DEFAULT_HISTOGRAM_COLORS,
-        thickness=DEFAULT_THICKNESS,
-        line_type=DEFAULT_LINE_TYPE,
-    ) -> None:
-        height, width = frame.shape[0:2]
-        assert len(self._histograms) in (1, 3)
-
-        hist_size = self._bins[0]
-        bin_w = int(round(width / hist_size))
-
-        for histogram, color in zip(self._histograms, colors):
-            hist = cv2.normalize(
-                histogram,
-                None,
-                alpha=0,
-                beta=height,
-                norm_type=cv2.NORM_MINMAX,
-            )
-
-            for i in range(1, hist_size):
-                x1 = bin_w * (i - 1)
-                y1 = height - int(hist[i - 1])
-                x2 = bin_w * i
-                y2 = height - int(hist[i])
-                p1 = x1, y1
-                p2 = x2, y2
-                cv2.line(frame, p1, p2, color, thickness, line_type)
-
-    def calc(self, frame: NDArray, roi: Optional[RectInt] = None) -> None:
-        assert frame.dtype in (uint8, float32)
-        assert len(frame.shape) in (2, 3)
-
-        if roi is not None:
-            x1, y1, x2, y2 = roi
-            left, right = min(x1, x2), max(x1, x2)
-            top, bottom = min(y1, y2), max(y1, y2)
-            area = abs(right - left) * abs(bottom - top)
-
-            if area > 0:
-                self._mask = zeros(frame.shape[:2], uint8)
-                self._mask[top:bottom, left:right] = 255
-            else:
-                self._mask = None
-        else:
-            self._mask = None
 
-        channels = 1 if len(frame.shape) == 2 else frame.shape[2]
-        self._histograms = [self.calc_hist(frame, i) for i in range(channels)]
+class CvlHistogram:
+    @staticmethod
+    def cvl_calc_hist(
+        images: Sequence[NDArray],
+        channels: Sequence[int],
+        mask: Optional[NDArray] = None,
+        hist_size: Sequence[int] = DEFAULT_HIST_SIZE,
+        ranges: Sequence[float] = DEFAULT_RANGES,
+        accumulate=False,
+    ):
+        return calc_hist(
+            images=images,
+            channels=channels,
+            mask=mask,
+            hist_size=hist_size,
+            ranges=ranges,
+            accumulate=accumulate,
+        )
+
+    @staticmethod
+    def cvl_normalize_drawable_histogram(
+        hist: NDArray,
+        width: int,
+        height: int,
+        hist_size=RANGE_MAX,
+    ):
+        return normalize_drawable_histogram(
+            hist=hist,
+            width=width,
+            height=height,
+            hist_size=hist_size,
+        )
 
+    @staticmethod
+    def cvl_draw_histogram_channel(
+        frame: NDArray,
+        roi: RectInt,
+        analysis: NDArray,
+        analysis_roi: Optional[RectInt] = None,
+        index=0,
+        channel_max=RANGE_MAX,
+        color=GRAY,
+        thickness=1,
+        line_type=LINE_AA,
+    ):
+        return draw_histogram_channel(
+            frame=frame,
+            roi=roi,
+            analysis=analysis,
+            analysis_roi=analysis_roi,
+            index=index,
+            channel_max=channel_max,
+            color=color,
+            thickness=thickness,
+            line_type=line_type,
+        )
 
-class CvlHistogram:
     @staticmethod
-    def cvl_create_histogram(bins=DEFAULT_BINS, ranges=DEFAULT_RANGES):
-        return Histogram(bins, ranges)
+    def cvl_draw_histogram_channels(
+        frame: NDArray,
+        roi: RectInt,
+        analysis: NDArray,
+        analysis_roi: Optional[RectInt] = None,
+        channels_max=(RANGE_MAX, RANGE_MAX, RANGE_MAX),
+        colors=(BLUE, GREEN, RED),
+        thickness=1,
+        line_type=LINE_AA,
+    ):
+        return draw_histogram_channels(
+            frame=frame,
+            roi=roi,
+            analysis=analysis,
+            analysis_roi=analysis_roi,
+            channels_max=channels_max,
+            colors=colors,
+            thickness=thickness,
+            line_type=line_type,
+        )
```

## cvlayer/cv/image_crop.py

```diff
@@ -1,21 +1,129 @@
 # -*- coding: utf-8 -*-
 
+from typing import Optional, Sequence
+
+from numpy import full
 from numpy.typing import NDArray
 
 from cvlayer.typing import RectInt
 
 
-def crop(src: NDArray, roi: RectInt) -> NDArray:
+def image_crop(src: NDArray, roi: RectInt, copy=False) -> NDArray:
+    x1, y1, x2, y2 = roi
+    width = x2 - x1
+    height = y2 - y1
+    area = width * height
+    if area == 0:
+        raise ValueError("ROIs with size 0 cannot be cropped")
+
+    left = min(x1, x2)
+    right = max(x1, x2)
+    top = min(y1, y2)
+    bottom = max(y1, y2)
+
+    src_height, src_width = src.shape[0], src.shape[1]
+    if left < 0 or src_width < left:
+        raise IndexError(f"Invalid roi: {roi}")
+    if right < 0 or src_width < right:
+        raise IndexError(f"Invalid roi: {roi}")
+    if top < 0 or src_height < top:
+        raise IndexError(f"Invalid roi: {roi}")
+    if bottom < 0 or src_height < bottom:
+        raise IndexError(f"Invalid roi: {roi}")
+
+    cropped = src[top:bottom, left:right]
+    if copy:
+        return cropped.copy()
+    else:
+        return cropped
+
+
+def image_crop_adjusted(
+    src: NDArray,
+    roi: RectInt,
+    copy=False,
+) -> NDArray:
     x1, y1, x2, y2 = roi
-    width = abs(x2 - x1)
-    height = abs(y2 - y1)
+    src_height, src_width = src.shape[0], src.shape[1]
+    left = max(min(x1, x2), 0)
+    right = min(max(x1, x2), src_width)
+    top = max(min(y1, y2), 0)
+    bottom = min(max(y1, y2), src_height)
+
+    width = right - left
+    height = bottom - top
     area = width * height
     if area == 0:
         raise ValueError("ROIs with size 0 cannot be cropped")
-    return src[y1:y2, x1:x2]
+
+    cropped = src[top:bottom, left:right]
+    if copy:
+        return cropped.copy()
+    else:
+        return cropped
+
+
+def image_crop_extended(
+    src: NDArray,
+    roi: RectInt,
+    fill: Optional[Sequence[int]] = None,
+) -> NDArray:
+    x1, y1, x2, y2 = roi
+    width = x2 - x1
+    height = y2 - y1
+    area = width * height
+    if area == 0:
+        raise ValueError("ROIs with size 0 cannot be cropped")
+
+    left = min(x1, x2)
+    right = max(x1, x2)
+    top = min(y1, y2)
+    bottom = max(y1, y2)
+
+    src_height, src_width = src.shape[0], src.shape[1]
+    crop_left = max(left, 0)
+    crop_right = min(right, src_width)
+    crop_top = max(top, 0)
+    crop_bottom = min(bottom, src_height)
+
+    left_over = abs(left - crop_left)
+    right_over = abs(right - crop_right)
+    top_over = abs(top - crop_top)
+    bottom_over = abs(bottom - crop_bottom)
+
+    cropped = src[crop_top:crop_bottom, crop_left:crop_right]
+    extend_height = cropped.shape[0] + top_over + bottom_over
+    extend_width = cropped.shape[1] + left_over + right_over
+    extend_shape = [extend_height, extend_width]
+    if len(src.shape) >= 3:
+        extend_shape += cropped.shape[2:]
+
+    canvas = full(extend_shape, fill if fill is not None else 0, dtype=cropped.dtype)
+    canvas_y1 = top_over
+    canvas_y2 = top_over + cropped.shape[0]
+    canvas_x1 = left_over
+    canvas_x2 = left_over + cropped.shape[1]
+    canvas[canvas_y1:canvas_y2, canvas_x1:canvas_x2] = cropped
+    return canvas
 
 
 class CvlImageCrop:
     @staticmethod
-    def cvl_crop(src: NDArray, roi: RectInt):
-        return crop(src, roi)
+    def cvl_image_crop(src: NDArray, roi: RectInt, copy=False):
+        return image_crop(src, roi, copy)
+
+    @staticmethod
+    def cvl_image_crop_adjusted(
+        src: NDArray,
+        roi: RectInt,
+        copy=False,
+    ) -> NDArray:
+        return image_crop_adjusted(src, roi, copy)
+
+    @staticmethod
+    def cvl_image_crop_extended(
+        src: NDArray,
+        roi: RectInt,
+        fill: Optional[Sequence[int]] = None,
+    ) -> NDArray:
+        return image_crop_extended(src, roi, fill)
```

## cvlayer/cv/image_make.py

```diff
@@ -1,13 +1,14 @@
 # -*- coding: utf-8 -*-
 
 from cvlayer.np.image import (
     make_image,
     make_image_empty,
     make_image_filled,
+    make_image_random,
     make_image_with_shape,
 )
 from cvlayer.typing import Color, ImageShape
 
 
 class CvlImageMake:
     @staticmethod
@@ -21,7 +22,11 @@
     @staticmethod
     def cvl_make_image_filled(width: int, height: int, color: Color):
         return make_image_filled(width, height, color)
 
     @staticmethod
     def cvl_make_image_empty(width: int, height: int):
         return make_image_empty(width, height)
+
+    @staticmethod
+    def cvl_make_image_random(width: int, height: int):
+        return make_image_random(width, height)
```

## cvlayer/cv/keymap.py

```diff
@@ -11,15 +11,16 @@
 )
 from cvlayer.keymap.create import (
     DEFAULT_CALLBACK_NAME_PREFIX,
     DEFAULT_CALLBACK_NAME_SUFFIX,
     create_callable_keymap,
 )
 
-KEYCODE_NULL: Final[int] = -1
+KEYCODE_TIMEOUT: Final[int] = -1
+KEYCODE_NULL: Final[int] = 0
 KEYCODE_ENTER: Final[int] = 13
 KEYCODE_ESC: Final[int] = 27
 
 
 @unique
 class HighGuiKeyCode(Enum):
     ARROW_UP = auto()
```

## cvlayer/cv/orb.py

```diff
@@ -64,15 +64,15 @@
 
     def detect_and_compute(self, image: NDArray) -> Tuple[Any, Any]:
         return self._orb.detectAndCompute(image, None)
 
 
 class CvlOrb:
     @staticmethod
-    def create_orb(
+    def cvl_create_orb(
         n_features=DEFAULT_N_FEATURES,
         scale_factor=DEFAULT_SCALE_FACTOR,
         n_levels=DEFAULT_N_LEVELS,
         edge_threshold=DEFAULT_EDGE_THRESHOLD,
         first_level=DEFAULT_FIRST_LEVEL,
         wta_k=DEFAULT_WTA_K,
         score_type=DEFAULT_SCORE_TYPE,
```

## cvlayer/cv/perspective.py

```diff
@@ -1,17 +1,17 @@
 # -*- coding: utf-8 -*-
 
 from enum import Enum, unique
-from typing import Final, Optional
+from typing import Any, Final, Optional
 
 import cv2
 from numpy import array, float32
 from numpy.typing import NDArray
 
-from cvlayer.typing import PointFloat, RectFloat, Scalar, SizeInt
+from cvlayer.typing import PerspectivePointsInt, PointFloat, RectFloat, Scalar, SizeInt
 
 
 @unique
 class MatrixDecomposition(Enum):
     LU = cv2.DECOMP_LU
     """Gaussian elimination with the optimal pivot element chosen"""
 
@@ -40,14 +40,46 @@
     NORMAL = cv2.DECOMP_NORMAL
     """
     while all the previous flags are mutually exclusive,
     this flag can be used together with any of the previous;
     """
 
 
+def cast_perspective_int(points: Any) -> PerspectivePointsInt:
+    assert isinstance(points, list)
+    assert len(points) == 4
+
+    assert isinstance(points[0], list)
+    assert len(points[0]) == 2
+    assert isinstance(points[0][0], int)
+    assert isinstance(points[0][1], int)
+
+    assert isinstance(points[1], list)
+    assert len(points[1]) == 2
+    assert isinstance(points[1][0], int)
+    assert isinstance(points[1][1], int)
+
+    assert isinstance(points[2], list)
+    assert len(points[2]) == 2
+    assert isinstance(points[2][0], int)
+    assert isinstance(points[2][1], int)
+
+    assert isinstance(points[3], list)
+    assert len(points[3]) == 2
+    assert isinstance(points[3][0], int)
+    assert isinstance(points[3][1], int)
+
+    return (
+        (points[0][0], points[0][1]),
+        (points[1][0], points[1][1]),
+        (points[2][0], points[2][1]),
+        (points[3][0], points[3][1]),
+    )
+
+
 def get_perspective_transform(
     src: NDArray,
     dest: NDArray,
     solve_method=MatrixDecomposition.LU,
 ) -> NDArray:
     return cv2.getPerspectiveTransform(src, dest, solve_method.value)
 
@@ -107,14 +139,18 @@
         borderMode=border_mode.value,
         borderValue=border_value,
     )
 
 
 class CvlPerspective:
     @staticmethod
+    def cvl_cast_perspective_int(points: Any) -> PerspectivePointsInt:
+        return cast_perspective_int(points)
+
+    @staticmethod
     def cvl_get_perspective_transform(
         src: NDArray,
         dest: NDArray,
         solve_method=MatrixDecomposition.LU,
     ):
         return get_perspective_transform(src, dest, solve_method)
```

## cvlayer/cv/sobel.py

```diff
@@ -6,15 +6,15 @@
 from numpy.typing import NDArray
 
 from cvlayer.cv.border import DEFAULT_BORDER_TYPE
 from cvlayer.cv.depth import DEFAULT_OUTPUT_DEPTH, validate_depth_combinations
 
 DEFAULT_DX: Final[int] = 1
 DEFAULT_DY: Final[int] = 1
-DEFAULT_KERNEL_SIZE: Final[int] = 1
+DEFAULT_KERNEL_SIZE: Final[int] = 3
 DEFAULT_SCALE: Final[float] = 1.0
 DEFAULT_DELTA: Final[float] = 0.0
 AVAILABLE_KERNEL_SIZE: Tuple[int, int, int, int] = 1, 3, 5, 7
 
 
 def sobel(
     frame: NDArray,
@@ -27,15 +27,15 @@
     border_type=DEFAULT_BORDER_TYPE,
 ):
     assert dx or dy
     assert kernel_size % 2 == 1
     assert kernel_size >= 1
     assert kernel_size in AVAILABLE_KERNEL_SIZE
 
-    validate_depth_combinations(frame, output_depth.value)
+    validate_depth_combinations(frame.dtype, output_depth.value)
 
     if border_type.value == cv2.BORDER_WRAP:
         raise ValueError("Unsupported border type: BORDER_WRAP")
 
     return cv2.Sobel(
         frame,
         output_depth.value,
```

## cvlayer/cv/threshold.py

```diff
@@ -25,30 +25,55 @@
     TRUNC = cv2.THRESH_TRUNC
     TOZERO = cv2.THRESH_TOZERO
     TOZERO_INV = cv2.THRESH_TOZERO_INV
 
 
 class ThresholdResult(NamedTuple):
     computed_threshold_value: float
+    """
+    The computed threshold value if Otsu's or Triangle methods used.
+    """
+
     threshold_image: NDArray
 
 
 def threshold(
     src: NDArray,
     thresh=PIXEL_8BIT_HALF,
     max_value=PIXEL_8BIT_MAX,
     method=ThresholdMethod.BINARY,
 ) -> ThresholdResult:
-    # The computed threshold value if Otsu's or Triangle methods used.
     computed_threshold_value, threshold_image = cv2.threshold(
         src, thresh, max_value, method.value
     )
     return ThresholdResult(computed_threshold_value, threshold_image)
 
 
+def threshold_otsu(
+    src: NDArray,
+    max_value=PIXEL_8BIT_MAX,
+    method=ThresholdMethod.BINARY,
+) -> ThresholdResult:
+    computed_threshold_value, threshold_image = cv2.threshold(
+        src, 0, max_value, method.value | cv2.THRESH_OTSU
+    )
+    return ThresholdResult(computed_threshold_value, threshold_image)
+
+
+def threshold_triangle(
+    src: NDArray,
+    max_value=PIXEL_8BIT_MAX,
+    method=ThresholdMethod.BINARY,
+) -> ThresholdResult:
+    computed_threshold_value, threshold_image = cv2.threshold(
+        src, 0, max_value, method.value | cv2.THRESH_TRIANGLE
+    )
+    return ThresholdResult(computed_threshold_value, threshold_image)
+
+
 def adaptive_threshold(
     src: NDArray,
     max_value=PIXEL_8BIT_MAX,
     adaptive_method=AdaptiveMethod.MEAN,
     method=ThresholdMethod.BINARY,
     block_size=DEFAULT_BLOCK_SIZE,
     c=DEFAULT_C,
@@ -65,14 +90,30 @@
         thresh=PIXEL_8BIT_HALF,
         max_value=PIXEL_8BIT_MAX,
         method=ThresholdMethod.BINARY,
     ):
         return threshold(src, thresh, max_value, method)
 
     @staticmethod
+    def cvl_threshold_otsu(
+        src: NDArray,
+        max_value=PIXEL_8BIT_MAX,
+        method=ThresholdMethod.BINARY,
+    ):
+        return threshold_otsu(src, max_value, method)
+
+    @staticmethod
+    def cvl_threshold_triangle(
+        src: NDArray,
+        max_value=PIXEL_8BIT_MAX,
+        method=ThresholdMethod.BINARY,
+    ):
+        return threshold_triangle(src, max_value, method)
+
+    @staticmethod
     def cvl_adaptive_threshold(
         src: NDArray,
         max_value=PIXEL_8BIT_MAX,
         adaptive_method=AdaptiveMethod.MEAN,
         method=ThresholdMethod.BINARY,
         block_size=DEFAULT_BLOCK_SIZE,
         c=DEFAULT_C,
```

## cvlayer/cv/window.py

```diff
@@ -56,33 +56,42 @@
     callback: Callable,
 ) -> None:
     func = getattr(cv2, FUNC_CREATE_TRACKBAR)
     func(trackbarname, winname, value, count, callback)
 
 
 class Window:
-    def __init__(self, name: str, flags=WINDOW_AUTOSIZE):
-        if not name:
+    def __init__(self, title: str, flags=WINDOW_NORMAL):
+        if not title:
             raise ValueError("A window name is required")
 
-        self._name = name
+        self._title = title
         self._has_mouse = _has_set_mouse_callback()
         self._has_trackbar = _has_create_trackbar()
 
-        cv2.namedWindow(name, flags)
+        cv2.namedWindow(title, flags)
         if self._has_mouse:
-            _set_mouse_callback(name, self._mouse_callback)
+            _set_mouse_callback(title, self._mouse_callback)
 
     @property
     def has_mouse(self) -> str:
-        return deepcopy(self._name)
+        return deepcopy(self._title)
 
     @property
-    def name(self) -> str:
-        return deepcopy(self._name)
+    def title(self) -> str:
+        return deepcopy(self._title)
+
+    def set_title(self, title: str) -> None:
+        cv2.setWindowTitle(self._title, title)
+        self._title = title
+
+    @property
+    def image_rect(self) -> RectInt:
+        x1, y1, x2, y2 = cv2.getWindowImageRect(self._title)
+        return x1, y1, x2, y2
 
     @staticmethod
     def start_window_thread() -> None:
         cv2.startWindowThread()
 
     @staticmethod
     def destroy_all_windows() -> None:
@@ -95,117 +104,124 @@
     def on_mouse(self, event: MouseEvent, x: int, y: int, flags: int) -> None:
         pass
 
     def _trackbar_callback(self, name: str, value: int) -> None:
         self.on_trackbar(name, value)
 
     def on_trackbar(self, name: str, value: int) -> None:
-        self.on_trackbar(name, value)
+        pass
 
     def create_trackbar(self, trackbarname: str, value: int, count: int) -> None:
         _create_trackbar(
             trackbarname,
-            self._name,
+            self._title,
             value,
             count,
             wraps(self._trackbar_callback, trackbarname),
         )
 
     def get_trackbar_pos(self, trackbarname: str) -> int:
-        return cv2.getTrackbarPos(trackbarname, self._name)
+        return cv2.getTrackbarPos(trackbarname, self._title)
 
     def set_trackbar_max(self, trackbarname: str, maxval: int) -> None:
-        cv2.setTrackbarMax(trackbarname, self._name, maxval)
+        cv2.setTrackbarMax(trackbarname, self._title, maxval)
 
     def set_trackbar_min(self, trackbarname: str, minval: int) -> None:
-        cv2.setTrackbarMin(trackbarname, self._name, minval)
+        cv2.setTrackbarMin(trackbarname, self._title, minval)
 
     def set_trackbar_pos(self, trackbarname: str, pos: int) -> None:
-        cv2.setTrackbarPos(trackbarname, self._name, pos)
+        cv2.setTrackbarPos(trackbarname, self._title, pos)
 
     def destroy(self) -> None:
-        cv2.destroyWindow(self._name)
+        cv2.destroyWindow(self._title)
 
     def draw(self, image: NDArray) -> None:
-        cv2.imshow(self._name, image)
+        cv2.imshow(self._title, image)
 
     def move(self, x: int, y: int) -> None:
-        cv2.moveWindow(self._name, x, y)
+        cv2.moveWindow(self._title, x, y)
 
     def resize(self, width: int, height: int) -> None:
-        cv2.resizeWindow(self._name, width, height)
+        cv2.resizeWindow(self._title, width, height)
+
+    def _get_property(self, prop: WindowProperty) -> float:
+        return cv2.getWindowProperty(self._title, prop.value)
 
-    def get_property(self, prop: WindowProperty) -> float:
-        return cv2.getWindowProperty(self._name, prop.value)
+    def _set_property(self, prop: WindowProperty, value: float) -> None:
+        cv2.setWindowProperty(self._title, prop.value, value)
 
-    def set_property(self, prop: WindowProperty, value: float) -> None:
-        cv2.setWindowProperty(self._name, prop.value, value)
+    def _get_boolean_property(self, prop: WindowProperty) -> bool:
+        if prop == WindowProperty.OPENGL:
+            # [IMPORTANT] It is `0` if OpenGL is supported, `-1` otherwise.
+            return self._get_property(prop) == 0
+        else:
+            return self._get_property(prop) == 1
+
+    def _set_boolean_property(self, prop: WindowProperty, value: bool) -> None:
+        if prop == WindowProperty.OPENGL:
+            # [IMPORTANT] It is `0` if OpenGL is supported, `-1` otherwise.
+            self._set_property(prop, 0 if value else -1)
+        else:
+            self._set_property(prop, 1 if value else 1)
 
     @property
-    def fullscreen(self) -> float:
-        return self.get_property(WindowProperty.FULLSCREEN)
+    def fullscreen(self) -> bool:
+        return self._get_boolean_property(WindowProperty.FULLSCREEN)
 
     @fullscreen.setter
-    def fullscreen(self, value: float) -> None:
-        self.set_property(WindowProperty.FULLSCREEN, value)
+    def fullscreen(self, value: bool) -> None:
+        self._set_boolean_property(WindowProperty.FULLSCREEN, value)
 
     @property
-    def autosize(self) -> float:
-        return self.get_property(WindowProperty.AUTOSIZE)
+    def autosize(self) -> bool:
+        return self._get_boolean_property(WindowProperty.AUTOSIZE)
 
     @autosize.setter
-    def autosize(self, value: float) -> None:
-        self.set_property(WindowProperty.AUTOSIZE, value)
+    def autosize(self, value: bool) -> None:
+        self._set_boolean_property(WindowProperty.AUTOSIZE, value)
 
     @property
-    def aspect_ratio(self) -> float:
-        return self.get_property(WindowProperty.ASPECT_RATIO)
+    def aspect_ratio(self) -> bool:
+        return self._get_boolean_property(WindowProperty.ASPECT_RATIO)
 
     @aspect_ratio.setter
-    def aspect_ratio(self, value: float) -> None:
-        self.set_property(WindowProperty.ASPECT_RATIO, value)
+    def aspect_ratio(self, value: bool) -> None:
+        self._set_boolean_property(WindowProperty.ASPECT_RATIO, value)
 
     @property
-    def opengl(self) -> float:
-        return self.get_property(WindowProperty.OPENGL)
+    def opengl(self) -> bool:
+        return self._get_boolean_property(WindowProperty.OPENGL)
 
     @opengl.setter
-    def opengl(self, value: float) -> None:
-        self.set_property(WindowProperty.OPENGL, value)
+    def opengl(self, value: bool) -> None:
+        self._set_boolean_property(WindowProperty.OPENGL, value)
 
     @property
-    def visible(self) -> float:
-        return self.get_property(WindowProperty.VISIBLE)
+    def visible(self) -> bool:
+        return self._get_boolean_property(WindowProperty.VISIBLE)
 
     @visible.setter
-    def visible(self, value: float) -> None:
-        self.set_property(WindowProperty.VISIBLE, value)
+    def visible(self, value: bool) -> None:
+        self._set_boolean_property(WindowProperty.VISIBLE, value)
 
     @property
-    def topmost(self) -> float:
-        return self.get_property(WindowProperty.TOPMOST)
+    def topmost(self) -> bool:
+        return self._get_boolean_property(WindowProperty.TOPMOST)
 
     @topmost.setter
-    def topmost(self, value: float) -> None:
-        self.set_property(WindowProperty.TOPMOST, value)
+    def topmost(self, value: bool) -> None:
+        self._set_boolean_property(WindowProperty.TOPMOST, value)
 
     @property
-    def vsync(self) -> float:
-        return self.get_property(WindowProperty.VSYNC)
+    def vsync(self) -> bool:
+        return self._get_boolean_property(WindowProperty.VSYNC)
 
     @vsync.setter
-    def vsync(self, value: float) -> None:
-        self.set_property(WindowProperty.VSYNC, value)
-
-    def set_title(self, title: str) -> None:
-        cv2.setWindowTitle(self._name, title)
-
-    def get_image_rect(self) -> RectInt:
-        x1, y1, x2, y2 = cv2.getWindowImageRect(self._name)
-        return x1, y1, x2, y2
+    def vsync(self, value: bool) -> None:
+        self._set_boolean_property(WindowProperty.VSYNC, value)
 
     @staticmethod
     def poll_key() -> int:
         return cv2.pollKey()
 
     @staticmethod
     def wait_key(delay=0) -> int:
```

## cvlayer/layers/base/layer_base.py

```diff
@@ -1,14 +1,15 @@
 # -*- coding: utf-8 -*-
 
-from abc import abstractmethod
 from copy import deepcopy
 from datetime import datetime
 from io import StringIO
-from typing import Any, Callable, Dict, List, Optional, Tuple
+from types import TracebackType
+from typing import Any, Dict, List, Literal, Optional, Tuple, Type
+from weakref import ref
 
 from numpy import zeros
 from numpy.typing import NDArray
 
 from cvlayer.cv.mouse import EventFlags, MouseEvent
 from cvlayer.layers.base.layer_parameter import LayerParameter
 
@@ -16,196 +17,259 @@
 class SkipError(ValueError):
     def __int__(self):
         msg = "An error occurred in the previous layer, so it cannot be executed"
         super().__init__(msg)
 
 
 class LayerBase:
-    _prev_frame: NDArray
-    _next_frame: NDArray
-
-    _prev_data: Any
-    _next_data: Any
-
     _params: Dict[str, LayerParameter]
-    _param_cursor: int
-
     _error: Optional[BaseException]
 
-    _duration: float
-
-    def __init__(self, name: Optional[str] = None, deep_copy_params=True):
-        self._name = name
-        self._deep_copy_params = deep_copy_params
-
-        self._prev_frame = zeros([])
-        self._next_frame = zeros([])
+    def __init__(
+        self,
+        name: Optional[str] = None,
+        prev: Optional[ref["LayerBase"]] = None,
+        **params: LayerParameter,
+    ):
+        self._name = name if name else str()
+        self._frame = zeros([])
+        self._data = None
+        self._params = params
+        self._cursor = 0
+        self._error = None
+        self._begin = datetime.now()
+        self._end = datetime.now()
 
-        self._prev_data = None
-        self._next_data = None
+        self._prev = prev
 
-        self._params = dict()
-        self._param_cursor = 0
-        self._error = None
+        self._keycode = 0
+        self._mouse_event = MouseEvent.MOUSE_MOVE
+        self._mouse_x = 0
+        self._mouse_y = 0
+        self._mouse_flags = 0
 
-        self._duration = 0.0
+    @property
+    def name(self):
+        return self._name
 
-    def __repr__(self) -> str:
-        cls_name = type(self).__name__
-        if self._name:
-            return f"{cls_name}<{self._name}>"
-        else:
-            return cls_name
+    @property
+    def prev_frame(self):
+        assert self._prev is not None
+        prev = self._prev()
+        assert isinstance(prev, LayerBase)
+        return prev.frame
 
     @property
-    def has_name(self) -> bool:
-        return bool(self._name)
+    def prev_data(self):
+        assert self._prev is not None
+        prev = self._prev()
+        assert isinstance(prev, LayerBase)
+        return prev.data
 
     @property
-    def name(self) -> str:
-        if self._name:
-            return self._name
-        else:
-            return str()
+    def frame(self):
+        return self._frame
+
+    @frame.setter
+    def frame(self, value: NDArray) -> None:
+        self._frame = value
 
     @property
-    def prev_frame(self) -> NDArray:
-        return self._prev_frame
+    def data(self):
+        return self._data
+
+    @data.setter
+    def data(self, value: Any) -> None:
+        self._data = value
 
     @property
-    def next_frame(self) -> NDArray:
-        return self._next_frame
+    def mouse_event(self):
+        return self._mouse_event
 
     @property
-    def prev_data(self) -> Any:
-        return self._prev_data
+    def mouse_x(self):
+        return self._mouse_x
 
     @property
-    def next_data(self) -> Any:
-        return self._next_data
+    def mouse_y(self):
+        return self._mouse_y
 
     @property
-    def duration(self) -> float:
-        return self._duration
+    def mouse_flags(self):
+        return self._mouse_flags
 
     @property
-    def param_cursor_key(self) -> str:
-        return list(self._params.keys())[self._param_cursor]
+    def keycode(self):
+        return self._keycode
+
+    def __str__(self):
+        return self._name  # Important !!
+
+    def __repr__(self) -> str:
+        if self._name:
+            return f"Layer[{self._name}]"
+        else:
+            return type(self).__name__
+
+    def __getitem__(self, item: str) -> LayerParameter:
+        return self.param(item)
+
+    def __setitem__(self, key: str, value: LayerParameter) -> None:
+        self._params[key] = value
+
+    def __enter__(self):
+        self._begin = datetime.now()
+        self._error = None
+        return self
+
+    def __exit__(
+        self,
+        exc_type: Optional[Type[BaseException]],
+        exc_val: Optional[BaseException],
+        exc_tb: Optional[TracebackType],
+    ) -> Optional[Literal[True]]:
+        self._error = exc_val
+        self._end = datetime.now()
+        # If an exception is supplied, and the method wishes to suppress the exception
+        # (i.e., prevent it from being propagated), it should return a true value
+        return None
 
     @property
     def keys(self) -> List[str]:
         return list(self._params.keys())
 
     @property
+    def cursor_key(self) -> str:
+        return list(self._params.keys())[self._cursor]
+
+    @property
+    def duration(self):
+        return (self._end - self._begin).total_seconds()
+
+    @property
     def has_error(self) -> bool:
         return self._error is not None
 
+    def clear_error(self) -> None:
+        self._error = None
+
+    def param(self, key: str) -> LayerParameter:
+        if key not in self._params:
+            self._params[key] = LayerParameter()
+        return self._params[key]
+
     def has(self, key: str) -> bool:
         return key in self._params
 
     def get(self, key: str) -> Any:
         return self._params[key].value
 
     def set(self, key: str, value: Any) -> None:
         self._params[key].value = value
 
     def decrease(self, key: str) -> None:
-        self._params[key].decrease()
+        self._params[key].do_decrease()
 
     def increase(self, key: str) -> None:
-        self._params[key].increase()
+        self._params[key].do_increase()
 
-    def change_param_cursor(self, index: int) -> None:
+    def set_cursor(self, index: int) -> None:
         if index < 0:
-            self._param_cursor = 0
+            self._cursor = 0
         elif index >= len(self._params):
-            self._param_cursor = len(self._params) - 1
+            self._cursor = len(self._params) - 1
         else:
-            self._param_cursor = index
+            self._cursor = index
 
-    def prev_param_cursor(self) -> None:
-        self.change_param_cursor(self._param_cursor - 1)
+    def prev_cursor(self) -> None:
+        self.set_cursor(self._cursor - 1)
 
-    def next_param_cursor(self) -> None:
-        self.change_param_cursor(self._param_cursor + 1)
+    def next_cursor(self) -> None:
+        self.set_cursor(self._cursor + 1)
 
-    def decrease_at_param_cursor(self) -> None:
-        self._params[self.param_cursor_key].decrease()
+    def decrease_at_cursor(self) -> None:
+        self._params[self.cursor_key].do_decrease()
 
-    def increase_at_param_cursor(self) -> None:
-        self._params[self.param_cursor_key].increase()
+    def increase_at_cursor(self) -> None:
+        self._params[self.cursor_key].do_increase()
 
-    def init_params(self) -> Dict[str, LayerParameter]:
-        assert self is not None
-        return dict()
+    def init_defaults(self) -> None:
+        self._params = self.on_defaults()
 
-    def to_help(self) -> str:
+    def as_help(self) -> str:
         buffer = StringIO()
         buffer.write(f"{repr(self)}")
 
         for key, param in self._params.items():
-            prefix = ">" if self.param_cursor_key == key else " "
-            buffer.write(f"\n{prefix} {key}: {param.printable()}")
+            prefix = ">" if self.cursor_key == key else " "
+            buffer.write(f"\n{prefix} {key}: {param.as_printable_text()}")
 
         if self._error is not None:
             buffer.write(f"\n{type(self._error).__name__} {self._error}")
 
         return buffer.getvalue()
 
     def skip(self):
+        self._begin = datetime.now()
+        self._end = deepcopy(self._begin)
         self._error = SkipError()
-        self._duration = 0.0
-
-    def run(self, frame: NDArray, data: Any) -> Tuple[NDArray, Any]:
-        if self._deep_copy_params:
-            self._prev_frame = frame.copy()
-            self._prev_frame.setflags(write=False)
-            self._prev_data = deepcopy(data)
-        else:
-            self._prev_frame = frame
-            self._prev_data = data
-
-        running_frame = frame.copy() if self._deep_copy_params else frame
-
-        next_frame: NDArray
-        next_data: Any
 
-        begin = datetime.now()
+    def run(self, frame: NDArray, data=None) -> Tuple[NDArray, Any]:
+        self._begin = datetime.now()
         try:
             self._error = None
-            next_frame, next_data = self.on_layer(running_frame, data)
+            self._frame, self._data = self.on_layer(frame, data)
         except BaseException as e:
             self._error = e
             raise e
         finally:
-            self._duration = (datetime.now() - begin).total_seconds()
+            self._end = datetime.now()
+        return self._frame, self._data
 
-        if self._deep_copy_params:
-            self._next_frame = next_frame.copy()
-            self._next_frame.setflags(write=False)
-            self._next_data = deepcopy(next_data)
-        else:
-            self._next_frame = next_frame
-            self._next_data = next_data
-
-        return next_frame, next_data
+    def on_defaults(self) -> Dict[str, LayerParameter]:
+        assert self is not None
+        return dict()
 
     def on_create(self) -> None:
-        assert self is not None
+        pass
 
     def on_destroy(self) -> None:
-        assert self is not None
-
-    def on_keydown(self, code: int) -> bool:
-        assert self is not None
-        assert isinstance(code, int)
-        return False  # If `True`, the event is consumed.
-
-    def on_mouse(self, event: MouseEvent, x: int, y: int, flags: EventFlags) -> None:
         pass
 
-    @abstractmethod
-    def on_layer(self, frame: NDArray, data: Any) -> Tuple[NDArray, Any]:
-        raise NotImplementedError
+    def on_keydown(self, keycode: int) -> Optional[bool]:
+        self._keycode = keycode
+
+        if self._params:
+            result = list()
+            for param in self._params.values():
+                if param.has_keydown:
+                    result.append(param.call_keydown(keycode))
+            if result:
+                return any(result)
+
+        return False
+
+    def on_mouse(
+        self,
+        event: MouseEvent,
+        x: int,
+        y: int,
+        flags: EventFlags,
+    ) -> Optional[bool]:
+        self._mouse_event = event
+        self._mouse_x = x
+        self._mouse_y = y
+        self._mouse_flags = flags
+
+        if self._params:
+            result = list()
+            for param in self._params.values():
+                if param.has_mouse:
+                    result.append(param.call_mouse(event, x, y, flags))
+            if result:
+                return any(result)
 
+        return False
 
-OnLayerCallable = Callable[[NDArray, Any], Tuple[NDArray, Any]]
+    def on_layer(self, frame: NDArray, data: Any) -> Tuple[NDArray, Any]:
+        assert self
+        return frame, data
```

## cvlayer/layers/base/layer_manager.py

```diff
@@ -1,189 +1,240 @@
 # -*- coding: utf-8 -*-
 
-from logging import Logger, getLogger
-from typing import Any, Dict, Final, List, Optional
+from copy import deepcopy
+from functools import reduce
+from logging import getLogger
+from typing import Any, Dict, Final, List, Optional, Tuple, Union
+from weakref import ref
 
 from numpy.typing import NDArray
 
 from cvlayer.cv.mouse import EventFlags, MouseEvent
 from cvlayer.layers.base.layer_base import LayerBase, SkipError
 
 LAST_LAYER_INDEX: Final[int] = -1
 
 
 class LayerManager:
     _layers: List[LayerBase]
-    _name_to_index: Dict[str, int]
-
-    def __init__(
-        self,
-        layer_index=LAST_LAYER_INDEX,
-        logger_name: Optional[str] = None,
-        deep_copy_params=True,
-    ):
-        self._layer_index = layer_index
-        self._logger_name = logger_name
-        self._deep_copy_params = deep_copy_params
+    _name2index: Dict[str, int]
 
+    def __init__(self, cursor=LAST_LAYER_INDEX, logger_name: Optional[str] = None):
+        self._cursor = cursor
         self._layers = list()
-        self._name_to_index = dict()
+        self._name2index = dict()
+        self._logger = getLogger(logger_name)
+
+        self._pseudo_first = LayerBase("__pseudo_first__", None)
+
+    def __getitem__(self, key: Any) -> LayerBase:
+        if not self.has_layer(key):
+            self.append_layer(str(key))
+        return self.get_layer(key)
+
+    def __setitem__(self, key: str, value: LayerBase) -> None:
+        raise NotImplementedError("Unsupported __setitem__ method")
 
     @property
-    def logger(self) -> Logger:
-        return getLogger(self._logger_name)
+    def cursor(self):
+        return self._cursor
 
     @property
-    def deep_copy_params(self) -> bool:
-        return self._deep_copy_params
+    def logger(self):
+        return self._logger
 
     @property
-    def layers(self) -> List[LayerBase]:
-        assert isinstance(self._layers, list)
-        return self._layers
+    def current_layer(self) -> LayerBase:
+        return self._layers[self._cursor]
 
     @property
-    def layer_index(self) -> int:
-        return self._layer_index
+    def first_layer(self) -> LayerBase:
+        return self._layers[0]
 
     @property
-    def current_layer(self) -> LayerBase:
-        return self._layers[self._layer_index]
+    def last_layer(self) -> LayerBase:
+        return self._layers[LAST_LAYER_INDEX]
 
     @property
-    def length_layers(self) -> int:
+    def number_of_layers(self) -> int:
         return len(self._layers)
 
     @property
-    def is_last_layer(self) -> bool:
-        return self._layer_index == LAST_LAYER_INDEX
+    def is_cursor_at_first(self) -> bool:
+        return self._cursor == 0
+
+    @property
+    def is_cursor_at_last(self) -> bool:
+        return self._cursor == LAST_LAYER_INDEX
+
+    @property
+    def total_duration(self) -> float:
+        if self.number_of_layers >= 1:
+            durations = map(lambda x: x.duration, self._layers)
+            return float(reduce(lambda x, y: x + y, durations))
+        else:
+            return 0.0
+
+    def append_layer(self, name: str) -> None:
+        if name in self._name2index:
+            raise KeyError(f"A layer with the same name already exists: '{name}'")
+
+        prev = self._layers[-1] if self._layers else self._pseudo_first
+        layer = LayerBase(name, ref(prev))
 
-    def append_layer(self, layer: LayerBase) -> None:
         self._layers.append(layer)
-        if layer.has_name:
-            self._name_to_index[layer.name] = len(self._layers) - 1
+        self._name2index[name] = len(self._layers) - 1
 
-    def get_layer_index_by_name(self, name: str) -> int:
-        return self._name_to_index[name]
+    def has_layer(self, key: Any) -> bool:
+        return str(key) in self._name2index
 
-    def get_layer_by_name(self, name: str) -> LayerBase:
-        return self._layers[self.get_layer_index_by_name(name)]
+    def get_layer_index(self, key: Any) -> int:
+        return self._name2index[str(key)]
 
-    def get_layer_prev_frame(self, index: int) -> NDArray:
-        return self._layers[index].prev_frame
+    def get_layer(self, key: Any) -> LayerBase:
+        return self._layers[self._name2index[str(key)]]
 
-    def get_layer_prev_data(self, index: int) -> Any:
-        return self._layers[index].prev_data
+    def get_layer_by_index(self, index: int) -> LayerBase:
+        return self._layers[index]
 
-    def get_layer_next_frame(self, index: int) -> NDArray:
-        return self._layers[index].next_frame
+    def get_layer_by_name(self, name: str) -> LayerBase:
+        return self._layers[self.get_layer_index(name)]
 
-    def get_layer_next_data(self, index: int) -> Any:
-        return self._layers[index].next_data
+    def get_layer_frame(self, key: Union[int, str]) -> NDArray:
+        return self.get_layer(key).frame
 
-    def has_layer_param(self, index: int, key: str) -> bool:
-        return self._layers[index].has(key)
+    def get_layer_data(self, key: Union[int, str]) -> Any:
+        return self.get_layer(key).data
 
-    def get_layer_param(self, index: int, key: str) -> Any:
-        return self._layers[index].get(key)
+    def has_layer_param(self, layer_key: Union[int, str], param_key: str) -> bool:
+        return self.get_layer(layer_key).has(param_key)
 
-    def set_layer_param(self, index: int, key: str, value: Any) -> None:
-        self._layers[index].set(key, value)
+    def get_layer_param(self, layer_key: Union[int, str], param_key: str) -> Any:
+        return self.get_layer(layer_key).get(param_key)
 
-    def change_layer(self, index: int) -> None:
-        if index == LAST_LAYER_INDEX or index == len(self._layers):
-            self._layer_index = LAST_LAYER_INDEX
+    def set_layer_param(
+        self,
+        layer_key: Union[int, str],
+        param_key: str,
+        value: Any,
+    ) -> None:
+        return self.get_layer(layer_key).set(param_key, value)
+
+    def set_cursor(self, cursor: int) -> None:
+        if cursor == LAST_LAYER_INDEX or cursor == len(self._layers):
+            self._cursor = LAST_LAYER_INDEX
             return
 
         if not self._layers:
             raise IndexError("LayerBase does not exist")
 
-        if 0 <= index < len(self._layers):
-            self._layer_index = index
+        if 0 <= cursor < len(self._layers):
+            self._cursor = cursor
         else:
-            raise IndexError(f"LayerBase index out of range: {index}")
+            raise IndexError(f"LayerBase index out of range: {cursor}")
 
-    def change_last_layer(self) -> None:
-        self._layer_index = LAST_LAYER_INDEX
+    def move_last_layer(self) -> None:
+        self._cursor = LAST_LAYER_INDEX
 
-    def change_prev_layer(self) -> None:
+    def move_prev_layer(self) -> None:
         if not self._layers:
             raise IndexError("LayerBase does not exist")
 
-        if self._layer_index == LAST_LAYER_INDEX:
-            self._layer_index = len(self._layers) - 1
+        if self._cursor == LAST_LAYER_INDEX:
+            self._cursor = len(self._layers) - 1
             return
 
-        prev_index = self._layer_index - 1
-        self._layer_index = prev_index if prev_index >= 0 else LAST_LAYER_INDEX
+        prev_index = self._cursor - 1
+        self._cursor = prev_index if prev_index >= 0 else LAST_LAYER_INDEX
 
-    def change_next_layer(self) -> None:
+    def move_next_layer(self) -> None:
         if not self._layers:
             raise IndexError("LayerBase does not exist")
 
-        if self._layer_index == LAST_LAYER_INDEX:
-            self._layer_index = 0
+        if self._cursor == LAST_LAYER_INDEX:
+            self._cursor = 0
             return
 
-        next_index = self._layer_index + 1
+        next_index = self._cursor + 1
         max_index = len(self._layers)
-        self._layer_index = next_index if next_index < max_index else LAST_LAYER_INDEX
+        self._cursor = next_index if next_index < max_index else LAST_LAYER_INDEX
 
-    def logging_current_param_cursor(self) -> None:
-        if self.is_last_layer:
-            self.logger.info("No layer have been selected")
+    def logging_current_param(self) -> None:
+        if self.is_cursor_at_last:
+            self._logger.info("No layer have been selected")
             return
 
         current_layer = self.current_layer
         layer_type = type(current_layer).__name__
 
-        key = current_layer.param_cursor_key
+        key = current_layer.cursor_key
         value = current_layer.get(key)
-        self.logger.info(f"[{layer_type}] '{key}' parameter value: {value}")
+        self._logger.info(f"[{layer_type}] '{key}' parameter value: {value}")
 
-    def logging_current_layer_information(self) -> None:
-        index = self._layer_index
+    def logging_current_layer(self) -> None:
+        index = self._cursor
         max_index = len(self._layers) - 1
         name = type(self._layers[index]).__name__
-        self.logger.info(f"Change layer ({index}/{max_index}) '{name}'")
+        self._logger.info(f"Change layer ({index}/{max_index}) '{name}'")
 
-    def call_init_params_with_layers(self) -> None:
-        for layer in self._layers:
-            layer._params = layer.init_params()
+    def update_first_frame_and_data(self, frame: NDArray, data=None) -> None:
+        self._pseudo_first.frame = frame
+        self._pseudo_first.data = data
 
-    def call_on_frame_with_layers(self, frame: NDArray) -> NDArray:
+    def run(self, frame: NDArray, data=None, use_deepcopy=False) -> Tuple[NDArray, Any]:
         if not self._layers:
-            return frame
+            return frame, data
 
         prev_layer: Optional[LayerBase] = None
         next_frame: NDArray = frame
-        next_data: Any = None
+        next_data: Any = data
 
         for layer_index, layer in enumerate(self._layers):
             assert isinstance(layer, LayerBase)
             if prev_layer is not None:
                 if prev_layer.has_error:
                     layer.skip()
                     continue
 
+            if use_deepcopy:
+                next_frame = next_frame.copy()
+                next_frame.setflags(write=False)
+                next_data = deepcopy(data)
+
             try:
                 next_frame, next_data = layer.run(next_frame, next_data)
             except SkipError:
                 continue
             except BaseException as e:
-                self.logger.exception(e)
+                self._logger.exception(e)
             finally:
                 prev_layer = layer
 
-        return next_frame
+        return next_frame, next_data
 
-    def call_on_keydown_with_current_layer(self, keycode: int) -> bool:
-        if self.is_last_layer:
-            return False  # If `True`, the event is consumed.
+    def on_create(self, init_defaults=True) -> None:
+        for layer in self._layers:
+            if init_defaults:
+                layer.init_defaults()
+            layer.on_create()
+
+    def on_destroy(self) -> None:
+        for layer in self._layers:
+            layer.on_destroy()
+
+    def on_keydown(self, keycode: int) -> Optional[bool]:
+        if self.is_cursor_at_last:
+            return False
         else:
             return self.current_layer.on_keydown(keycode)
 
-    def call_on_mouse_with_current_layer(
-        self, event: MouseEvent, x: int, y: int, flags: EventFlags
-    ) -> None:
-        if not self.is_last_layer:
+    def on_mouse(
+        self,
+        event: MouseEvent,
+        x: int,
+        y: int,
+        flags: EventFlags,
+    ) -> Optional[bool]:
+        if self.is_cursor_at_last:
+            return False
+        else:
             return self.current_layer.on_mouse(event, x, y, flags)
```

## cvlayer/layers/base/layer_parameter.py

```diff
@@ -1,171 +1,479 @@
 # -*- coding: utf-8 -*-
 
 from copy import deepcopy
 from enum import Enum
-from typing import Any, Callable, Iterable, Optional
+from math import ceil, floor
+from typing import Any, Callable, Iterable, Optional, Union
+
+from cvlayer.cv.mouse import EventFlags, MouseEvent
+from cvlayer.typing import PointInt, RectInt
 
 LimitedCallable = Callable[[], Any]
 ModifyCallable = Callable[[Any], Any]
 PrintableCallable = Callable[[Any], str]
 GetterCallable = Callable[[Any], Any]
 SetterCallable = Callable[[Any], Any]
+OnKeydownCallable = Callable[[int], Optional[bool]]
+OnMouseCallable = Callable[[MouseEvent, int, int, EventFlags], Optional[bool]]
+
+
+class AlreadyFrozenError(BaseException):
+    def __init__(self, *args):
+        super().__init__(*args)
+
+
+class NotReadyFrozenError(BaseException):
+    def __init__(self, *args):
+        super().__init__(*args)
 
 
 class LayerParameter:
     def __init__(
         self,
-        value: Any,
+        value=None,
         min_value: Optional[LimitedCallable] = None,
         max_value: Optional[LimitedCallable] = None,
         decrease: Optional[ModifyCallable] = None,
         increase: Optional[ModifyCallable] = None,
         getter: Optional[GetterCallable] = None,
         setter: Optional[SetterCallable] = None,
         printable: Optional[PrintableCallable] = None,
+        keydown: Optional[OnKeydownCallable] = None,
+        mouse: Optional[OnMouseCallable] = None,
+        nullable=True,
+        frozen=False,
+        **kwargs,
     ):
         self._value = value
         self._min_value = min_value
         self._max_value = max_value
         self._decrease = decrease
         self._increase = increase
         self._getter = getter
         self._setter = setter
         self._printable = printable
+        self._keydown = keydown
+        self._mouse = mouse
+        self._nullable = nullable
+        self._frozen = frozen
+        self._kwargs = kwargs
+
+    def freeze(self) -> None:
+        self._frozen = True
+
+    def melt(self) -> None:
+        self._frozen = False
+
+    @property
+    def initialized(self) -> bool:
+        return self._frozen
+
+    def _clear_all_properties(self) -> None:
+        self._value = None
+        self._min_value = None
+        self._max_value = None
+        self._decrease = None
+        self._increase = None
+        self._getter = None
+        self._setter = None
+        self._printable = None
+        self._keydown = None
+        self._mouse = None
+        self._nullable = True
+        self._frozen = False
+        self._kwargs = dict()
+
+    def _validate_initialize(self) -> None:
+        if self._frozen:
+            raise AlreadyFrozenError("Already frozen state")
+
+    def _set_value(self, value: Any):
+        self._validate_initialize()
+        self._value = value
+
+    def _set_min(self, callback: LimitedCallable):
+        self._validate_initialize()
+        self._min_value = callback
+
+    def _set_max(self, callback: LimitedCallable):
+        self._validate_initialize()
+        self._max_value = callback
+
+    def _set_decrease(self, callback: ModifyCallable):
+        self._validate_initialize()
+        self._decrease = callback
+
+    def _set_increase(self, callback: ModifyCallable):
+        self._validate_initialize()
+        self._increase = callback
+
+    def _set_getter(self, callback: GetterCallable):
+        self._validate_initialize()
+        self._getter = callback
+
+    def _set_setter(self, callback: SetterCallable):
+        self._validate_initialize()
+        self._setter = callback
+
+    def _set_keydown(self, callback: OnKeydownCallable):
+        self._validate_initialize()
+        self._keydown = callback
+
+    def _set_mouse(self, callback: OnMouseCallable):
+        self._validate_initialize()
+        self._mouse = callback
+
+    def _set_printable(self, callback: PrintableCallable):
+        self._validate_initialize()
+        self._printable = callback
+
+    def _set_nullable(self, callback: PrintableCallable):
+        self._validate_initialize()
+        self._nullable = callback
+
+    initial = property(None, _set_value)
+    min = property(None, _set_min)
+    max = property(None, _set_max)
+    decrease = property(None, _set_decrease)
+    increase = property(None, _set_increase)
+    getter = property(None, _set_getter)
+    setter = property(None, _set_setter)
+    keydown = property(None, _set_keydown)
+    mouse = property(None, _set_mouse)
+    printable = property(None, _set_printable)
+    nullable = property(None, _set_nullable)
 
     def normalize_by_candidate_value(self, value: Any) -> Any:
         if value is None:
-            return None
+            if self._nullable:
+                return None
+            else:
+                raise ValueError("A 'None' value cannot be assigned.")
+
+        assert value is not None
+        if not isinstance(value, type(self._value)):
+            raise TypeError(f"The value must be of type {type(self._value).__name__}")
 
         minval = self._min_value() if self._min_value else None
         maxval = self._max_value() if self._max_value else None
 
         if minval is not None and value < minval:
             return minval
         if maxval is not None and value > maxval:
             return maxval
         else:
             return value
 
+    def validate(self) -> None:
+        if not self._frozen:
+            raise NotReadyFrozenError("Not ready frozen state")
+
     @property
     def value(self) -> Any:
-        return self._getter(self._value) if self._getter else self._value
+        self.validate()
+        if self._getter:
+            return self._getter(self._value)
+        else:
+            return self._value
 
     @value.setter
-    def value(self, value: Any) -> None:
-        normalized_val = self.normalize_by_candidate_value(value)
-        self._value = self._setter(normalized_val) if self._setter else normalized_val
+    def value(self, val: Any) -> None:
+        self.validate()
+        normalized = self.normalize_by_candidate_value(val)
+        if self._setter:
+            self._value = self._setter(normalized)
+        else:
+            self._value = normalized
 
-    def decrease(self) -> None:
+    def do_decrease(self) -> None:
+        self.validate()
         if not self._decrease:
             return
-        self._value = self.normalize_by_candidate_value(self._decrease(self._value))
+        candidate = self._decrease(self._value)
+        self._value = self.normalize_by_candidate_value(candidate)
 
-    def increase(self) -> None:
+    def do_increase(self) -> None:
+        self.validate()
         if not self._increase:
             return
-        self._value = self.normalize_by_candidate_value(self._increase(self._value))
+        candidate = self._increase(self._value)
+        self._value = self.normalize_by_candidate_value(candidate)
 
-    def printable(self) -> str:
-        return self._printable(self._value) if self._printable else str(self._value)
+    def as_printable_text(self) -> str:
+        self.validate()
+        if self._printable:
+            return self._printable(self._value)
+        else:
+            return str(self._value)
 
+    @property
+    def has_keydown(self) -> bool:
+        return self._keydown is not None
 
-def printonly_param(printable: Callable[[], str]) -> LayerParameter:
-    return LayerParameter(value=None, printable=lambda x: printable())
+    @property
+    def has_mouse(self) -> bool:
+        return self._mouse is not None
 
+    def call_keydown(self, keycode: int) -> Optional[bool]:
+        if self._keydown:
+            return self._keydown(keycode)
+        else:
+            return False
 
-def readonly_param(
-    value: Any,
-    printable: Optional[PrintableCallable] = None,
-) -> LayerParameter:
-    return LayerParameter(value=value, printable=printable)
-
-
-def bool_param(
-    value: bool,
-    printable: Optional[PrintableCallable] = None,
-) -> LayerParameter:
-    return LayerParameter(
-        value=value,
-        decrease=lambda x: not x,
-        increase=lambda x: not x,
-        printable=printable,
-    )
-
-
-def int_param(
-    value: int,
-    min_value: Optional[int] = None,
-    max_value: Optional[int] = None,
-    printable: Optional[PrintableCallable] = None,
-    step=1,
-) -> LayerParameter:
-    return LayerParameter(
-        value=value,
-        min_value=lambda: min_value,
-        max_value=lambda: max_value,
-        decrease=lambda x: x - step,
-        increase=lambda x: x + step,
-        printable=printable,
-    )
-
-
-def uint_param(
-    value: int,
-    max_value: Optional[int] = None,
-    step=1,
-) -> LayerParameter:
-    return int_param(
-        value=value,
-        min_value=0,
-        max_value=max_value,
-        printable=None,
-        step=step,
-    )
-
-
-def float_param(
-    value: float,
-    min_value: Optional[float] = None,
-    max_value: Optional[float] = None,
-    printable: Optional[PrintableCallable] = None,
-    step=0.1,
-) -> LayerParameter:
-    return LayerParameter(
-        value=value,
-        min_value=lambda: min_value,
-        max_value=lambda: max_value,
-        decrease=lambda x: x - step,
-        increase=lambda x: x + step,
-        printable=printable,
-    )
-
-
-def enum_param(value: Enum) -> LayerParameter:
-    assert isinstance(value, Enum)
-    enum_cls = type(value)
-    assert issubclass(enum_cls, Enum)
-    available_enums = [m for m in enum_cls]
-    return LayerParameter(
-        value=available_enums.index(value),
-        min_value=lambda: 0,
-        max_value=lambda: len(available_enums) - 1,
-        decrease=lambda index: index - 1,
-        increase=lambda index: index + 1,
-        getter=lambda index: available_enums[index],
-        setter=lambda element: available_enums.index(element),
-        printable=lambda index: f"{index} ({available_enums[index].name})",
-    )
-
-
-def list_param(items: Iterable[Any], value: Optional[Any] = None) -> LayerParameter:
-    available_items = list(deepcopy(items))
-    return LayerParameter(
-        value=available_items.index(value),
-        min_value=lambda: 0,
-        max_value=lambda: len(available_items) - 1,
-        decrease=lambda index: index - 1,
-        increase=lambda index: index + 1,
-        getter=lambda index: available_items[index],
-        setter=lambda element: available_items.index(element),
-        printable=lambda index: f"{index} ({available_items[index]})",
-    )
+    def call_mouse(
+        self,
+        event: MouseEvent,
+        x: int,
+        y: int,
+        flags: EventFlags,
+    ) -> Optional[bool]:
+        if self._mouse:
+            return self._mouse(event, x, y, flags)
+        else:
+            return False
+
+    def __str__(self):
+        return str(self.value)
+
+    def __int__(self):
+        return int(self.value)
+
+    def __float__(self):
+        return float(self.value)
+
+    def __floor__(self):
+        return floor(self.value)
+
+    def __ceil__(self):
+        return ceil(self.value)
+
+    def __repr__(self):
+        return self.as_printable_text()
+
+    def build_printonly(self, printable: Callable[[], str]):
+        if self._frozen:
+            return self
+        self._clear_all_properties()
+        self._printable = lambda x: printable()
+        self._frozen = True
+        return self
+
+    def build_readonly(self, value: Any, printable: Optional[PrintableCallable] = None):
+        if self._frozen:
+            return self
+        self._clear_all_properties()
+        self._value = value
+        self._printable = printable
+        self._frozen = True
+        return self
+
+    def build_boolean(self, value: bool, printable: Optional[PrintableCallable] = None):
+        if self._frozen:
+            return self
+        self._clear_all_properties()
+        self._value = value
+        self._decrease = lambda x: not x
+        self._increase = lambda x: not x
+        self._printable = printable
+        self._frozen = True
+        return self
+
+    def build_integer(
+        self,
+        value: int,
+        min_value: Optional[int] = None,
+        max_value: Optional[int] = None,
+        printable: Optional[PrintableCallable] = None,
+        step=1,
+    ):
+        if self._frozen:
+            return self
+        self._clear_all_properties()
+        self._value = value
+        self._min_value = lambda: min_value
+        self._max_value = lambda: max_value
+        self._decrease = lambda x: x - step
+        self._increase = lambda x: x + step
+        self._printable = printable
+        self._frozen = True
+        return self
+
+    def build_unsigned(
+        self,
+        value: int,
+        min_value: Optional[int] = None,
+        max_value: Optional[int] = None,
+        printable: Optional[PrintableCallable] = None,
+        step=1,
+    ):
+        if self._frozen:
+            return self
+        if min_value is not None and min_value < 0:
+            raise ValueError("The unsigned type must be 0 or greater")
+        return self.build_integer(
+            value=value,
+            min_value=min_value if min_value is not None else 0,
+            max_value=max_value,
+            printable=printable,
+            step=step,
+        )
+
+    def build_floating(
+        self,
+        value: float,
+        min_value: Optional[float] = None,
+        max_value: Optional[float] = None,
+        printable: Optional[PrintableCallable] = None,
+        step=0.01,
+    ):
+        if self._frozen:
+            return self
+        self._clear_all_properties()
+        self._value = value
+        self._min_value = lambda: min_value
+        self._max_value = lambda: max_value
+        self._decrease = lambda x: x - step
+        self._increase = lambda x: x + step
+        self._printable = printable
+        self._frozen = True
+        return self
+
+    def build_enumeration(
+        self,
+        value: Enum,
+        excludes: Optional[Union[Enum, Iterable[Enum]]] = None,
+    ):
+        if self._frozen:
+            return self
+
+        self._clear_all_properties()
+
+        assert isinstance(value, Enum)
+        enum_type = type(value)
+        assert issubclass(enum_type, Enum)
+
+        available_items = [m for m in enum_type]
+        if excludes:
+            if isinstance(excludes, enum_type):
+                try:
+                    available_items.remove(excludes)
+                except ValueError:
+                    pass
+            elif isinstance(excludes, (tuple, list)):
+                for ex in excludes:
+                    try:
+                        available_items.remove(ex)
+                    except ValueError:
+                        pass
+            else:
+                raise TypeError(f"Invalid exclude type: {type(excludes).__name__}")
+
+        if not available_items:
+            raise ValueError("There are no items available")
+
+        self._value = available_items.index(value)
+        self._min_value = lambda: 0
+        self._max_value = lambda: len(available_items) - 1
+        self._decrease = lambda index: index - 1
+        self._increase = lambda index: index + 1
+        self._getter = lambda index: available_items[index]
+        self._setter = lambda element: available_items.index(element)
+        self._printable = lambda index: f"{index} ({available_items[index].name})"
+        self._frozen = True
+        return self
+
+    def build_list(self, items: Iterable[Any], value: Optional[Any] = None):
+        if self._frozen:
+            return self
+
+        self._clear_all_properties()
+
+        if not items:
+            raise ValueError("The 'items' is empty")
+
+        available_items = list(deepcopy(items))
+
+        self._value = available_items.index(value) if value is not None else 0
+        self._min_value = lambda: 0
+        self._max_value = lambda: len(available_items) - 1
+        self._decrease = lambda index: index - 1
+        self._increase = lambda index: index + 1
+        self._getter = lambda index: available_items[index]
+        self._setter = lambda element: available_items.index(element)
+        self._printable = lambda index: f"{index} ({available_items[index]})"
+        self._frozen = True
+        return self
+
+    def build_latest_keycode(self, value=0):
+        if self._frozen:
+            return self
+
+        self._clear_all_properties()
+
+        def _keydown(keycode: int):
+            self._value = keycode
+            return True
+
+        self._value = value
+        self._keydown = _keydown
+        self._frozen = True
+        return self
+
+    def build_select_roi(self, roi: Optional[RectInt] = None):
+        if self._frozen:
+            return self
+
+        self._clear_all_properties()
+
+        def _mouse(event: MouseEvent, mx: int, my: int, _):
+            if event == MouseEvent.LBUTTON_DOWN:
+                self._value = mx, my, self._value[2], self._value[3]
+                self._kwargs["button_down"] = True
+            if self._kwargs["button_down"]:
+                if event == MouseEvent.MOUSE_MOVE:
+                    self._value = self._value[0], self._value[1], mx, my
+                elif event == MouseEvent.LBUTTON_UP:
+                    self._value = self._value[0], self._value[1], mx, my
+                    self._kwargs["button_down"] = False
+            return True
+
+        self._value = roi if roi else (0, 0, 0, 0)
+        self._mouse = _mouse
+        self._frozen = True
+        self._kwargs["button_down"] = False
+        return self
+
+    def build_select_point(self, point: Optional[PointInt] = None):
+        if self._frozen:
+            return self
+
+        self._clear_all_properties()
+
+        def _mouse(event: MouseEvent, mx: int, my: int, _):
+            if event.LBUTTON_DOWN:
+                self._value = mx, my
+            return True
+
+        self._value = point
+        self._mouse = _mouse
+        self._frozen = True
+        return self
+
+    def build_select_points(self, points: Optional[Iterable[PointInt]] = None):
+        if self._frozen:
+            return self
+
+        self._clear_all_properties()
+
+        def _mouse(event: MouseEvent, mx: int, my: int, _):
+            assert isinstance(self._value, list)
+            if event == MouseEvent.LBUTTON_DOWN:
+                self._value.append((mx, my))
+            elif event == MouseEvent.MBUTTON_DOWN:
+                self._value.pop()
+            return True
+
+        self._value = list(points) if points else list()
+        self._mouse = _mouse
+        self._frozen = True
+        return self
```

## cvlayer/np/image.py

```diff
@@ -1,10 +1,11 @@
 # -*- coding: utf-8 -*-
 
 from numpy import full, ndarray, uint8, zeros
+from numpy.random import randint
 
 from cvlayer.typing import Color, Image, ImageShape
 
 
 def make_image_with_shape(shape: ImageShape, data: bytes) -> Image:
     return ndarray(shape, dtype=uint8, buffer=data)
 
@@ -15,7 +16,11 @@
 
 def make_image_filled(width: int, height: int, color: Color) -> Image:
     return full((height, width, 3), color, dtype=uint8)
 
 
 def make_image_empty(width: int, height: int) -> Image:
     return zeros((height, width, 3), dtype=uint8)
+
+
+def make_image_random(width: int, height: int) -> Image:
+    return randint(low=0, high=256, size=(height, width, 3), dtype=uint8)
```

## cvlayer/typing/__init__.py

```diff
@@ -3,14 +3,17 @@
 from cvlayer.typing.color import Color
 from cvlayer.typing.geomerty import (
     LineFloat,
     LineInt,
     LineT,
     Number,
     NumberT,
+    PerspectivePointsFloat,
+    PerspectivePointsInt,
+    PerspectivePointsT,
     PointFloat,
     PointInt,
     PointT,
     PolygonT,
     RectFloat,
     RectInt,
     RectT,
@@ -26,14 +29,17 @@
     "Image",
     "ImageShape",
     "LineFloat",
     "LineInt",
     "LineT",
     "Number",
     "NumberT",
+    "PerspectivePointsFloat",
+    "PerspectivePointsInt",
+    "PerspectivePointsT",
     "PointFloat",
     "PointInt",
     "PointT",
     "PolygonT",
     "RectFloat",
     "RectInt",
     "RectT",
```

## cvlayer/typing/geomerty.py

```diff
@@ -21,8 +21,12 @@
 RectInt = Tuple[int, int, int, int]
 RectFloat = Tuple[float, float, float, float]
 
 PolygonT = List[PointT]
 PolygonInt = List[PointInt]
 PolygonFloat = List[PointFloat]
 
+PerspectivePointsT = Tuple[PointT, PointT, PointT, PointT]
+PerspectivePointsInt = Tuple[PointInt, PointInt, PointInt, PointInt]
+PerspectivePointsFloat = Tuple[PointFloat, PointFloat, PointFloat, PointFloat]
+
 Scalar = Tuple[float, float, float, float]
```

## Comparing `cvlayer/vio/vio.py` & `cvlayer/cvwindow.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,582 +1,700 @@
 # -*- coding: utf-8 -*-
 
-import os
+from dataclasses import dataclass
 from datetime import datetime
-from functools import lru_cache, reduce
+from enum import Enum, auto, unique
 from io import StringIO
-from math import floor, isclose
-from typing import Any, Dict, List, Optional, Tuple
+from math import isclose
+from os import W_OK, access, getcwd, mkdir, path
+from typing import Any, Final, List, Optional
 
-import cv2
+from numpy import full_like, uint8, zeros_like
 from numpy.typing import NDArray
-from overrides import overrides
 
-from cvlayer.cv.drawable import draw_multiline_text
+from cvlayer.cv.basic import mean
+from cvlayer.cv.cvt_color import CvtColorCode, cvt_color
+from cvlayer.cv.drawable import FONT_HERSHEY_SIMPLEX, draw_multiline_text_box
 from cvlayer.cv.fourcc import FOURCC_MP4V
+from cvlayer.cv.histogram import draw_histogram_channels
+from cvlayer.cv.image_io import image_write
+from cvlayer.cv.image_resize import Interpolation, resize_ratio
 from cvlayer.cv.keymap import (
-    KEYCODE_ENTER,
-    KEYCODE_ESC,
     KEYCODE_NULL,
+    KEYCODE_TIMEOUT,
     HighGuiKeyCode,
     has_highgui_arrow_keys,
     highgui_keys,
 )
 from cvlayer.cv.mouse import EventFlags, MouseEvent
-from cvlayer.keymap.create import (
-    DEFAULT_CALLBACK_NAME_PREFIX,
-    DEFAULT_CALLBACK_NAME_SUFFIX,
-    create_callable_keymap,
-)
+from cvlayer.cv.video_capture import VideoCapture
+from cvlayer.cv.video_writer import VideoWriter
+from cvlayer.cv.window import WINDOW_NORMAL, Window
+from cvlayer.debug.avg_stat import AvgStat
+from cvlayer.inspect.member import get_public_instance_attributes
+from cvlayer.keymap.create import create_callable_keymap
+from cvlayer.layers.base.layer_base import LayerBase
 from cvlayer.layers.base.layer_manager import LayerManager
-from cvlayer.np.image import make_image_empty
-from cvlayer.vio.vio_interface import VioInterface
+from cvlayer.palette.flat import CLOUDS_50, MIDNIGHT_BLUE_900
+from cvlayer.typing import PointFloat, PointInt, RectInt, SizeInt
 
+DEFAULT_WINDOW_EX_TITLE: Final[str] = "CvWindow"
+DEFAULT_HELP_OFFSET: Final[PointInt] = 0, 0
+DEFAULT_HELP_ANCHOR: Final[PointFloat] = 0.0, 0.0
+DEFAULT_PLOT_SIZE: Final[SizeInt] = 256, 256
+
+
+@unique
+class HelpMode(Enum):
+    HIDE = auto()
+    INFO = auto()
+    PLOT = auto()
+
+
+@dataclass
+class KeyDefine:
+    quit: List[str]
+    play: List[str]
+    help: List[str]
+    manpage: List[str]
+    snapshot: List[str]
+    wait_down: List[str]
+    wait_up: List[str]
+    layer_select: List[str]
+    layer_prev: List[str]
+    layer_next: List[str]
+    layer_last: List[str]
+    frame_prev: List[str]
+    frame_next: List[str]
+    param_prev: List[str]
+    param_next: List[str]
+    param_down: List[str]
+    param_up: List[str]
+
+    @classmethod
+    def defaults(cls):
+        return cls(
+            quit=["Q", "q"],
+            play=[" "],
+            help=["H", "h"],
+            manpage=["/", "?"],
+            snapshot=["`", "\n"],
+            wait_down=["-", "_"],
+            wait_up=["=", "+"],
+            layer_select=[str(i) for i in range(10)],
+            layer_prev=["{", "["],
+            layer_next=["}", "]"],
+            layer_last=["\\", "|"],
+            frame_prev=["P", "p", "<", ","],
+            frame_next=["N", "n", ">", "."],
+            param_prev=["W", "w"],
+            param_next=["S", "s"],
+            param_down=["A", "a"],
+            param_up=["D", "d"],
+        )
 
-@lru_cache
-def get_default_keymap():
-    return {
-        "quit": [ord("Q"), ord("q"), KEYCODE_ESC],
-        "play": [ord(" ")],
-        "help": [ord("H"), ord("h"), ord("/"), ord("?")],
-        "snapshot": [ord("S"), ord("s"), KEYCODE_ENTER],
-        "wait_up": [ord("W")],
-        "wait_down": [ord("w")],
-        "layer_select": [ord(str(i)) for i in range(10)],
-        "layer_next": [ord("]"), ord("}")],
-        "layer_prev": [ord("["), ord("{")],
-        "layer_last": [ord("\\"), ord("|")],
-        "frame_next": [ord("N"), ord("n")],
-        "frame_prev": [ord("P"), ord("p")],
-        "param_next": [ord(">"), ord(".")],
-        "param_prev": [ord("<"), ord(",")],
-        "param_up": [ord("="), ord("+")],
-        "param_down": [ord("-"), ord("_")],
-    }
-
-
-class Vio(LayerManager, VioInterface):
-    _capture: Optional[cv2.VideoCapture]
-    _writer: Optional[cv2.VideoWriter]
 
-    _process_durations: List[float]
-    _layers_durations: List[float]
+class CvWindow(Window):
+    _writer: Optional[VideoWriter]
 
     def __init__(
         self,
-        source: str,
+        input: str,  # noqa
         output: Optional[str] = None,
-        preview_scale=1.0,
-        font=cv2.FONT_HERSHEY_SIMPLEX,
+        font=FONT_HERSHEY_SIMPLEX,
         font_scale=1.0,
-        preview_scale_method=cv2.INTER_AREA,
-        start_frame_position=0,
-        initial_stop=False,
+        preview_scale=1.0,
+        preview_scale_method=Interpolation.INTER_AREA,
+        start_position=0,
+        help_mode=HelpMode.INFO,
+        play=False,
         headless=False,
-        hide_help_popup=False,
-        window_title: Optional[str] = None,
-        keymap: Optional[Dict[str, List[int]]] = None,
-        keymap_callback_prefix=DEFAULT_CALLBACK_NAME_PREFIX,
-        keymap_callback_suffix=DEFAULT_CALLBACK_NAME_SUFFIX,
+        show_man=False,
+        verbose=0,
+        keymap: Optional[KeyDefine] = None,
+        window_title=DEFAULT_WINDOW_EX_TITLE,
+        window_flags=WINDOW_NORMAL,
+        window_wait=1,
+        window_size: Optional[SizeInt] = None,
+        window_position: Optional[PointInt] = None,
+        writer_size: Optional[SizeInt] = None,
+        writer_fps: Optional[float] = None,
+        writer_fourcc=FOURCC_MP4V,
+        logger_name: Optional[str] = None,
+        logging_step=1,
+        help_offset: Optional[PointInt] = None,
+        help_anchor: Optional[PointFloat] = None,
+        plot_size: Optional[SizeInt] = None,
+        plot_roi: Optional[RectInt] = None,
+        use_deepcopy=False,
     ):
-        super().__init__()
+        super().__init__(window_title, window_flags)
+
+        assert 0 <= start_position
+        assert 1 <= window_wait
 
-        self._source = source
+        self._input = input
         self._output = output
-        self._preview_scale = preview_scale
         self._font = font
         self._font_scale = font_scale
+        self._preview_scale = preview_scale
         self._preview_scale_method = preview_scale_method
-        self._start_frame_position = start_frame_position
-        self._play = not initial_stop
-        self._preview = not headless
-        self._help = not hide_help_popup
-
-        self._shortcut_map = create_callable_keymap(
-            self,
-            keymap if keymap else get_default_keymap(),
-            keymap_callback_prefix,
-            keymap_callback_suffix,
+        self._window_wait = window_wait
+        self._help_mode = help_mode
+        self._play = play
+        self._headless = headless
+        self._show_man = show_man
+        self._verbose = verbose
+        self._help_offset = help_offset if help_offset else DEFAULT_HELP_OFFSET
+        self._help_anchor = help_anchor if help_anchor else DEFAULT_HELP_ANCHOR
+        self._plot_size = plot_size if plot_size else DEFAULT_PLOT_SIZE
+        self._plot_roi = plot_roi
+        self._use_deepcopy = use_deepcopy
+
+        self._manager = LayerManager(logger_name=logger_name)
+
+        if window_size is not None:
+            win_width, win_height = window_size
+            if win_width <= 0 or win_height <= 0:
+                raise ValueError(f"Invalid window size: {window_size}")
+            self.resize(win_width, win_height)
+
+        if window_position is not None:
+            win_x, win_y = window_position
+            if win_x <= 0 or win_y <= 0:
+                raise ValueError(f"Invalid window position: {window_position}")
+            self.move(win_x, win_y)
+
+        self._capture = VideoCapture(self._input)
+        if not self._capture.opened:
+            raise RuntimeError("A Video Capture was created but not opened")
+        if self._capture.width < 1:
+            raise RuntimeError("Invalid input video's width")
+        if self._capture.height < 1:
+            raise RuntimeError("Invalid input video's height")
+        if self._capture.fps < 1:
+            raise RuntimeError("Invalid input video's FPS")
+        if self._capture.frames < 1:
+            raise RuntimeError("Invalid input video's frame count")
+
+        width = self._capture.width
+        height = self._capture.height
+        self._capture.pos = start_position
+
+        retval, frame = self._capture.read()
+        if not retval:
+            raise EOFError("Failed to read the first frame")
+
+        self._empty_frame = zeros_like(frame, dtype=uint8)
+        self._original_frame = frame
+        self._preview_frame = frame
+
+        if self._output:
+            size = writer_size if writer_size is not None else (width, height)
+            fps = writer_fps if writer_fps is not None else self._capture.fps
+            self._writer = VideoWriter(self._output, size, fps, writer_fourcc)
+            if not self._writer.opened:
+                raise RuntimeError("A Video Writer was created but not opened")
+        else:
+            self._writer = None
+
+        keymap = keymap if keymap else KeyDefine.defaults()
+        assert keymap is not None
+        keymap_attrs = get_public_instance_attributes(keymap)
+
+        shortcut = dict()
+        buffer = StringIO()
+        buffer.write("Keyboard shortcuts\n")
+        for name, keys in keymap_attrs:
+            assert isinstance(keys, list)
+            shortcut[name] = [ord(k) for k in keys]
+            buffer.write(f" {name}: {keys}\n")
+
+        self._keymap = create_callable_keymap(self, shortcut)
+        self._manpage = full_like(frame, fill_value=MIDNIGHT_BLUE_900, dtype=uint8)
+        assert len(self._manpage.shape) == 3
+        assert self._manpage.shape[2] == 3
+        draw_multiline_text_box(
+            self._manpage,
+            buffer.getvalue(),
+            0,
+            0,
+            font=font,
+            scale=font_scale,
+            color=CLOUDS_50,
+            background_alpha=0,
         )
 
         self._highgui_keys = highgui_keys()
         self._has_arrow_keys = has_highgui_arrow_keys(self._highgui_keys)
 
-        self._capture = None
-        self._writer = None
+        self._mouse_event = MouseEvent.MOUSE_MOVE
+        self._mouse_x = 0
+        self._mouse_y = 0
+        self._mouse_flags = 0
+        self._keycode = 0
 
-        self._width = 0
-        self._height = 0
-        self._fps = 0.0
-        self._frames = 0
-        self._fourcc = FOURCC_MP4V
-
-        self._title = window_title if window_title else type(self).__name__
-        self._frame_index = self._start_frame_position
-        self._wait_milliseconds = 1
-        self._debugging_step = 10
-        self._shutdown = False
-        self._help_x = 0
-        self._help_y = 0
-        self._help_last_layer = "LAST LAYER"
+        self._stat = AvgStat("Iter", self._manager.logger, logging_step, verbose, 1)
         self._process_duration = 0.0
+        self._shutdown = False
+
+    @property
+    def logger(self):
+        return self._manager.logger
+
+    def layer(self, name: str) -> LayerBase:
+        return self._manager.__getitem__(name)
 
-        self._empty_frame = make_image_empty(800, 600)
-        self._original_frame = self._empty_frame
-        self._processed_frame = self._empty_frame
-        self._resized_preview = self._empty_frame
-        self._record_frame = self._empty_frame
+    def has_layer(self, layer: Any) -> bool:
+        return self._manager.has_layer(layer)
 
-        self._process_durations = list()
-        self._layers_durations = list()
+    def get_layer_frame(self, key: Any) -> NDArray:
+        return self._manager.get_layer_frame(key)
+
+    def get_layer_data(self, key: Any) -> Any:
+        return self._manager.get_layer_data(key)
 
     @property
-    def played(self) -> bool:
-        return self._play
+    def original_frame(self) -> NDArray:
+        return self._original_frame
 
     @property
-    def paused(self) -> bool:
-        return not self._play
+    def preview_frame(self) -> NDArray:
+        return self._preview_frame
 
     @property
-    def show_help(self) -> bool:
-        return self._help
+    def last_frame(self) -> NDArray:
+        return self._manager.last_layer.frame
 
     @property
-    def process_duration(self) -> float:
-        return self._process_duration
+    def last_data(self) -> Any:
+        return self._manager.last_layer.data
 
     @property
-    def process_layers_duration(self) -> float:
-        if self.layers:
-            durations = map(lambda x: x.duration, self.layers)
-            return float(reduce(lambda x, y: x + y, durations))
-        else:
-            return 0.0
+    def mouse_event(self):
+        return self._mouse_event
 
     @property
-    def preview_frame(self) -> NDArray:
-        if self.is_last_layer:
-            frame = self._resized_preview.copy()
-        else:
-            frame = self.current_layer.next_frame.copy()
+    def mouse_x(self):
+        return self._mouse_x
 
-        if not self._help:
-            return frame
+    @property
+    def mouse_y(self):
+        return self._mouse_y
 
-        x = self._help_x
-        y = self._help_y
-        font = self._font
-        scale = self._font_scale
-        frame_index = f"Frame {self._frame_index}/{self._frames}\n"
-        layer_index = f"Layer [{self.layer_index}/{self.length_layers}] "
-
-        if self.is_last_layer:
-            duration = f"Duration: {self._process_duration:.3f}s\n"
-            duration += f"Layers duration: {self.process_layers_duration:.3f}s\n"
-            text = frame_index + duration + layer_index + self._help_last_layer
-        else:
-            duration = f"Duration: {self.current_layer.duration:.3f}s\n"
-            text = frame_index + duration + layer_index + self.current_layer.to_help()
+    @property
+    def mouse_flags(self):
+        return self._mouse_flags
 
-        draw_multiline_text(frame, text, x, y, font, scale)
+    @property
+    def keycode(self):
+        return self._keycode
 
-        return frame
+    @property
+    def plot_roi(self):
+        return self._plot_roi
 
-    def shutdown(self) -> None:
-        self._shutdown = True
+    @plot_roi.setter
+    def plot_roi(self, value: Optional[RectInt]) -> None:
+        self._plot_roi = value
 
-    def increase_wait_milliseconds(self) -> None:
-        self._wait_milliseconds += 1
+    def on_keydown_quit(self, keycode: int) -> None:
+        raise KeyboardInterrupt("Quit key detected")
 
-    def decrease_wait_milliseconds(self) -> None:
-        if self._wait_milliseconds >= 2:
-            self._wait_milliseconds -= 1
-
-    def aggregate_debugging_information(self) -> Tuple[float, float]:
-        return (
-            sum(self._process_durations) / len(self._process_durations),
-            sum(self._layers_durations) / len(self._layers_durations),
-        )
+    def on_keydown_play(self, keycode: int) -> None:
+        assert 0 < keycode
+        self.flip_play()
 
-    def update_debugging_information(self) -> None:
-        self._process_durations.append(self.process_duration)
-        self._layers_durations.append(self.process_layers_duration)
-
-    def clear_debugging_information(self) -> None:
-        self._process_durations.clear()
-        self._layers_durations.clear()
+    def on_keydown_help(self, keycode: int) -> None:
+        assert 0 < keycode
+        self.flip_help_popup()
 
-    def get_logging_information(self) -> str:
-        buffer = StringIO()
-        buffer.write(f"Original source: {self._source}")
-        buffer.write(f"\nRecord destination: {self._output}")
-        buffer.write(f"\nPreview mode: {self._preview}")
-        buffer.write(f"\nPreview scale: {self._preview_scale}")
-        buffer.write(f"\nPreview scale method: {self._preview_scale_method}")
-        buffer.write(f"\nVideo resolution: {self._width}x{self._height}")
-        buffer.write(f"\nVideo FPS: {self._fps:.2f}")
-        buffer.write(f"\nVideo frame count: {self._frames}")
-        buffer.write(f"\nVideo start frame position: {self._start_frame_position}")
-        return buffer.getvalue()
+    def on_keydown_manpage(self, keycode: int) -> None:
+        assert 0 < keycode
+        self.flip_manual_page()
 
-    def read_next_frame(self) -> bool:
-        assert self._capture is not None
-        retval, self._original_frame = self._capture.read()
-        if not retval:
-            return False
+    def on_keydown_snapshot(self, keycode: int) -> None:
+        assert 0 < keycode
+        self.snapshot()
 
-        self._frame_index += 1
-        if self._frame_index % self._debugging_step == 0:
-            process_avg, layers_avg = self.aggregate_debugging_information()
+    def on_keydown_wait_down(self, keycode: int) -> None:
+        assert 0 < keycode
+        self.do_wait_down()
 
-            message = StringIO()
-            message.write(f"Read next frame {self._frame_index}/{self._frames} (")
-            message.write(f"process avg: {process_avg:.3f}s, ")
-            message.write(f"layers avg: {layers_avg:.3f}s)")
+    def on_keydown_wait_up(self, keycode: int) -> None:
+        assert 0 < keycode
+        self.do_wait_up()
 
-            self._layers_durations.append(self.process_layers_duration)
-            self.logger.debug(message.getvalue())
+    def on_keydown_layer_select(self, keycode: int) -> None:
+        assert 0 < keycode
+        index = keycode - ord("0")
+        assert 0 <= index <= 9
+        self.do_layer_select(index)
 
-        return True
+    def on_keydown_layer_prev(self, keycode: int) -> None:
+        assert 0 < keycode
+        self.do_layer_prev()
 
-    def read_prev_frame(self) -> bool:
-        self.move_frame_position(self._frame_index - 2)
-        return self.read_next_frame()
+    def on_keydown_layer_next(self, keycode: int) -> None:
+        assert 0 < keycode
+        self.do_layer_next()
 
-    def move_frame_position(self, frame_index: int) -> None:
-        assert self._capture is not None
-        self._capture.set(cv2.CAP_PROP_POS_FRAMES, frame_index)
-        self._frame_index = frame_index
+    def on_keydown_layer_last(self, keycode: int) -> None:
+        assert 0 < keycode
+        self.do_layer_last()
 
-    def process_next_frame(self) -> None:
-        begin = datetime.now()
-        try:
-            self._processed_frame = self.on_frame(self._original_frame.copy())
-        finally:
-            self._process_duration = (datetime.now() - begin).total_seconds()
+    def on_keydown_frame_prev(self, keycode: int) -> None:
+        assert 0 < keycode
+        self.do_frame_prev()
 
-        if isclose(self._preview_scale, 1.0):
-            self._resized_preview = self._processed_frame.copy()
-        else:
-            self._resized_preview = cv2.resize(
-                self._processed_frame,
-                dsize=(0, 0),
-                fx=self._preview_scale,  # noqa
-                fy=self._preview_scale,  # noqa
-                interpolation=self._preview_scale_method,
-            )
+    def on_keydown_frame_next(self, keycode: int) -> None:
+        assert 0 < keycode
+        self.do_frame_next()
 
-        gray_processed_frame = len(self._processed_frame.shape) == 2
-        if gray_processed_frame:
-            self._record_frame = cv2.cvtColor(self._processed_frame, cv2.COLOR_GRAY2BGR)
-        else:
-            self._record_frame = self._processed_frame.copy()
+    def on_keydown_param_prev(self, keycode: int) -> None:
+        assert 0 < keycode
+        self.do_param_prev()
+
+    def on_keydown_param_next(self, keycode: int) -> None:
+        assert 0 < keycode
+        self.do_param_next()
+
+    def on_keydown_param_down(self, keycode: int) -> None:
+        assert 0 < keycode
+        self.do_param_down()
+
+    def on_keydown_param_up(self, keycode: int) -> None:
+        assert 0 < keycode
+        self.do_param_up()
+
+    def on_create(self) -> None:
+        self._manager.on_create()
 
-    def process_key_events(self) -> bool:
-        keycode = cv2.waitKeyEx(self._wait_milliseconds)
-        if keycode == KEYCODE_NULL:
-            return True
+    def on_destroy(self) -> None:
+        self._manager.on_destroy()
+
+    def on_frame(self, image: NDArray) -> Optional[NDArray]:
+        self._manager.run(image, self._use_deepcopy)
+        return None
 
+    def on_keydown(self, keycode: int) -> None:
         # Process user events with priority.
         # And if it consumed the event with a return value of `True`,
         # It doesn't handle default events.
-        if self.on_keydown(keycode):
-            return True
+        if self._manager.on_keydown(keycode):
+            return
 
-        if keycode in self._shortcut_map:
-            self._shortcut_map[keycode](keycode)
-            return True
+        if keycode in self._keymap:
+            self._keymap[keycode](keycode)
+            return
 
         if self._has_arrow_keys:
             if keycode == self._highgui_keys[HighGuiKeyCode.ARROW_UP]:
-                self.on_keydown_param_prev(keycode)
-                return True
+                self.do_param_prev()
             elif keycode == self._highgui_keys[HighGuiKeyCode.ARROW_DOWN]:
-                self.on_keydown_param_next(keycode)
-                return True
+                self.do_param_next()
             elif keycode == self._highgui_keys[HighGuiKeyCode.ARROW_LEFT]:
-                self.on_keydown_param_down(keycode)
-                return True
+                self.do_param_down()
             elif keycode == self._highgui_keys[HighGuiKeyCode.ARROW_RIGHT]:
-                self.on_keydown_param_up(keycode)
-                return True
-
-        self.logger.debug(f"Unmatched keycode: {keycode}")
-        return True
+                self.do_param_up()
 
-    def on_keydown_quit(self, keycode: int) -> None:
-        raise InterruptedError("Quit key detected")
-
-    def on_keydown_play(self, keycode: int) -> None:
-        assert keycode > 0
-        self._play = not self._play
-        state_text = "played" if self._play else "stopped"
-        self.logger.info(f"The video has been {state_text}")
+    def on_mouse(self, event: MouseEvent, x: int, y: int, flags: EventFlags) -> None:
+        self._mouse_event = event
+        self._mouse_x = x
+        self._mouse_y = y
+        self._mouse_flags = flags
 
-    def on_keydown_help(self, keycode: int) -> None:
-        assert keycode > 0
-        self._help = not self._help
-        popup_state = "Show" if self._help else "Hide"
-        self.logger.info(f"{popup_state} help popup")
+        # Process user events with priority.
+        # And if it consumed the event with a return value of `True`,
+        # It doesn't handle default events.
+        if self._manager.on_mouse(event, x, y, flags):
+            return
 
-    def on_keydown_snapshot(self, keycode: int) -> None:
-        assert keycode > 0
+        # TODO: Global mouse event implementation to be added later
 
-        # if not self._output:
-        #     raise AttributeError("The '--output' argument is required")
-        # output_dir = os.path.basename(os.path.abspath(self._output))
+    def on_trackbar(self, name: str, value: int) -> None:
+        pass
 
-        now = datetime.now().strftime("%Y%m%d_%H%M%S")
-        source_basename = os.path.basename(self._source)
-        output_dirname = f"{source_basename}-f{self._frame_index}-{now}"
-        prefix = os.path.join(os.getcwd(), output_dirname)
-        image_ext = ".png"
+    def shutdown(self) -> None:
+        self._shutdown = True
 
-        if not os.path.isdir(prefix):
-            os.mkdir(prefix)
+    def read_next_frame(self) -> NDArray:
+        retval, frame = self._capture.read()
+        if not retval:
+            raise EOFError("Failed to read the next frame")
+        return frame
 
-        self.logger.debug(f"Saving all layer snapshots as '{prefix}' directory ...")
+    def read_prev_frame(self) -> NDArray:
+        self._capture.pos -= 2
+        try:
+            return self.read_next_frame()
+        except EOFError:
+            raise EOFError("Failed to read the prev frame")
 
-        for layer_index in range(self.length_layers):
-            prev_path = f"{prefix}/layer{layer_index}-prev{image_ext}"
-            next_path = f"{prefix}/layer{layer_index}-next{image_ext}"
-            cv2.imwrite(prev_path, self.get_layer_prev_frame(layer_index))
-            cv2.imwrite(next_path, self.get_layer_next_frame(layer_index))
-
-        cv2.imwrite(f"{prefix}/original{image_ext}", self._original_frame)
-        cv2.imwrite(f"{prefix}/processed{image_ext}", self._processed_frame)
-        cv2.imwrite(f"{prefix}/resized{image_ext}", self._resized_preview)
-        cv2.imwrite(f"{prefix}/record{image_ext}", self._record_frame)
-        cv2.imwrite(f"{prefix}/preview{image_ext}", self.preview_frame)
+    def flip_play(self) -> None:
+        self._play = not self._play
+        state_text = "played" if self._play else "stopped"
+        self.logger.info(f"The video has been {state_text}")
 
-        self.logger.info(
-            f"Successful saving all layer snapshots as '{prefix}' directory!"
-        )
+    def flip_help_popup(self) -> None:
+        if self._help_mode == HelpMode.HIDE:
+            self._help_mode = HelpMode.INFO
+        elif self._help_mode == HelpMode.INFO:
+            self._help_mode = HelpMode.PLOT
+        elif self._help_mode == HelpMode.PLOT:
+            self._help_mode = HelpMode.HIDE
+        else:
+            assert False, "Inaccessible section"
+        self.logger.info(f"{self._help_mode.name} help popup")
 
-    def on_keydown_wait_up(self, keycode: int) -> None:
-        assert keycode > 0
-        self.increase_wait_milliseconds()
-        self.logger.info(f"Increase wait milliseconds to {self._wait_milliseconds}ms")
+    def flip_manual_page(self) -> None:
+        self._show_man = not self._show_man
+        popup_state = "Show" if self._show_man else "Hide"
+        self.logger.info(f"{popup_state} man page")
+
+    def snapshot(self, directory: Optional[str] = None, ext=".png") -> None:
+        base = directory if directory else (self._output if self._output else getcwd())
+        basedir = path.basename(base)
+
+        if not path.isdir(basedir):
+            raise NotADirectoryError(f"'{base}' is not a directory")
+        if not access(basedir, W_OK):
+            raise PermissionError(f"Write access to directory '{base}' is required")
 
-    def on_keydown_wait_down(self, keycode: int) -> None:
-        assert keycode > 0
-        self.decrease_wait_milliseconds()
-        self.logger.info(f"Decrease wait milliseconds to {self._wait_milliseconds}ms")
+        now = datetime.now().strftime("%Y%m%d_%H%M%S")
+        prefix = path.join(basedir, f"{self._capture.pos}-{now}")
 
-    def on_keydown_layer_select(self, keycode: int) -> None:
-        assert keycode > 0
-        self.change_layer(keycode - ord("0"))
-        self.logging_current_layer_information()
+        if not path.isdir(prefix):
+            mkdir(prefix)
+            self.logger.debug(f"Make directory; '{prefix}'")
 
-    def on_keydown_layer_next(self, keycode: int) -> None:
-        assert keycode > 0
-        self.change_next_layer()
-        self.logging_current_layer_information()
+        self.logger.debug(f"Saving all layer snapshots as '{prefix}' directory ...")
 
-    def on_keydown_layer_prev(self, keycode: int) -> None:
-        assert keycode > 0
-        self.change_prev_layer()
-        self.logging_current_layer_information()
+        for index in range(self._manager.number_of_layers):
+            layer_path = path.join(prefix, f"layer{index}-{ext}")
+            layer_frame = self._manager.get_layer_frame(index)
+            image_write(layer_path, layer_frame)
+
+        image_write(path.join(prefix, f"original{ext}"), self._original_frame)
+        image_write(path.join(prefix, f"preview{ext}"), self._preview_frame)
+
+        self.logger.info(f"Snapshot was successfully saved to directory '{prefix}'")
+
+    def do_wait_up(self) -> None:
+        self._window_wait += 1
+        self.logger.info(f"Increase wait milliseconds to {self._window_wait}ms")
+
+    def do_wait_down(self) -> None:
+        if self._window_wait >= 2:
+            self._window_wait -= 1
+        self.logger.info(f"Decrease wait milliseconds to {self._window_wait}ms")
+
+    def do_layer_select(self, index: int) -> None:
+        self._manager.set_cursor(index)
+        self._manager.logging_current_layer()
+
+    def do_layer_prev(self) -> None:
+        self._manager.move_prev_layer()
+        self._manager.logging_current_layer()
+
+    def do_layer_next(self) -> None:
+        self._manager.move_next_layer()
+        self._manager.logging_current_layer()
 
-    def on_keydown_layer_last(self, keycode: int) -> None:
-        assert keycode > 0
-        self.change_last_layer()
+    def do_layer_last(self) -> None:
+        self._manager.move_last_layer()
         self.logger.info("Change last layer")
 
-    def on_keydown_frame_next(self, keycode: int) -> None:
-        assert keycode > 0
-        if not self.read_next_frame():
-            raise InterruptedError("Failed to read the next frame")
+    def do_frame_prev(self) -> None:
+        self._original_frame = self.read_prev_frame()
 
-    def on_keydown_frame_prev(self, keycode: int) -> None:
-        assert keycode > 0
-        if not self.read_prev_frame():
-            raise InterruptedError("Failed to read the prev frame")
+    def do_frame_next(self) -> None:
+        self._original_frame = self.read_next_frame()
 
-    def on_keydown_param_prev(self, keycode: int) -> None:
-        assert keycode > 0
-        if self.is_last_layer:
+    def do_param_prev(self) -> None:
+        if self._manager.is_cursor_at_last:
             raise IndexError("The current layer is the last layer")
 
-        self.current_layer.prev_param_cursor()
+        self._manager.current_layer.prev_cursor()
         self.logger.info("Change prev param cursor")
-        self.logging_current_param_cursor()
+        self._manager.logging_current_param()
 
-    def on_keydown_param_next(self, keycode: int) -> None:
-        assert keycode > 0
-        if self.is_last_layer:
+    def do_param_next(self) -> None:
+        if self._manager.is_cursor_at_last:
             raise IndexError("The current layer is the last layer")
 
-        self.current_layer.next_param_cursor()
+        self._manager.current_layer.next_cursor()
         self.logger.info("Change next param cursor")
-        self.logging_current_param_cursor()
+        self._manager.logging_current_param()
 
-    def on_keydown_param_up(self, keycode: int) -> None:
-        assert keycode > 0
-        if self.is_last_layer:
+    def do_param_up(self) -> None:
+        if self._manager.is_cursor_at_last:
             raise IndexError("The current layer is the last layer")
 
-        self.current_layer.increase_at_param_cursor()
+        self._manager.current_layer.increase_at_cursor()
         self.logger.info("Increase value at param cursor")
-        self.logging_current_param_cursor()
+        self._manager.logging_current_param()
 
-    def on_keydown_param_down(self, keycode: int) -> None:
-        assert keycode > 0
-        if self.is_last_layer:
+    def do_param_down(self) -> None:
+        if self._manager.is_cursor_at_last:
             raise IndexError("The current layer is the last layer")
 
-        self.current_layer.decrease_at_param_cursor()
+        self._manager.current_layer.decrease_at_cursor()
         self.logger.info("Decrease value at param cursor")
-        self.logging_current_param_cursor()
+        self._manager.logging_current_param()
 
-    @overrides
-    def on_create(self) -> None:
-        pass
-
-    @overrides
-    def on_destroy(self) -> None:
-        pass
-
-    @overrides
-    def on_frame(self, frame: NDArray) -> NDArray:
-        return self.call_on_frame_with_layers(frame)
-
-    @overrides
-    def on_keydown(self, keycode: int) -> bool:
-        return self.call_on_keydown_with_current_layer(keycode)
-
-    @overrides
-    def on_mouse(self, event: MouseEvent, x: int, y: int, flags: EventFlags) -> None:
-        self.call_on_mouse_with_current_layer(event, x, y, flags)
-
-    def _init_capture(self) -> None:
-        if not os.path.isfile(self._source):
-            raise FileNotFoundError(f"The `{self._source}` can only be of file type")
-        if not os.access(self._source, os.R_OK):
-            raise PermissionError(f"You need read access to the `{self._source}` file")
-
-        self._capture = cv2.VideoCapture(self._source)
-
-        if not self._capture.isOpened():
-            raise RuntimeError(f"Failed to open file `{self._source}`")
-
-        self._width = floor(self._capture.get(cv2.CAP_PROP_FRAME_WIDTH))
-        self._height = floor(self._capture.get(cv2.CAP_PROP_FRAME_HEIGHT))
-        self._fps = self._capture.get(cv2.CAP_PROP_FPS)
-        self._frames = floor(self._capture.get(cv2.CAP_PROP_FRAME_COUNT))
-
-        if self._width < 1:
-            raise RuntimeError("Invalid source video's width")
-        if self._height < 1:
-            raise RuntimeError("Invalid source video's height")
-        if self._fps < 1:
-            raise RuntimeError("Invalid source video's FPS")
-        if self._frames < 1:
-            raise RuntimeError("Invalid source video's frame count")
-
-    def _init_writer(self) -> None:
-        if not self._output:
-            return
-
-        output = self._output
-        fps = self._fps
-        width = self._width
-        height = self._height
-        fourcc = self._fourcc
+    def do_process(self, frame: NDArray) -> Optional[NDArray]:
+        begin = datetime.now()
+        try:
+            if self._use_deepcopy:
+                frame = frame.copy()
+            self._manager.update_first_frame_and_data(frame)
+            return self.on_frame(frame)
+        except BaseException as e:
+            self.logger.exception(e)
+            return None
+        finally:
+            self._process_duration = (datetime.now() - begin).total_seconds()
 
-        self._writer = cv2.VideoWriter(output, fourcc, fps, (width, height))
-        assert self._writer is not None
+    def as_information_text(self, analyze_frame: Optional[NDArray] = None) -> str:
+        duration = self._stat.avg
+        fps = 1.0 / duration if duration != 0 else 0
+        cursor = self._manager.cursor
+        number_of_layers = self._manager.number_of_layers
 
-        if not self._writer.isOpened():
-            raise RuntimeError("A Video Writer was created but not opened")
+        buffer = StringIO()
+        buffer.write(f"Frame {self._capture.pos}/{self._capture.frames}\n")
+        buffer.write(f"FPS: {fps:.1f} (duration={duration:.3f}s)\n")
+        buffer.write(f"Layer index: {cursor}/{number_of_layers}\n")
+        buffer.write(f"Process duration: {self._process_duration:.3f}s\n")
+        buffer.write(f"Layers total duration: {self._manager.total_duration:.3f}s\n")
 
-    def _run_prefix(self) -> None:
-        self.on_create()
+        if self._manager.is_cursor_at_last:
+            buffer.write("[Last layer]")
+        else:
+            layer_duration = self._manager.current_layer.duration
+            buffer.write(f"Layer duration: {layer_duration:.3f}s\n")
+            buffer.write(self._manager.current_layer.as_help())
 
-        for layer in self._layers:
-            layer.on_create()
+        if analyze_frame is not None:
+            buffer.write(f"\nMeans: {[round(m) for m in mean(analyze_frame)]}")
 
-        self._init_capture()
-        self._init_writer()
-        self.logger.info(self.get_logging_information())
-        self.call_init_params_with_layers()
+        return buffer.getvalue()
 
-        assert self._capture is not None
-        assert self._capture.isOpened()
+    def _select_preview_source(self, result_frame: Optional[NDArray]) -> NDArray:
+        if self._show_man:
+            return self._manpage
+        elif self._manager.is_cursor_at_last:
+            if result_frame is not None:
+                return result_frame
+            else:
+                return self._empty_frame
+        else:
+            try:
+                return self._manager.current_layer.frame
+            except:  # noqa
+                return self._empty_frame
+
+    def _coloring(self, frame: NDArray) -> NDArray:
+        assert self
+        if len(frame.shape) == 2:
+            return cvt_color(frame, CvtColorCode.GRAY2BGR)
+        else:
+            return frame.copy() if self._use_deepcopy else frame
 
-        if self._start_frame_position:
-            self._capture.set(cv2.CAP_PROP_POS_FRAMES, self._start_frame_position)
+    def _resizing(self, frame: NDArray) -> NDArray:
+        if isclose(self._preview_scale, 1.0):
+            return frame.copy() if self._use_deepcopy else frame
+        else:
+            sx = self._preview_scale
+            sy = self._preview_scale
+            sm = self._preview_scale_method
+            return resize_ratio(frame, sx, sy, sm)
+
+    def _draw_information(self, frame: NDArray, analyze_frame: NDArray) -> NDArray:
+        if self._use_deepcopy:
+            frame = frame.copy()
 
-        def _mouse_cb(event: int, x: int, y: int, flags: int, param: Any) -> None:
-            assert param is None
-            self.on_mouse(MouseEvent(event), x, y, flags)
+        if self._show_man:
+            return frame
 
-        if self._preview:
-            title = self._title
-            cv2.namedWindow(title, cv2.WINDOW_NORMAL)
-            cv2.setMouseCallback(title, _mouse_cb, None)  # type: ignore[attr-defined]
+        if self._help_mode == HelpMode.HIDE:
+            return frame
 
-    def _run_release(self) -> None:
-        for layer in self._layers:
-            layer.on_destroy()
+        help_roi = draw_multiline_text_box(
+            image=frame,
+            text=self.as_information_text(analyze_frame),
+            x=self._help_offset[0],
+            y=self._help_offset[1],
+            font=self._font,
+            scale=self._font_scale,
+            anchor_x=self._help_anchor[0],
+            anchor_y=self._help_anchor[1],
+        )
 
-        self.on_destroy()
+        if self._help_mode == HelpMode.PLOT:
+            hx1, hy1, hx2, hy2 = help_roi
+            dx1 = hx1 if self._help_anchor[0] < 0.5 else hx2 - self._plot_size[0]
+            dy1 = hy2 if self._help_anchor[1] < 0.5 else hy1 - self._plot_size[1]
+            dx2 = dx1 + self._plot_size[0]
+            dy2 = dy1 + self._plot_size[1]
+            draw_roi = dx1, dy1, dx2, dy2
+            draw_histogram_channels(
+                frame,
+                draw_roi,
+                analyze_frame,
+                self._plot_roi,
+            )
 
-        assert self._capture is not None
-        self._capture.release()
+        return frame
 
-        if self._writer is not None:
-            self._writer.release()
-        if self._preview:
-            cv2.destroyWindow(self._title)
-        self.logger.debug("Done")
-
-    def _run_loop(self) -> bool:
-        assert self._capture is not None
-        if not self._capture.isOpened():
-            self.logger.error("Source video is not opened")
-            return False
+    def _iter(self) -> None:
+        if not self._capture.opened:
+            raise EOFError("Input video is not opened")
 
         if self._play:
-            if not self.read_next_frame():
-                self.logger.error(f"Failed to read the {self._frame_index}th frame")
-                return False
+            self._original_frame = self.read_next_frame()
 
-        self.process_next_frame()
-        self.update_debugging_information()
+        result_frame = self.do_process(self._original_frame)
+        select_frame = self._select_preview_source(result_frame)
+        colored_frame = self._coloring(select_frame)
+        resized_frame = self._resizing(colored_frame)
+        self._preview_frame = self._draw_information(resized_frame, select_frame)
 
         if self._writer is not None:
-            assert self._writer.isOpened()
-            self._writer.write(self._record_frame)
-
-        if self._preview:
-            cv2.imshow(self._title, self.preview_frame)
+            assert self._writer.opened
+            self._writer.write(self._preview_frame)
 
-        try:
-            if not self.process_key_events():
-                self.logger.warning("Exit key detected")
-                return False
-        except InterruptedError:
-            self.logger.warning("Interrupt detected")
-            return False
-        except BaseException as e:
-            self.logger.error(e)
+        if not self._headless:
+            self.draw(self._preview_frame)
 
-        if self._shutdown:
-            self.logger.warning("Enabled shutdown flag")
-            return False
+        self._keycode = self.wait_key_ex(self._window_wait)
 
-        return True
+        if not self.visible:
+            raise InterruptedError("The window is not visible")
+
+        if self._keycode not in (KEYCODE_NULL, KEYCODE_TIMEOUT):
+            try:
+                self.on_keydown(self._keycode)
+            except KeyboardInterrupt:
+                raise
+            except InterruptedError:
+                raise
+            except BaseException as e:
+                self.logger.exception(e)
 
     def run(self) -> None:
-        self._run_prefix()
+        self.on_create()
         try:
-            if not self._play:
-                if not self.read_next_frame():
-                    self.logger.error("Failed to read the first frame")
-                    return
-
-            while self._run_loop():
-                pass
+            while not self._shutdown:
+                with self._stat:
+                    self._iter()
+        except KeyboardInterrupt as e:
+            self.logger.warning(e)
+        except InterruptedError as e:
+            self.logger.warning(e)
+        except EOFError as e:
+            self.logger.error(e)
+        except BaseException as e:
+            self.logger.exception(e)
         finally:
-            self._run_release()
+            self.on_destroy()
```

## Comparing `cvlayer-0.8.0.dist-info/LICENSE` & `cvlayer-0.9.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `cvlayer-0.8.0.dist-info/RECORD` & `cvlayer-0.9.0.dist-info/RECORD`

 * *Files 8% similar despite different names*

```diff
@@ -1,102 +1,107 @@
-cvlayer/__init__.py,sha256=bKuA9R7mRTuiVA108ywi_9CkTuGKd6UXTA_A13iYZfA,132
-cvlayer/cvlayer.py,sha256=uJHGRBm6WaAlReMaSLGNUHMdf-Wzz-OJz7VtRCJ-328,2844
+cvlayer/__init__.py,sha256=xNeLm1nAHYEsW095Vpb-4Rys1Fvj71Kjh1nzf3rc6SA,186
+cvlayer/cvlayer.py,sha256=VdsMZZLJGCBOewnio2xv4by54986zbzPLgPpmmXlgEU,3121
+cvlayer/cvwindow.py,sha256=OhD0fH5Tbb_l6L6LVBkiBoZqJY8y5bzvdoUcuItiiwI,23548
 cvlayer/chrono/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 cvlayer/chrono/datetime_filename.py,sha256=2zhtGrzSGw2i-PgdqV_b5qjUhhY09uU7km0d4IPxNn4,1084
 cvlayer/cv/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 cvlayer/cv/angle.py,sha256=aIzUaGv0NImT9XWHrCKf7ybvZC_D876wj2e1vMWXGzU,1447
 cvlayer/cv/aspect_ratio.py,sha256=UJBmXrppHJvmKih0MgW4kxhziwMkvBihnjiYzrDK5Oc,502
 cvlayer/cv/backend.py,sha256=waZAty_preYvzV9Y7_5riAST_yF961XJc_8HDHt5fZw,1540
-cvlayer/cv/bgsub.py,sha256=u2P7cTeC9IiES9klzEgS3VzryZbfblO3FeNLUqRTR5w,5815
+cvlayer/cv/basic.py,sha256=Fc5ZF91hAynH7HplVdO82S8Q8jRwZtvhEr_D1mrD9qc,1763
+cvlayer/cv/bgsub.py,sha256=BZBL-BvqYQzAubuQipMT2Hih-8-CcffecoAhUhkLr0M,13945
 cvlayer/cv/bitwise.py,sha256=WXd7ltw_tJwozHE-AslYIrWxNAjuvsKyjDhHNQ5lCEE,1074
 cvlayer/cv/border.py,sha256=5JMdqNWvIxJ15WD_Cl_N50SHyXcMnwGkS4EMwiYLmss,474
 cvlayer/cv/canny.py,sha256=SJmG3epIVSZALOFBGgRA2RHNi4VUIzzccz39__ZXUwY,575
 cvlayer/cv/color.py,sha256=aW5shk7Vci94l59Nv2011l7mcs8sJxPAJZu3oYzfQVw,134
 cvlayer/cv/contours.py,sha256=GU814Nifl25YWBYhdW97PfHbiZ4VWRp8cvb4x7n4fe0,3483
-cvlayer/cv/contours_edge.py,sha256=CW_aktlsJ1DeOH0k-XnjmxmlolnPyZNnBFQ0LnpuFtw,5105
+cvlayer/cv/contours_edge.py,sha256=cAA5p8nDo49tEEeHqUwpDk-KkiWBuW4QmRZLcNaS14Q,5511
 cvlayer/cv/contours_intersection.py,sha256=pYs5WgfUoWoMTrgjh8KAX55cgRZ83Pxt5GNz_8bHbt0,2194
 cvlayer/cv/convert_scale_abs.py,sha256=m3FXTLYTeJeli3KUX6JHANg4wtSFtiPiSx1C85lMPeU,607
-cvlayer/cv/cvt_color.py,sha256=CWFjh4N4g7HZPtsVbVnLpGCo8tJ9gy5nbutoiRNQ63o,1287
+cvlayer/cv/cvt_color.py,sha256=6q7FHAOnNB5pkFxKfsxsNSlhZ49JzaPJxMYp201QnCQ,16007
 cvlayer/cv/cvt_shapely.py,sha256=i1LYF599aafQG2Abg-4R95U1c1RskKRUP1xEcQATqw4,3857
 cvlayer/cv/data_type.py,sha256=FVfa_4Th4ivuLKZL1wF0CM3e2D_dm7S3ScMpIgJb-ck,1008
 cvlayer/cv/dehaze.py,sha256=PYv4le9VTG7Ag0bGMkJ5WhcqqIAoejADGBZp6LPCyiM,2908
-cvlayer/cv/depth.py,sha256=xxxYGt_k-t_d3IsPCwd3_8beMJnODw1JpJ-ZrLAiwtE,1171
-cvlayer/cv/drawable.py,sha256=OTO22ZPALWbiza5mq3DxiDTPYtIZuHtjwUFSPClr3Vk,7489
+cvlayer/cv/depth.py,sha256=fWAZAYr_foFIiZJuz9mmszJpfFFx8dLYND5laclVCzk,1181
+cvlayer/cv/drawable.py,sha256=E4sYjhPVmcRM7d1hIW-vSivaw8_63-PcRmz6CKdK--c,18870
 cvlayer/cv/drawable_contours.py,sha256=5sZh9cWT4Yqub6CgJXrhFJXVuXDUxzH-tvE1kOtgl7I,2273
 cvlayer/cv/fourcc.py,sha256=IfIx5FdcEfUxrZLfeSKzh002D-Q8XmqHBt1wUN5cru4,1507
 cvlayer/cv/fourier_transform.py,sha256=gZJ62yQlCqtHsPmTAuM4Va4sEV6poU8LtxD4TYjVtl8,801
-cvlayer/cv/histogram.py,sha256=vxJwDVb6Y4NQqJ-qFNmAtX5uXfc4r-oVZteEff9ANBw,2993
+cvlayer/cv/histogram.py,sha256=KRmyINfhmhxU9Eq_4c06q54y4WOak2gTHqvtnWWKcYg,5669
 cvlayer/cv/hough_lines.py,sha256=J9LxAgcmQ7Fi-8MXB3ZnaVcxfE3pIaAGI04hi3sHfqw,820
 cvlayer/cv/hsv.py,sha256=CUBDm0quAJiqvlMyHohJTbyQc_enzTgDVMudBBvyQRQ,1128
-cvlayer/cv/image_crop.py,sha256=tvyGCHMBiZBfKYcHrpT-2dlWBE9nPPB6aoY_2XYPJiQ,473
-cvlayer/cv/image_make.py,sha256=dlLV5L77bGTX-eNbFxTm8Zxn_1xw87BSIYHhqrfGrV0,741
+cvlayer/cv/image_crop.py,sha256=nhVbnwXeM6lr7RI1JCkB6Btv4usd_FC2FS3bnkZNwmg,3502
+cvlayer/cv/image_flip.py,sha256=tI8K3l8GhIrfQX15rYGgTJCLRHvqI04LaYWSBh9TqiA,1017
+cvlayer/cv/image_io.py,sha256=HeksG6atJ6g3Ee0VyMnZxNAKFdh_G88lvwpiq-hcRxY,13747
+cvlayer/cv/image_make.py,sha256=fMrkmzhucea9HuTKzt24gUUsE1SUOx81Sqw_p82c_qY,887
 cvlayer/cv/image_move.py,sha256=CeHIlrUBDrXibjA8h7qaBFhQgInh4UVJzIHmeAQbzWY,501
 cvlayer/cv/image_resize.py,sha256=GwkPshH6qEf6VnbvhPfAjSROuYFfZjdzn5mng3ImcHM,1417
 cvlayer/cv/in_range.py,sha256=3twXi1wkmd2IHi3ib_2hBsVwQliBcBvAiSWKjCgBmwM,1403
 cvlayer/cv/intrusion_detection.py,sha256=yEaPoccHQBNjMh61DsziJF-MmkSMSgk4MNsJjXX7swo,9436
 cvlayer/cv/iou.py,sha256=yFOCsM3dbVlP7ASqGjwIM8003k1GV5gqDSLsXs788rE,237
-cvlayer/cv/keymap.py,sha256=viaRnldzzoZDTGLL-wUhs0u4fjA3HWNbkkhydQ5_3eo,2235
+cvlayer/cv/keymap.py,sha256=tUvQdOZBRRIYHT7ACyjno_tog-nOqbl-K8dYXsUc2Co,2267
 cvlayer/cv/laplacian.py,sha256=11EERjfqYoizKjMW0CL3FODGHS6Izvve--5dmSRqZ7c,1686
 cvlayer/cv/match_template.py,sha256=8kE36CElk7M4-5RUzutFf8PrF-KitAmrmsG0FNInVO8,1590
 cvlayer/cv/matcher.py,sha256=F47jKp7_Ey4WtiThURNTGBGa4T2bHob_tSg_czzF-Cc,966
 cvlayer/cv/morphology.py,sha256=MhDkgUMxNPmw-i5pjy5i43mMwqt3Oh9LaPyBNGUbtDE,1780
 cvlayer/cv/mouse.py,sha256=njXr7ezaNP8taosr6XNGoHxrvn8LLFAOv5JAq7j0BtU,1009
 cvlayer/cv/norm.py,sha256=CVbI3yy6itYWxcet-bCuvkGiM3Vf3iPQtSAY-o0luhw,528
-cvlayer/cv/orb.py,sha256=1kzdcv8wVN_-LnLBAap91r1hZpTA9Aw-1729PYGPJ2E,2505
+cvlayer/cv/orb.py,sha256=8Ly48AXr04RgWjT1EshvYC57YdtAS8HhQ6Na-RIXYnE,2509
 cvlayer/cv/palette.py,sha256=epWuXGNWcvLAoJGnog3uKJ5M9h_2Yv3zCLLi0YiE7rU,670
-cvlayer/cv/perspective.py,sha256=KsK4ay_ARmgGUVt3MmF8JzgheJtGN16fntItNgXgOOM,4028
+cvlayer/cv/perspective.py,sha256=JRk56dV-M-jN2qtKDHtfT-CA_KNDLyqmKQt6_QoUkRM,5102
+cvlayer/cv/plot.py,sha256=uo1UZTGLBEvRAvcp4yK4-mML_dNhXz_e6ItlwKtzQ1w,5339
 cvlayer/cv/rotate_tracer.py,sha256=mBsNsQJMs2jF-erdYF1SU6oNHnPK2brOBVfXjw3UUKE,5253
-cvlayer/cv/sobel.py,sha256=pNJ-ZX6lQe2vLa5oyaR12VKm4vMBKWNFnnRHS5QlZ2w,1689
+cvlayer/cv/sobel.py,sha256=1rxiqN2Swb95fYogTD6Y650gNR2z7EW7eCnjCS2Xmgg,1695
 cvlayer/cv/stabilizer.py,sha256=VJs3Xegf0gR-MHyOx40ow-iJbhFVKARAzfwE_gZ9i50,475
-cvlayer/cv/threshold.py,sha256=WJpOyn_og--fuKjc9jya3DF7AgOg1BlVg3dpEvYK42k,2054
+cvlayer/cv/stack.py,sha256=mO6rwHN0zf4oyZq6GwYsr4--Rp-30cQuGFmEH86jLN8,476
+cvlayer/cv/threshold.py,sha256=jyn4Tj74tB81dHwnn8q9NTS-4N8HhAETg70vljSdQ8U,3139
 cvlayer/cv/tracker.py,sha256=djgauGeITClJ1k1PpnpHyz_kGdxx9xzhmm9kNnJgT_0,2769
 cvlayer/cv/tracking.py,sha256=OD6cj2iL66sec1Oo55DQR8C042pH1wp88bZo9RAOX18,2131
 cvlayer/cv/video_capture.py,sha256=4Ie77fQ2o9fPOuvjwOyEzVLOmLfz11hRdpze2Ok_qJk,9578
 cvlayer/cv/video_writer.py,sha256=74tHEGpNSC9q9zE23pORZxjtq-SlEyyYUBcxAP2pRJ0,6571
-cvlayer/cv/window.py,sha256=DDZ7HMaAmuuR1XrjRu3FBJxr37XYZxruc3bouBRXg2c,6505
+cvlayer/cv/window.py,sha256=rVA-8wlxsKcjT44oic3kzirpK54ZYSTfcNY3GnbaWp0,7276
+cvlayer/debug/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+cvlayer/debug/avg_stat.py,sha256=z1rLCoETaftIDuG8q0hatUHB9yV7-5OeEVcFGy1j_4k,3367
 cvlayer/geometry/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 cvlayer/geometry/find_nearset_point.py,sha256=bu0ZycMjhtwnka12At4NrWbZx-OvOZnO44Ktu8XcX2I,401
 cvlayer/geometry/flatten.py,sha256=WTUX0QmO4voXjyKHq3DzzJxrf_lCvtMBnFZSeiH8oWo,167
 cvlayer/geometry/iou.py,sha256=GVukKtR3wuaXfsRLg9ItPl1et-Tt8-PcFwnyzQ19tXs,862
 cvlayer/inspect/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 cvlayer/inspect/member.py,sha256=_o20tFjBx7JLmY3f7HWe-7Mfwx6Vi0tAjYEc5Eeznzk,979
 cvlayer/keymap/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 cvlayer/keymap/create.py,sha256=sfYTNUwSshNJMOboBW7a5IB16VX_-ClR3XyCGPWs9Rw,1006
 cvlayer/layers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 cvlayer/layers/base/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-cvlayer/layers/base/layer_base.py,sha256=tVdGBA6G315uNSb0YFtmKPFuk1ky0zvrKtOtfnG3aF0,5650
-cvlayer/layers/base/layer_manager.py,sha256=33LrQ54NhYDAtDK-m7JoRUgQ_swkdb9f7BXxh3h1ATg,5949
-cvlayer/layers/base/layer_parameter.py,sha256=H36bG_7Mql2GvQYjuj1yJrSOuT64v2V9t0hZCcd25yc,5102
+cvlayer/layers/base/layer_base.py,sha256=_a2qlWA-e7Vge3c8afFcWmgPTs_GFCILNXLUvmAtP5Y,7180
+cvlayer/layers/base/layer_manager.py,sha256=xOGqdwYkX4WNXLbDq362gJzkd0DjFKtx4Qq-PChVP9Y,7385
+cvlayer/layers/base/layer_parameter.py,sha256=nI1n4E72iGIdfIvk-w9GBETPycugk55zEbpJwxllUqA,14650
 cvlayer/math/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 cvlayer/math/angle.py,sha256=s-eG-I4yKFCUC6wJrpIjEaMWR5sUg-zryXV00R_9tcg,1740
 cvlayer/math/aspect_ratio.py,sha256=UGRY8A2-7gZebax-gkWv5B9LxhUuPFy7jAkKlBxmlO8,690
 cvlayer/math/constant.py,sha256=lru-8c_jYeRFOTnlU7_VjTlRnuITppOnRQVgpDIPGRI,126
 cvlayer/math/norm.py,sha256=KSE_emsdQb0x6O4I1gtaYynqKqgEVtu_K0wNew8kVME,451
 cvlayer/math/equation/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 cvlayer/math/equation/linear.py,sha256=F-6jUIMKZez0qDHs3svXicxVmRNXX-jQ03qYFpJvmXo,1160
 cvlayer/np/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-cvlayer/np/image.py,sha256=ION4BZTGLjfpjKuMLdc6yv9nd5HEmB2apxUeu3vlCI4,607
+cvlayer/np/image.py,sha256=vX5bOMBDXhZaqKKdKpJr-hPJHG2JA3i5saX4dIVvEy4,773
 cvlayer/np/mask.py,sha256=z_WDYZP_AB7TPjkc87863-R8KDoHPz6WeYktF-Zb-mA,1547
 cvlayer/palette/__init__.py,sha256=Kh8AKM8P3R1vQVNC5PtIrK_iIP1PIK1cHRN3BrcY08o,1663
 cvlayer/palette/basic.py,sha256=J_ebCmNr6Vrbmgfel8n1hK7Dmv81WijbuX-7YOGCh8U,511
 cvlayer/palette/css4.py,sha256=KE6m4lkKRWxHF9U_cCVo__5MUhcv8Oo1OW2uzBz1-3w,4656
 cvlayer/palette/extended.py,sha256=XwAio4JakffL8AxNmSQg0R6ZwoL_KOpE3R2uWu1Oo4k,4612
 cvlayer/palette/flat.py,sha256=NylX9nnDb4O9-i6gGPxLeJryxJpsWaxMa70L8qGeJVU,8449
 cvlayer/palette/tableau.py,sha256=l0ybJ4_2AHBXAbHATo1bZzHIqdmdgYJQhexJvYM6yxg,291
 cvlayer/palette/xkcd.py,sha256=xwRW9BHgcCCq6lbfax3HnCxreJ6JPIcGZRtN6X5BC00,32876
 cvlayer/shape/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 cvlayer/shape/points.py,sha256=NmDg2bs3IqlrkLF4vljLC2OMzI0dTo6ZAIP-hXHiAkE,1654
 cvlayer/shape/polygons.py,sha256=Dj_RIAAYuF_Lp9qMxKksUdjrwGRjcoMJUdD9T_kPp7Y,1509
 cvlayer/tk/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 cvlayer/tk/tk_window.py,sha256=wi9HFsORkY5tNhVBbl5Zw25ubx7Iar3Rd1JyzUtSqTg,4334
-cvlayer/typing/__init__.py,sha256=si6PaR2SeZhfvOxndVj4GLaPzPoqvAs193Iu4RMcaPg,663
+cvlayer/typing/__init__.py,sha256=vBDdss-Q6hl-2cdpuEEOdhWacJwoTMpBvZT0fDoBdLA,825
 cvlayer/typing/color.py,sha256=sK4aeEv9wOIQMBh2zizGcPLquyCoSJPcAleiSuraNvg,123
-cvlayer/typing/geomerty.py,sha256=wHF6vtQ0Y2uF367tS7r4tgqbs_vpDKBnf8iwhAxZ7kA,697
+cvlayer/typing/geomerty.py,sha256=zqJFGskwWQeiQEqCgHwhjNVz2a8oiDzips84MtEYbzE,905
 cvlayer/typing/np.py,sha256=_st5RsUv9ebs7E9U-hbMDJaXjrd-v6Uw1hmYCzhV9K4,240
-cvlayer/vio/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-cvlayer/vio/vio.py,sha256=g4s21SMZDcYHKe2KZxpC5sOuWTZqKN1uIj6mF8DKgN0,20246
-cvlayer/vio/vio_interface.py,sha256=o0Fc7B7zb2DBint187eljJIPVXZcD_CyfpU0at70CyE,719
-cvlayer-0.8.0.dist-info/LICENSE,sha256=W6E4CImwrifHZNTPd3mERP-Ni9XDYgU6BFAxMyccl4c,1065
-cvlayer-0.8.0.dist-info/METADATA,sha256=CqcKU7gWczm7rQe1i5XszmvDdtz3hvMffCyzR6LLN90,1941
-cvlayer-0.8.0.dist-info/WHEEL,sha256=yQN5g4mg4AybRjkgi-9yy4iQEFibGQmlz78Pik5Or-A,92
-cvlayer-0.8.0.dist-info/top_level.txt,sha256=AsUq0dJkH0_6g2OExn9KL6kXW1ffCJWNRtR-AoJWvtQ,8
-cvlayer-0.8.0.dist-info/RECORD,,
+cvlayer-0.9.0.dist-info/LICENSE,sha256=W6E4CImwrifHZNTPd3mERP-Ni9XDYgU6BFAxMyccl4c,1065
+cvlayer-0.9.0.dist-info/METADATA,sha256=qbNHht0K4QpL1IoTl9WilPC7gD928yvwaRlCY7jYnyM,4650
+cvlayer-0.9.0.dist-info/WHEEL,sha256=yQN5g4mg4AybRjkgi-9yy4iQEFibGQmlz78Pik5Or-A,92
+cvlayer-0.9.0.dist-info/top_level.txt,sha256=AsUq0dJkH0_6g2OExn9KL6kXW1ffCJWNRtR-AoJWvtQ,8
+cvlayer-0.9.0.dist-info/RECORD,,
```

