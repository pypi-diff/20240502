# Comparing `tmp/aos_signer-1.8.2b6-py3-none-any.whl.zip` & `tmp/aos_signer-1.8.2b7-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,39 +1,39 @@
-Zip file size: 29374 bytes, number of entries: 37
--rw-rw-rw-  2.0 fat      114 b- defN 22-Nov-23 12:48 aos_signer/__init__.py
--rw-rw-rw-  2.0 fat     3909 b- defN 22-Nov-23 11:35 aos_signer/main.py
+Zip file size: 29433 bytes, number of entries: 37
+-rw-rw-rw-  2.0 fat      114 b- defN 22-Dec-02 13:24 aos_signer/__init__.py
+-rw-rw-rw-  2.0 fat     3909 b- defN 22-Dec-02 13:22 aos_signer/main.py
 -rw-rw-rw-  2.0 fat      245 b- defN 22-Nov-22 16:35 aos_signer/test.py
 -rw-rw-rw-  2.0 fat     2750 b- defN 22-Feb-07 18:56 aos_signer/files/1rootCA.crt
 -rw-rw-rw-  2.0 fat      129 b- defN 22-Nov-21 11:23 aos_signer/files/__init__.py
 -rw-rw-rw-  2.0 fat     2297 b- defN 22-Feb-07 18:56 aos_signer/files/build_schema.json
--rw-rw-rw-  2.0 fat     2929 b- defN 22-Nov-21 11:23 aos_signer/files/config.yaml
--rw-rw-rw-  2.0 fat    10542 b- defN 22-Oct-12 12:55 aos_signer/files/configuration_schema.json
+-rw-rw-rw-  2.0 fat     2929 b- defN 22-Dec-02 13:20 aos_signer/files/config.yaml
+-rw-rw-rw-  2.0 fat    10542 b- defN 22-Dec-02 13:20 aos_signer/files/configuration_schema.json
 -rw-rw-rw-  2.0 fat     1706 b- defN 22-Feb-07 18:56 aos_signer/files/publish_schema.json
 -rw-rw-rw-  2.0 fat      565 b- defN 22-Feb-07 18:56 aos_signer/files/publisher_schema.json
 -rw-rw-rw-  2.0 fat      418 b- defN 22-Feb-07 18:56 aos_signer/files/root_schema.json
 -rw-rw-rw-  2.0 fat      583 b- defN 22-Feb-07 18:56 aos_signer/files/state_schema.json
 -rw-rw-rw-  2.0 fat       93 b- defN 22-Feb-07 18:56 aos_signer/service_config/__init__.py
 -rw-rw-rw-  2.0 fat     5968 b- defN 22-Oct-12 12:55 aos_signer/service_config/config_xml_generator.py
--rw-rw-rw-  2.0 fat     2952 b- defN 22-Nov-23 12:27 aos_signer/service_config/service_configuration.py
+-rw-rw-rw-  2.0 fat     2952 b- defN 22-Dec-02 13:22 aos_signer/service_config/service_configuration.py
 -rw-rw-rw-  2.0 fat       93 b- defN 22-Feb-07 18:56 aos_signer/service_config/models/__init__.py
 -rw-rw-rw-  2.0 fat        0 b- defN 22-Feb-07 18:56 aos_signer/service_config/models/alerts.py
 -rw-rw-rw-  2.0 fat     2073 b- defN 22-May-31 12:52 aos_signer/service_config/models/build.py
--rw-rw-rw-  2.0 fat     1074 b- defN 22-Nov-23 12:28 aos_signer/service_config/models/config_chapter.py
+-rw-rw-rw-  2.0 fat     1108 b- defN 22-Dec-02 13:22 aos_signer/service_config/models/config_chapter.py
 -rw-rw-rw-  2.0 fat     6679 b- defN 22-Oct-12 12:55 aos_signer/service_config/models/configuration.py
 -rw-rw-rw-  2.0 fat     1574 b- defN 22-May-31 12:52 aos_signer/service_config/models/publish.py
 -rw-rw-rw-  2.0 fat      494 b- defN 22-May-31 12:52 aos_signer/service_config/models/publisher.py
 -rw-rw-rw-  2.0 fat     1258 b- defN 22-May-31 12:52 aos_signer/service_config/models/state.py
 -rw-rw-rw-  2.0 fat       93 b- defN 22-Nov-21 11:23 aos_signer/signer/__init__.py
 -rw-rw-rw-  2.0 fat     2247 b- defN 22-Nov-21 11:23 aos_signer/signer/bootstrapper.py
--rw-rw-rw-  2.0 fat     2128 b- defN 22-Nov-23 12:48 aos_signer/signer/commands.py
+-rw-rw-rw-  2.0 fat     2198 b- defN 22-Dec-02 13:22 aos_signer/signer/commands.py
 -rw-rw-rw-  2.0 fat     1135 b- defN 22-Nov-21 11:23 aos_signer/signer/common.py
 -rw-rw-rw-  2.0 fat     1050 b- defN 22-Nov-21 11:23 aos_signer/signer/errors.py
 -rw-rw-rw-  2.0 fat     1291 b- defN 22-Feb-07 18:56 aos_signer/signer/file_details.py
--rw-rw-rw-  2.0 fat     7626 b- defN 22-Nov-23 11:35 aos_signer/signer/signer.py
--rw-rw-rw-  2.0 fat     3297 b- defN 22-Nov-23 11:35 aos_signer/signer/uploader.py
--rw-rw-rw-  2.0 fat     8442 b- defN 22-Nov-23 12:48 aos_signer/signer/user_credentials.py
--rw-rw-rw-  2.0 fat      988 b- defN 22-Nov-23 12:48 aos_signer-1.8.2b6.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 22-Nov-23 12:48 aos_signer-1.8.2b6.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       53 b- defN 22-Nov-23 12:48 aos_signer-1.8.2b6.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat       11 b- defN 22-Nov-23 12:48 aos_signer-1.8.2b6.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     3347 b- defN 22-Nov-23 12:48 aos_signer-1.8.2b6.dist-info/RECORD
-37 files, 80245 bytes uncompressed, 23912 bytes compressed:  70.2%
+-rw-rw-rw-  2.0 fat     7626 b- defN 22-Dec-02 13:22 aos_signer/signer/signer.py
+-rw-rw-rw-  2.0 fat     3288 b- defN 22-Dec-02 13:31 aos_signer/signer/uploader.py
+-rw-rw-rw-  2.0 fat     8668 b- defN 22-Dec-02 13:22 aos_signer/signer/user_credentials.py
+-rw-rw-rw-  2.0 fat      988 b- defN 22-Dec-02 13:31 aos_signer-1.8.2b7.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 22-Dec-02 13:31 aos_signer-1.8.2b7.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       53 b- defN 22-Dec-02 13:31 aos_signer-1.8.2b7.dist-info/entry_points.txt
+-rw-rw-rw-  2.0 fat       11 b- defN 22-Dec-02 13:31 aos_signer-1.8.2b7.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     3347 b- defN 22-Dec-02 13:31 aos_signer-1.8.2b7.dist-info/RECORD
+37 files, 80566 bytes uncompressed, 23971 bytes compressed:  70.2%
```

## zipnote {}

```diff
@@ -90,23 +90,23 @@
 
 Filename: aos_signer/signer/uploader.py
 Comment: 
 
 Filename: aos_signer/signer/user_credentials.py
 Comment: 
 
-Filename: aos_signer-1.8.2b6.dist-info/METADATA
+Filename: aos_signer-1.8.2b7.dist-info/METADATA
 Comment: 
 
-Filename: aos_signer-1.8.2b6.dist-info/WHEEL
+Filename: aos_signer-1.8.2b7.dist-info/WHEEL
 Comment: 
 
-Filename: aos_signer-1.8.2b6.dist-info/entry_points.txt
+Filename: aos_signer-1.8.2b7.dist-info/entry_points.txt
 Comment: 
 
-Filename: aos_signer-1.8.2b6.dist-info/top_level.txt
+Filename: aos_signer-1.8.2b7.dist-info/top_level.txt
 Comment: 
 
-Filename: aos_signer-1.8.2b6.dist-info/RECORD
+Filename: aos_signer-1.8.2b7.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## aos_signer/__init__.py

```diff
@@ -1,6 +1,6 @@
 #
 #  Copyright (c) 2018-2022 Renesas Inc.
 #  Copyright (c) 2018-2022 EPAM Systems Inc.
 #
 
-__version__ = '1.8.2b6'
+__version__ = '1.8.2b7'
```

## aos_signer/service_config/models/config_chapter.py

 * *Ordering differences only*

```diff
@@ -1,34 +1,34 @@
-#
-#  Copyright (c) 2018-2022 Renesas Inc.
-#  Copyright (c) 2018-2022 EPAM Systems Inc.
-#
-import json
-import sys
-from abc import ABC, abstractmethod
-
-import jsonschema
-
-if sys.version_info > (3, 9):
-    from importlib import resources as pkg_resources  # noqa: WPS433, WPS440
-else:
-    import importlib_resources as pkg_resources  # noqa: WPS433, WPS440
-
-
-class ConfigChapter(ABC):
-
-    @staticmethod
-    @abstractmethod
-    def from_yaml(input_dict):
-        pass
-
-    @staticmethod
-    def validate(received_chapter, validation_schema=None, validation_file=None):
-        if validation_schema is not None:
-            return jsonschema.validate(received_chapter, schema=validation_schema)
-
-        if validation_file is not None:
-            schema = pkg_resources.files('aos_signer') / ('files/' + validation_file)
-            with pkg_resources.as_file(schema) as schema_path:
-                with open(schema_path, 'r') as f:
-                    schema_loaded = json.loads(f.read())
-                    return jsonschema.validate(received_chapter, schema=schema_loaded)
+#
+#  Copyright (c) 2018-2022 Renesas Inc.
+#  Copyright (c) 2018-2022 EPAM Systems Inc.
+#
+import json
+import sys
+from abc import ABC, abstractmethod
+
+import jsonschema
+
+if sys.version_info > (3, 9):
+    from importlib import resources as pkg_resources  # noqa: WPS433, WPS440
+else:
+    import importlib_resources as pkg_resources  # noqa: WPS433, WPS440
+
+
+class ConfigChapter(ABC):
+
+    @staticmethod
+    @abstractmethod
+    def from_yaml(input_dict):
+        pass
+
+    @staticmethod
+    def validate(received_chapter, validation_schema=None, validation_file=None):
+        if validation_schema is not None:
+            return jsonschema.validate(received_chapter, schema=validation_schema)
+
+        if validation_file is not None:
+            schema = pkg_resources.files('aos_signer') / ('files/' + validation_file)
+            with pkg_resources.as_file(schema) as schema_path:
+                with open(schema_path, 'r') as f:
+                    schema_loaded = json.loads(f.read())
+                    return jsonschema.validate(received_chapter, schema=schema_loaded)
```

## aos_signer/signer/commands.py

 * *Ordering differences only*

```diff
@@ -1,70 +1,70 @@
-#
-#  Copyright (c) 2018-2022 Renesas Inc.
-#  Copyright (c) 2018-2022 EPAM Systems Inc.
-#
-import sys
-from pathlib import Path
-
-from aos_signer.service_config.service_configuration import ServiceConfiguration
-from aos_signer.signer.bootstrapper import run_bootstrap
-from aos_signer.signer.common import print_message
-from aos_signer.signer.errors import SignerError
-from aos_signer.signer.signer import Signer
-from aos_signer.signer.uploader import run_upload
-
-
-def bootstrap_service_folder():
-    """Create service folder structure and config.yaml."""
-    print_message("[green]Starting INIT process...")
-    run_bootstrap()
-
-
-def validate_service_config(config_path: Path):
-    """Validate config.yaml.
-    Args:
-        config_path: Path to config file.
-    Raises:
-        SignerConfigError: If config is not valid.
-    """
-    print_message("[bright_black]Starting CONFIG VALIDATION process...")
-    ServiceConfiguration(Path(config_path))
-    print_message("[green]Config is valid")
-
-
-def upload_service(config_path: Path):
-    """Upload service.
-    Args:
-        config_path: Path to config file.
-    Raises:
-        SignerError: If upload failed.
-    """
-    config = ServiceConfiguration(config_path)
-
-    print_message("[bright_black]Starting SERVICE UPLOAD process...")
-    try:
-        run_upload(config, Path(config_path))
-    except OSError:
-        raise SignerError(str(sys.exc_info()[1]))
-
-
-def sign_service(config_path: Path, sources_folder: str = 'src', package_folder: str = '.'):
-    """Sign service.
-    Args:
-        config_path: Path to config file.
-        sources_folder: Service sources folder.
-        package_folder: Result save folder.
-    Raises:
-        SignerError: If sign process failed.
-    """
-    print_message("[bright_black]Starting SERVICE SIGNING process...")
-    config = ServiceConfiguration(config_path)
-    try:
-        s = Signer(
-            src_folder=sources_folder,
-            package_folder=package_folder,
-            config=config,
-            config_path=Path(config_path)
-        )
-        s.process()
-    except OSError:
-        raise SignerError(str(sys.exc_info()[1]))
+#
+#  Copyright (c) 2018-2022 Renesas Inc.
+#  Copyright (c) 2018-2022 EPAM Systems Inc.
+#
+import sys
+from pathlib import Path
+
+from aos_signer.service_config.service_configuration import ServiceConfiguration
+from aos_signer.signer.bootstrapper import run_bootstrap
+from aos_signer.signer.common import print_message
+from aos_signer.signer.errors import SignerError
+from aos_signer.signer.signer import Signer
+from aos_signer.signer.uploader import run_upload
+
+
+def bootstrap_service_folder():
+    """Create service folder structure and config.yaml."""
+    print_message("[green]Starting INIT process...")
+    run_bootstrap()
+
+
+def validate_service_config(config_path: Path):
+    """Validate config.yaml.
+    Args:
+        config_path: Path to config file.
+    Raises:
+        SignerConfigError: If config is not valid.
+    """
+    print_message("[bright_black]Starting CONFIG VALIDATION process...")
+    ServiceConfiguration(Path(config_path))
+    print_message("[green]Config is valid")
+
+
+def upload_service(config_path: Path):
+    """Upload service.
+    Args:
+        config_path: Path to config file.
+    Raises:
+        SignerError: If upload failed.
+    """
+    config = ServiceConfiguration(config_path)
+
+    print_message("[bright_black]Starting SERVICE UPLOAD process...")
+    try:
+        run_upload(config, Path(config_path))
+    except OSError:
+        raise SignerError(str(sys.exc_info()[1]))
+
+
+def sign_service(config_path: Path, sources_folder: str = 'src', package_folder: str = '.'):
+    """Sign service.
+    Args:
+        config_path: Path to config file.
+        sources_folder: Service sources folder.
+        package_folder: Result save folder.
+    Raises:
+        SignerError: If sign process failed.
+    """
+    print_message("[bright_black]Starting SERVICE SIGNING process...")
+    config = ServiceConfiguration(config_path)
+    try:
+        s = Signer(
+            src_folder=sources_folder,
+            package_folder=package_folder,
+            config=config,
+            config_path=Path(config_path)
+        )
+        s.process()
+    except OSError:
+        raise SignerError(str(sys.exc_info()[1]))
```

## aos_signer/signer/uploader.py

```diff
@@ -1,79 +1,80 @@
-#
-#  Copyright (c) 2018-2022 Renesas Inc.
-#  Copyright (c) 2018-2022 EPAM Systems Inc.
-#
-
-import json
-from pathlib import Path
-
-import requests
-from requests.exceptions import SSLError
-from requests_pkcs12 import post
-
-from aos_signer.service_config.service_configuration import ServiceConfiguration
-from aos_signer.signer.common import ca_certificate
-from aos_signer.signer.common import print_message
-from aos_signer.signer.errors import SignerError
-from aos_signer.signer.user_credentials import UserCredentials
-
-
-def run_upload(config: ServiceConfiguration, config_path: Path):
-    uc = UserCredentials(config, config_path)
-    uc.find_upload_key_and_cert()
-
-    upload_data = {'service': config.publish.service_uid, 'package_version': 2}
-    version = config.publish.version
-
-    if version:
-        upload_data['version'] = version
-
-    print_message("Uploading...                   ", end='')
-
-    with ca_certificate() as server_certificate_path:
-        try:
-            if uc.pkcs_credentials is None:
-                resp = requests.post(
-                    'https://{}:10000/api/v1/services/versions/'.format(config.publish.url),
-                    files={'file': open('service.tar.gz', 'rb')},
-                    data=upload_data,
-                    cert=(uc.upload_cert_path, uc.upload_key_path),
-                    verify=server_certificate_path)
-            else:
-                resp = post(
-                    'https://{}:10000/api/v1/services/versions/'.format(config.publish.url),
-                    files={'file': open('service.tar.gz', 'rb')},
-                    data=upload_data,
-                    pkcs12_filename=uc.upload_p12_path,
-                    pkcs12_password='',
-                    verify=server_certificate_path)
-        except SSLError:
-            print_message('[yellow]TLS verification against Aos Root CA failed.')
-            print_message('[yellow]Try to POST using TLS verification against system CAs.')
-            if uc.pkcs_credentials is None:
-                resp = requests.post(
-                    'https://{}:10000/api/v1/services/versions/'.format(config.publish.url),
-                    files={'file': open('service.tar.gz', 'rb')},
-                    data=upload_data,
-                    cert=(uc.upload_cert_path, uc.upload_key_path))
-            else:
-                resp = post(
-                    'https://{}:10000/api/v1/services/versions/'.format(config.publish.url),
-                    files={'file': open('service.tar.gz', 'rb')},
-                    data=upload_data,
-                    pkcs12_filename=uc.upload_p12_path,
-                    pkcs12_password='')
-
-        if resp.status_code != 201:
-            print_message('[red]ERROR')
-            print_message('[red]Server returned error while uploading:')
-            try:
-                errors = json.loads(resp.text)
-                message = ''
-                for key, value in errors.items():
-                    message += f'   {key}: {value}'
-                    raise SignerError(message)
-            except json.JSONDecodeError:
-                raise SignerError(resp.text)
-
-    print_message(f"[green]DONE")
-    print_message(f'[green]Service successfully uploaded!')
+#
+#  Copyright (c) 2018-2022 Renesas Inc.
+#  Copyright (c) 2018-2022 EPAM Systems Inc.
+#
+
+import json
+from pathlib import Path
+
+import requests
+from requests.exceptions import SSLError
+from requests_pkcs12 import post
+
+from aos_signer.service_config.service_configuration import ServiceConfiguration
+from aos_signer.signer.common import ca_certificate
+from aos_signer.signer.common import print_message
+from aos_signer.signer.errors import SignerError
+from aos_signer.signer.user_credentials import UserCredentials
+
+
+def run_upload(config: ServiceConfiguration, config_path: Path):
+    uc = UserCredentials(config, config_path)
+    uc.find_upload_key_and_cert()
+
+    upload_data = {'service': config.publish.service_uid, 'package_version': 2}
+    version = config.publish.version
+
+    if version:
+        upload_data['version'] = version
+
+    file_to_upload = (config_path.parent.parent / 'service.tar.gz').resolve()
+    print_message("Uploading...                   ", end='')
+
+    with ca_certificate() as server_certificate_path:
+        try:
+            if uc.pkcs_credentials is None:
+                resp = requests.post(
+                    'https://{}:10000/api/v1/services/versions/'.format(config.publish.url),
+                    files={'file': open(file_to_upload, 'rb')},
+                    data=upload_data,
+                    cert=(uc.upload_cert_path, uc.upload_key_path),
+                    verify=server_certificate_path)
+            else:
+                resp = post(
+                    'https://{}:10000/api/v1/services/versions/'.format(config.publish.url),
+                    files={'file': open(file_to_upload, 'rb')},
+                    data=upload_data,
+                    pkcs12_filename=uc.upload_p12_path,
+                    pkcs12_password='',
+                    verify=server_certificate_path)
+        except SSLError:
+            print_message('[yellow]TLS verification against Aos Root CA failed.')
+            print_message('[yellow]Try to POST using TLS verification against system CAs.')
+            if uc.pkcs_credentials is None:
+                resp = requests.post(
+                    'https://{}:10000/api/v1/services/versions/'.format(config.publish.url),
+                    files={'file': open(file_to_upload, 'rb')},
+                    data=upload_data,
+                    cert=(uc.upload_cert_path, uc.upload_key_path))
+            else:
+                resp = post(
+                    'https://{}:10000/api/v1/services/versions/'.format(config.publish.url),
+                    files={'file': open(file_to_upload, 'rb')},
+                    data=upload_data,
+                    pkcs12_filename=uc.upload_p12_path,
+                    pkcs12_password='')
+
+        if resp.status_code != 201:
+            print_message('[red]ERROR')
+            print_message('[red]Server returned error while uploading:')
+            try:
+                errors = json.loads(resp.text)
+                message = ''
+                for key, value in errors.items():
+                    message += f'   {key}: {value}'
+                    raise SignerError(message)
+            except json.JSONDecodeError:
+                raise SignerError(resp.text)
+
+    print_message(f"[green]DONE")
+    print_message(f'[green]Service successfully uploaded!')
```

## aos_signer/signer/user_credentials.py

 * *Ordering differences only*

```diff
@@ -1,226 +1,226 @@
-#
-#  Copyright (c) 2018-2019 Renesas Inc.
-#  Copyright (c) 2018-2019 EPAM Systems Inc.
-#
-import os
-import tempfile
-from os.path import join, exists, isabs
-from pathlib import Path
-
-import OpenSSL
-from cryptography.hazmat.backends import default_backend
-from cryptography.hazmat.primitives._serialization import Encoding, PrivateFormat, NoEncryption
-from cryptography.hazmat.primitives.serialization.pkcs12 import load_key_and_certificates
-from cryptography.x509 import load_pem_x509_certificate
-
-from aos_signer.service_config.service_configuration import ServiceConfiguration
-from aos_signer.signer.errors import SignerConfigError
-
-
-def _create_temp_file(data: bytes):
-    tmp_file = tempfile.NamedTemporaryFile(delete=False)
-    tmp_file.write(data)
-    tmp_file.close()
-    return tmp_file.name
-
-
-class TempCredentials:
-    def __init__(self, certificate: bytes, key: bytes):
-        self._key = key
-        self._certificate = certificate
-        self._key_file_name = None
-        self._cert_file_name = None
-
-    def __enter__(self):
-        self._key_file_name = _create_temp_file(self._key)
-        self._cert_file_name = _create_temp_file(self._certificate)
-        return self
-
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        os.unlink(self._key_file_name)
-        os.unlink(self._cert_file_name)
-
-    @property
-    def key_file_name(self):
-        return self._key_file_name
-
-    @property
-    def cert_file_name(self):
-        return self._cert_file_name
-
-
-class UserCredentials(object):
-
-    DEFAULT_USER_CREDENTIALS_FOLDER = str(Path.home() / '.aos' / 'security')
-
-    def __init__(self, config: ServiceConfiguration, config_path: Path):
-        self._config = config
-        self._sign_key_path = None
-        self._sign_cert_path = None
-        self._upload_key_path = None
-        self._upload_cert_path = None
-
-        self._sign_p12_path = None
-        self._upload_p12_path = None
-        self._temp_files = []
-
-        self._sign_key = None
-        self._sign_cert = None
-
-        self._pkcs_credentials = None
-
-        self._config_path = config_path.parent
-
-    @property
-    def sign_key(self):
-        return self._sign_key
-
-    @property
-    def sign_certificate(self):
-        return self._sign_cert
-
-    @property
-    def upload_key_path(self):
-        return self._upload_key_path
-
-    @property
-    def upload_cert_path(self):
-        return self._upload_cert_path
-
-    @property
-    def pkcs_credentials(self):
-        return self._pkcs_credentials
-
-    @property
-    def upload_p12_path(self):
-        return self._upload_p12_path
-
-    def find_sign_key_and_cert(self):
-        if self._config.build.sign_pkcs12 is not None:
-            self._sign_p12_path = self.__find_user_cred_file(self._config.build.sign_pkcs12, 'publish->sign_pkcs12')
-
-            with open(self._sign_p12_path, 'rb') as pkcs12_file:
-                self._sign_cert, self._sign_key = UserCredentials.__pkcs12_to_pem(pkcs12_file.read())
-
-        else:
-            self._sign_key_path = self.__find_user_cred_file(self._config.build.sign_key, 'build->sign_key')
-            self._sign_cert_path = self.__find_user_cred_file(
-                self._config.build.sign_certificate, 'build->sign_certificate')
-
-            with open(self._sign_key_path, 'rb') as key_file:
-                self._sign_key = key_file.read()
-
-            with open(self._sign_cert_path, 'rb') as cert_file:
-                self._sign_cert = cert_file.read()
-
-    def find_upload_key_and_cert(self):
-        if self._config.publish.tls_pkcs12 is not None:
-            self._upload_p12_path = self.__find_user_cred_file(self._config.publish.tls_pkcs12, 'publish->tls_pkcs12')
-
-            with open(self._upload_p12_path, 'rb') as pkcs12_file:
-                cert_bytes, key_bytes = UserCredentials.__pkcs12_to_pem(pkcs12_file.read())
-                self._pkcs_credentials = TempCredentials(cert_bytes, key_bytes)
-        else:
-            if self._config.publish.tls_key is not None:
-                self._upload_key_path = self.__find_user_cred_file(self._config.publish.tls_key, 'publish->tls_key')
-            else:
-                self._upload_key_path = self.__find_user_cred_file(self._config.build.sign_key, 'build->sign_key')
-
-            if self._config.publish.tls_certificate is not None:
-                self._upload_cert_path = self.__find_user_cred_file(
-                    self._config.publish.tls_certificate, 'publish -> sign_certificate')
-            else:
-                self._upload_cert_path = self.__find_user_cred_file(
-                    self._config.build.sign_certificate, 'build -> sign_key')
-
-    def __find_user_cred_file(self, config_file_name: str, config_entry: str) -> str:
-        """Search for file by absolute path, in `meta` folder or in default keys folder.
-
-        Args:
-            config_file_name (str): Filename or absolute file path.
-            config_entry (str): Place in config to show error to user.
-        Raises:
-            SignerConfigError: If received absolute path and file not found or received relative path and file not
-                               found nor in meta neither in aos folders.
-        Returns:
-            str: Path to existing file
-        """
-        path = config_file_name
-        if isabs(path):
-            if exists(path):
-                return path
-            else:
-                raise SignerConfigError('{} is set to absolute path but file not found.'.format(config_entry))
-
-        for search_dir in (self._config_path, self.DEFAULT_USER_CREDENTIALS_FOLDER):
-            path = join(search_dir, config_file_name)
-            if exists(path):
-                return path
-        raise SignerConfigError(
-                'Configured {} file is set to {}, but file not found neither in {} nor in {} directory.'.format(
-                    config_entry,
-                    config_file_name,
-                    self._config_path,
-                    self.DEFAULT_USER_CREDENTIALS_FOLDER
-                )
-            )
-
-    @staticmethod
-    def __validate_key_cert_pair(key_path, cert_path):
-        """Check key and certificate are in valid format and certificate is derived from the key.
-
-        Args:
-            key_path (str): Path to key file.
-            cert_path (str): Path to certificate file.
-        Raises:
-            SignerConfigError: In case of any certificate or key error.
-        Returns:
-            None: if no errors
-        """
-        with open(cert_path, "rb") as c, open(key_path, "rb") as k:
-            cert_content = c.read()
-            key_content = k.read()
-
-        try:
-            private_key_obj = OpenSSL.crypto.load_privatekey(OpenSSL.crypto.FILETYPE_PEM, key_content)
-        except OpenSSL.crypto.Error:
-            raise SignerConfigError('Private key {} is not correct'.format(key_path))
-
-        try:
-            cert_obj = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert_content)
-        except OpenSSL.crypto.Error:
-            raise SignerConfigError('Certificate {} is not correct'.format(cert_path))
-
-        context = OpenSSL.SSL.Context(OpenSSL.SSL.TLSv1_2_METHOD)
-        context.use_privatekey(private_key_obj)
-        context.use_certificate(cert_obj)
-        try:
-            context.check_privatekey()
-        except OpenSSL.SSL.Error:
-            SignerConfigError('Certificate public key is not derived from the private key')
-
-    @staticmethod
-    def __pkcs12_to_pem(pkcs12_bytes: bytes):
-        private_key, certificate, additional_certificates = \
-            load_key_and_certificates(pkcs12_bytes, ''.encode('utf8'), default_backend())
-
-        cert_bytes = bytearray(certificate.public_bytes(Encoding.PEM))
-        for add_cert in additional_certificates:
-            cert_bytes += add_cert.public_bytes(Encoding.PEM)
-        key_bytes = private_key.private_bytes(Encoding.PEM, PrivateFormat.PKCS8, NoEncryption())
-        cert_bytes = bytes(cert_bytes)
-        return cert_bytes, key_bytes
-
-    @classmethod
-    def get_issuer(cls, certificate_data: bytes):
-        certificate = load_pem_x509_certificate(certificate_data)
-        return certificate.issuer.rfc4514_string()
-
-    @classmethod
-    def get_certificate_serial_number_hex(cls, certificate_data: bytes) -> str:
-        certificate = load_pem_x509_certificate(certificate_data)
-
-        serial = f'{certificate.serial_number:X}'
-        if len(serial) % 2:
-            return '0' + serial
-        return serial
+#
+#  Copyright (c) 2018-2019 Renesas Inc.
+#  Copyright (c) 2018-2019 EPAM Systems Inc.
+#
+import os
+import tempfile
+from os.path import join, exists, isabs
+from pathlib import Path
+
+import OpenSSL
+from cryptography.hazmat.backends import default_backend
+from cryptography.hazmat.primitives._serialization import Encoding, PrivateFormat, NoEncryption
+from cryptography.hazmat.primitives.serialization.pkcs12 import load_key_and_certificates
+from cryptography.x509 import load_pem_x509_certificate
+
+from aos_signer.service_config.service_configuration import ServiceConfiguration
+from aos_signer.signer.errors import SignerConfigError
+
+
+def _create_temp_file(data: bytes):
+    tmp_file = tempfile.NamedTemporaryFile(delete=False)
+    tmp_file.write(data)
+    tmp_file.close()
+    return tmp_file.name
+
+
+class TempCredentials:
+    def __init__(self, certificate: bytes, key: bytes):
+        self._key = key
+        self._certificate = certificate
+        self._key_file_name = None
+        self._cert_file_name = None
+
+    def __enter__(self):
+        self._key_file_name = _create_temp_file(self._key)
+        self._cert_file_name = _create_temp_file(self._certificate)
+        return self
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        os.unlink(self._key_file_name)
+        os.unlink(self._cert_file_name)
+
+    @property
+    def key_file_name(self):
+        return self._key_file_name
+
+    @property
+    def cert_file_name(self):
+        return self._cert_file_name
+
+
+class UserCredentials(object):
+
+    DEFAULT_USER_CREDENTIALS_FOLDER = str(Path.home() / '.aos' / 'security')
+
+    def __init__(self, config: ServiceConfiguration, config_path: Path):
+        self._config = config
+        self._sign_key_path = None
+        self._sign_cert_path = None
+        self._upload_key_path = None
+        self._upload_cert_path = None
+
+        self._sign_p12_path = None
+        self._upload_p12_path = None
+        self._temp_files = []
+
+        self._sign_key = None
+        self._sign_cert = None
+
+        self._pkcs_credentials = None
+
+        self._config_path = config_path.parent
+
+    @property
+    def sign_key(self):
+        return self._sign_key
+
+    @property
+    def sign_certificate(self):
+        return self._sign_cert
+
+    @property
+    def upload_key_path(self):
+        return self._upload_key_path
+
+    @property
+    def upload_cert_path(self):
+        return self._upload_cert_path
+
+    @property
+    def pkcs_credentials(self):
+        return self._pkcs_credentials
+
+    @property
+    def upload_p12_path(self):
+        return self._upload_p12_path
+
+    def find_sign_key_and_cert(self):
+        if self._config.build.sign_pkcs12 is not None:
+            self._sign_p12_path = self.__find_user_cred_file(self._config.build.sign_pkcs12, 'publish->sign_pkcs12')
+
+            with open(self._sign_p12_path, 'rb') as pkcs12_file:
+                self._sign_cert, self._sign_key = UserCredentials.__pkcs12_to_pem(pkcs12_file.read())
+
+        else:
+            self._sign_key_path = self.__find_user_cred_file(self._config.build.sign_key, 'build->sign_key')
+            self._sign_cert_path = self.__find_user_cred_file(
+                self._config.build.sign_certificate, 'build->sign_certificate')
+
+            with open(self._sign_key_path, 'rb') as key_file:
+                self._sign_key = key_file.read()
+
+            with open(self._sign_cert_path, 'rb') as cert_file:
+                self._sign_cert = cert_file.read()
+
+    def find_upload_key_and_cert(self):
+        if self._config.publish.tls_pkcs12 is not None:
+            self._upload_p12_path = self.__find_user_cred_file(self._config.publish.tls_pkcs12, 'publish->tls_pkcs12')
+
+            with open(self._upload_p12_path, 'rb') as pkcs12_file:
+                cert_bytes, key_bytes = UserCredentials.__pkcs12_to_pem(pkcs12_file.read())
+                self._pkcs_credentials = TempCredentials(cert_bytes, key_bytes)
+        else:
+            if self._config.publish.tls_key is not None:
+                self._upload_key_path = self.__find_user_cred_file(self._config.publish.tls_key, 'publish->tls_key')
+            else:
+                self._upload_key_path = self.__find_user_cred_file(self._config.build.sign_key, 'build->sign_key')
+
+            if self._config.publish.tls_certificate is not None:
+                self._upload_cert_path = self.__find_user_cred_file(
+                    self._config.publish.tls_certificate, 'publish -> sign_certificate')
+            else:
+                self._upload_cert_path = self.__find_user_cred_file(
+                    self._config.build.sign_certificate, 'build -> sign_key')
+
+    def __find_user_cred_file(self, config_file_name: str, config_entry: str) -> str:
+        """Search for file by absolute path, in `meta` folder or in default keys folder.
+
+        Args:
+            config_file_name (str): Filename or absolute file path.
+            config_entry (str): Place in config to show error to user.
+        Raises:
+            SignerConfigError: If received absolute path and file not found or received relative path and file not
+                               found nor in meta neither in aos folders.
+        Returns:
+            str: Path to existing file
+        """
+        path = config_file_name
+        if isabs(path):
+            if exists(path):
+                return path
+            else:
+                raise SignerConfigError('{} is set to absolute path but file not found.'.format(config_entry))
+
+        for search_dir in (self._config_path, self.DEFAULT_USER_CREDENTIALS_FOLDER):
+            path = join(search_dir, config_file_name)
+            if exists(path):
+                return path
+        raise SignerConfigError(
+                'Configured {} file is set to {}, but file not found neither in {} nor in {} directory.'.format(
+                    config_entry,
+                    config_file_name,
+                    self._config_path,
+                    self.DEFAULT_USER_CREDENTIALS_FOLDER
+                )
+            )
+
+    @staticmethod
+    def __validate_key_cert_pair(key_path, cert_path):
+        """Check key and certificate are in valid format and certificate is derived from the key.
+
+        Args:
+            key_path (str): Path to key file.
+            cert_path (str): Path to certificate file.
+        Raises:
+            SignerConfigError: In case of any certificate or key error.
+        Returns:
+            None: if no errors
+        """
+        with open(cert_path, "rb") as c, open(key_path, "rb") as k:
+            cert_content = c.read()
+            key_content = k.read()
+
+        try:
+            private_key_obj = OpenSSL.crypto.load_privatekey(OpenSSL.crypto.FILETYPE_PEM, key_content)
+        except OpenSSL.crypto.Error:
+            raise SignerConfigError('Private key {} is not correct'.format(key_path))
+
+        try:
+            cert_obj = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert_content)
+        except OpenSSL.crypto.Error:
+            raise SignerConfigError('Certificate {} is not correct'.format(cert_path))
+
+        context = OpenSSL.SSL.Context(OpenSSL.SSL.TLSv1_2_METHOD)
+        context.use_privatekey(private_key_obj)
+        context.use_certificate(cert_obj)
+        try:
+            context.check_privatekey()
+        except OpenSSL.SSL.Error:
+            SignerConfigError('Certificate public key is not derived from the private key')
+
+    @staticmethod
+    def __pkcs12_to_pem(pkcs12_bytes: bytes):
+        private_key, certificate, additional_certificates = \
+            load_key_and_certificates(pkcs12_bytes, ''.encode('utf8'), default_backend())
+
+        cert_bytes = bytearray(certificate.public_bytes(Encoding.PEM))
+        for add_cert in additional_certificates:
+            cert_bytes += add_cert.public_bytes(Encoding.PEM)
+        key_bytes = private_key.private_bytes(Encoding.PEM, PrivateFormat.PKCS8, NoEncryption())
+        cert_bytes = bytes(cert_bytes)
+        return cert_bytes, key_bytes
+
+    @classmethod
+    def get_issuer(cls, certificate_data: bytes):
+        certificate = load_pem_x509_certificate(certificate_data)
+        return certificate.issuer.rfc4514_string()
+
+    @classmethod
+    def get_certificate_serial_number_hex(cls, certificate_data: bytes) -> str:
+        certificate = load_pem_x509_certificate(certificate_data)
+
+        serial = f'{certificate.serial_number:X}'
+        if len(serial) % 2:
+            return '0' + serial
+        return serial
```

## Comparing `aos_signer-1.8.2b6.dist-info/METADATA` & `aos_signer-1.8.2b7.dist-info/METADATA`

 * *Files 10% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: aos-signer
-Version: 1.8.2b6
+Version: 1.8.2b7
 Summary: Aos service manager
 Home-page: UNKNOWN
 Author: EPAM Systems
 Author-email: support@aoscloud.io
 License: Apache License 2.0
 Platform: any
 Classifier: Operating System :: OS Independent
```

## Comparing `aos_signer-1.8.2b6.dist-info/RECORD` & `aos_signer-1.8.2b7.dist-info/RECORD`

 * *Files 14% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-aos_signer/__init__.py,sha256=duKmiR-W8MHWl86XCdZgzM9PPlC4dL4AOZerXpI_t3I,114
+aos_signer/__init__.py,sha256=XhCG2mcrLfcqNTUrQ9Wc479gihxlbryhauX4wCRShdU,114
 aos_signer/main.py,sha256=ts5qXFCFvzs4GaR12vUoCmskklqS5fsbviY_ibxiKN4,3909
 aos_signer/test.py,sha256=V656YShZDg70cteTe-_GSBhw5sKAeisARFW2ZCFnNzk,245
 aos_signer/files/1rootCA.crt,sha256=X3mH5kWiKpchVXfrW0HAhI94103mLhjftx2dR4KyWbw,2750
 aos_signer/files/__init__.py,sha256=4CfhMXKCJ5C82352m-lxcX5N8jrSuaE5zBaF0XhF1OE,129
 aos_signer/files/build_schema.json,sha256=fCcdo7fVE1LcLOLovhTDgwKMCSCvn-NpaRwjMctQb2g,2297
 aos_signer/files/config.yaml,sha256=vqZ7Kqo23Mh5DDNOATIhaIZHYZ6kJEnTPc7m9Px1Jks,2929
 aos_signer/files/configuration_schema.json,sha256=0mxNFxCuPrnPaLMHhxZRF1iJQsBdEPN9xAKrY0d1Pyg,10542
@@ -12,26 +12,26 @@
 aos_signer/files/state_schema.json,sha256=mk5bObyJspklV61leRp7V2FJZgPJ1a4KIsv3CgBqtUE,583
 aos_signer/service_config/__init__.py,sha256=SV8o0hPcxkA6At5Ld9-efqkwcaXoCo9K5Z-USahSVx4,93
 aos_signer/service_config/config_xml_generator.py,sha256=Uss1S13sUljrdPLpg3W6p3mSyyvH8Bwh9rUYSJKN2Tg,5968
 aos_signer/service_config/service_configuration.py,sha256=1W8uY6z0DbNquuhPuHIJTZJfTojCWAWVJZdJ9EW5OA4,2952
 aos_signer/service_config/models/__init__.py,sha256=SV8o0hPcxkA6At5Ld9-efqkwcaXoCo9K5Z-USahSVx4,93
 aos_signer/service_config/models/alerts.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 aos_signer/service_config/models/build.py,sha256=UUGSlH93orDqj6_tsQHdwl6rAN2TN0Ya9Sra8BKXGiA,2073
-aos_signer/service_config/models/config_chapter.py,sha256=Js-eTy_-ApajimPtYc2JrB7i_b8TjTHy9fpA6DV4_iM,1074
+aos_signer/service_config/models/config_chapter.py,sha256=ITWjsYJz1z5D1OBFK4vLyqZR6hjP7AxMgmyA3w2e-mw,1108
 aos_signer/service_config/models/configuration.py,sha256=yi7jGPoDihFQkIK4IP57goWYyaaJr78Cs4YRKLk0I34,6679
 aos_signer/service_config/models/publish.py,sha256=cOGe1gAVK1_a2iDqTCxmkRfdIiTyiw_QIybMylme22I,1574
 aos_signer/service_config/models/publisher.py,sha256=emtip2i5biRlaY2r-FcffGzwa8siUCJbAqTnk6XiJM4,494
 aos_signer/service_config/models/state.py,sha256=mEWjkFwspHqIpPIDsWckERuvWKi9UvGSxUyxrYsVn9g,1258
 aos_signer/signer/__init__.py,sha256=lJlMhnUS4oONIEGs9ER8BXIp3GPfTurWn3Ko52JUvAk,93
 aos_signer/signer/bootstrapper.py,sha256=2eNym4c15H3C_i4j8bnCeiKx1j28r0gDJ7rYtyg4Zts,2247
-aos_signer/signer/commands.py,sha256=ffAwsj-SRr3wlWalX7YYxw5HEgyemyGEYeUxzeft6BE,2128
+aos_signer/signer/commands.py,sha256=b6hOhWP4w9xsLgBmu7GwxERoLp8GCNZJuz4MUlVqf4I,2198
 aos_signer/signer/common.py,sha256=_0sAGRrDyVyQQfzN3e9PpEvzFBqwtb-tk0LgV6dTT0Y,1135
 aos_signer/signer/errors.py,sha256=5-_y9PnQhOtXCbbgYr-2TEdp-iAOjfHX5qF9rdHiJxo,1050
 aos_signer/signer/file_details.py,sha256=R2fpEaDdY0ENi1ag7P-FoH73fyk5OzO5ZrpGn1FGvSY,1291
 aos_signer/signer/signer.py,sha256=YBzOcDoPX5iSU8tNddlFmYWJRrWDXfHbYjfcMPPuvlU,7626
-aos_signer/signer/uploader.py,sha256=osR5kACJ7WXaI0_bo8Q1I-sOENCvn504BQnii_MMnhg,3297
-aos_signer/signer/user_credentials.py,sha256=vxk4TJcqiZ-5Dbga1pmlJMceGlNSbzNJ3rKml81qsa0,8442
-aos_signer-1.8.2b6.dist-info/METADATA,sha256=IFZ6ElElJHEi6KDPRkwluBPC8AZAL9ack-SqazX-ne4,988
-aos_signer-1.8.2b6.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-aos_signer-1.8.2b6.dist-info/entry_points.txt,sha256=CDg4Cwol1UxC1cAYy0HWiZv_0fzgZSl8nm6-WQ4W538,53
-aos_signer-1.8.2b6.dist-info/top_level.txt,sha256=r1AUCxd43esI8nxguqDjRMHM82YcUh6FcKjOHTm7Xbk,11
-aos_signer-1.8.2b6.dist-info/RECORD,,
+aos_signer/signer/uploader.py,sha256=UTsaAz6ThsQT2YaPUaMoOquY2ZXxuI2sxv02IK0zE0U,3288
+aos_signer/signer/user_credentials.py,sha256=mRUJJt4aB2wzWrc9nB0skMqM4j4dvB5ZIcJNxbBgdnQ,8668
+aos_signer-1.8.2b7.dist-info/METADATA,sha256=vqqh9G2Lh_2TS-FLMX9UCuknGh-HRjNxxKKkjomr8DI,988
+aos_signer-1.8.2b7.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+aos_signer-1.8.2b7.dist-info/entry_points.txt,sha256=CDg4Cwol1UxC1cAYy0HWiZv_0fzgZSl8nm6-WQ4W538,53
+aos_signer-1.8.2b7.dist-info/top_level.txt,sha256=r1AUCxd43esI8nxguqDjRMHM82YcUh6FcKjOHTm7Xbk,11
+aos_signer-1.8.2b7.dist-info/RECORD,,
```

