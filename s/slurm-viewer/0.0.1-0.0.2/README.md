# Comparing `tmp/slurm_viewer-0.0.1-py3-none-any.whl.zip` & `tmp/slurm_viewer-0.0.2-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,18 +1,16 @@
-Zip file size: 14959 bytes, number of entries: 16
+Zip file size: 14228 bytes, number of entries: 14
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Dec-04 09:04 src/__init__.py
--rw-rw-rw-  2.0 fat     6877 b- defN 23-Dec-08 11:59 src/cluster_info.py
--rw-rw-rw-  2.0 fat     4269 b- defN 23-Dec-08 12:17 src/cluster_widget.py
--rw-rw-rw-  2.0 fat     1133 b- defN 23-Dec-04 13:15 src/common_types.py
--rw-rw-rw-  2.0 fat     1287 b- defN 23-Dec-04 13:59 src/config.py
--rw-rw-rw-  2.0 fat      557 b- defN 23-Dec-07 15:40 src/main.py
--rw-rw-rw-  2.0 fat     7397 b- defN 23-Dec-08 11:59 src/node_acct.py
--rw-rw-rw-  2.0 fat     5089 b- defN 23-Dec-08 11:59 src/queue_info.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Dec-06 15:18 src/queue_widget.py
--rw-rw-rw-  2.0 fat     9834 b- defN 23-Dec-11 08:10 src/slurm_viewer.py
--rw-rw-rw-  2.0 fat     2078 b- defN 23-Dec-01 07:50 src/sortable_data_table.py
--rw-rw-rw-  2.0 fat     1872 b- defN 23-Dec-11 09:08 slurm_viewer-0.0.1.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Dec-11 09:08 slurm_viewer-0.0.1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       46 b- defN 23-Dec-11 09:08 slurm_viewer-0.0.1.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat        4 b- defN 23-Dec-11 09:08 slurm_viewer-0.0.1.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1232 b- defN 23-Dec-11 09:08 slurm_viewer-0.0.1.dist-info/RECORD
-16 files, 41767 bytes uncompressed, 12945 bytes compressed:  69.0%
+-rw-rw-rw-  2.0 fat     6877 b- defN 23-Dec-11 13:13 src/cluster_info.py
+-rw-rw-rw-  2.0 fat     1825 b- defN 24-Jan-18 13:20 src/common_types.py
+-rw-rw-rw-  2.0 fat     1289 b- defN 24-May-02 11:43 src/config.py
+-rw-rw-rw-  2.0 fat      387 b- defN 23-Dec-15 08:01 src/main.py
+-rw-rw-rw-  2.0 fat     8094 b- defN 24-Jan-18 13:20 src/node_acct.py
+-rw-rw-rw-  2.0 fat     5078 b- defN 23-Dec-11 13:40 src/queue_info.py
+-rw-rw-rw-  2.0 fat    12119 b- defN 24-Jan-18 09:38 src/slurm_viewer.py
+-rw-rw-rw-  2.0 fat     2383 b- defN 23-Dec-12 07:51 src/sortable_data_table.py
+-rw-rw-rw-  2.0 fat     1922 b- defN 24-May-02 11:51 slurm_viewer-0.0.2.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-May-02 11:51 slurm_viewer-0.0.2.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       46 b- defN 24-May-02 11:51 slurm_viewer-0.0.2.dist-info/entry_points.txt
+-rw-rw-rw-  2.0 fat        4 b- defN 24-May-02 11:51 slurm_viewer-0.0.2.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1082 b- defN 24-May-02 11:51 slurm_viewer-0.0.2.dist-info/RECORD
+14 files, 41198 bytes uncompressed, 12446 bytes compressed:  69.8%
```

## zipnote {}

```diff
@@ -1,16 +1,13 @@
 Filename: src/__init__.py
 Comment: 
 
 Filename: src/cluster_info.py
 Comment: 
 
-Filename: src/cluster_widget.py
-Comment: 
-
 Filename: src/common_types.py
 Comment: 
 
 Filename: src/config.py
 Comment: 
 
 Filename: src/main.py
@@ -18,32 +15,29 @@
 
 Filename: src/node_acct.py
 Comment: 
 
 Filename: src/queue_info.py
 Comment: 
 
-Filename: src/queue_widget.py
-Comment: 
-
 Filename: src/slurm_viewer.py
 Comment: 
 
 Filename: src/sortable_data_table.py
 Comment: 
 
-Filename: slurm_viewer-0.0.1.dist-info/METADATA
+Filename: slurm_viewer-0.0.2.dist-info/METADATA
 Comment: 
 
-Filename: slurm_viewer-0.0.1.dist-info/WHEEL
+Filename: slurm_viewer-0.0.2.dist-info/WHEEL
 Comment: 
 
-Filename: slurm_viewer-0.0.1.dist-info/entry_points.txt
+Filename: slurm_viewer-0.0.2.dist-info/entry_points.txt
 Comment: 
 
-Filename: slurm_viewer-0.0.1.dist-info/top_level.txt
+Filename: slurm_viewer-0.0.2.dist-info/top_level.txt
 Comment: 
 
-Filename: slurm_viewer-0.0.1.dist-info/RECORD
+Filename: slurm_viewer-0.0.2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## src/common_types.py

```diff
@@ -1,40 +1,67 @@
 CPU_TIME_RE = r'^(?:(?P<days>\d+)-)?(?P<hours>\d+):(?P<minutes>\d+):(?P<seconds>\d+)$'
 
 
+class PostFixUnit:
+    def __init__(self, value: str) -> None:
+        self.value: float | None = None
+        if value.endswith('K'):
+            self.value = float(value[:-1]) / 1024
+            return
+
+        if value.endswith('M'):
+            self.value = float(value[:-1])
+            return
+
+        if value.endswith('G'):
+            self.value = float(value[:-1]) * 1024
+            return
+
+        try:
+            self.value = float(value) / (1024 * 1204)
+        except ValueError:
+            self.value = None
+
+    def __str__(self) -> str:
+        return f'{self.value}'
+
+    def __repr__(self) -> str:
+        return f'{self.value}'
+
+
 class MemoryUsed:
     def __init__(self, value: str) -> None:
-        self.value: int | None = None
+        self.value: float | None = None
         if value.endswith('K'):
-            self.value = int(value[:-1]) // 1024
+            self.value = float(value[:-1]) / 1024
             return
 
         if value.endswith('M'):
-            self.value = int(value[:-1])
+            self.value = float(value[:-1])
             return
 
         if value.endswith('G'):
-            self.value = int(value[:-1]) * 1024
+            self.value = float(value[:-1]) * 1024
             return
 
         try:
-            self.value = int(value) // (1024 * 1204)
+            self.value = float(value) / (1024 * 1204)
         except ValueError:
             self.value = None
 
     def __str__(self) -> str:
         return f'{self.GB}GB'
 
     def __repr__(self) -> str:
         return f'{self.GB}GB'
 
     @property
-    def MB(self) -> int:  # pylint: disable=invalid-name
+    def MB(self) -> float:  # pylint: disable=invalid-name
         if self.value is None:
             raise RuntimeError('Value not set.')
         return self.value
 
     @property
-    def GB(self) -> int:  # pylint: disable=invalid-name
+    def GB(self) -> float:  # pylint: disable=invalid-name
         if self.value is None:
             raise RuntimeError('Value not set.')
         return self.value // 1024
```

## src/config.py

```diff
@@ -12,15 +12,15 @@
         filename = Path(os.environ['SLURM_VIEW_CONFIG'])
         if filename.exists():
             return filename
 
     if filename.exists():
         return filename
 
-    filename = Path.home() / '.config/slurm_view/settings.json'
+    filename = Path.home() / '.config/slurm_viewer/settings.json'
     if filename.exists():
         return filename
 
     raise RuntimeError('Settings file could not be found. ')
 
 
 class Config(BaseModel):
```

## src/main.py

```diff
@@ -1,27 +1,19 @@
 import rich.traceback
 import typer
 
-from src.cluster_widget import ClusterApp
 from src.config import Config
 from src.slurm_viewer import SlurmViewer
 
 app = typer.Typer(add_completion=False, no_args_is_help=True)
 
 
 @app.command()
-def view() -> None:
+def node() -> None:
     """ View the nodes """
     config = Config.init()
     SlurmViewer(config).run()
 
 
-@app.command()
-def test() -> None:
-    """ View the nodes """
-    config = Config.init()
-    ClusterApp(config).run()
-
-
 if __name__ == "__main__":
     rich.traceback.install(width=200)
     app()
```

## src/node_acct.py

```diff
@@ -4,15 +4,15 @@
 import re
 import subprocess
 from enum import Enum
 from pathlib import Path
 
 from pydantic import BaseModel, field_validator, ConfigDict
 
-from src.common_types import MemoryUsed, CPU_TIME_RE
+from src.common_types import MemoryUsed, CPU_TIME_RE, PostFixUnit
 from src.config import Config
 
 TRES_USAGE_IN_AVE_RE = (r'^cpu=(?P<cpu>(?:\d+-)?\d+:\d+:\d+),energy=(?P<energy>\d+),fs/disk=(?P<disk>\d+),'
                         r'gres/gpumem=(?P<gpu_mem>\w+),gres/gpuutil=(?P<gpu_util>\d+),mem=(?P<mem>\d+K),'
                         r'pages=(?P<pages>\d+),vmem=(?P<vmem>\d+K)$')
 
 REQ_ALLOC_TRES_RE = (r'^(?:billing=(?P<billing>\d+),)?cpu=(?P<cpu>\d+)(?:,energy=(?P<energy>\d+))?,'
@@ -36,20 +36,20 @@
             return
 
         self.code = None
         self.signal = None
 
 
 # noinspection PyNestedDecorators
-class TrackableResourceUsageInAve(BaseModel):
+class TrackableResourceUsage(BaseModel):
     model_config = ConfigDict(arbitrary_types_allowed=True)
 
     cpu: datetime.timedelta | None = None
-    energy: str | None = None
-    disk: str | None = None
+    energy: int | None = None
+    disk: MemoryUsed | None = None
     gpu_mem: MemoryUsed | None = None
     gpu_util: int | None = None
     mem: MemoryUsed | None = None
     pages: int | None = None
     vmem: MemoryUsed | None = None
 
     @field_validator('cpu', mode='before')
@@ -57,15 +57,15 @@
     def timedelta_validator(cls, value: str) -> datetime.timedelta:
         m = re.search(CPU_TIME_RE, value)
         if not m:
             return datetime.timedelta(0)
 
         return datetime.timedelta(**{k: float(v) for k, v in m.groupdict().items() if v is not None})
 
-    @field_validator('gpu_mem', 'mem', 'vmem', mode='before')
+    @field_validator('gpu_mem', 'mem', 'vmem', 'disk', mode='before')
     @classmethod
     def mem_validator(cls, value: str) -> MemoryUsed:
         return MemoryUsed(value)
 
 
 # noinspection PyNestedDecorators
 class ReqAllocTrackableResources(BaseModel):
@@ -106,73 +106,73 @@
 class NodeAcct(BaseModel):
     model_config = ConfigDict(arbitrary_types_allowed=True)
 
     JobID: str
     JobIDRaw: str
     JobName: str
     Partition: str
-    MaxVMSize: str
+    MaxVMSize: MemoryUsed
     MaxVMSizeNode: str
     MaxVMSizeTask: str
-    AveVMSize: str
-    MaxRSS: str
+    AveVMSize: MemoryUsed
+    MaxRSS: MemoryUsed
     MaxRSSNode: str
     MaxRSSTask: str
-    AveRSS: str
+    AveRSS: MemoryUsed
     MaxPages: str
     MaxPagesNode: str
     MaxPagesTask: str
     AvePages: str
-    MinCPU: str
+    MinCPU: datetime.timedelta
     MinCPUNode: str
     MinCPUTask: str
-    AveCPU: str
+    AveCPU: datetime.timedelta
     NTasks: str
-    AllocCPUS: str
+    AllocCPUS: int
     Elapsed: datetime.timedelta
     State: JobStateCodes
     ExitCode: ExitCodeSignal
-    AveCPUFreq: str
-    ReqCPUFreqMin: str
-    ReqCPUFreqMax: str
-    ReqCPUFreqGov: str
+    AveCPUFreq: PostFixUnit
+    ReqCPUFreqMin: PostFixUnit
+    ReqCPUFreqMax: PostFixUnit
+    ReqCPUFreqGov: PostFixUnit
     ReqMem: MemoryUsed
-    ConsumedEnergy: str
-    MaxDiskRead: str
+    ConsumedEnergy: PostFixUnit
+    MaxDiskRead: MemoryUsed
     MaxDiskReadNode: str
     MaxDiskReadTask: str
-    AveDiskRead: str
-    MaxDiskWrite: str
+    AveDiskRead: MemoryUsed
+    MaxDiskWrite: MemoryUsed
     MaxDiskWriteNode: str
     MaxDiskWriteTask: str
-    AveDiskWrite: str
+    AveDiskWrite: MemoryUsed
     ReqTRES: ReqAllocTrackableResources
     AllocTRES: ReqAllocTrackableResources
-    TRESUsageInAve: TrackableResourceUsageInAve
-    TRESUsageInMax: str
+    TRESUsageInAve: TrackableResourceUsage
+    TRESUsageInMax: TrackableResourceUsage
     TRESUsageInMaxNode: str
     TRESUsageInMaxTask: str
-    TRESUsageInMin: str
+    TRESUsageInMin: TrackableResourceUsage
     TRESUsageInMinNode: str
     TRESUsageInMinTask: str
-    TRESUsageInTot: str
+    TRESUsageInTot: TrackableResourceUsage
     TRESUsageOutMax: str
     TRESUsageOutMaxNode: str
     TRESUsageOutMaxTask: str
     TRESUsageOutAve: str
     TRESUsageOutTot: str
 
-    @field_validator('TRESUsageInAve', mode='before')
+    @field_validator('TRESUsageInAve', 'TRESUsageInMax', 'TRESUsageInMin', 'TRESUsageInTot', mode='before')
     @classmethod
-    def tres_usage_in_ave_validator(cls, value: str) -> TrackableResourceUsageInAve:
+    def tres_usage_in_ave_validator(cls, value: str) -> TrackableResourceUsage:
         m = re.search(TRES_USAGE_IN_AVE_RE, value)
         if not m:
-            return TrackableResourceUsageInAve()
+            return TrackableResourceUsage()
 
-        return TrackableResourceUsageInAve(**m.groupdict())
+        return TrackableResourceUsage(**m.groupdict())
 
     @field_validator('ReqTRES', 'AllocTRES', mode='before')
     @classmethod
     def req_alloc_tres_validator(cls, value: str) -> ReqAllocTrackableResources:
         m = re.search(REQ_ALLOC_TRES_RE, value)
         if not m:
             return ReqAllocTrackableResources()
@@ -185,51 +185,57 @@
         return JobStateCodes(value.split()[0])
 
     @field_validator('ExitCode', mode='before')
     @classmethod
     def exit_code_validator(cls, value: str) -> ExitCodeSignal:
         return ExitCodeSignal(value)
 
-    @field_validator('ReqMem', mode='before')
+    @field_validator('ReqMem', 'AveDiskWrite', 'AveDiskRead', 'MaxDiskWrite', 'MaxDiskRead', 'MaxVMSize', 'AveVMSize',
+                     'AveRSS', 'MaxRSS', mode='before')
     @classmethod
     def mem_validator(cls, value: str) -> MemoryUsed:
         return MemoryUsed(value)
 
-    @field_validator('Elapsed', mode='before')
+    @field_validator('AveCPUFreq', 'ReqCPUFreqMin', 'ReqCPUFreqMax', 'ReqCPUFreqGov', 'ConsumedEnergy', mode='before')
+    @classmethod
+    def post_fix_validator(cls, value: str) -> PostFixUnit:
+        return PostFixUnit(value)
+
+    @field_validator('Elapsed', 'MinCPU', 'AveCPU', mode='before')
     @classmethod
     def timedelta_validator(cls, value: str) -> datetime.timedelta:
         m = re.search(CPU_TIME_RE, value)
         if not m:
             return datetime.timedelta(0)
 
         return datetime.timedelta(**{k: float(v) for k, v in m.groupdict().items() if v is not None})
 
 
 def create_node_acct(data: str, header: list[str]) -> NodeAcct:
     return NodeAcct(**dict(zip(header, data.rstrip().split('|'))))
 
 
-def _get_lines(server: str | None, nodelist: list[str], debug: bool = False) -> list[str]:
+def _get_lines(server: str | None, nodelist: list[str], num_weeks: int = 4, debug: bool = False) -> list[str]:
     if debug:
         with (Path(__file__).parent / '_data/sacct.csv').open('r', encoding='utf8') as log:
             return log.readlines()
 
     try:
         arguments = f'ssh -t {server} ' if server is not None else ''
-        arguments += f'sacct --starttime now-1months --long --allusers --parsable2 --nodelist={",".join(nodelist)}'
+        arguments += f'sacct --starttime now-{num_weeks}week --long --allusers --parsable2 --nodelist={",".join(nodelist)}'
 
         with subprocess.Popen(arguments, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                               universal_newlines=True) as process:
             stdout, _ = process.communicate(timeout=10)
     except subprocess.TimeoutExpired:
         print('TimeoutExpired')
         return []
     except subprocess.CalledProcessError:
         print('CalledProcessError')
         return []
     return stdout.splitlines()
 
 
-def account_info(config: Config) -> list[NodeAcct]:
-    lines = _get_lines(config.server, config.node_list, config.debug)
+def account_info(config: Config, num_weeks: int) -> list[NodeAcct]:
+    lines = _get_lines(config.server, config.node_list, num_weeks=num_weeks, debug=config.debug)
     header = lines[0].rstrip().split('|')
     return [create_node_acct(x, header) for x in lines[1:]]
```

## src/queue_info.py

```diff
@@ -128,15 +128,15 @@
         with (Path(__file__).parent / '_data/squeue.csv').open('r', encoding='utf8') as log:
             lines = log.readlines()
 
         return create_output(lines)
 
     try:
         arguments = f'ssh -t {config.server} ' if config.server is not None else ''
-        arguments += f'squeue -w show nodes {",".join(config.node_list)} --format=%all'
+        arguments += f'squeue -w {",".join(config.node_list)} --format=%all'
 
         with subprocess.Popen(arguments, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                               universal_newlines=True) as process:
             stdout, _ = process.communicate(timeout=10)
     except subprocess.TimeoutExpired:
         print('TimeoutExpired')
         return []
```

## src/slurm_viewer.py

```diff
@@ -1,34 +1,36 @@
 import datetime
 import subprocess
-from typing import Set, Any
+from dataclasses import dataclass
+from typing import Set, Any, Callable, Generator
 
 import textual.widget
 from rich.text import Text
 from textual import on, work
 from textual.app import App, ComposeResult
-from textual.containers import Horizontal, Vertical, Grid
+from textual.containers import Horizontal, Vertical, Grid, ScrollableContainer
 from textual.screen import Screen
-from textual.widgets import Footer, Header, TabbedContent, TabPane, Checkbox, Button, Label, SelectionList
+from textual.widgets import Footer, Header, TabbedContent, TabPane, Checkbox, Button, Label, SelectionList, Collapsible, \
+    RadioSet, RadioButton
 from textual.widgets.selection_list import Selection
 from textual_plotext import PlotextPlot
 
 from src.cluster_info import cluster_info, ClusterNode
 from src.config import Config
 from src.node_acct import account_info
 from src.queue_info import queue_info
 from src.sortable_data_table import SortableDataTable
 
 
-def partitions(data: list[ClusterNode]) -> set[str]:
-    result: Set[str] = set()
+def partitions(data: list[ClusterNode]) -> list[str]:
+    result: Set[str] = {ALL_PARTITIONS}
     for value in data:
-        result.update(*value.partitions)
+        result.update(value.partitions)
 
-    return result
+    return sorted(result)
 
 
 def group_users(config: Config, group: str) -> list[str]:
     try:
         arguments = f'ssh -t {config.server} ' if config.server is not None else ''
         arguments += f'getent group {group}'
 
@@ -41,14 +43,40 @@
     except subprocess.CalledProcessError:
         print('CalledProcessError')
         return []
 
     return sorted(stdout.rsplit(':', maxsplit=1)[-1].split(','))
 
 
+@dataclass
+class FilterOptions:
+    gpu: bool
+    gpu_available: bool
+    partition: str | None
+
+
+ALL_PARTITIONS = 'ALL'
+
+
+def filter_nodes(nodes: list[ClusterNode], node_filter: FilterOptions) -> list[ClusterNode]:
+    result = []
+    for node in nodes:
+        if node.gpu_tot == 0 and node_filter.gpu:
+            continue
+
+        if node.gpu_avail == 0 and node_filter.gpu_available:
+            continue
+
+        if node_filter.partition != ALL_PARTITIONS and node_filter.partition not in node.partitions:
+            continue
+
+        result.append(node)
+    return result
+
+
 class Loading:
     def __init__(self, widget: textual.widget.Widget) -> None:
         self.widget = widget
 
     def __enter__(self) -> None:
         self.widget.loading = True
 
@@ -91,89 +119,111 @@
     def on_button_pressed(self, event: Button.Pressed) -> None:
         if event.button.id == 'ok':
             self.dismiss(self.query_one(SelectionList).selected)
         else:
             self.dismiss(None)
 
 
+def sort_column(value: Any) -> Any:
+    if value is None:
+        return ''
+
+    if isinstance(value, Text):
+        return value.plain
+
+    return value
+
+
 class SlurmViewer(App):
     CSS = """
-    #data_table {
-        width: 1fr;
-        height: 1fr;
-        border: panel limegreen;
-    }
-    
     #cluster_horizontal {
         height: auto;
     }
     
     #cluster_label {
         width: 1fr;
         padding: 1 1;
         text-align: right;
     }
     
     #cluster_data_table {
         height: 100%;
     }
+    
+    #queue_horizontal {
+        height: auto;
+    }
+    
+    #queue_label {
+        width: 1fr;
+        padding: 1 1;
+        text-align: right;
+    }
+    
+    #queue_data_table {
+        height: 100%;
+    }    
     """
 
     def __init__(self, config: Config) -> None:
         super().__init__()
         self.title = f'{self.__class__.__name__} ({config.server})'
         self.config = config
         self.cluster_info = cluster_info(self.config)
         self.queue_info = queue_info(self.config)
-        self.gpu_usage = account_info(self.config)
+        self.gpu_history = 4  # weeks
+        self.gpu_usage = account_info(self.config, self.gpu_history)
         self.partitions = partitions(self.cluster_info)
-        self.users = group_users(self.config, 'lkeb-hpc')
+        # self.users = group_users(self.config, 'lkeb-hpc')
+        self.sort_function: Callable[[Any], Any] | None = sort_column
 
     def compose(self) -> ComposeResult:
         yield Header(name=self.config.server, show_clock=False)
         with TabbedContent():
             with TabPane('Cluster', id='tab_cluster'):
-                with Vertical():
-                    with Horizontal(id='cluster_horizontal'):
-                        yield Checkbox(label='GPU only', id='cluster_show_gpu')
-                        yield Checkbox(label='GPU available', id='cluster_show_gpu_available')
-                        yield Label(f'Last update: {datetime.datetime.now().strftime("%H:%M:%S")}', id='cluster_label')
-                        yield Button(label='Refresh', id='cluster_refresh')
-                        yield Button(label='Select columns', id='cluster_show_columns')
-                    yield SortableDataTable(id='cluster_data_table')
+                yield from self._setup_cluster_tab()
             with TabPane('Queue', id='tab_queue'):
-                yield SortableDataTable(id='job_queue_table')
+                yield from self._setup_queue_tab()
             with TabPane('GPU usage', id='tab_gpu_usage'):
                 yield PlotextPlot(id='plot')
         yield Footer()
 
-    def on_mount(self) -> None:
-        self._cluster_data_table()
-        self._queue_data_table()
-        self._gpu_usage_plot()
-
     @staticmethod
-    def _filter_nodes(nodes: list[ClusterNode], gpu: bool, gpu_available: bool) -> list[ClusterNode]:
-        result = []
-        for node in nodes:
-            if node.gpu_tot == 0 and gpu:
-                continue
-
-            if node.gpu_avail == 0 and gpu_available:
-                continue
-
-            result.append(node)
-        return result
+    def _setup_queue_tab() -> Generator:
+        with Vertical():
+            with Horizontal(id='queue_horizontal'):
+                yield Label(f'Last update: {datetime.datetime.now().strftime("%H:%M:%S")}', id='queue_label')
+                yield Button(label='Refresh', id='queue_refresh')
+            yield SortableDataTable(id='job_queue_table')
+
+    def _setup_cluster_tab(self) -> Generator:
+        with Vertical():
+            with Horizontal(id='cluster_horizontal'):
+                yield Checkbox(label='GPU only', id='cluster_show_gpu')
+                yield Checkbox(label='GPU available', id='cluster_show_gpu_available')
+                with Collapsible(title='Partitions', id='cluster_collapsible'):
+                    with RadioSet(id='cluster_partitions'):
+                        for label in self.partitions:
+                            yield RadioButton(label, value=label == ALL_PARTITIONS)
+                yield Label(f'Last update: {datetime.datetime.now().strftime("%H:%M:%S")}', id='cluster_label')
+                yield Button(label='Refresh', id='cluster_refresh')
+                yield Button(label='Select columns', id='cluster_show_columns')
+            with ScrollableContainer():
+                table = SortableDataTable(id='cluster_data_table')
+                table.sort_function = self.sort_function
+                yield table
+
+    async def on_mount(self) -> None:
+        await self._cluster_data_table()
+        await self._queue_data_table()
+        await self._gpu_usage_plot()
 
     @on(Checkbox.Changed, '#cluster_show_gpu')
     @on(Checkbox.Changed, '#cluster_show_gpu_available')
     def show_gpu(self, _: Checkbox.Changed) -> None:
-        data_table = self.query_one('#cluster_data_table', SortableDataTable)
-        data_table.clear()
-
         self.update_cluster_info()
 
     @on(Button.Pressed, '#cluster_show_columns')
     def select_columns(self, _: Checkbox.Changed) -> None:
         def check_result(result: list[str] | None) -> None:
             if result is None:
                 return
@@ -194,76 +244,87 @@
         screen = ColumnSelectionScreen(columns)
         self.push_screen(screen, check_result)
 
     @work(thread=True)
     @on(Button.Pressed, '#cluster_refresh')
     def refresh_info(self, _: Checkbox.Changed) -> None:
         data_table = self.query_one('#cluster_data_table', SortableDataTable)
-        data_table.clear()
 
         with Loading(data_table):
             self.cluster_info = cluster_info(self.config)
 
         self.update_cluster_info()
         self.query_one('#cluster_label', Label).update(f'Last update: {datetime.datetime.now().strftime("%H:%M:%S")}')
 
+    @on(RadioSet.Changed, '#cluster_partitions')
+    def partitions_changed(self, value: RadioSet.Changed) -> None:
+        data_table = self.query_one('#cluster_data_table', SortableDataTable)
+        data_table.clear()
+        checkboxes = self._checkbox_values()
+        options = FilterOptions(gpu=checkboxes['GPU only'], gpu_available=checkboxes['GPU available'],
+                                partition=value.pressed.label.plain)
+        self._update_data_table(filter_nodes(self.cluster_info, options), data_table)
+
+    def _checkbox_values(self) -> dict[str, bool]:
+        return {x.label.plain: x.value for x in self.query(Checkbox).nodes}
+
     def update_cluster_info(self) -> None:
-        data_table = self.query_one('#job_queue_table', SortableDataTable)
-        gpu = self.query_one('#cluster_show_gpu', Checkbox).value
-        gpu_available = self.query_one('#cluster_show_gpu_available', Checkbox).value
-        self._update_data_table(self._filter_nodes(self.cluster_info, gpu, gpu_available), data_table)
+        data_table = self.query_one('#cluster_data_table', SortableDataTable)
+        data_table.clear()
+        checkboxes = self._checkbox_values()
+        button = self.query_one('#cluster_partitions', RadioSet).pressed_button
+        partition = button.label.plain if button is not None else None
+        options = FilterOptions(gpu=checkboxes['GPU only'], gpu_available=checkboxes['GPU available'], partition=partition)
+        self._update_data_table(filter_nodes(self.cluster_info, options), data_table)
 
     def _update_data_table(self, nodes: list[ClusterNode], table: SortableDataTable) -> None:
         for index, row in enumerate(nodes, 1):
             label = Text(str(index), style='#B0FC38 italic')
             data = []
             for key in self.config.node_columns:
                 value = getattr(row, key)
-                data.append(str(value) if value is not None else '')
-            try:
-                table.add_row(*data, label=label)
-            except AttributeError as e:
-                print(e)
+                data.append(value if value is not None else '')
+            table.add_row(*data, label=label)
 
-    def _queue_data_table(self) -> None:
+    async def _queue_data_table(self) -> None:
         data_table = self.query_one('#job_queue_table', SortableDataTable)
         data_table.cursor_type = 'row'
         data_table.clear(columns=True)
         data_table.zebra_stripes = True
         data_table.add_columns(*self.config.queue_columns)
         data_table.border_title = f'{len(self.queue_info)} nodes'
 
         for index, row in enumerate(self.queue_info, 1):
             label = Text(str(index), style='#B0FC38 italic')
             data = [getattr(row, key) for key in self.config.queue_columns]
             data_table.add_row(*data, label=label)
 
-    def _cluster_data_table(self) -> None:
+    async def _cluster_data_table(self) -> None:
         data_table = self.query_one('#cluster_data_table', SortableDataTable)
         data_table.cursor_type = 'row'
         data_table.clear(columns=True)
         data_table.zebra_stripes = True
         data_table.add_columns(*self.config.node_columns)
         data_table.border_title = f'{len(self.cluster_info)} nodes'
 
         self._update_data_table(self.cluster_info, data_table)
 
-    def _gpu_usage_plot(self) -> None:
+    async def _gpu_usage_plot(self) -> None:
         data = []
         for value in self.gpu_usage:
             if not value.TRESUsageInAve.gpu_mem or not value.TRESUsageInAve.gpu_mem.value:
                 continue
             data.append(value.TRESUsageInAve.gpu_mem.GB)
 
         plotextplot = self.query_one('#plot', PlotextPlot)
         plt = plotextplot.plt
         plt.clear_figure()
         bins = 48
         plt.hist(data, bins)
-        plt.title(f'Job GPU size last month ({len(data)} jobs)')
+        plt.title(f'Job GPU size last {self.gpu_history} weeks ({len(data)} jobs)')
         plt.xlabel('GPU Mem (GB)')
         plt.ylabel('# jobs')
         plotextplot.refresh()
 
 
 if __name__ == "__main__":
     app = SlurmViewer(Config.init())
```

## src/sortable_data_table.py

```diff
@@ -1,9 +1,9 @@
 from dataclasses import dataclass
-from typing import Any, Final
+from typing import Any, Final, Callable
 
 from textual import on
 from textual.binding import Binding
 from textual.widgets import DataTable
 from textual.widgets.data_table import ColumnKey, CellKey
 
 
@@ -31,14 +31,15 @@
         Binding('ctrl+r', 'show_row_labels', 'Toggle Row labels')
     ]
 
     def __init__(self, **kwargs: Any) -> None:
         super().__init__(**kwargs)
         self._sort = Sort()
         self.cursor_type = 'row'
+        self.sort_function: Callable[[Any], Any] | None = None
 
     @on(DataTable.HeaderSelected)
     def header_clicked(self, header: DataTable.HeaderSelected) -> None:
         if self._sort.key is not None:
             column = self.columns[self._sort.key]
             column.label.remove_suffix(self._sort.indicator)
             self._update_column_width(self._sort.key)
@@ -48,16 +49,20 @@
             sort_value = self._sort
             sort_value.reverse()
 
         assert sort_value.key
         self.columns[header.column_key].label += sort_value.indicator
         self._update_column_width(header.column_key)
 
-        self.sort(sort_value.key, reverse=sort_value.direction)
-        self._sort = sort_value
+        try:
+            self.sort(sort_value.key, reverse=sort_value.direction, key=self.sort_function)
+            self._sort = sort_value
+        except TypeError:
+            self.columns[header.column_key].label.remove_suffix(self._sort.indicator)
+            print(f'Error sorting on column: {sort_value.key.value}')
 
     def _update_column_width(self, key: ColumnKey) -> None:
         self._update_column_widths({CellKey(row_key=next(iter(self.rows)), column_key=key)})
 
     def action_toggle_zebra(self) -> None:
         self.zebra_stripes = not self.zebra_stripes
```

## Comparing `slurm_viewer-0.0.1.dist-info/METADATA` & `slurm_viewer-0.0.2.dist-info/METADATA`

 * *Files 9% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 Metadata-Version: 2.1
-Name: slurm-viewer
-Version: 0.0.1
+Name: slurm_viewer
+Version: 0.0.2
 Summary: View a SLURM cluster and inspect nodes and jobs.
 Author-email: Patrick de Koning <pjhdekoning@lumc.nl>
-Project-URL: Homepage, https://gitlab.com/lkeb/slurm_view
+Project-URL: Homepage, https://gitlab.com/lkeb/slurm_viewer
 Keywords: XNAT,TUI
 Classifier: Operating System :: OS Independent
 Classifier: Development Status :: 2 - Pre-Alpha
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: Healthcare Industry
 Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: MIT License
@@ -32,14 +32,15 @@
 Requires-Dist: textual-dev ; extra == 'dev'
 
 # Slurm Viewer
 ## Introduction
 View the nodes in a slurm cluster and view the queue.
 
 ## Settings
+placed in ~/.config/slurm_viewer/settings.json
 ```json
 {
   "debug": "True",
   "server": "SERVER or NONE",
   "nodelist": ["List of nodes to view"],
   "node_columns": [
     "short_name",
```

